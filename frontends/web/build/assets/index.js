var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: !0 });
var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 != "string" && !Array.isArray(e2)) {
      for (const k2 in e2)
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          d2 && Object.defineProperty(n2, k2, d2.get ? d2 : {
            enumerable: !0,
            get: () => e2[k2]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
__name(_mergeNamespaces, "_mergeNamespaces");
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = /* @__PURE__ */ __name(function a3() {
      return this instanceof a3 ? Reflect.construct(f2, arguments, this.constructor) : f2.apply(this, arguments);
    }, "a");
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  return Object.defineProperty(a2, "__esModule", { value: !0 }), Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: !0,
      get: function() {
        return n2[k2];
      }
    });
  }), a2;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, react = { exports: {} }, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$5(a2) {
  return a2 === null || typeof a2 != "object" ? null : (a2 = z$3 && a2[z$3] || a2["@@iterator"], typeof a2 == "function" ? a2 : null);
}
__name(A$5, "A$5");
var B$3 = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$2(a2, b2, e2) {
  this.props = a2, this.context = b2, this.refs = D$3, this.updater = e2 || B$3;
}
__name(E$2, "E$2");
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if (typeof a2 != "object" && typeof a2 != "function" && a2 != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
__name(F$2, "F$2");
F$2.prototype = E$2.prototype;
function G$3(a2, b2, e2) {
  this.props = a2, this.context = b2, this.refs = D$3, this.updater = e2 || B$3;
}
__name(G$3, "G$3");
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$3(H$3, E$2.prototype);
H$3.isPureReactComponent = !0;
var I$2 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: !0, ref: !0, __self: !0, __source: !0 };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (b2 != null)
    for (d2 in b2.ref !== void 0 && (h2 = b2.ref), b2.key !== void 0 && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (g2 === 1)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      c2[d2] === void 0 && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
__name(M$2, "M$2");
function N$3(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
__name(N$3, "N$3");
function O$3(a2) {
  return typeof a2 == "object" && a2 !== null && a2.$$typeof === l$3;
}
__name(O$3, "O$3");
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
__name(escape$1, "escape$1");
var P$2 = /\/+/g;
function Q$3(a2, b2) {
  return typeof a2 == "object" && a2 !== null && a2.key != null ? escape$1("" + a2.key) : b2.toString(36);
}
__name(Q$3, "Q$3");
function R$2(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  (k2 === "undefined" || k2 === "boolean") && (a2 = null);
  var h2 = !1;
  if (a2 === null)
    h2 = !0;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = !0;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$3:
          case n$2:
            h2 = !0;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = d2 === "" ? "." + Q$3(h2, 0) : d2, I$2(c2) ? (e2 = "", a2 != null && (e2 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
      return a3;
    })) : c2 != null && (O$3(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  if (h2 = 0, d2 = d2 === "" ? "." : d2 + ":", I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$5(a2), typeof f2 == "function")
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if (k2 === "object")
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + (b2 === "[object Object]" ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
__name(R$2, "R$2");
function S$3(a2, b2, e2) {
  if (a2 == null)
    return a2;
  var d2 = [], c2 = 0;
  return R$2(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  }), d2;
}
__name(S$3, "S$3");
function T$3(a2) {
  if (a2._status === -1) {
    var b2 = a2._result;
    b2 = b2(), b2.then(function(b3) {
      (a2._status === 0 || a2._status === -1) && (a2._status = 1, a2._result = b3);
    }, function(b3) {
      (a2._status === 0 || a2._status === -1) && (a2._status = 2, a2._result = b3);
    }), a2._status === -1 && (a2._status = 0, a2._result = b2);
  }
  if (a2._status === 1)
    return a2._result.default;
  throw a2._result;
}
__name(T$3, "T$3");
var U$3 = { current: null }, V$3 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e2) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  return S$3(a2, function() {
    b2++;
  }), b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (a2 == null)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (b2 != null) {
    if (b2.ref !== void 0 && (k2 = b2.ref, h2 = K$2.current), b2.key !== void 0 && (c2 = "" + b2.key), a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = b2[f2] === void 0 && g2 !== void 0 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (f2 === 1)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  return a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a2.Provider = { $$typeof: t$2, _context: a2 }, a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  return b2.type = a2, b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$3 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: b2 === void 0 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$3.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$3.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$3.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
react.exports = react_production_min;
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports), React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: !0, ref: !0, __self: !0, __source: !0 };
function q$2(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  g2 !== void 0 && (e2 = "" + g2), a2.key !== void 0 && (e2 = "" + a2.key), a2.ref !== void 0 && (h2 = a2.ref);
  for (b2 in a2)
    m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      d2[b2] === void 0 && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
__name(q$2, "q$2");
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports, reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  __name(f2, "f");
  function h2(a2) {
    return a2.length === 0 ? null : a2[0];
  }
  __name(h2, "h");
  function k2(a2) {
    if (a2.length === 0)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  __name(k2, "k");
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a2.id - b2.id;
  }
  if (__name(g2, "g"), typeof performance == "object" && typeof performance.now == "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = !1, A2 = !1, B2 = !1, D2 = typeof setTimeout == "function" ? setTimeout : null, E2 = typeof clearTimeout == "function" ? clearTimeout : null, F2 = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); b2 !== null; ) {
      if (b2.callback === null)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  __name(G2, "G");
  function H2(a2) {
    if (B2 = !1, G2(a2), !A2)
      if (h2(r2) !== null)
        A2 = !0, I2(J2);
      else {
        var b2 = h2(t2);
        b2 !== null && K2(H2, b2.startTime - a2);
      }
  }
  __name(H2, "H");
  function J2(a2, b2) {
    A2 = !1, B2 && (B2 = !1, E2(L2), L2 = -1), z2 = !0;
    var c2 = y2;
    try {
      for (G2(b2), v2 = h2(r2); v2 !== null && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if (typeof d2 == "function") {
          v2.callback = null, y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now(), typeof e2 == "function" ? v2.callback = e2 : v2 === h2(r2) && k2(r2), G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (v2 !== null)
        var w2 = !0;
      else {
        var m2 = h2(t2);
        m2 !== null && K2(H2, m2.startTime - b2), w2 = !1;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = !1;
    }
  }
  __name(J2, "J");
  var N2 = !1, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return !(exports.unstable_now() - Q2 < P2);
  }
  __name(M2, "M");
  function R2() {
    if (O2 !== null) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = !0;
      try {
        b2 = O2(!0, a2);
      } finally {
        b2 ? S2() : (N2 = !1, O2 = null);
      }
    } else
      N2 = !1;
  }
  __name(R2, "R");
  var S2;
  if (typeof F2 == "function")
    S2 = /* @__PURE__ */ __name(function() {
      F2(R2);
    }, "S");
  else if (typeof MessageChannel < "u") {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2, S2 = /* @__PURE__ */ __name(function() {
      U2.postMessage(null);
    }, "S");
  } else
    S2 = /* @__PURE__ */ __name(function() {
      D2(R2, 0);
    }, "S");
  function I2(a2) {
    O2 = a2, N2 || (N2 = !0, S2());
  }
  __name(I2, "I");
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  __name(K2, "K"), exports.unstable_IdlePriority = 5, exports.unstable_ImmediatePriority = 1, exports.unstable_LowPriority = 4, exports.unstable_NormalPriority = 3, exports.unstable_Profiling = null, exports.unstable_UserBlockingPriority = 2, exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  }, exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = !0, I2(J2));
  }, exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  }, exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  }, exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  }, exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  }, exports.unstable_pauseExecution = function() {
  }, exports.unstable_requestPaint = function() {
  }, exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  }, exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    switch (typeof c2 == "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 == "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2, a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    return e2 = c2 + e2, a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 }, c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), h2(r2) === null && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = !0, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = !0, I2(J2))), a2;
  }, exports.unstable_shouldYield = M2, exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
__name(p$3, "p$3");
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2), ha(a2 + "Capture", b2);
}
__name(fa, "fa");
function ha(a2, b2) {
  for (ea[a2] = b2, a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
__name(ha, "ha");
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  return ja.call(ma, a2) ? !0 : ja.call(la, a2) ? !1 : ka.test(a2) ? ma[a2] = !0 : (la[a2] = !0, !1);
}
__name(oa, "oa");
function pa(a2, b2, c2, d2) {
  if (c2 !== null && c2.type === 0)
    return !1;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return d2 ? !1 : c2 !== null ? !c2.acceptsBooleans : (a2 = a2.toLowerCase().slice(0, 5), a2 !== "data-" && a2 !== "aria-");
    default:
      return !1;
  }
}
__name(pa, "pa");
function qa(a2, b2, c2, d2) {
  if (b2 === null || typeof b2 > "u" || pa(a2, b2, c2, d2))
    return !0;
  if (d2)
    return !1;
  if (c2 !== null)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return b2 === !1;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return !1;
}
__name(qa, "qa");
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = b2 === 2 || b2 === 3 || b2 === 4, this.attributeName = d2, this.attributeNamespace = e2, this.mustUseProperty = c2, this.propertyName = a2, this.type = b2, this.sanitizeURL = f2, this.removeEmptyString = g2;
}
__name(v$2, "v$2");
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 0, !1, a2, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$2(b2, 1, !1, a2[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, !1, a2.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, !1, a2, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, !1, a2.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, !0, a2, null, !1, !1);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 4, !1, a2, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 6, !1, a2, null, !1, !1);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 5, !1, a2.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
__name(sa, "sa");
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$2[b2] = new v$2(b2, 1, !1, a2, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, !1, a2, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, !1, a2, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, !1, a2.toLowerCase(), null, !1, !1);
});
z$2.xlinkHref = new v$2("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, !1, a2.toLowerCase(), null, !0, !0);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  (e2 !== null ? e2.type !== 0 : d2 || !(2 < b2.length) || b2[0] !== "o" && b2[0] !== "O" || b2[1] !== "n" && b2[1] !== "N") && (qa(b2, c2, e2, d2) && (c2 = null), d2 || e2 === null ? oa(b2) && (c2 === null ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = c2 === null ? e2.type === 3 ? !1 : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, c2 === null ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = e2 === 3 || e2 === 4 && c2 === !0 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2))));
}
__name(ta, "ta");
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy"), Ia = Symbol.for("react.offscreen"), Ja = Symbol.iterator;
function Ka(a2) {
  return a2 === null || typeof a2 != "object" ? null : (a2 = Ja && a2[Ja] || a2["@@iterator"], typeof a2 == "function" ? a2 : null);
}
__name(Ka, "Ka");
var A$4 = Object.assign, La;
function Ma(a2) {
  if (La === void 0)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return `
` + La + a2;
}
__name(Ma, "Ma");
var Na = !1;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = !0;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = /* @__PURE__ */ __name(function() {
        throw Error();
      }, "b"), Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && typeof l2.stack == "string") {
      for (var e2 = l2.stack.split(`
`), f2 = d2.stack.split(`
`), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1)
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = `
` + e2[g2].replace(" at new ", " at ");
                return a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName)), k2;
              }
            while (1 <= g2 && 0 <= h2);
          break;
        }
    }
  } finally {
    Na = !1, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
__name(Oa, "Oa");
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, !1), a2;
    case 11:
      return a2 = Oa(a2.type.render, !1), a2;
    case 1:
      return a2 = Oa(a2.type, !0), a2;
    default:
      return "";
  }
}
__name(Pa, "Pa");
function Qa(a2) {
  if (a2 == null)
    return null;
  if (typeof a2 == "function")
    return a2.displayName || a2.name || null;
  if (typeof a2 == "string")
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if (typeof a2 == "object")
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        return a2 = a2.displayName, a2 || (a2 = b2.displayName || b2.name || "", a2 = a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef"), a2;
      case Ga:
        return b2 = a2.displayName || null, b2 !== null ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload, a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch {
        }
    }
  return null;
}
__name(Qa, "Qa");
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || (a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof b2 == "function")
        return b2.displayName || b2.name || null;
      if (typeof b2 == "string")
        return b2;
  }
  return null;
}
__name(Ra, "Ra");
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
__name(Sa, "Sa");
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && a2.toLowerCase() === "input" && (b2 === "checkbox" || b2 === "radio");
}
__name(Ta, "Ta");
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && typeof c2 < "u" && typeof c2.get == "function" && typeof c2.set == "function") {
    var e2 = c2.get, f2 = c2.set;
    return Object.defineProperty(a2, b2, { configurable: !0, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3, f2.call(this, a3);
    } }), Object.defineProperty(a2, b2, { enumerable: c2.enumerable }), { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null, delete a2[b2];
    } };
  }
}
__name(Ua, "Ua");
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
__name(Va, "Va");
function Wa(a2) {
  if (!a2)
    return !1;
  var b2 = a2._valueTracker;
  if (!b2)
    return !0;
  var c2 = b2.getValue(), d2 = "";
  return a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value), a2 = d2, a2 !== c2 ? (b2.setValue(a2), !0) : !1;
}
__name(Wa, "Wa");
function Xa(a2) {
  if (a2 = a2 || (typeof document < "u" ? document : void 0), typeof a2 > "u")
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch {
    return a2.body;
  }
}
__name(Xa, "Xa");
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c2 ?? a2._wrapperState.initialChecked });
}
__name(Ya, "Ya");
function Za(a2, b2) {
  var c2 = b2.defaultValue == null ? "" : b2.defaultValue, d2 = b2.checked != null ? b2.checked : b2.defaultChecked;
  c2 = Sa(b2.value != null ? b2.value : c2), a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: b2.type === "checkbox" || b2.type === "radio" ? b2.checked != null : b2.value != null };
}
__name(Za, "Za");
function ab(a2, b2) {
  b2 = b2.checked, b2 != null && ta(a2, "checked", b2, !1);
}
__name(ab, "ab");
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (c2 != null)
    d2 === "number" ? (c2 === 0 && a2.value === "" || a2.value != c2) && (a2.value = "" + c2) : a2.value !== "" + c2 && (a2.value = "" + c2);
  else if (d2 === "submit" || d2 === "reset") {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue)), b2.checked == null && b2.defaultChecked != null && (a2.defaultChecked = !!b2.defaultChecked);
}
__name(bb, "bb");
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!(d2 !== "submit" && d2 !== "reset" || b2.value !== void 0 && b2.value !== null))
      return;
    b2 = "" + a2._wrapperState.initialValue, c2 || b2 === a2.value || (a2.value = b2), a2.defaultValue = b2;
  }
  c2 = a2.name, c2 !== "" && (a2.name = ""), a2.defaultChecked = !!a2._wrapperState.initialChecked, c2 !== "" && (a2.name = c2);
}
__name(db, "db");
function cb(a2, b2, c2) {
  (b2 !== "number" || Xa(a2.ownerDocument) !== a2) && (c2 == null ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2));
}
__name(cb, "cb");
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  if (a2 = a2.options, b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = !0;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = !0);
  } else {
    for (c2 = "" + Sa(c2), b2 = null, e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = !0, d2 && (a2[e2].defaultSelected = !0);
        return;
      }
      b2 !== null || a2[e2].disabled || (b2 = a2[e2]);
    }
    b2 !== null && (b2.selected = !0);
  }
}
__name(fb, "fb");
function gb(a2, b2) {
  if (b2.dangerouslySetInnerHTML != null)
    throw Error(p$3(91));
  return A$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
__name(gb, "gb");
function hb(a2, b2) {
  var c2 = b2.value;
  if (c2 == null) {
    if (c2 = b2.children, b2 = b2.defaultValue, c2 != null) {
      if (b2 != null)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    b2 == null && (b2 = ""), c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
__name(hb, "hb");
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  c2 != null && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), b2.defaultValue == null && a2.defaultValue !== c2 && (a2.defaultValue = c2)), d2 != null && (a2.defaultValue = "" + d2);
}
__name(ib, "ib");
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && b2 !== "" && b2 !== null && (a2.value = b2);
}
__name(jb, "jb");
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
__name(kb, "kb");
function lb(a2, b2) {
  return a2 == null || a2 === "http://www.w3.org/1999/xhtml" ? kb(b2) : a2 === "http://www.w3.org/2000/svg" && b2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a2;
}
__name(lb, "lb");
var mb, nb = function(a2) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if (a2.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>", b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && c2.nodeType === 3) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
__name(ob, "ob");
var pb = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1), pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return b2 == null || typeof b2 == "boolean" || b2 === "" ? "" : c2 || typeof b2 != "number" || b2 === 0 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
__name(rb, "rb");
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = c2.indexOf("--") === 0, e2 = rb(c2, b2[c2], d2);
      c2 === "float" && (c2 = "cssFloat"), d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
__name(sb, "sb");
var tb = A$4({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (b2.children != null || b2.dangerouslySetInnerHTML != null))
      throw Error(p$3(137, a2));
    if (b2.dangerouslySetInnerHTML != null) {
      if (b2.children != null)
        throw Error(p$3(60));
      if (typeof b2.dangerouslySetInnerHTML != "object" || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (b2.style != null && typeof b2.style != "object")
      throw Error(p$3(62));
  }
}
__name(ub, "ub");
function vb(a2, b2) {
  if (a2.indexOf("-") === -1)
    return typeof b2.is == "string";
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
__name(vb, "vb");
var wb = null;
function xb(a2) {
  return a2 = a2.target || a2.srcElement || window, a2.correspondingUseElement && (a2 = a2.correspondingUseElement), a2.nodeType === 3 ? a2.parentNode : a2;
}
__name(xb, "xb");
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if (typeof yb != "function")
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
__name(Bb, "Bb");
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
__name(Eb, "Eb");
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    if (Ab = zb = null, Bb(a2), b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
__name(Fb, "Fb");
function Gb(a2, b2) {
  return a2(b2);
}
__name(Gb, "Gb");
function Hb() {
}
__name(Hb, "Hb");
var Ib = !1;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = !0;
  try {
    return Gb(a2, b2, c2);
  } finally {
    Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb());
  }
}
__name(Jb, "Jb");
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (c2 === null)
    return null;
  var d2 = Db(c2);
  if (d2 === null)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !(a2 === "button" || a2 === "input" || a2 === "select" || a2 === "textarea")), a2 = !d2;
        break a;
      default:
        a2 = !1;
    }
  if (a2)
    return null;
  if (c2 && typeof c2 != "function")
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
__name(Kb, "Kb");
var Lb = !1;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = !0;
    } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
  } catch {
    Lb = !1;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
__name(Nb, "Nb");
var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function(a2) {
  Ob = !0, Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = !1, Pb = null, Nb.apply(Sb, arguments);
}
__name(Tb, "Tb");
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  if (Tb.apply(this, arguments), Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = !1, Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = !0, Rb = l2);
  }
}
__name(Ub, "Ub");
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, b2.flags & 4098 && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return b2.tag === 3 ? c2 : null;
}
__name(Vb, "Vb");
function Wb(a2) {
  if (a2.tag === 13) {
    var b2 = a2.memoizedState;
    if (b2 === null && (a2 = a2.alternate, a2 !== null && (b2 = a2.memoizedState)), b2 !== null)
      return b2.dehydrated;
  }
  return null;
}
__name(Wb, "Wb");
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
__name(Xb, "Xb");
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    if (b2 = Vb(a2), b2 === null)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (e2 === null)
      break;
    var f2 = e2.alternate;
    if (f2 === null) {
      if (d2 = e2.return, d2 !== null) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = !1, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = !0, c2 = e2, d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = !0, d2 = e2, c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = !0, c2 = f2, d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = !0, d2 = f2, c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (c2.tag !== 3)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
__name(Yb, "Yb");
function Zb(a2) {
  return a2 = Yb(a2), a2 !== null ? $b(a2) : null;
}
__name(Zb, "Zb");
function $b(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2;
  for (a2 = a2.child; a2 !== null; ) {
    var b2 = $b(a2);
    if (b2 !== null)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
__name($b, "$b");
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && typeof lc.onCommitFiberRoot == "function")
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, (a2.current.flags & 128) === 128);
    } catch {
    }
}
__name(mc, "mc");
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  return a2 >>>= 0, a2 === 0 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
__name(nc, "nc");
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
__name(tc, "tc");
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (c2 === 0)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (g2 !== 0) {
    var h2 = g2 & ~e2;
    h2 !== 0 ? d2 = tc(h2) : (f2 &= g2, f2 !== 0 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, g2 !== 0 ? d2 = tc(g2) : f2 !== 0 && (d2 = tc(f2));
  if (d2 === 0)
    return 0;
  if (b2 !== 0 && b2 !== d2 && !(b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || e2 === 16 && (f2 & 4194240) !== 0))
    return b2;
  if (d2 & 4 && (d2 |= c2 & 16), b2 = a2.entangledLanes, b2 !== 0)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
__name(uc, "uc");
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
__name(vc, "vc");
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    k2 === -1 ? (!(h2 & c2) || h2 & d2) && (e2[g2] = vc(h2, b2)) : k2 <= b2 && (a2.expiredLanes |= h2), f2 &= ~h2;
  }
}
__name(wc, "wc");
function xc(a2) {
  return a2 = a2.pendingLanes & -1073741825, a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
__name(xc, "xc");
function yc() {
  var a2 = rc;
  return rc <<= 1, !(rc & 4194240) && (rc = 64), a2;
}
__name(yc, "yc");
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
__name(zc, "zc");
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2, b2 !== 536870912 && (a2.suspendedLanes = 0, a2.pingedLanes = 0), a2 = a2.eventTimes, b2 = 31 - oc(b2), a2[b2] = c2;
}
__name(Ac, "Ac");
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2, a2.suspendedLanes = 0, a2.pingedLanes = 0, a2.expiredLanes &= b2, a2.mutableReadLanes &= b2, a2.entangledLanes &= b2, b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0, d2[e2] = -1, a2[e2] = -1, c2 &= ~f2;
  }
}
__name(Bc, "Bc");
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2), c2 &= ~e2;
  }
}
__name(Cc, "Cc");
var C$2 = 0;
function Dc(a2) {
  return a2 &= -a2, 1 < a2 ? 4 < a2 ? a2 & 268435455 ? 16 : 536870912 : 4 : 1;
}
__name(Dc, "Dc");
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
__name(Sc, "Sc");
function Tc(a2, b2, c2, d2, e2, f2) {
  return a2 === null || a2.nativeEvent !== f2 ? (a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, b2 !== null && (b2 = Cb(b2), b2 !== null && Fc(b2)), a2) : (a2.eventSystemFlags |= d2, b2 = a2.targetContainers, e2 !== null && b2.indexOf(e2) === -1 && b2.push(e2), a2);
}
__name(Tc, "Tc");
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), !0;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), !0;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), !0;
    case "pointerover":
      var f2 = e2.pointerId;
      return Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2)), !0;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), !0;
  }
  return !1;
}
__name(Uc, "Uc");
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (b2 !== null) {
    var c2 = Vb(b2);
    if (c2 !== null) {
      if (b2 = c2.tag, b2 === 13) {
        if (b2 = Wb(c2), b2 !== null) {
          a2.blockedOn = b2, Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (b2 === 3 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = c2.tag === 3 ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
__name(Vc, "Vc");
function Xc(a2) {
  if (a2.blockedOn !== null)
    return !1;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (c2 === null) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2, c2.target.dispatchEvent(d2), wb = null;
    } else
      return b2 = Cb(c2), b2 !== null && Fc(b2), a2.blockedOn = c2, !1;
    b2.shift();
  }
  return !0;
}
__name(Xc, "Xc");
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
__name(Zc, "Zc");
function $c() {
  Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
}
__name($c, "$c");
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
__name(ad, "ad");
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (__name(b2, "b"), 0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  for (Lc !== null && ad(Lc, a2), Mc !== null && ad(Mc, a2), Nc !== null && ad(Nc, a2), Oc.forEach(b2), Pc.forEach(b2), c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], c2.blockedOn === null); )
    Vc(c2), c2.blockedOn === null && Qc.shift();
}
__name(bd, "bd");
var cd = ua.ReactCurrentBatchConfig, dd = !0;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
__name(ed, "ed");
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
__name(gd, "gd");
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (e2 === null)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; e2 !== null; ) {
        var f2 = Cb(e2);
        if (f2 !== null && Ec(f2), f2 = Yc(a2, b2, c2, d2), f2 === null && hd(a2, b2, d2, id, c2), f2 === e2)
          break;
        e2 = f2;
      }
      e2 !== null && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
__name(fd, "fd");
var id = null;
function Yc(a2, b2, c2, d2) {
  if (id = null, a2 = xb(d2), a2 = Wc(a2), a2 !== null)
    if (b2 = Vb(a2), b2 === null)
      a2 = null;
    else if (c2 = b2.tag, c2 === 13) {
      if (a2 = Wb(b2), a2 !== null)
        return a2;
      a2 = null;
    } else if (c2 === 3) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return b2.tag === 3 ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  return id = a2, null;
}
__name(Yc, "Yc");
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
__name(jd, "jd");
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
__name(nd, "nd");
function od(a2) {
  var b2 = a2.keyCode;
  return "charCode" in a2 ? (a2 = a2.charCode, a2 === 0 && b2 === 13 && (a2 = 13)) : a2 = b2, a2 === 10 && (a2 = 13), 32 <= a2 || a2 === 13 ? a2 : 0;
}
__name(od, "od");
function pd() {
  return !0;
}
__name(pd, "pd");
function qd() {
  return !1;
}
__name(qd, "qd");
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3, this._targetInst = e2, this.type = d2, this.nativeEvent = f2, this.target = g2, this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    return this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this;
  }
  return __name(b2, "b"), A$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : typeof a3.returnValue != "unknown" && (a3.returnValue = !1), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : typeof a3.cancelBubble != "unknown" && (a3.cancelBubble = !0), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd }), b2;
}
__name(rd, "rd");
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return a2.relatedTarget === void 0 ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  return "movementX" in a2 ? a2.movementX : (a2 !== yd && (yd && a2.type === "mousemove" ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2), wd);
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : !1;
}
__name(Pd, "Pd");
function zd() {
  return Pd;
}
__name(zd, "zd");
var Qd = A$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if (b2 !== "Unidentified")
      return b2;
  }
  return a2.type === "keypress" ? (a2 = od(a2), a2 === 13 ? "Enter" : String.fromCharCode(a2)) : a2.type === "keydown" || a2.type === "keyup" ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return a2.type === "keypress" ? od(a2) : 0;
}, keyCode: function(a2) {
  return a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
}, which: function(a2) {
  return a2.type === "keypress" ? od(a2) : a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$2 || be$1 && 8 < be$1 && 11 >= be$1), ee$2 = String.fromCharCode(32), fe$1 = !1;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return $d.indexOf(b2.keyCode) !== -1;
    case "keydown":
      return b2.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
__name(ge$1, "ge$1");
function he$1(a2) {
  return a2 = a2.detail, typeof a2 == "object" && "data" in a2 ? a2.data : null;
}
__name(he$1, "he$1");
var ie$2 = !1;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      return b2.which !== 32 ? null : (fe$1 = !0, ee$2);
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$1 ? null : a2;
    default:
      return null;
  }
}
__name(je, "je");
function ke$2(a2, b2) {
  if (ie$2)
    return a2 === "compositionend" || !ae$2 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = !1, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && b2.locale !== "ko" ? null : b2.data;
    default:
      return null;
  }
}
__name(ke$2, "ke$2");
var le$1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 === "input" ? !!le$1[a2.type] : b2 === "textarea";
}
__name(me$1, "me$1");
function ne$1(a2, b2, c2, d2) {
  Eb(d2), b2 = oe$2(b2, "onChange"), 0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
__name(ne$1, "ne$1");
var pe$1 = null, qe$1 = null;
function re$2(a2) {
  se$2(a2, 0);
}
__name(re$2, "re$2");
function te$2(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
__name(te$2, "te$2");
function ve$1(a2, b2) {
  if (a2 === "change")
    return b2;
}
__name(ve$1, "ve$1");
var we$1 = !1;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;"), ye$1 = typeof ze$1.oninput == "function";
    }
    xe$1 = ye$1;
  } else
    xe$1 = !1;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
__name(Ae$1, "Ae$1");
function Be$1(a2) {
  if (a2.propertyName === "value" && te$2(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2)), Jb(re$2, b2);
  }
}
__name(Be$1, "Be$1");
function Ce$2(a2, b2, c2) {
  a2 === "focusin" ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : a2 === "focusout" && Ae$1();
}
__name(Ce$2, "Ce$2");
function De$1(a2) {
  if (a2 === "selectionchange" || a2 === "keyup" || a2 === "keydown")
    return te$2(qe$1);
}
__name(De$1, "De$1");
function Ee(a2, b2) {
  if (a2 === "click")
    return te$2(b2);
}
__name(Ee, "Ee");
function Fe$1(a2, b2) {
  if (a2 === "input" || a2 === "change")
    return te$2(b2);
}
__name(Fe$1, "Fe$1");
function Ge$1(a2, b2) {
  return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
__name(Ge$1, "Ge$1");
var He$1 = typeof Object.is == "function" ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return !0;
  if (typeof a2 != "object" || a2 === null || typeof b2 != "object" || b2 === null)
    return !1;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return !1;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return !1;
  }
  return !0;
}
__name(Ie$1, "Ie$1");
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
__name(Je$1, "Je$1");
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (c2.nodeType === 3) {
      if (d2 = a2 + c2.textContent.length, a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
__name(Ke, "Ke");
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? !0 : a2 && a2.nodeType === 3 ? !1 : b2 && b2.nodeType === 3 ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : !1 : !1;
}
__name(Le, "Le");
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = typeof b2.contentWindow.location.href == "string";
    } catch {
      c2 = !1;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
__name(Me$2, "Me$2");
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && (b2 === "input" && (a2.type === "text" || a2.type === "search" || a2.type === "tel" || a2.type === "url" || a2.type === "password") || b2 === "textarea" || a2.contentEditable === "true");
}
__name(Ne, "Ne");
function Oe(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (d2 !== null && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, a2 === void 0 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = d2.end === void 0 ? f2 : Math.min(d2.end, e2), !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2), e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (a2.rangeCount !== 1 || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    for (b2 = [], a2 = c2; a2 = a2.parentNode; )
      a2.nodeType === 1 && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    for (typeof c2.focus == "function" && c2.focus(), c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
__name(Oe, "Oe");
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = !1;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : c2.nodeType === 9 ? c2 : c2.ownerDocument;
  Te$1 || Qe$1 == null || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$2(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
__name(Ue$1, "Ue$1");
function Ve$1(a2, b2) {
  var c2 = {};
  return c2[a2.toLowerCase()] = b2.toLowerCase(), c2["Webkit" + a2] = "webkit" + b2, c2["Moz" + a2] = "moz" + b2, c2;
}
__name(Ve$1, "Ve$1");
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
__name(Ze$1, "Ze$1");
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2), fa(b2, [a2]);
}
__name(ff, "ff");
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2, Ub(d2, b2, void 0, a2), a2.currentTarget = null;
}
__name(nf, "nf");
function se$2(a2, b2) {
  b2 = (b2 & 4) !== 0;
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          if (h2 = h2.listener, k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2), f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          if (h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget, h2 = h2.listener, k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2), f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = !1, Rb = null, a2;
}
__name(se$2, "se$2");
function D$2(a2, b2) {
  var c2 = b2[of];
  c2 === void 0 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, !1), c2.add(d2));
}
__name(D$2, "D$2");
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4), pf(c2, a2, d2, b2);
}
__name(qf, "qf");
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = !0, da.forEach(function(b3) {
      b3 !== "selectionchange" && (mf.has(b3) || qf(b3, !1, a2), qf(b3, !0, a2));
    });
    var b2 = a2.nodeType === 9 ? a2 : a2.ownerDocument;
    b2 === null || b2[rf] || (b2[rf] = !0, qf("selectionchange", !1, b2));
  }
}
__name(sf, "sf");
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2), e2 = void 0, !Lb || b2 !== "touchstart" && b2 !== "touchmove" && b2 !== "wheel" || (e2 = !0), d2 ? e2 !== void 0 ? a2.addEventListener(b2, c2, { capture: !0, passive: e2 }) : a2.addEventListener(b2, c2, !0) : e2 !== void 0 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, !1);
}
__name(pf, "pf");
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (!(b2 & 1) && !(b2 & 2) && d2 !== null)
    a:
      for (; ; ) {
        if (d2 === null)
          return;
        var g2 = d2.tag;
        if (g2 === 3 || g2 === 4) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || h2.nodeType === 8 && h2.parentNode === e2)
            break;
          if (g2 === 4)
            for (g2 = d2.return; g2 !== null; ) {
              var k2 = g2.tag;
              if ((k2 === 3 || k2 === 4) && (k2 = g2.stateNode.containerInfo, k2 === e2 || k2.nodeType === 8 && k2.parentNode === e2))
                return;
              g2 = g2.return;
            }
          for (; h2 !== null; ) {
            if (g2 = Wc(h2), g2 === null)
              return;
            if (k2 = g2.tag, k2 === 5 || k2 === 6) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (h3 !== void 0) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (od(c2) === 0)
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus", k3 = Fd;
            break;
          case "focusout":
            n2 = "blur", k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (c2.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = (b2 & 4) !== 0, J2 = !t2 && a2 === "scroll", x2 = t2 ? h3 !== null ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; w2 !== null; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          if (u2.tag === 5 && F2 !== null && (u2 = F2, x2 !== null && (F2 = Kb(w2, x2), F2 != null && t2.push(tf(w2, F2, u2)))), J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (!(b2 & 7)) {
      a: {
        if (h3 = a2 === "mouseover" || a2 === "pointerover", k3 = a2 === "mouseout" || a2 === "pointerout", h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if ((k3 || h3) && (h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window, k3 ? (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, n2 !== null && (J2 = Vb(n2), n2 !== J2 || n2.tag !== 5 && n2.tag !== 6) && (n2 = null)) : (k3 = null, n2 = d3), k3 !== n2)) {
          if (t2 = Bd, F2 = "onMouseLeave", x2 = "onMouseEnter", w2 = "mouse", (a2 === "pointerout" || a2 === "pointerover") && (t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer"), J2 = k3 == null ? h3 : ue$1(k3), u2 = n2 == null ? h3 : ue$1(n2), h3 = new t2(F2, w2 + "leave", k3, c2, e3), h3.target = J2, h3.relatedTarget = u2, F2 = null, Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2), J2 = F2, k3 && n2)
            b: {
              for (t2 = k3, x2 = n2, w2 = 0, u2 = t2; u2; u2 = vf(u2))
                w2++;
              for (u2 = 0, F2 = x2; F2; F2 = vf(F2))
                u2++;
              for (; 0 < w2 - u2; )
                t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; )
                x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || x2 !== null && t2 === x2.alternate)
                  break b;
                t2 = vf(t2), x2 = vf(x2);
              }
              t2 = null;
            }
          else
            t2 = null;
          k3 !== null && wf(g3, h3, k3, t2, !1), n2 !== null && J2 !== null && wf(g3, J2, n2, t2, !0);
        }
      }
      a: {
        if (h3 = d3 ? ue$1(d3) : window, k3 = h3.nodeName && h3.nodeName.toLowerCase(), k3 === "select" || k3 === "input" && h3.type === "file")
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$2;
          }
        else
          (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3), a2 === "focusout" && (xa = h3._wrapperState) && xa.controlled && h3.type === "number" && cb(h3, "number", h3.value);
      }
      switch (xa = d3 ? ue$1(d3) : window, a2) {
        case "focusin":
          (me$1(xa) || xa.contentEditable === "true") && (Qe$1 = xa, Re$1 = d3, Se$1 = null);
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = !1, Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$2)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : a2 === "keydown" && c2.keyCode === 229 && (ba = "onCompositionStart");
      ba && (de$1 && c2.locale !== "ko" && (ie$2 || ba !== "onCompositionStart" ? ba === "onCompositionEnd" && ie$2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = !0)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), $a !== null && (ba.data = $a)))), ($a = ce$2 ? je(a2, c2) : ke$2(a2, c2)) && (d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a));
    }
    se$2(g3, b2);
  });
}
__name(hd, "hd");
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
__name(tf, "tf");
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; a2 !== null; ) {
    var e2 = a2, f2 = e2.stateNode;
    e2.tag === 5 && f2 !== null && (e2 = f2, f2 = Kb(a2, c2), f2 != null && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), f2 != null && d2.push(tf(a2, f2, e2))), a2 = a2.return;
  }
  return d2;
}
__name(oe$2, "oe$2");
function vf(a2) {
  if (a2 === null)
    return null;
  do
    a2 = a2.return;
  while (a2 && a2.tag !== 5);
  return a2 || null;
}
__name(vf, "vf");
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; c2 !== null && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (k2 !== null && k2 === d2)
      break;
    h2.tag === 5 && l2 !== null && (h2 = l2, e2 ? (k2 = Kb(c2, f2), k2 != null && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), k2 != null && g2.push(tf(c2, k2, h2)))), c2 = c2.return;
  }
  g2.length !== 0 && a2.push({ event: b2, listeners: g2 });
}
__name(wf, "wf");
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return (typeof a2 == "string" ? a2 : "" + a2).replace(xf, `
`).replace(yf, "");
}
__name(zf, "zf");
function Af(a2, b2, c2) {
  if (b2 = zf(b2), zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
__name(Af, "Af");
function Bf() {
}
__name(Bf, "Bf");
var Cf = null, Df = null;
function Ef(a2, b2) {
  return a2 === "textarea" || a2 === "noscript" || typeof b2.children == "string" || typeof b2.children == "number" || typeof b2.dangerouslySetInnerHTML == "object" && b2.dangerouslySetInnerHTML !== null && b2.dangerouslySetInnerHTML.__html != null;
}
__name(Ef, "Ef");
var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
__name(If, "If");
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    if (a2.removeChild(c2), e2 && e2.nodeType === 8)
      if (c2 = e2.data, c2 === "/$") {
        if (d2 === 0) {
          a2.removeChild(e2), bd(b2);
          return;
        }
        d2--;
      } else
        c2 !== "$" && c2 !== "$?" && c2 !== "$!" || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
__name(Kf, "Kf");
function Lf(a2) {
  for (; a2 != null; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (b2 === 1 || b2 === 3)
      break;
    if (b2 === 8) {
      if (b2 = a2.data, b2 === "$" || b2 === "$!" || b2 === "$?")
        break;
      if (b2 === "/$")
        return null;
    }
  }
  return a2;
}
__name(Lf, "Lf");
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (a2.nodeType === 8) {
      var c2 = a2.data;
      if (c2 === "$" || c2 === "$!" || c2 === "$?") {
        if (b2 === 0)
          return a2;
        b2--;
      } else
        c2 === "/$" && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
__name(Mf, "Mf");
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      if (c2 = b2.alternate, b2.child !== null || c2 !== null && c2.child !== null)
        for (a2 = Mf(a2); a2 !== null; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2, c2 = a2.parentNode;
  }
  return null;
}
__name(Wc, "Wc");
function Cb(a2) {
  return a2 = a2[Of] || a2[uf], !a2 || a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 13 && a2.tag !== 3 ? null : a2;
}
__name(Cb, "Cb");
function ue$1(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2.stateNode;
  throw Error(p$3(33));
}
__name(ue$1, "ue$1");
function Db(a2) {
  return a2[Pf] || null;
}
__name(Db, "Db");
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
__name(Uf, "Uf");
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
__name(E$1, "E$1");
function G$2(a2, b2) {
  Tf++, Sf[Tf] = a2.current, a2.current = b2;
}
__name(G$2, "G$2");
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(!1), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  return d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2), e2;
}
__name(Yf, "Yf");
function Zf(a2) {
  return a2 = a2.childContextTypes, a2 != null;
}
__name(Zf, "Zf");
function $f() {
  E$1(Wf), E$1(H$2);
}
__name($f, "$f");
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$3(168));
  G$2(H$2, b2), G$2(Wf, c2);
}
__name(ag, "ag");
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (b2 = b2.childContextTypes, typeof d2.getChildContext != "function")
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A$4({}, c2, d2);
}
__name(bg, "bg");
function cg(a2) {
  return a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf, Xf = H$2.current, G$2(H$2, a2), G$2(Wf, Wf.current), !0;
}
__name(cg, "cg");
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$2(H$2, a2)) : E$1(Wf), G$2(Wf, c2);
}
__name(dg, "dg");
var eg = null, fg = !1, gg = !1;
function hg(a2) {
  eg === null ? eg = [a2] : eg.push(a2);
}
__name(hg, "hg");
function ig(a2) {
  fg = !0, hg(a2);
}
__name(ig, "ig");
function jg() {
  if (!gg && eg !== null) {
    gg = !0;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(!0);
        while (d2 !== null);
      }
      eg = null, fg = !1;
    } catch (e2) {
      throw eg !== null && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = !1;
    }
  }
  return null;
}
__name(jg, "jg");
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng, kg[lg++] = mg, mg = a2, ng = b2;
}
__name(tg, "tg");
function ug(a2, b2, c2) {
  og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2), c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32), d2 >>= g2, e2 -= g2, rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2, sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
__name(ug, "ug");
function vg(a2) {
  a2.return !== null && (tg(a2, 1), ug(a2, 1, 0));
}
__name(vg, "vg");
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
__name(wg, "wg");
var xg = null, yg = null, I$1 = !1, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED", c2.stateNode = b2, c2.return = a2, b2 = a2.deletions, b2 === null ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
__name(Ag, "Ag");
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      return b2 = b2.nodeType !== 1 || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2, b2 !== null ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), !0) : !1;
    case 6:
      return b2 = a2.pendingProps === "" || b2.nodeType !== 3 ? null : b2, b2 !== null ? (a2.stateNode = b2, xg = a2, yg = null, !0) : !1;
    case 13:
      return b2 = b2.nodeType !== 8 ? null : b2, b2 !== null ? (c2 = qg !== null ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, !0) : !1;
    default:
      return !1;
  }
}
__name(Cg, "Cg");
function Dg(a2) {
  return (a2.mode & 1) !== 0 && (a2.flags & 128) === 0;
}
__name(Dg, "Dg");
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = !1, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2, I$1 = !1, xg = a2;
    }
  }
}
__name(Eg, "Eg");
function Fg(a2) {
  for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
    a2 = a2.return;
  xg = a2;
}
__name(Fg, "Fg");
function Gg(a2) {
  if (a2 !== xg)
    return !1;
  if (!I$1)
    return Fg(a2), I$1 = !0, !1;
  var b2;
  if ((b2 = a2.tag !== 3) && !(b2 = a2.tag !== 5) && (b2 = a2.type, b2 = b2 !== "head" && b2 !== "body" && !Ef(a2.type, a2.memoizedProps)), b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  if (Fg(a2), a2.tag === 13) {
    if (a2 = a2.memoizedState, a2 = a2 !== null ? a2.dehydrated : null, !a2)
      throw Error(p$3(317));
    a: {
      for (a2 = a2.nextSibling, b2 = 0; a2; ) {
        if (a2.nodeType === 8) {
          var c2 = a2.data;
          if (c2 === "/$") {
            if (b2 === 0) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            c2 !== "$" && c2 !== "$!" && c2 !== "$?" || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return !0;
}
__name(Gg, "Gg");
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
__name(Hg, "Hg");
function Ig() {
  yg = xg = null, I$1 = !1;
}
__name(Ig, "Ig");
function Jg(a2) {
  zg === null ? zg = [a2] : zg.push(a2);
}
__name(Jg, "Jg");
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$4({}, b2), a2 = a2.defaultProps;
    for (var c2 in a2)
      b2[c2] === void 0 && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
__name(Lg, "Lg");
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
__name(Qg, "Qg");
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg), a2._currentValue = b2;
}
__name(Rg, "Rg");
function Sg(a2, b2, c2) {
  for (; a2 !== null; ) {
    var d2 = a2.alternate;
    if ((a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, d2 !== null && (d2.childLanes |= b2)) : d2 !== null && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2), a2 === c2)
      break;
    a2 = a2.return;
  }
}
__name(Sg, "Sg");
function Tg(a2, b2) {
  Ng = a2, Pg = Og = null, a2 = a2.dependencies, a2 !== null && a2.firstContext !== null && (a2.lanes & b2 && (Ug = !0), a2.firstContext = null);
}
__name(Tg, "Tg");
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, Og === null) {
      if (Ng === null)
        throw Error(p$3(308));
      Og = a2, Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
__name(Vg, "Vg");
var Wg = null;
function Xg(a2) {
  Wg === null ? Wg = [a2] : Wg.push(a2);
}
__name(Xg, "Xg");
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  return e2 === null ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2), b2.interleaved = c2, Zg(a2, d2);
}
__name(Yg, "Yg");
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  for (c2 !== null && (c2.lanes |= b2), c2 = a2, a2 = a2.return; a2 !== null; )
    a2.childLanes |= b2, c2 = a2.alternate, c2 !== null && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return c2.tag === 3 ? c2.stateNode : null;
}
__name(Zg, "Zg");
var $g = !1;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
__name(ah, "ah");
function bh(a2, b2) {
  a2 = a2.updateQueue, b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
__name(bh, "bh");
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
__name(ch, "ch");
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (d2 === null)
    return null;
  if (d2 = d2.shared, K$1 & 2) {
    var e2 = d2.pending;
    return e2 === null ? b2.next = b2 : (b2.next = e2.next, e2.next = b2), d2.pending = b2, Zg(a2, c2);
  }
  return e2 = d2.interleaved, e2 === null ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2), d2.interleaved = b2, Zg(a2, c2);
}
__name(dh, "dh");
function eh(a2, b2, c2) {
  if (b2 = b2.updateQueue, b2 !== null && (b2 = b2.shared, (c2 & 4194240) !== 0)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes, c2 |= d2, b2.lanes = c2, Cc(a2, c2);
  }
}
__name(eh, "eh");
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (d2 !== null && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    if (c2 = c2.firstBaseUpdate, c2 !== null) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        f2 === null ? e2 = f2 = g2 : f2 = f2.next = g2, c2 = c2.next;
      } while (c2 !== null);
      f2 === null ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects }, a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate, a2 === null ? c2.firstBaseUpdate = b2 : a2.next = b2, c2.lastBaseUpdate = b2;
}
__name(fh, "fh");
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = !1;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (h2 !== null) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null, g2 === null ? f2 = l2 : g2.next = l2, g2 = k2;
    var m2 = a2.alternate;
    m2 !== null && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (h2 === null ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (f2 !== null) {
    var q2 = e2.baseState;
    g2 = 0, m2 = l2 = k2 = null, h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        m2 !== null && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          switch (r2 = b2, y2 = c2, t2.tag) {
            case 1:
              if (n2 = t2.payload, typeof n2 == "function") {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              if (n2 = t2.payload, r2 = typeof n2 == "function" ? n2.call(y2, q2, r2) : n2, r2 == null)
                break a;
              q2 = A$4({}, q2, r2);
              break a;
            case 2:
              $g = !0;
          }
        }
        h2.callback !== null && h2.lane !== 0 && (a2.flags |= 64, r2 = e2.effects, r2 === null ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, m2 === null ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      if (h2 = h2.next, h2 === null) {
        if (h2 = e2.shared.pending, h2 === null)
          break;
        r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      }
    } while (1);
    if (m2 === null && (k2 = q2), e2.baseState = k2, e2.firstBaseUpdate = l2, e2.lastBaseUpdate = m2, b2 = e2.shared.interleaved, b2 !== null) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      f2 === null && (e2.shared.lanes = 0);
    hh |= g2, a2.lanes = g2, a2.memoizedState = q2;
  }
}
__name(gh, "gh");
function ih(a2, b2, c2) {
  if (a2 = b2.effects, b2.effects = null, a2 !== null)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (e2 !== null) {
        if (d2.callback = null, d2 = c2, typeof e2 != "function")
          throw Error(p$3(191, e2));
        e2.call(d2);
      }
    }
}
__name(ih, "ih");
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState, c2 = c2(d2, b2), c2 = c2 == null ? b2 : A$4({}, b2, c2), a2.memoizedState = c2, a2.lanes === 0 && (a2.updateQueue.baseState = c2);
}
__name(kh, "kh");
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : !1;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2, c2 != null && (f2.callback = c2), b2 = dh(a2, f2, e2), b2 !== null && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1, f2.payload = b2, c2 != null && (f2.callback = c2), b2 = dh(a2, f2, e2), b2 !== null && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2, b2 != null && (e2.callback = b2), b2 = dh(a2, e2, d2), b2 !== null && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  return a2 = a2.stateNode, typeof a2.shouldComponentUpdate == "function" ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : !0;
}
__name(oh, "oh");
function ph(a2, b2, c2) {
  var d2 = !1, e2 = Vf, f2 = b2.contextType;
  return typeof f2 == "object" && f2 !== null ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = d2 != null) ? Yf(a2, e2) : Vf), b2 = new b2(c2, f2), a2.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null, b2.updater = nh, a2.stateNode = b2, b2._reactInternals = a2, d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2), b2;
}
__name(ph, "ph");
function qh(a2, b2, c2, d2) {
  a2 = b2.state, typeof b2.componentWillReceiveProps == "function" && b2.componentWillReceiveProps(c2, d2), typeof b2.UNSAFE_componentWillReceiveProps == "function" && b2.UNSAFE_componentWillReceiveProps(c2, d2), b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
__name(qh, "qh");
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2, e2.state = a2.memoizedState, e2.refs = jh, ah(a2);
  var f2 = b2.contextType;
  typeof f2 == "object" && f2 !== null ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2)), e2.state = a2.memoizedState, f2 = b2.getDerivedStateFromProps, typeof f2 == "function" && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState), typeof b2.getDerivedStateFromProps == "function" || typeof e2.getSnapshotBeforeUpdate == "function" || typeof e2.UNSAFE_componentWillMount != "function" && typeof e2.componentWillMount != "function" || (b2 = e2.state, typeof e2.componentWillMount == "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount == "function" && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState), typeof e2.componentDidMount == "function" && (a2.flags |= 4194308);
}
__name(rh, "rh");
function sh(a2, b2, c2) {
  if (a2 = c2.ref, a2 !== null && typeof a2 != "function" && typeof a2 != "object") {
    if (c2._owner) {
      if (c2 = c2._owner, c2) {
        if (c2.tag !== 1)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      return b2 !== null && b2.ref !== null && typeof b2.ref == "function" && b2.ref._stringRef === f2 ? b2.ref : (b2 = /* @__PURE__ */ __name(function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {}), a3 === null ? delete b3[f2] : b3[f2] = a3;
      }, "b"), b2._stringRef = f2, b2);
    }
    if (typeof a2 != "string")
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
__name(sh, "sh");
function th(a2, b2) {
  throw a2 = Object.prototype.toString.call(b2), Error(p$3(31, a2 === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
__name(th, "th");
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
__name(uh, "uh");
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      d3 === null ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  __name(b2, "b");
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; d3 !== null; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  __name(c2, "c");
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); b3 !== null; )
      b3.key !== null ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  __name(d2, "d");
  function e2(a3, b3) {
    return a3 = wh(a3, b3), a3.index = 0, a3.sibling = null, a3;
  }
  __name(e2, "e");
  function f2(b3, c3, d3) {
    return b3.index = d3, a2 ? (d3 = b3.alternate, d3 !== null ? (d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3) : (b3.flags |= 2, c3)) : (b3.flags |= 1048576, c3);
  }
  __name(f2, "f");
  function g2(b3) {
    return a2 && b3.alternate === null && (b3.flags |= 2), b3;
  }
  __name(g2, "g");
  function h2(a3, b3, c3, d3) {
    return b3 === null || b3.tag !== 6 ? (b3 = xh(c3, a3.mode, d3), b3.return = a3, b3) : (b3 = e2(b3, c3), b3.return = a3, b3);
  }
  __name(h2, "h");
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    return f3 === ya ? m2(a3, b3, c3.props.children, d3, c3.key) : b3 !== null && (b3.elementType === f3 || typeof f3 == "object" && f3 !== null && f3.$$typeof === Ha && uh(f3) === b3.type) ? (d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3) : (d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3), d3.ref = sh(a3, b3, c3), d3.return = a3, d3);
  }
  __name(k2, "k");
  function l2(a3, b3, c3, d3) {
    return b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation ? (b3 = zh(c3, a3.mode, d3), b3.return = a3, b3) : (b3 = e2(b3, c3.children || []), b3.return = a3, b3);
  }
  __name(l2, "l");
  function m2(a3, b3, c3, d3, f3) {
    return b3 === null || b3.tag !== 7 ? (b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3) : (b3 = e2(b3, c3), b3.return = a3, b3);
  }
  __name(m2, "m");
  function q2(a3, b3, c3) {
    if (typeof b3 == "string" && b3 !== "" || typeof b3 == "number")
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if (typeof b3 == "object" && b3 !== null) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  __name(q2, "q");
  function r2(a3, b3, c3, d3) {
    var e3 = b3 !== null ? b3.key : null;
    if (typeof c3 == "string" && c3 !== "" || typeof c3 == "number")
      return e3 !== null ? null : h2(a3, b3, "" + c3, d3);
    if (typeof c3 == "object" && c3 !== null) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return e3 !== null ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  __name(r2, "r");
  function y2(a3, b3, c3, d3, e3) {
    if (typeof d3 == "string" && d3 !== "" || typeof d3 == "number")
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if (typeof d3 == "object" && d3 !== null) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  __name(y2, "y");
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; u2 !== null && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (n3 === null) {
        u2 === null && (u2 = x2);
        break;
      }
      a2 && u2 && n3.alternate === null && b2(e3, u2), g3 = f2(n3, g3, w2), m3 === null ? l3 = n3 : m3.sibling = n3, m3 = n3, u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$1 && tg(e3, w2), l3;
    if (u2 === null) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), u2 !== null && (g3 = f2(u2, g3, w2), m3 === null ? l3 = u2 : m3.sibling = u2, m3 = u2);
      return I$1 && tg(e3, w2), l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), x2 !== null && (a2 && x2.alternate !== null && u2.delete(x2.key === null ? w2 : x2.key), g3 = f2(x2, g3, w2), m3 === null ? l3 = x2 : m3.sibling = x2, m3 = x2);
    return a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    }), I$1 && tg(e3, w2), l3;
  }
  __name(n2, "n");
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if (typeof l3 != "function")
      throw Error(p$3(150));
    if (h3 = l3.call(h3), h3 == null)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); m3 !== null && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (t3 === null) {
        m3 === null && (m3 = x2);
        break;
      }
      a2 && m3 && t3.alternate === null && b2(e3, m3), g3 = f2(t3, g3, w2), u2 === null ? l3 = t3 : u2.sibling = t3, u2 = t3, m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$1 && tg(e3, w2), l3;
    if (m3 === null) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), n3 !== null && (g3 = f2(n3, g3, w2), u2 === null ? l3 = n3 : u2.sibling = n3, u2 = n3);
      return I$1 && tg(e3, w2), l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), n3 !== null && (a2 && n3.alternate !== null && m3.delete(n3.key === null ? w2 : n3.key), g3 = f2(n3, g3, w2), u2 === null ? l3 = n3 : u2.sibling = n3, u2 = n3);
    return a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    }), I$1 && tg(e3, w2), l3;
  }
  __name(t2, "t");
  function J2(a3, d3, f3, h3) {
    if (typeof f3 == "object" && f3 !== null && f3.type === ya && f3.key === null && (f3 = f3.props.children), typeof f3 == "object" && f3 !== null) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; l3 !== null; ) {
              if (l3.key === k3) {
                if (k3 = f3.type, k3 === ya) {
                  if (l3.tag === 7) {
                    c2(a3, l3.sibling), d3 = e2(l3, f3.props.children), d3.return = a3, a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || typeof k3 == "object" && k3 !== null && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling), d3 = e2(l3, f3.props), d3.ref = sh(a3, l3, f3), d3.return = a3, a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; d3 !== null; ) {
              if (d3.key === l3)
                if (d3.tag === 4 && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling), d3 = e2(d3, f3.children || []), d3.return = a3, a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3), d3.return = a3, a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return typeof f3 == "string" && f3 !== "" || typeof f3 == "number" ? (f3 = "" + f3, d3 !== null && d3.tag === 6 ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return __name(J2, "J"), J2;
}
__name(vh, "vh");
var Bh = vh(!0), Ch = vh(!1), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$3(174));
  return a2;
}
__name(Hh, "Hh");
function Ih(a2, b2) {
  switch (G$2(Gh, b2), G$2(Fh, a2), G$2(Eh, Dh), a2 = b2.nodeType, a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = a2 === 8 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh), G$2(Eh, b2);
}
__name(Ih, "Ih");
function Jh() {
  E$1(Eh), E$1(Fh), E$1(Gh);
}
__name(Jh, "Jh");
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current), c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
__name(Kh, "Kh");
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
__name(Lh, "Lh");
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; b2 !== null; ) {
    if (b2.tag === 13) {
      var c2 = b2.memoizedState;
      if (c2 !== null && (c2 = c2.dehydrated, c2 === null || c2.data === "$?" || c2.data === "$!"))
        return b2;
    } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
      if (b2.flags & 128)
        return b2;
    } else if (b2.child !== null) {
      b2.child.return = b2, b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; b2.sibling === null; ) {
      if (b2.return === null || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return, b2 = b2.sibling;
  }
  return null;
}
__name(Mh, "Mh");
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
__name(Oh, "Oh");
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$1 = null, Sh = !1, Th = !1, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$3(321));
}
__name(Q$2, "Q$2");
function Wh(a2, b2) {
  if (b2 === null)
    return !1;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return !1;
  return !0;
}
__name(Wh, "Wh");
function Xh(a2, b2, c2, d2, e2, f2) {
  if (Rh = f2, N$2 = b2, b2.memoizedState = null, b2.updateQueue = null, b2.lanes = 0, Ph.current = a2 === null || a2.memoizedState === null ? Yh : Zh, a2 = c2(d2, e2), Th) {
    f2 = 0;
    do {
      if (Th = !1, Uh = 0, 25 <= f2)
        throw Error(p$3(301));
      f2 += 1, P$1 = O$2 = null, b2.updateQueue = null, Ph.current = $h, a2 = c2(d2, e2);
    } while (Th);
  }
  if (Ph.current = ai$1, b2 = O$2 !== null && O$2.next !== null, Rh = 0, P$1 = O$2 = N$2 = null, Sh = !1, b2)
    throw Error(p$3(300));
  return a2;
}
__name(Xh, "Xh");
function bi$1() {
  var a2 = Uh !== 0;
  return Uh = 0, a2;
}
__name(bi$1, "bi$1");
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return P$1 === null ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2, P$1;
}
__name(ci$1, "ci$1");
function di$1() {
  if (O$2 === null) {
    var a2 = N$2.alternate;
    a2 = a2 !== null ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = P$1 === null ? N$2.memoizedState : P$1.next;
  if (b2 !== null)
    P$1 = b2, O$2 = a2;
  else {
    if (a2 === null)
      throw Error(p$3(310));
    O$2 = a2, a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null }, P$1 === null ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
__name(di$1, "di$1");
function ei$1(a2, b2) {
  return typeof b2 == "function" ? b2(a2) : b2;
}
__name(ei$1, "ei$1");
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (f2 !== null) {
    if (e2 !== null) {
      var g2 = e2.next;
      e2.next = f2.next, f2.next = g2;
    }
    d2.baseQueue = e2 = f2, c2.pending = null;
  }
  if (e2 !== null) {
    f2 = e2.next, d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        k2 !== null && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        k2 === null ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2, N$2.lanes |= m2, hh |= m2;
      }
      l2 = l2.next;
    } while (l2 !== null && l2 !== f2);
    k2 === null ? g2 = d2 : k2.next = h2, He$1(d2, b2.memoizedState) || (Ug = !0), b2.memoizedState = d2, b2.baseState = g2, b2.baseQueue = k2, c2.lastRenderedState = d2;
  }
  if (a2 = c2.interleaved, a2 !== null) {
    e2 = a2;
    do
      f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    e2 === null && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
__name(fi$1, "fi$1");
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (e2 !== null) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = !0), b2.memoizedState = f2, b2.baseQueue === null && (b2.baseState = f2), c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
__name(gi$1, "gi$1");
function hi$1() {
}
__name(hi$1, "hi$1");
function ii$1(a2, b2) {
  var c2 = N$2, d2 = di$1(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
  if (f2 && (d2.memoizedState = e2, Ug = !0), d2 = d2.queue, ji$1(ki$1.bind(null, c2, d2, a2), [a2]), d2.getSnapshot !== b2 || f2 || P$1 !== null && P$1.memoizedState.tag & 1) {
    if (c2.flags |= 2048, li$1(9, mi$1.bind(null, c2, d2, e2, b2), void 0, null), R$1 === null)
      throw Error(p$3(349));
    Rh & 30 || ni$1(c2, b2, e2);
  }
  return e2;
}
__name(ii$1, "ii$1");
function ni$1(a2, b2, c2) {
  a2.flags |= 16384, a2 = { getSnapshot: b2, value: c2 }, b2 = N$2.updateQueue, b2 === null ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, c2 === null ? b2.stores = [a2] : c2.push(a2));
}
__name(ni$1, "ni$1");
function mi$1(a2, b2, c2, d2) {
  b2.value = c2, b2.getSnapshot = d2, oi$1(b2) && pi$1(a2);
}
__name(mi$1, "mi$1");
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
__name(ki$1, "ki$1");
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch {
    return !0;
  }
}
__name(oi$1, "oi$1");
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  b2 !== null && mh(b2, a2, 1, -1);
}
__name(pi$1, "pi$1");
function qi$1(a2) {
  var b2 = ci$1();
  return typeof a2 == "function" && (a2 = a2()), b2.memoizedState = b2.baseState = a2, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 }, b2.queue = a2, a2 = a2.dispatch = ri$1.bind(null, N$2, a2), [b2.memoizedState, a2];
}
__name(qi$1, "qi$1");
function li$1(a2, b2, c2, d2) {
  return a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null }, b2 = N$2.updateQueue, b2 === null ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, c2 === null ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2)), a2;
}
__name(li$1, "li$1");
function si$1() {
  return di$1().memoizedState;
}
__name(si$1, "si$1");
function ti$1(a2, b2, c2, d2) {
  var e2 = ci$1();
  N$2.flags |= a2, e2.memoizedState = li$1(1 | b2, c2, void 0, d2 === void 0 ? null : d2);
}
__name(ti$1, "ti$1");
function ui$1(a2, b2, c2, d2) {
  var e2 = di$1();
  d2 = d2 === void 0 ? null : d2;
  var f2 = void 0;
  if (O$2 !== null) {
    var g2 = O$2.memoizedState;
    if (f2 = g2.destroy, d2 !== null && Wh(d2, g2.deps)) {
      e2.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2, e2.memoizedState = li$1(1 | b2, c2, f2, d2);
}
__name(ui$1, "ui$1");
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
__name(vi$1, "vi$1");
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
__name(ji$1, "ji$1");
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
__name(wi$1, "wi$1");
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
__name(xi$1, "xi$1");
function yi$1(a2, b2) {
  if (typeof b2 == "function")
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (b2 != null)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
__name(yi$1, "yi$1");
function zi$1(a2, b2, c2) {
  return c2 = c2 != null ? c2.concat([a2]) : null, ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
__name(zi$1, "zi$1");
function Ai$1() {
}
__name(Ai$1, "Ai$1");
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  return d2 !== null && b2 !== null && Wh(b2, d2[1]) ? d2[0] : (c2.memoizedState = [a2, b2], a2);
}
__name(Bi$1, "Bi$1");
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  return d2 !== null && b2 !== null && Wh(b2, d2[1]) ? d2[0] : (a2 = a2(), c2.memoizedState = [a2, b2], a2);
}
__name(Ci$1, "Ci$1");
function Di$1(a2, b2, c2) {
  return Rh & 21 ? (He$1(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = !0), b2) : (a2.baseState && (a2.baseState = !1, Ug = !0), a2.memoizedState = c2);
}
__name(Di$1, "Di$1");
function Ei$1(a2, b2) {
  var c2 = C$2;
  C$2 = c2 !== 0 && 4 > c2 ? c2 : 4, a2(!0);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(!1), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
__name(Ei$1, "Ei$1");
function Fi$1() {
  return di$1().memoizedState;
}
__name(Fi$1, "Fi$1");
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  if (c2 = { lane: d2, action: c2, hasEagerState: !1, eagerState: null, next: null }, Hi$1(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), c2 !== null) {
    var e2 = L$2();
    mh(c2, a2, d2, e2), Ji$1(c2, b2, d2);
  }
}
__name(Gi$1, "Gi$1");
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: !1, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, e2);
  else {
    var f2 = a2.alternate;
    if (a2.lanes === 0 && (f2 === null || f2.lanes === 0) && (f2 = b2.lastRenderedReducer, f2 !== null))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        if (e2.hasEagerState = !0, e2.eagerState = h2, He$1(h2, g2)) {
          var k2 = b2.interleaved;
          k2 === null ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2), b2.interleaved = e2;
          return;
        }
      } catch {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2), c2 !== null && (e2 = L$2(), mh(c2, a2, d2, e2), Ji$1(c2, b2, d2));
  }
}
__name(ri$1, "ri$1");
function Hi$1(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || b2 !== null && b2 === N$2;
}
__name(Hi$1, "Hi$1");
function Ii$1(a2, b2) {
  Th = Sh = !0;
  var c2 = a2.pending;
  c2 === null ? b2.next = b2 : (b2.next = c2.next, c2.next = b2), a2.pending = b2;
}
__name(Ii$1, "Ii$1");
function Ji$1(a2, b2, c2) {
  if (c2 & 4194240) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes, c2 |= d2, b2.lanes = c2, Cc(a2, c2);
  }
}
__name(Ji$1, "Ji$1");
var ai$1 = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: !1 }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  return ci$1().memoizedState = [a2, b2 === void 0 ? null : b2], a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  return c2 = c2 != null ? c2.concat([a2]) : null, ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  return b2 = b2 === void 0 ? null : b2, a2 = a2(), c2.memoizedState = [a2, b2], a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  return b2 = c2 !== void 0 ? c2(b2) : b2, d2.memoizedState = d2.baseState = b2, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 }, d2.queue = a2, a2 = a2.dispatch = Gi$1.bind(null, N$2, a2), [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  return a2 = { current: a2 }, b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(!1), b2 = a2[0];
  return a2 = Ei$1.bind(null, a2[1]), ci$1().memoizedState = a2, [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e2 = ci$1();
  if (I$1) {
    if (c2 === void 0)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    if (c2 = b2(), R$1 === null)
      throw Error(p$3(349));
    Rh & 30 || ni$1(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  return e2.queue = f2, vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]), d2.flags |= 2048, li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null), c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg, d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2, b2 = ":" + b2 + "R" + c2, c2 = Uh++, 0 < c2 && (b2 += "H" + c2.toString(32)), b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: !1 }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi$1,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: !1
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi$1, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return O$2 === null ? b2.memoizedState = a2 : Di$1(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: !1 };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = `
Error generating stack: ` + f2.message + `
` + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
__name(Ki$1, "Ki$1");
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: c2 ?? null, digest: b2 ?? null };
}
__name(Li$1, "Li$1");
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
__name(Mi$1, "Mi$1");
var Ni$1 = typeof WeakMap == "function" ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2), c2.tag = 3, c2.payload = { element: null };
  var d2 = b2.value;
  return c2.callback = function() {
    Pi$1 || (Pi$1 = !0, Qi$1 = d2), Mi$1(a2, b2);
  }, c2;
}
__name(Oi$1, "Oi$1");
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2), c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if (typeof d2 == "function") {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    }, c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  return f2 !== null && typeof f2.componentDidCatch == "function" && (c2.callback = function() {
    Mi$1(a2, b2), typeof d2 != "function" && (Si$1 === null ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: c3 !== null ? c3 : "" });
  }), c2;
}
__name(Ri$1, "Ri$1");
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (d2 === null) {
    d2 = a2.pingCache = new Ni$1();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), e2 === void 0 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui$1.bind(null, a2, b2, c2), b2.then(a2, a2));
}
__name(Ti$1, "Ti$1");
function Vi$1(a2) {
  do {
    var b2;
    if ((b2 = a2.tag === 13) && (b2 = a2.memoizedState, b2 = b2 !== null ? b2.dehydrated !== null : !0), b2)
      return a2;
    a2 = a2.return;
  } while (a2 !== null);
  return null;
}
__name(Vi$1, "Vi$1");
function Wi$1(a2, b2, c2, d2, e2) {
  return a2.mode & 1 ? (a2.flags |= 65536, a2.lanes = e2, a2) : (a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, c2.tag === 1 && (c2.alternate === null ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2);
}
__name(Wi$1, "Wi$1");
var Xi$1 = ua.ReactCurrentOwner, Ug = !1;
function Yi$1(a2, b2, c2, d2) {
  b2.child = a2 === null ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
__name(Yi$1, "Yi$1");
function Zi$1(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  return Tg(b2, e2), d2 = Xh(a2, b2, c2, d2, f2, e2), c2 = bi$1(), a2 !== null && !Ug ? (b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2)) : (I$1 && c2 && vg(b2), b2.flags |= 1, Yi$1(a2, b2, d2, e2), b2.child);
}
__name(Zi$1, "Zi$1");
function aj(a2, b2, c2, d2, e2) {
  if (a2 === null) {
    var f2 = c2.type;
    return typeof f2 == "function" && !bj(f2) && f2.defaultProps === void 0 && c2.compare === null && c2.defaultProps === void 0 ? (b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2)) : (a2 = yh(c2.type, null, d2, b2, b2.mode, e2), a2.ref = b2.ref, a2.return = b2, b2.child = a2);
  }
  if (f2 = a2.child, !(a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    if (c2 = c2.compare, c2 = c2 !== null ? c2 : Ie$1, c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e2);
  }
  return b2.flags |= 1, a2 = wh(f2, d2), a2.ref = b2.ref, a2.return = b2, b2.child = a2;
}
__name(aj, "aj");
function cj(a2, b2, c2, d2, e2) {
  if (a2 !== null) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = !1, b2.pendingProps = d2 = f2, (a2.lanes & e2) !== 0)
        a2.flags & 131072 && (Ug = !0);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
__name(cj, "cj");
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = a2 !== null ? a2.memoizedState : null;
  if (d2.mode === "hidden")
    if (!(b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (!(c2 & 1073741824))
        return a2 = f2 !== null ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d2 = f2 !== null ? f2.baseLanes : c2, G$2(fj, gj), gj |= d2;
    }
  else
    f2 !== null ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$2(fj, gj), gj |= d2;
  return Yi$1(a2, b2, e2, c2), b2.child;
}
__name(ej, "ej");
function hj(a2, b2) {
  var c2 = b2.ref;
  (a2 === null && c2 !== null || a2 !== null && a2.ref !== c2) && (b2.flags |= 512, b2.flags |= 2097152);
}
__name(hj, "hj");
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  return f2 = Yf(b2, f2), Tg(b2, e2), c2 = Xh(a2, b2, c2, d2, f2, e2), d2 = bi$1(), a2 !== null && !Ug ? (b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2)) : (I$1 && d2 && vg(b2), b2.flags |= 1, Yi$1(a2, b2, c2, e2), b2.child);
}
__name(dj, "dj");
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = !0;
    cg(b2);
  } else
    f2 = !1;
  if (Tg(b2, e2), b2.stateNode === null)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = !0;
  else if (a2 === null) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    typeof l2 == "object" && l2 !== null ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = typeof m2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function";
    q2 || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2), $g = !1;
    var r2 = b2.memoizedState;
    g2.state = r2, gh(b2, d2, g2, e2), k2 = b2.memoizedState, h2 !== d2 || r2 !== k2 || Wf.current || $g ? (typeof m2 == "function" && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || typeof g2.UNSAFE_componentWillMount != "function" && typeof g2.componentWillMount != "function" || (typeof g2.componentWillMount == "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount == "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount == "function" && (b2.flags |= 4194308)) : (typeof g2.componentDidMount == "function" && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : (typeof g2.componentDidMount == "function" && (b2.flags |= 4194308), d2 = !1);
  } else {
    g2 = b2.stateNode, bh(a2, b2), h2 = b2.memoizedProps, l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2), g2.props = l2, q2 = b2.pendingProps, r2 = g2.context, k2 = c2.contextType, typeof k2 == "object" && k2 !== null ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = typeof y2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function") || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2), $g = !1, r2 = b2.memoizedState, g2.state = r2, gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? (typeof y2 == "function" && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || !1) ? (m2 || typeof g2.UNSAFE_componentWillUpdate != "function" && typeof g2.componentWillUpdate != "function" || (typeof g2.componentWillUpdate == "function" && g2.componentWillUpdate(d2, n2, k2), typeof g2.UNSAFE_componentWillUpdate == "function" && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), typeof g2.componentDidUpdate == "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate == "function" && (b2.flags |= 1024)) : (typeof g2.componentDidUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : (typeof g2.componentDidUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = !1);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
__name(ij, "ij");
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = (b2.flags & 128) !== 0;
  if (!d2 && !g2)
    return e2 && dg(b2, c2, !1), $i$1(a2, b2, f2);
  d2 = b2.stateNode, Xi$1.current = b2;
  var h2 = g2 && typeof c2.getDerivedStateFromError != "function" ? null : d2.render();
  return b2.flags |= 1, a2 !== null && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi$1(a2, b2, h2, f2), b2.memoizedState = d2.state, e2 && dg(b2, c2, !0), b2.child;
}
__name(kj, "kj");
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, !1), Ih(a2, b2.containerInfo);
}
__name(lj, "lj");
function mj(a2, b2, c2, d2, e2) {
  return Ig(), Jg(e2), b2.flags |= 256, Yi$1(a2, b2, c2, d2), b2.child;
}
__name(mj, "mj");
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
__name(oj, "oj");
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = !1, g2 = (b2.flags & 128) !== 0, h2;
  if ((h2 = g2) || (h2 = a2 !== null && a2.memoizedState === null ? !1 : (e2 & 2) !== 0), h2 ? (f2 = !0, b2.flags &= -129) : (a2 === null || a2.memoizedState !== null) && (e2 |= 1), G$2(M$1, e2 & 1), a2 === null)
    return Eg(b2), a2 = b2.memoizedState, a2 !== null && (a2 = a2.dehydrated, a2 !== null) ? (b2.mode & 1 ? a2.data === "$!" ? b2.lanes = 8 : b2.lanes = 1073741824 : b2.lanes = 1, null) : (g2 = d2.children, a2 = d2.fallback, f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, !(d2 & 1) && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2));
  if (e2 = a2.memoizedState, e2 !== null && (h2 = e2.dehydrated, h2 !== null))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback, g2 = b2.mode, e2 = a2.child, h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    return !(g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064), h2 !== null ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2), f2.return = b2, d2.return = b2, d2.sibling = f2, b2.child = d2, d2 = f2, f2 = b2.child, g2 = a2.child.memoizedState, g2 = g2 === null ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions }, f2.memoizedState = g2, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = nj, d2;
  }
  return f2 = a2.child, a2 = f2.sibling, d2 = wh(f2, { mode: "visible", children: d2.children }), !(b2.mode & 1) && (d2.lanes = c2), d2.return = b2, d2.sibling = null, a2 !== null && (c2 = b2.deletions, c2 === null ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2)), b2.child = d2, b2.memoizedState = null, d2;
}
__name(pj, "pj");
function rj(a2, b2) {
  return b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null), b2.return = a2, a2.child = b2;
}
__name(rj, "rj");
function tj(a2, b2, c2, d2) {
  return d2 !== null && Jg(d2), Bh(b2, a2.child, null, c2), a2 = rj(b2, b2.pendingProps.children), a2.flags |= 2, b2.memoizedState = null, a2;
}
__name(tj, "tj");
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2)
    return b2.flags & 256 ? (b2.flags &= -257, d2 = Li$1(Error(p$3(422))), tj(a2, b2, g2, d2)) : b2.memoizedState !== null ? (b2.child = a2.child, b2.flags |= 128, null) : (f2 = d2.fallback, e2 = b2.mode, d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null), f2 = Ah(f2, e2, g2, null), f2.flags |= 2, d2.return = b2, f2.return = b2, d2.sibling = f2, b2.child = d2, b2.mode & 1 && Bh(b2, a2.child, null, g2), b2.child.memoizedState = oj(g2), b2.memoizedState = nj, f2);
  if (!(b2.mode & 1))
    return tj(a2, b2, g2, null);
  if (e2.data === "$!") {
    if (d2 = e2.nextSibling && e2.nextSibling.dataset, d2)
      var h2 = d2.dgst;
    return d2 = h2, f2 = Error(p$3(419)), d2 = Li$1(f2, d2, void 0), tj(a2, b2, g2, d2);
  }
  if (h2 = (g2 & a2.childLanes) !== 0, Ug || h2) {
    if (d2 = R$1, d2 !== null) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = e2 & (d2.suspendedLanes | g2) ? 0 : e2, e2 !== 0 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    return uj(), d2 = Li$1(Error(p$3(421))), tj(a2, b2, g2, d2);
  }
  return e2.data === "$?" ? (b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null) : (a2 = f2.treeContext, yg = Lf(e2.nextSibling), xg = b2, I$1 = !0, zg = null, a2 !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2), b2 = rj(b2, d2.children), b2.flags |= 4096, b2);
}
__name(sj, "sj");
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  d2 !== null && (d2.lanes |= b2), Sg(a2.return, b2, c2);
}
__name(wj, "wj");
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  f2 === null ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
__name(xj, "xj");
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  if (Yi$1(a2, b2, d2.children, c2), d2 = M$1.current, d2 & 2)
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (a2 !== null && a2.flags & 128)
      a:
        for (a2 = b2.child; a2 !== null; ) {
          if (a2.tag === 13)
            a2.memoizedState !== null && wj(a2, c2, b2);
          else if (a2.tag === 19)
            wj(a2, c2, b2);
          else if (a2.child !== null) {
            a2.child.return = a2, a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; a2.sibling === null; ) {
            if (a2.return === null || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return, a2 = a2.sibling;
        }
    d2 &= 1;
  }
  if (G$2(M$1, d2), !(b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        for (c2 = b2.child, e2 = null; c2 !== null; )
          a2 = c2.alternate, a2 !== null && Mh(a2) === null && (e2 = c2), c2 = c2.sibling;
        c2 = e2, c2 === null ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null), xj(b2, !1, e2, c2, f2);
        break;
      case "backwards":
        for (c2 = null, e2 = b2.child, b2.child = null; e2 !== null; ) {
          if (a2 = e2.alternate, a2 !== null && Mh(a2) === null) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling, e2.sibling = c2, c2 = e2, e2 = a2;
        }
        xj(b2, !0, c2, null, f2);
        break;
      case "together":
        xj(b2, !1, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
__name(yj, "yj");
function jj(a2, b2) {
  !(b2.mode & 1) && a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
__name(jj, "jj");
function $i$1(a2, b2, c2) {
  if (a2 !== null && (b2.dependencies = a2.dependencies), hh |= b2.lanes, !(c2 & b2.childLanes))
    return null;
  if (a2 !== null && b2.child !== a2.child)
    throw Error(p$3(153));
  if (b2.child !== null) {
    for (a2 = b2.child, c2 = wh(a2, a2.pendingProps), b2.child = c2, c2.return = b2; a2.sibling !== null; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
__name($i$1, "$i$1");
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2), Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$2(Mg, d2._currentValue), d2._currentValue = e2;
      break;
    case 13:
      if (d2 = b2.memoizedState, d2 !== null)
        return d2.dehydrated !== null ? (G$2(M$1, M$1.current & 1), b2.flags |= 128, null) : c2 & b2.child.childLanes ? pj(a2, b2, c2) : (G$2(M$1, M$1.current & 1), a2 = $i$1(a2, b2, c2), a2 !== null ? a2.sibling : null);
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      if (d2 = (c2 & b2.childLanes) !== 0, a2.flags & 128) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      if (e2 = b2.memoizedState, e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null), G$2(M$1, M$1.current), d2)
        break;
      return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
__name(zj, "zj");
var Aj, Bj, Cj, Dj;
Aj = /* @__PURE__ */ __name(function(a2, b2) {
  for (var c2 = b2.child; c2 !== null; ) {
    if (c2.tag === 5 || c2.tag === 6)
      a2.appendChild(c2.stateNode);
    else if (c2.tag !== 4 && c2.child !== null) {
      c2.child.return = c2, c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return, c2 = c2.sibling;
  }
}, "Aj");
Bj = /* @__PURE__ */ __name(function() {
}, "Bj");
Cj = /* @__PURE__ */ __name(function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode, Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2), d2 = Ya(a2, d2), f2 = [];
        break;
      case "select":
        e2 = A$4({}, e2, { value: void 0 }), d2 = A$4({}, d2, { value: void 0 }), f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2), d2 = gb(a2, d2), f2 = [];
        break;
      default:
        typeof e2.onClick != "function" && typeof d2.onClick == "function" && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && e2[l2] != null)
        if (l2 === "style") {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      if (h2 = e2 != null ? e2[l2] : void 0, d2.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null))
        if (l2 === "style")
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 != "string" && typeof k2 != "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ea.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    (b2.updateQueue = l2) && (b2.flags |= 4);
  }
}, "Cj");
Dj = /* @__PURE__ */ __name(function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
}, "Dj");
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; b2 !== null; )
          b2.alternate !== null && (c2 = b2), b2 = b2.sibling;
        c2 === null ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; c2 !== null; )
          c2.alternate !== null && (d2 = c2), c2 = c2.sibling;
        d2 === null ? b2 || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
__name(Ej, "Ej");
function S$2(a2) {
  var b2 = a2.alternate !== null && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  return a2.subtreeFlags |= d2, a2.childLanes = c2, b2;
}
__name(S$2, "S$2");
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  switch (wg(b2), b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 3:
      return d2 = b2.stateNode, Jh(), E$1(Wf), E$1(H$2), Oh(), d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null), (a2 === null || a2.child === null) && (Gg(b2) ? b2.flags |= 4 : a2 === null || a2.memoizedState.isDehydrated && !(b2.flags & 256) || (b2.flags |= 1024, zg !== null && (Gj(zg), zg = null))), Bj(a2, b2), S$2(b2), null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      if (c2 = b2.type, a2 !== null && b2.stateNode != null)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (b2.stateNode === null)
            throw Error(p$3(166));
          return S$2(b2), null;
        }
        if (a2 = Hh(Eh.current), Gg(b2)) {
          d2 = b2.stateNode, c2 = b2.type;
          var f2 = b2.memoizedProps;
          switch (d2[Of] = b2, d2[Pf] = f2, a2 = (b2.mode & 1) !== 0, c2) {
            case "dialog":
              D$2("cancel", d2), D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$2(lf[e2], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              ), D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2), D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple }, D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2), e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              g2 === "children" ? typeof h2 == "string" ? d2.textContent !== h2 && (f2.suppressHydrationWarning !== !0 && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : typeof h2 == "number" && d2.textContent !== "" + h2 && (f2.suppressHydrationWarning !== !0 && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && h2 != null && g2 === "onScroll" && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2), db(d2, f2, !0);
              break;
            case "textarea":
              Va(d2), jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f2.onClick == "function" && (d2.onclick = Bf);
          }
          d2 = e2, b2.updateQueue = d2, d2 !== null && (b2.flags |= 4);
        } else {
          g2 = e2.nodeType === 9 ? e2 : e2.ownerDocument, a2 === "http://www.w3.org/1999/xhtml" && (a2 = kb(c2)), a2 === "http://www.w3.org/1999/xhtml" ? c2 === "script" ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : typeof d2.is == "string" ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), c2 === "select" && (g2 = a2, d2.multiple ? g2.multiple = !0 : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2), a2[Of] = b2, a2[Pf] = d2, Aj(a2, b2, !1, !1), b2.stateNode = a2;
          a: {
            switch (g2 = vb(c2, d2), c2) {
              case "dialog":
                D$2("cancel", a2), D$2("close", a2), e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2), e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$2("error", a2), e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                ), D$2("load", a2), e2 = d2;
                break;
              case "details":
                D$2("toggle", a2), e2 = d2;
                break;
              case "input":
                Za(a2, d2), e2 = Ya(a2, d2), D$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple }, e2 = A$4({}, d2, { value: void 0 }), D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2), e2 = gb(a2, d2), D$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2), h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                f2 === "style" ? sb(a2, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && nb(a2, k2)) : f2 === "children" ? typeof k2 == "string" ? (c2 !== "textarea" || k2 !== "") && ob(a2, k2) : typeof k2 == "number" && ob(a2, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (ea.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && D$2("scroll", a2) : k2 != null && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2), db(a2, d2, !1);
                break;
              case "textarea":
                Va(a2), jb(a2);
                break;
              case "option":
                d2.value != null && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple, f2 = d2.value, f2 != null ? fb(a2, !!d2.multiple, f2, !1) : d2.defaultValue != null && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  !0
                );
                break;
              default:
                typeof e2.onClick == "function" && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = !0;
                break a;
              default:
                d2 = !1;
            }
          }
          d2 && (b2.flags |= 4);
        }
        b2.ref !== null && (b2.flags |= 512, b2.flags |= 2097152);
      }
      return S$2(b2), null;
    case 6:
      if (a2 && b2.stateNode != null)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if (typeof d2 != "string" && b2.stateNode === null)
          throw Error(p$3(166));
        if (c2 = Hh(Gh.current), Hh(Eh.current), Gg(b2)) {
          if (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[Of] = b2, (f2 = d2.nodeValue !== c2) && (a2 = xg, a2 !== null))
            switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, (a2.mode & 1) !== 0);
                break;
              case 5:
                a2.memoizedProps.suppressHydrationWarning !== !0 && Af(d2.nodeValue, c2, (a2.mode & 1) !== 0);
            }
          f2 && (b2.flags |= 4);
        } else
          d2 = (c2.nodeType === 9 ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      return S$2(b2), null;
    case 13:
      if (E$1(M$1), d2 = b2.memoizedState, a2 === null || a2.memoizedState !== null && a2.memoizedState.dehydrated !== null) {
        if (I$1 && yg !== null && b2.mode & 1 && !(b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = !1;
        else if (f2 = Gg(b2), d2 !== null && d2.dehydrated !== null) {
          if (a2 === null) {
            if (!f2)
              throw Error(p$3(318));
            if (f2 = b2.memoizedState, f2 = f2 !== null ? f2.dehydrated : null, !f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), !(b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$2(b2), f2 = !1;
        } else
          zg !== null && (Gj(zg), zg = null), f2 = !0;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      return b2.flags & 128 ? (b2.lanes = c2, b2) : (d2 = d2 !== null, d2 !== (a2 !== null && a2.memoizedState !== null) && d2 && (b2.child.flags |= 8192, b2.mode & 1 && (a2 === null || M$1.current & 1 ? T$2 === 0 && (T$2 = 3) : uj())), b2.updateQueue !== null && (b2.flags |= 4), S$2(b2), null);
    case 4:
      return Jh(), Bj(a2, b2), a2 === null && sf(b2.stateNode.containerInfo), S$2(b2), null;
    case 10:
      return Rg(b2.type._context), S$2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 19:
      if (E$1(M$1), f2 = b2.memoizedState, f2 === null)
        return S$2(b2), null;
      if (d2 = (b2.flags & 128) !== 0, g2 = f2.rendering, g2 === null)
        if (d2)
          Ej(f2, !1);
        else {
          if (T$2 !== 0 || a2 !== null && a2.flags & 128)
            for (a2 = b2.child; a2 !== null; ) {
              if (g2 = Mh(a2), g2 !== null) {
                for (b2.flags |= 128, Ej(f2, !1), d2 = g2.updateQueue, d2 !== null && (b2.updateQueue = d2, b2.flags |= 4), b2.subtreeFlags = 0, d2 = c2, c2 = b2.child; c2 !== null; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = a2 === null ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                return G$2(M$1, M$1.current & 1 | 2), b2.child;
              }
              a2 = a2.sibling;
            }
          f2.tail !== null && B$2() > Hj && (b2.flags |= 128, d2 = !0, Ej(f2, !1), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), a2 !== null) {
            if (b2.flags |= 128, d2 = !0, c2 = a2.updateQueue, c2 !== null && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, !0), f2.tail === null && f2.tailMode === "hidden" && !g2.alternate && !I$1)
              return S$2(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && c2 !== 1073741824 && (b2.flags |= 128, d2 = !0, Ej(f2, !1), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, c2 !== null ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      return f2.tail !== null ? (b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2) : (S$2(b2), null);
    case 22:
    case 23:
      return Ij(), d2 = b2.memoizedState !== null, a2 !== null && a2.memoizedState !== null !== d2 && (b2.flags |= 8192), d2 && b2.mode & 1 ? gj & 1073741824 && (S$2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
__name(Fj, "Fj");
function Jj(a2, b2) {
  switch (wg(b2), b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a2 = b2.flags, a2 & 65536 && !(a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      if (E$1(M$1), a2 = b2.memoizedState, a2 !== null && a2.dehydrated !== null) {
        if (b2.alternate === null)
          throw Error(p$3(340));
        Ig();
      }
      return a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
__name(Jj, "Jj");
var Kj = !1, U$2 = !1, Lj = typeof WeakSet == "function" ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (c2 !== null)
    if (typeof c2 == "function")
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
__name(Mj, "Mj");
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
__name(Nj, "Nj");
var Oj = !1;
function Pj(a2, b2) {
  if (Cf = dd, a2 = Me$2(), Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && d2.rangeCount !== 0) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; q2 !== c2 || e2 !== 0 && q2.nodeType !== 3 || (h2 = g2 + e2), q2 !== f2 || d2 !== 0 && q2.nodeType !== 3 || (k2 = g2 + d2), q2.nodeType === 3 && (g2 += q2.nodeValue.length), (y2 = q2.firstChild) !== null; )
                r2 = q2, q2 = y2;
              for (; ; ) {
                if (q2 === a2)
                  break b;
                if (r2 === c2 && ++l2 === e2 && (h2 = g2), r2 === f2 && ++m2 === d2 && (k2 = g2), (y2 = q2.nextSibling) !== null)
                  break;
                q2 = r2, r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = h2 === -1 || k2 === -1 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  for (Df = { focusedElem: a2, selectionRange: c2 }, dd = !1, V$2 = b2; V$2 !== null; )
    if (b2 = V$2, a2 = b2.child, (b2.subtreeFlags & 1028) !== 0 && a2 !== null)
      a2.return = b2, V$2 = a2;
    else
      for (; V$2 !== null; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (b2.flags & 1024)
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (n2 !== null) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                u2.nodeType === 1 ? u2.textContent = "" : u2.nodeType === 9 && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        if (a2 = b2.sibling, a2 !== null) {
          a2.return = b2.return, V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  return n2 = Oj, Oj = !1, n2;
}
__name(Pj, "Pj");
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  if (d2 = d2 !== null ? d2.lastEffect : null, d2 !== null) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0, f2 !== void 0 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
__name(Qj, "Qj");
function Rj(a2, b2) {
  if (b2 = b2.updateQueue, b2 = b2 !== null ? b2.lastEffect : null, b2 !== null) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
__name(Rj, "Rj");
function Sj(a2) {
  var b2 = a2.ref;
  if (b2 !== null) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    typeof b2 == "function" ? b2(a2) : b2.current = a2;
  }
}
__name(Sj, "Sj");
function Tj(a2) {
  var b2 = a2.alternate;
  b2 !== null && (a2.alternate = null, Tj(b2)), a2.child = null, a2.deletions = null, a2.sibling = null, a2.tag === 5 && (b2 = a2.stateNode, b2 !== null && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf])), a2.stateNode = null, a2.return = null, a2.dependencies = null, a2.memoizedProps = null, a2.memoizedState = null, a2.pendingProps = null, a2.stateNode = null, a2.updateQueue = null;
}
__name(Tj, "Tj");
function Uj(a2) {
  return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
}
__name(Uj, "Uj");
function Vj(a2) {
  a:
    for (; ; ) {
      for (; a2.sibling === null; ) {
        if (a2.return === null || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      for (a2.sibling.return = a2.return, a2 = a2.sibling; a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 18; ) {
        if (a2.flags & 2 || a2.child === null || a2.tag === 4)
          continue a;
        a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
__name(Vj, "Vj");
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.nodeType === 8 ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (c2.nodeType === 8 ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, c2 != null || b2.onclick !== null || (b2.onclick = Bf));
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Wj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
__name(Wj, "Wj");
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Xj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
__name(Xj, "Xj");
var X$2 = null, Yj = !1;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; c2 !== null; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
__name(Zj, "Zj");
function ak(a2, b2, c2) {
  if (lc && typeof lc.onCommitFiberUnmount == "function")
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e2 = Yj;
      X$2 = null, Zj(a2, b2, c2), X$2 = d2, Yj = e2, X$2 !== null && (Yj ? (a2 = X$2, c2 = c2.stateNode, a2.nodeType === 8 ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      X$2 !== null && (Yj ? (a2 = X$2, c2 = c2.stateNode, a2.nodeType === 8 ? Kf(a2.parentNode, c2) : a2.nodeType === 1 && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2, e2 = Yj, X$2 = c2.stateNode.containerInfo, Yj = !0, Zj(a2, b2, c2), X$2 = d2, Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, d2 !== null && (d2 = d2.lastEffect, d2 !== null))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag, g2 !== void 0 && (f2 & 2 || f2 & 4) && Nj(c2, b2, g2), e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, typeof d2.componentWillUnmount == "function"))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || c2.memoizedState !== null, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
__name(ak, "ak");
function bk(a2) {
  var b2 = a2.updateQueue;
  if (b2 !== null) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    c2 === null && (c2 = a2.stateNode = new Lj()), b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
__name(bk, "bk");
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (c2 !== null)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; h2 !== null; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode, Yj = !1;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo, Yj = !0;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo, Yj = !0;
                break a;
            }
            h2 = h2.return;
          }
        if (X$2 === null)
          throw Error(p$3(160));
        ak(f2, g2, e2), X$2 = null, Yj = !1;
        var k2 = e2.alternate;
        k2 !== null && (k2.return = null), e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; b2 !== null; )
      ek(b2, a2), b2 = b2.sibling;
}
__name(dk, "dk");
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (dk(b2, a2), fk(a2), d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2), fk(a2), d2 & 512 && c2 !== null && Mj(c2, c2.return);
      break;
    case 5:
      if (dk(b2, a2), fk(a2), d2 & 512 && c2 !== null && Mj(c2, c2.return), a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, e2 != null)) {
        var f2 = a2.memoizedProps, g2 = c2 !== null ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        if (a2.updateQueue = null, k2 !== null)
          try {
            h2 === "input" && f2.type === "radio" && f2.name != null && ab(e2, f2), vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              m2 === "style" ? sb(e2, q2) : m2 === "dangerouslySetInnerHTML" ? nb(e2, q2) : m2 === "children" ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                y2 != null ? fb(e2, !!f2.multiple, y2, !1) : r2 !== !!f2.multiple && (f2.defaultValue != null ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  !0
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", !1));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      if (dk(b2, a2), fk(a2), d2 & 4) {
        if (a2.stateNode === null)
          throw Error(p$3(162));
        e2 = a2.stateNode, f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      if (dk(b2, a2), fk(a2), d2 & 4 && c2 !== null && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2), fk(a2);
      break;
    case 13:
      dk(b2, a2), fk(a2), e2 = a2.child, e2.flags & 8192 && (f2 = e2.memoizedState !== null, e2.stateNode.isHidden = f2, !f2 || e2.alternate !== null && e2.alternate.memoizedState !== null || (gk = B$2())), d2 & 4 && bk(a2);
      break;
    case 22:
      if (m2 = c2 !== null && c2.memoizedState !== null, a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2), fk(a2), d2 & 8192) {
        if (l2 = a2.memoizedState !== null, (a2.stateNode.isHidden = l2) && !m2 && a2.mode & 1)
          for (V$2 = a2, m2 = a2.child; m2 !== null; ) {
            for (q2 = V$2 = m2; V$2 !== null; ) {
              switch (r2 = V$2, y2 = r2.child, r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if (typeof n2.componentWillUnmount == "function") {
                    d2 = r2, c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (r2.memoizedState !== null) {
                    hk(q2);
                    continue;
                  }
              }
              y2 !== null ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (q2.tag === 5) {
              if (m2 === null) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, typeof f2.setProperty == "function" ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = k2 != null && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (q2.tag === 6) {
              if (m2 === null)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((q2.tag !== 22 && q2.tag !== 23 || q2.memoizedState === null || q2 === a2) && q2.child !== null) {
              q2.child.return = q2, q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; q2.sibling === null; ) {
              if (q2.return === null || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null), q2 = q2.return;
            }
            m2 === q2 && (m2 = null), q2.sibling.return = q2.return, q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2), fk(a2), d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
__name(ek, "ek");
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; c2 !== null; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
__name(fk, "fk");
function ik(a2, b2, c2) {
  V$2 = a2, jk(a2);
}
__name(ik, "ik");
function jk(a2, b2, c2) {
  for (var d2 = (a2.mode & 1) !== 0; V$2 !== null; ) {
    var e2 = V$2, f2 = e2.child;
    if (e2.tag === 22 && d2) {
      var g2 = e2.memoizedState !== null || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = h2 !== null && h2.memoizedState !== null || U$2;
        h2 = Kj;
        var l2 = U$2;
        if (Kj = g2, (U$2 = k2) && !l2)
          for (V$2 = e2; V$2 !== null; )
            g2 = V$2, k2 = g2.child, g2.tag === 22 && g2.memoizedState !== null ? kk(e2) : k2 !== null ? (k2.return = g2, V$2 = k2) : kk(e2);
        for (; f2 !== null; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e2, Kj = h2, U$2 = l2;
      }
      lk(a2);
    } else
      e2.subtreeFlags & 8772 && f2 !== null ? (f2.return = e2, V$2 = f2) : lk(a2);
  }
}
__name(jk, "jk");
function lk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    if (b2.flags & 8772) {
      var c2 = b2.alternate;
      try {
        if (b2.flags & 8772)
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (c2 === null)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              f2 !== null && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (g2 !== null) {
                if (c2 = null, b2.child !== null)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (c2 === null && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (b2.memoizedState === null) {
                var l2 = b2.alternate;
                if (l2 !== null) {
                  var m2 = l2.memoizedState;
                  if (m2 !== null) {
                    var q2 = m2.dehydrated;
                    q2 !== null && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    if (c2 = b2.sibling, c2 !== null) {
      c2.return = b2.return, V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(lk, "lk");
function hk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (c2 !== null) {
      c2.return = b2.return, V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(hk, "hk");
function kk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if (typeof d2.componentDidMount == "function") {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (h2 !== null) {
      h2.return = b2.return, V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(kk, "kk");
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$2 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = 1 / 0, vk = null, Pi$1 = !1, Qi$1 = null, Si$1 = null, wk = !1, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return K$1 & 6 ? B$2() : Bk !== -1 ? Bk : Bk = B$2();
}
__name(L$2, "L$2");
function lh(a2) {
  return a2.mode & 1 ? K$1 & 2 && Z$2 !== 0 ? Z$2 & -Z$2 : Kg.transition !== null ? (Ck === 0 && (Ck = yc()), Ck) : (a2 = C$2, a2 !== 0 || (a2 = window.event, a2 = a2 === void 0 ? 16 : jd(a2.type)), a2) : 1;
}
__name(lh, "lh");
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$3(185));
  Ac(a2, c2, d2), (!(K$1 & 2) || a2 !== R$1) && (a2 === R$1 && (!(K$1 & 2) && (rk |= c2), T$2 === 4 && Dk(a2, Z$2)), Ek(a2, d2), c2 === 1 && K$1 === 0 && !(b2.mode & 1) && (Hj = B$2() + 500, fg && jg()));
}
__name(mh, "mh");
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (d2 === 0)
    c2 !== null && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    if (c2 != null && bc(c2), b2 === 1)
      a2.tag === 0 ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        !(K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2, a2.callbackNode = c2;
  }
}
__name(Ek, "Ek");
function Hk(a2, b2) {
  if (Bk = -1, Ck = 0, K$1 & 6)
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (d2 === 0)
    return null;
  if (d2 & 30 || d2 & a2.expiredLanes || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    (R$1 !== a2 || Z$2 !== b2) && (vk = null, Hj = B$2() + 500, Lk(a2, b2));
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg(), nk.current = f2, K$1 = e2, Y$1 !== null ? b2 = 0 : (R$1 = null, Z$2 = 0, b2 = T$2);
  }
  if (b2 !== 0) {
    if (b2 === 2 && (e2 = xc(a2), e2 !== 0 && (d2 = e2, b2 = Ok(a2, e2))), b2 === 1)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (b2 === 6)
      Dk(a2, d2);
    else {
      if (e2 = a2.current.alternate, !(d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), b2 === 2 && (f2 = xc(a2), f2 !== 0 && (d2 = f2, b2 = Ok(a2, f2))), b2 === 1))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      switch (a2.finishedWork = e2, a2.finishedLanes = d2, b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          if (Dk(a2, d2), (d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (uc(a2, 0) !== 0)
              break;
            if (e2 = a2.suspendedLanes, (e2 & d2) !== d2) {
              L$2(), a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          if (Dk(a2, d2), (d2 & 4194240) === d2)
            break;
          for (b2 = a2.eventTimes, e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2, g2 = b2[g2], g2 > e2 && (e2 = g2), d2 &= ~f2;
          }
          if (d2 = e2, d2 = B$2() - d2, d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2, 10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  return Ek(a2, B$2()), a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
__name(Hk, "Hk");
function Ok(a2, b2) {
  var c2 = tk;
  return a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256), a2 = Jk(a2, b2), a2 !== 2 && (b2 = uk, uk = c2, b2 !== null && Gj(b2)), a2;
}
__name(Ok, "Ok");
function Gj(a2) {
  uk === null ? uk = a2 : uk.push.apply(uk, a2);
}
__name(Gj, "Gj");
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (c2 !== null && (c2 = c2.stores, c2 !== null))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return !1;
          } catch {
            return !1;
          }
        }
    }
    if (c2 = b2.child, b2.subtreeFlags & 16384 && c2 !== null)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; b2.sibling === null; ) {
        if (b2.return === null || b2.return === a2)
          return !0;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return, b2 = b2.sibling;
    }
  }
  return !0;
}
__name(Pk, "Pk");
function Dk(a2, b2) {
  for (b2 &= ~sk, b2 &= ~rk, a2.suspendedLanes |= b2, a2.pingedLanes &= ~b2, a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1, b2 &= ~d2;
  }
}
__name(Dk, "Dk");
function Fk(a2) {
  if (K$1 & 6)
    throw Error(p$3(327));
  Ik();
  var b2 = uc(a2, 0);
  if (!(b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (a2.tag !== 0 && c2 === 2) {
    var d2 = xc(a2);
    d2 !== 0 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (c2 === 1)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (c2 === 6)
    throw Error(p$3(345));
  return a2.finishedWork = a2.current.alternate, a2.finishedLanes = b2, Qk(a2, uk, vk), Ek(a2, B$2()), null;
}
__name(Fk, "Fk");
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, K$1 === 0 && (Hj = B$2() + 500, fg && jg());
  }
}
__name(Rk, "Rk");
function Sk(a2) {
  xk !== null && xk.tag === 0 && !(K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, !(K$1 & 6) && jg();
  }
}
__name(Sk, "Sk");
function Ij() {
  gj = fj.current, E$1(fj);
}
__name(Ij, "Ij");
function Lk(a2, b2) {
  a2.finishedWork = null, a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  if (c2 !== -1 && (a2.timeoutHandle = -1, Gf(c2)), Y$1 !== null)
    for (c2 = Y$1.return; c2 !== null; ) {
      var d2 = c2;
      switch (wg(d2), d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes, d2 != null && $f();
          break;
        case 3:
          Jh(), E$1(Wf), E$1(H$2), Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  if (R$1 = a2, Y$1 = a2 = wh(a2.current, null), Z$2 = gj = b2, T$2 = 0, qk = null, sk = rk = hh = 0, uk = tk = null, Wg !== null) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, d2 !== null) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (f2 !== null) {
          var g2 = f2.next;
          f2.next = e2, d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
__name(Lk, "Lk");
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      if (Qg(), Ph.current = ai$1, Sh) {
        for (var d2 = N$2.memoizedState; d2 !== null; ) {
          var e2 = d2.queue;
          e2 !== null && (e2.pending = null), d2 = d2.next;
        }
        Sh = !1;
      }
      if (Rh = 0, P$1 = O$2 = N$2 = null, Th = !1, Uh = 0, ok.current = null, c2 === null || c2.return === null) {
        T$2 = 1, qk = b2, Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        if (b2 = Z$2, h2.flags |= 32768, k2 !== null && typeof k2 == "object" && typeof k2.then == "function") {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (!(m2.mode & 1) && (q2 === 0 || q2 === 11 || q2 === 15)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (y2 !== null) {
            y2.flags &= -257, Wi$1(y2, g2, h2, f2, b2), y2.mode & 1 && Ti$1(f2, l2, b2), b2 = y2, k2 = l2;
            var n2 = b2.updateQueue;
            if (n2 === null) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2), b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (!(b2 & 1)) {
              Ti$1(f2, l2, b2), uj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (J2 !== null) {
            !(J2.flags & 65536) && (J2.flags |= 256), Wi$1(J2, g2, h2, f2, b2), Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2), T$2 !== 4 && (T$2 = 2), tk === null ? tk = [f2] : tk.push(f2), f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536, b2 &= -b2, f2.lanes |= b2;
              var x2 = Oi$1(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (!(f2.flags & 128) && (typeof w2.getDerivedStateFromError == "function" || u2 !== null && typeof u2.componentDidCatch == "function" && (Si$1 === null || !Si$1.has(u2)))) {
                f2.flags |= 65536, b2 &= -b2, f2.lanes |= b2;
                var F2 = Ri$1(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (f2 !== null);
      }
      Tk(c2);
    } catch (na) {
      b2 = na, Y$1 === c2 && c2 !== null && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
__name(Nk, "Nk");
function Kk() {
  var a2 = nk.current;
  return nk.current = ai$1, a2 === null ? ai$1 : a2;
}
__name(Kk, "Kk");
function uj() {
  (T$2 === 0 || T$2 === 3 || T$2 === 2) && (T$2 = 4), R$1 === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R$1, Z$2);
}
__name(uj, "uj");
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  (R$1 !== a2 || Z$2 !== b2) && (vk = null, Lk(a2, b2));
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  if (Qg(), K$1 = c2, nk.current = d2, Y$1 !== null)
    throw Error(p$3(261));
  return R$1 = null, Z$2 = 0, T$2;
}
__name(Jk, "Jk");
function Uk() {
  for (; Y$1 !== null; )
    Vk(Y$1);
}
__name(Uk, "Uk");
function Mk() {
  for (; Y$1 !== null && !cc(); )
    Vk(Y$1);
}
__name(Mk, "Mk");
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps, b2 === null ? Tk(a2) : Y$1 = b2, ok.current = null;
}
__name(Vk, "Vk");
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    if (a2 = b2.return, b2.flags & 32768) {
      if (c2 = Jj(c2, b2), c2 !== null) {
        c2.flags &= 32767, Y$1 = c2;
        return;
      }
      if (a2 !== null)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$2 = 6, Y$1 = null;
        return;
      }
    } else if (c2 = Fj(c2, b2, gj), c2 !== null) {
      Y$1 = c2;
      return;
    }
    if (b2 = b2.sibling, b2 !== null) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (b2 !== null);
  T$2 === 0 && (T$2 = 5);
}
__name(Tk, "Tk");
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
__name(Qk, "Qk");
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (xk !== null);
  if (K$1 & 6)
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (c2 === null)
    return null;
  if (a2.finishedWork = null, a2.finishedLanes = 0, c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null, a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  if (Bc(a2, f2), a2 === R$1 && (Y$1 = R$1 = null, Z$2 = 0), !(c2.subtreeFlags & 2064) && !(c2.flags & 2064) || wk || (wk = !0, Gk(hc, function() {
    return Ik(), null;
  })), f2 = (c2.flags & 15990) !== 0, c2.subtreeFlags & 15990 || f2) {
    f2 = pk.transition, pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4, ok.current = null, Pj(a2, c2), ek(c2, a2), Oe(Df), dd = !!Cf, Df = Cf = null, a2.current = c2, ik(c2), dc(), K$1 = h2, C$2 = g2, pk.transition = f2;
  } else
    a2.current = c2;
  if (wk && (wk = !1, xk = a2, yk = e2), f2 = a2.pendingLanes, f2 === 0 && (Si$1 = null), mc(c2.stateNode), Ek(a2, B$2()), b2 !== null)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi$1)
    throw Pi$1 = !1, a2 = Qi$1, Qi$1 = null, a2;
  return yk & 1 && a2.tag !== 0 && Ik(), f2 = a2.pendingLanes, f2 & 1 ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0, jg(), null;
}
__name(Xk, "Xk");
function Ik() {
  if (xk !== null) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      if (pk.transition = null, C$2 = 16 > a2 ? 16 : a2, xk === null)
        var d2 = !1;
      else {
        if (a2 = xk, xk = null, yk = 0, K$1 & 6)
          throw Error(p$3(331));
        var e2 = K$1;
        for (K$1 |= 4, V$2 = a2.current; V$2 !== null; ) {
          var f2 = V$2, g2 = f2.child;
          if (V$2.flags & 16) {
            var h2 = f2.deletions;
            if (h2 !== null) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; V$2 !== null; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (q2 !== null)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; V$2 !== null; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      if (Tj(m2), m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (r2 !== null) {
                        r2.return = y2, V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (n2 !== null) {
                var t2 = n2.child;
                if (t2 !== null) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null, t2 = J2;
                  } while (t2 !== null);
                }
              }
              V$2 = f2;
            }
          }
          if (f2.subtreeFlags & 2064 && g2 !== null)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; V$2 !== null; ) {
                if (f2 = V$2, f2.flags & 2048)
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (x2 !== null) {
                  x2.return = f2.return, V$2 = x2;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; V$2 !== null; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (g2.subtreeFlags & 2064 && u2 !== null)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; V$2 !== null; ) {
                if (h2 = V$2, h2.flags & 2048)
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (F2 !== null) {
                  F2.return = h2.return, V$2 = F2;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        if (K$1 = e2, jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch {
          }
        d2 = !0;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return !1;
}
__name(Ik, "Ik");
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2), b2 = Oi$1(a2, b2, 1), a2 = dh(a2, b2, 1), b2 = L$2(), a2 !== null && (Ac(a2, 1, b2), Ek(a2, b2));
}
__name(Yk, "Yk");
function W$1(a2, b2, c2) {
  if (a2.tag === 3)
    Yk(a2, a2, c2);
  else
    for (; b2 !== null; ) {
      if (b2.tag === 3) {
        Yk(b2, a2, c2);
        break;
      } else if (b2.tag === 1) {
        var d2 = b2.stateNode;
        if (typeof b2.type.getDerivedStateFromError == "function" || typeof d2.componentDidCatch == "function" && (Si$1 === null || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2), a2 = Ri$1(b2, a2, 1), b2 = dh(b2, a2, 1), a2 = L$2(), b2 !== null && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
__name(W$1, "W$1");
function Ui$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  d2 !== null && d2.delete(b2), b2 = L$2(), a2.pingedLanes |= a2.suspendedLanes & c2, R$1 === a2 && (Z$2 & c2) === c2 && (T$2 === 4 || T$2 === 3 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2), Ek(a2, b2);
}
__name(Ui$1, "Ui$1");
function Zk(a2, b2) {
  b2 === 0 && (a2.mode & 1 ? (b2 = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : b2 = 1);
  var c2 = L$2();
  a2 = Zg(a2, b2), a2 !== null && (Ac(a2, b2, c2), Ek(a2, c2));
}
__name(Zk, "Zk");
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  b2 !== null && (c2 = b2.retryLane), Zk(a2, c2);
}
__name(vj, "vj");
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode, e2 = a2.memoizedState;
      e2 !== null && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  d2 !== null && d2.delete(b2), Zk(a2, c2);
}
__name(ck, "ck");
var Wk;
Wk = /* @__PURE__ */ __name(function(a2, b2, c2) {
  if (a2 !== null)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = !0;
    else {
      if (!(a2.lanes & c2) && !(b2.flags & 128))
        return Ug = !1, zj(a2, b2, c2);
      Ug = !!(a2.flags & 131072);
    }
  else
    Ug = !1, I$1 && b2.flags & 1048576 && ug(b2, ng, b2.index);
  switch (b2.lanes = 0, b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2), a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2), e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi$1();
      return b2.flags |= 1, typeof e2 == "object" && e2 !== null && typeof e2.render == "function" && e2.$$typeof === void 0 ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = !0, cg(b2)) : f2 = !1, b2.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, !0, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi$1(null, b2, e2, c2), b2 = b2.child), b2;
    case 16:
      d2 = b2.elementType;
      a: {
        switch (jj(a2, b2), a2 = b2.pendingProps, e2 = d2._init, d2 = e2(d2._payload), b2.type = d2, e2 = b2.tag = $k(d2), a2 = Lg(d2, a2), e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        if (lj(b2), a2 === null)
          throw Error(p$3(387));
        d2 = b2.pendingProps, f2 = b2.memoizedState, e2 = f2.element, bh(a2, b2), gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        if (d2 = g2.element, f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: !1, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki$1(Error(p$3(423)), b2), b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki$1(Error(p$3(424)), b2), b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = !0, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          if (Ig(), d2 === e2) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi$1(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), a2 === null && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = a2 !== null ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : f2 !== null && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi$1(a2, b2, g2, c2), b2.child;
    case 6:
      return a2 === null && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, a2 === null ? b2.child = Bh(b2, null, d2, c2) : Yi$1(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi$1(a2, b2, d2, e2, c2);
    case 7:
      return Yi$1(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        if (d2 = b2.type._context, e2 = b2.pendingProps, f2 = b2.memoizedProps, g2 = e2.value, G$2(Mg, d2._currentValue), d2._currentValue = g2, f2 !== null)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, f2 !== null && (f2.return = b2); f2 !== null; ) {
              var h2 = f2.dependencies;
              if (h2 !== null) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; k2 !== null; ) {
                  if (k2.context === d2) {
                    if (f2.tag === 1) {
                      k2 = ch(-1, c2 & -c2), k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (l2 !== null) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        m2 === null ? k2.next = k2 : (k2.next = m2.next, m2.next = k2), l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2, k2 = f2.alternate, k2 !== null && (k2.lanes |= c2), Sg(
                      f2.return,
                      c2,
                      b2
                    ), h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (f2.tag === 10)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (f2.tag === 18) {
                if (g2 = f2.return, g2 === null)
                  throw Error(p$3(341));
                g2.lanes |= c2, h2 = g2.alternate, h2 !== null && (h2.lanes |= c2), Sg(g2, c2, b2), g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (g2 !== null)
                g2.return = f2;
              else
                for (g2 = f2; g2 !== null; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  if (f2 = g2.sibling, f2 !== null) {
                    f2.return = g2.return, g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi$1(a2, b2, e2.children, c2), b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi$1(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = !0, cg(b2)) : a2 = !1, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, !0, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
}, "Wk");
function Gk(a2, b2) {
  return ac(a2, b2);
}
__name(Gk, "Gk");
function al(a2, b2, c2, d2) {
  this.tag = a2, this.key = c2, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b2, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d2, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
__name(al, "al");
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
__name(Bg, "Bg");
function bj(a2) {
  return a2 = a2.prototype, !(!a2 || !a2.isReactComponent);
}
__name(bj, "bj");
function $k(a2) {
  if (typeof a2 == "function")
    return bj(a2) ? 1 : 0;
  if (a2 != null) {
    if (a2 = a2.$$typeof, a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
__name($k, "$k");
function wh(a2, b2) {
  var c2 = a2.alternate;
  return c2 === null ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null), c2.flags = a2.flags & 14680064, c2.childLanes = a2.childLanes, c2.lanes = a2.lanes, c2.child = a2.child, c2.memoizedProps = a2.memoizedProps, c2.memoizedState = a2.memoizedState, c2.updateQueue = a2.updateQueue, b2 = a2.dependencies, c2.dependencies = b2 === null ? null : { lanes: b2.lanes, firstContext: b2.firstContext }, c2.sibling = a2.sibling, c2.index = a2.index, c2.ref = a2.ref, c2;
}
__name(wh, "wh");
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  if (d2 = a2, typeof a2 == "function")
    bj(a2) && (g2 = 1);
  else if (typeof a2 == "string")
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8, e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if (typeof a2 == "object" && a2 !== null)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16, d2 = null;
                break a;
            }
          throw Error(p$3(130, a2 == null ? a2 : typeof a2, ""));
      }
  return b2 = Bg(g2, c2, b2, e2), b2.elementType = a2, b2.type = d2, b2.lanes = f2, b2;
}
__name(yh, "yh");
function Ah(a2, b2, c2, d2) {
  return a2 = Bg(7, a2, d2, b2), a2.lanes = c2, a2;
}
__name(Ah, "Ah");
function qj(a2, b2, c2, d2) {
  return a2 = Bg(22, a2, d2, b2), a2.elementType = Ia, a2.lanes = c2, a2.stateNode = { isHidden: !1 }, a2;
}
__name(qj, "qj");
function xh(a2, b2, c2) {
  return a2 = Bg(6, a2, null, b2), a2.lanes = c2, a2;
}
__name(xh, "xh");
function zh(a2, b2, c2) {
  return b2 = Bg(4, a2.children !== null ? a2.children : [], a2.key, b2), b2.lanes = c2, b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation }, b2;
}
__name(zh, "zh");
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2, this.containerInfo = a2, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d2, this.onRecoverableError = e2, this.mutableSourceEagerHydrationData = null;
}
__name(bl, "bl");
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  return a2 = new bl(a2, b2, c2, h2, k2), b2 === 1 ? (b2 = 1, f2 === !0 && (b2 |= 8)) : b2 = 0, f2 = Bg(3, null, null, b2), a2.current = f2, f2.stateNode = a2, f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah(f2), a2;
}
__name(cl, "cl");
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: wa, key: d2 == null ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
__name(dl, "dl");
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || a2.tag !== 1)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (b2 !== null);
    throw Error(p$3(171));
  }
  if (a2.tag === 1) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
__name(el, "el");
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  return a2 = cl(c2, d2, !0, a2, e2, f2, g2, h2, k2), a2.context = el(null), c2 = a2.current, d2 = L$2(), e2 = lh(c2), f2 = ch(d2, e2), f2.callback = b2 ?? null, dh(c2, f2, e2), a2.current.lanes = e2, Ac(a2, e2, d2), Ek(a2, d2), a2;
}
__name(fl, "fl");
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$2(), g2 = lh(e2);
  return c2 = el(c2), b2.context === null ? b2.context = c2 : b2.pendingContext = c2, b2 = ch(f2, g2), b2.payload = { element: a2 }, d2 = d2 === void 0 ? null : d2, d2 !== null && (b2.callback = d2), a2 = dh(e2, b2, g2), a2 !== null && (mh(a2, e2, g2, f2), eh(a2, e2, g2)), g2;
}
__name(gl, "gl");
function hl(a2) {
  if (a2 = a2.current, !a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
__name(hl, "hl");
function il(a2, b2) {
  if (a2 = a2.memoizedState, a2 !== null && a2.dehydrated !== null) {
    var c2 = a2.retryLane;
    a2.retryLane = c2 !== 0 && c2 < b2 ? c2 : b2;
  }
}
__name(il, "il");
function jl(a2, b2) {
  il(a2, b2), (a2 = a2.alternate) && il(a2, b2);
}
__name(jl, "jl");
function kl() {
  return null;
}
__name(kl, "kl");
var ll = typeof reportError == "function" ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
__name(ml, "ml");
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (b2 === null)
    throw Error(p$3(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (a2 !== null) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    }), b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
__name(nl, "nl");
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && b2 !== 0 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2), c2 === 0 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11);
}
__name(ol, "ol");
function pl(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11 && (a2.nodeType !== 8 || a2.nodeValue !== " react-mount-point-unstable "));
}
__name(pl, "pl");
function ql() {
}
__name(ql, "ql");
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if (typeof d2 == "function") {
      var f2 = d2;
      d2 = /* @__PURE__ */ __name(function() {
        var a3 = hl(g2);
        f2.call(a3);
      }, "d");
    }
    var g2 = fl(b2, d2, a2, 0, null, !1, !1, "", ql);
    return a2._reactRootContainer = g2, a2[uf] = g2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), Sk(), g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if (typeof d2 == "function") {
    var h2 = d2;
    d2 = /* @__PURE__ */ __name(function() {
      var a3 = hl(k2);
      h2.call(a3);
    }, "d");
  }
  var k2 = cl(a2, 0, !1, null, null, !1, !1, "", ql);
  return a2._reactRootContainer = k2, a2[uf] = k2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), Sk(function() {
    gl(b2, k2, c2, d2);
  }), k2;
}
__name(rl, "rl");
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if (typeof e2 == "function") {
      var h2 = e2;
      e2 = /* @__PURE__ */ __name(function() {
        var a3 = hl(g2);
        h2.call(a3);
      }, "e");
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
__name(sl, "sl");
Ec = /* @__PURE__ */ __name(function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        c2 !== 0 && (Cc(b2, c2 | 1), Ek(b2, B$2()), !(K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (b3 !== null) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
}, "Ec");
Fc = /* @__PURE__ */ __name(function(a2) {
  if (a2.tag === 13) {
    var b2 = Zg(a2, 134217728);
    if (b2 !== null) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
}, "Fc");
Gc = /* @__PURE__ */ __name(function(a2) {
  if (a2.tag === 13) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (c2 !== null) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
}, "Gc");
Hc = /* @__PURE__ */ __name(function() {
  return C$2;
}, "Hc");
Ic = /* @__PURE__ */ __name(function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
}, "Ic");
yb = /* @__PURE__ */ __name(function(a2, b2, c2) {
  switch (b2) {
    case "input":
      if (bb(a2, c2), b2 = c2.name, c2.type === "radio" && b2 != null) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        for (c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]'), b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$3(90));
            Wa(d2), bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, b2 != null && fb(a2, !!c2.multiple, b2, !1);
  }
}, "yb");
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: !1, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  return a2 = Zb(a2), a2 === null ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$3(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$3(299));
  var c2 = !1, d2 = "", e2 = ll;
  return b2 != null && (b2.unstable_strictMode === !0 && (c2 = !0), b2.identifierPrefix !== void 0 && (d2 = b2.identifierPrefix), b2.onRecoverableError !== void 0 && (e2 = b2.onRecoverableError)), b2 = cl(a2, 1, !1, null, null, c2, !1, d2, e2), a2[uf] = b2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (a2 == null)
    return null;
  if (a2.nodeType === 1)
    return a2;
  var b2 = a2._reactInternals;
  if (b2 === void 0)
    throw typeof a2.render == "function" ? Error(p$3(188)) : (a2 = Object.keys(a2).join(","), Error(p$3(268, a2)));
  return a2 = Zb(b2), a2 = a2 === null ? null : a2.stateNode, a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, !0, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$3(405));
  var d2 = c2 != null && c2.hydratedSources || null, e2 = !1, f2 = "", g2 = ll;
  if (c2 != null && (c2.unstable_strictMode === !0 && (e2 = !0), c2.identifierPrefix !== void 0 && (f2 = c2.identifierPrefix), c2.onRecoverableError !== void 0 && (g2 = c2.onRecoverableError)), b2 = fl(b2, null, a2, 1, c2 ?? null, e2, !1, f2, g2), a2[uf] = b2.current, sf(a2), d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), b2.mutableSourceEagerHydrationData == null ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, !1, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, !1, function() {
      a2._reactRootContainer = null, a2[uf] = null;
    });
  }), !0) : !1;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$3(200));
  if (a2 == null || a2._reactInternals === void 0)
    throw Error(p$3(38));
  return sl(a2, b2, c2, !1, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
}
__name(checkDCE, "checkDCE");
checkDCE(), reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports, createRoot, m$3 = reactDomExports;
createRoot = m$3.createRoot, m$3.hydrateRoot;
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
__name(_objectWithoutPropertiesLoose$1, "_objectWithoutPropertiesLoose$1");
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
__name(_typeof, "_typeof");
function toPrimitive(t2, r2) {
  if (_typeof(t2) != "object" || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i = e2.call(t2, r2 || "default");
    if (_typeof(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r2 === "string" ? String : Number)(t2);
}
__name(toPrimitive, "toPrimitive");
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return _typeof(i) == "symbol" ? i : String(i);
}
__name(toPropertyKey, "toPropertyKey");
function _defineProperty(obj, key, value) {
  return key = toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
__name(_defineProperty, "_defineProperty");
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", {
    writable: !1
  }), Constructor;
}
__name(_createClass, "_createClass");
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0
}, i18nInstance, I18nContext = React.createContext();
function getDefaults() {
  return defaultOptions;
}
__name(getDefaults, "getDefaults");
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2), this.usedNamespaces = {};
  }
  return __name(ReportNamespaces2, "ReportNamespaces"), _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: /* @__PURE__ */ __name(function(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns2) {
        _this.usedNamespaces[ns2] || (_this.usedNamespaces[ns2] = !0);
      });
    }, "addUsedNamespaces")
  }, {
    key: "getUsedNamespaces",
    value: /* @__PURE__ */ __name(function() {
      return Object.keys(this.usedNamespaces);
    }, "getUsedNamespaces")
  }]), ReportNamespaces2;
}();
function getI18n() {
  return i18nInstance;
}
__name(getI18n, "getI18n");
function warn() {
  if (console && console.warn) {
    for (var _console, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    typeof args[0] == "string" && (args[0] = "react-i18next:: ".concat(args[0])), (_console = console).warn.apply(_console, args);
  }
}
__name(warn, "warn");
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
    args[_key2] = arguments[_key2];
  typeof args[0] == "string" && alreadyWarned[args[0]] || (typeof args[0] == "string" && (alreadyWarned[args[0]] = /* @__PURE__ */ new Date()), warn.apply(void 0, args));
}
__name(warnOnce, "warnOnce");
function loadNamespaces(i18n, ns2, cb2) {
  i18n.loadNamespaces(ns2, function() {
    if (i18n.isInitialized)
      cb2();
    else {
      var initialized = /* @__PURE__ */ __name(function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0), cb2();
      }, "initialized");
      i18n.on("initialized", initialized);
    }
  });
}
__name(loadNamespaces, "loadNamespaces");
function oldI18nextHasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, lng = i18n.languages[0], fallbackLng = i18n.options ? i18n.options.fallbackLng : !1, lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return !0;
  var loadNotPending = /* @__PURE__ */ __name(function(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  }, "loadNotPending");
  return options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns2) ? !1 : !!(i18n.hasResourceBundle(lng, ns2) || !i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages || loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)));
}
__name(oldI18nextHasLoadedNamespace, "oldI18nextHasLoadedNamespace");
function hasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length)
    return warnOnce("i18n.languages were undefined or empty", i18n.languages), !0;
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  return isNewerI18next ? i18n.hasLoadedNamespace(ns2, {
    precheck: /* @__PURE__ */ __name(function(i18nInstance2, loadNotPending) {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns2))
        return !1;
    }, "precheck")
  }) : oldI18nextHasLoadedNamespace(ns2, i18n, options2);
}
__name(hasLoadedNamespace, "hasLoadedNamespace");
function getDisplayName$1(Component) {
  return Component.displayName || Component.name || (typeof Component == "string" && Component.length > 0 ? Component : "Unknown");
}
__name(getDisplayName$1, "getDisplayName$1");
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _iterableToArrayLimit(r2, l2) {
  var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
  if (t2 != null) {
    var e2, n2, i, u2, a2 = [], f2 = !0, o2 = !1;
    try {
      if (i = (t2 = t2.call(r2)).next, l2 === 0) {
        if (Object(t2) !== t2)
          return;
        f2 = !1;
      } else
        for (; !(f2 = (e2 = i.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = !0)
          ;
    } catch (r3) {
      o2 = !0, n2 = r3;
    } finally {
      try {
        if (!f2 && t2.return != null && (u2 = t2.return(), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _unsupportedIterableToArray(o2, minLen) {
  if (o2) {
    if (typeof o2 == "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableRest, "_nonIterableRest");
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$8, "ownKeys$8");
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$8, "_objectSpread$8");
function useTranslation(ns2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i18nFromProps = props.i18n, _ref3 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref3.i18n, defaultNSFromContext = _ref3.defaultNS, i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces && (i18n.reportNamespaces = new ReportNamespaces()), !i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = /* @__PURE__ */ __name(function(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    }, "notReadyT"), retNotReady = [notReadyT, {}, !1];
    return retNotReady.t = notReadyT, retNotReady.i18n = {}, retNotReady.ready = !1, retNotReady;
  }
  i18n.options.react && i18n.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, getDefaults()), i18n.options.react), props), useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix, namespaces = ns2 || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces == "string" ? [namespaces] : namespaces || ["translation"], i18n.reportNamespaces.addUsedNamespaces && i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  __name(getT, "getT");
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1], isMounted = reactExports.useRef(!0);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = !0, !ready && !useSuspense && loadNamespaces(i18n, namespaces, function() {
      isMounted.current && setT(getT);
    });
    function boundReset() {
      isMounted.current && setT(getT);
    }
    return __name(boundReset, "boundReset"), bindI18n && i18n && i18n.on(bindI18n, boundReset), bindI18nStore && i18n && i18n.store.on(bindI18nStore, boundReset), function() {
      isMounted.current = !1, bindI18n && i18n && bindI18n.split(" ").forEach(function(e2) {
        return i18n.off(e2, boundReset);
      }), bindI18nStore && i18n && bindI18nStore.split(" ").forEach(function(e2) {
        return i18n.store.off(e2, boundReset);
      });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = reactExports.useRef(!0);
  reactExports.useEffect(function() {
    isMounted.current && !isInitial.current && setT(getT), isInitial.current = !1;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  if (ret.t = t2, ret.i18n = i18n, ret.ready = ready, ready || !ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces, function() {
      resolve();
    });
  });
}
__name(useTranslation, "useTranslation");
var _excluded$8 = ["forwardedRef"];
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$7, "ownKeys$7");
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$7, "_objectSpread$7");
function withTranslation(ns2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    function I18nextWithTranslation(_ref3) {
      var forwardedRef = _ref3.forwardedRef, rest = _objectWithoutProperties(_ref3, _excluded$8), _useTranslation = useTranslation(ns2, rest), _useTranslation2 = _slicedToArray(_useTranslation, 3), t2 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2], passDownProps = _objectSpread$7(_objectSpread$7({}, rest), {}, {
        t: t2,
        i18n,
        tReady: ready
      });
      return options2.withRef && forwardedRef ? passDownProps.ref = forwardedRef : !options2.withRef && forwardedRef && (passDownProps.forwardedRef = forwardedRef), React.createElement(WrappedComponent, passDownProps);
    }
    __name(I18nextWithTranslation, "I18nextWithTranslation"), I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName$1(WrappedComponent), ")"), I18nextWithTranslation.WrappedComponent = WrappedComponent;
    var forwardRef = /* @__PURE__ */ __name(function(props, ref) {
      return React.createElement(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    }, "forwardRef");
    return options2.withRef ? React.forwardRef(forwardRef) : I18nextWithTranslation;
  }, "Extend");
}
__name(withTranslation, "withTranslation");
function I18nextProvider(_ref3) {
  var i18n = _ref3.i18n, defaultNS = _ref3.defaultNS, children2 = _ref3.children, value = reactExports.useMemo(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return reactExports.createElement(I18nContext.Provider, {
    value
  }, children2);
}
__name(I18nextProvider, "I18nextProvider");
/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$3.apply(this, arguments);
}
__name(_extends$3, "_extends$3");
var Action;
(function(Action2) {
  Action2.Pop = "POP", Action2.Push = "PUSH", Action2.Replace = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  options2 === void 0 && (options2 = {});
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  __name(createBrowserLocation, "createBrowserLocation");
  function createBrowserHref(window2, to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return __name(createBrowserHref, "createBrowserHref"), getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
__name(createBrowserHistory, "createBrowserHistory");
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
__name(createKey, "createKey");
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
__name(getHistoryState, "getHistoryState");
function createLocation(current, to, state, key) {
  return state === void 0 && (state = null), _extends$3({
    pathname: typeof current == "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to == "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
}
__name(createLocation, "createLocation");
function createPath(_ref3) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref3;
  return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash2 && hash2 !== "#" && (pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2), pathname;
}
__name(createPath, "createPath");
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
    let searchIndex = path.indexOf("?");
    searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
  }
  return parsedPath;
}
__name(parsePath, "parsePath");
function createURL(location) {
  let base3 = typeof window < "u" && typeof window.location < "u" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown", href = typeof location == "string" ? location : createPath(location);
  return new URL(href, base3);
}
__name(createURL, "createURL");
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options2) {
  options2 === void 0 && (options2 = {});
  let {
    window: window2 = document.defaultView,
    v5Compat = !1
  } = options2, globalHistory = window2.history, action2 = Action.Pop, listener = null;
  function handlePop() {
    action2 = Action.Pop, listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(handlePop, "handlePop");
  function push(to, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to);
    let historyState = getHistoryState(location), url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch {
      window2.location.assign(url);
    }
    v5Compat && listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(push, "push");
  function replace2(to, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to);
    let historyState = getHistoryState(location), url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(replace2, "replace");
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn2) {
      if (listener)
        throw new Error("A history only accepts one active listener");
      return window2.addEventListener(PopStateEventType, handlePop), listener = fn2, () => {
        window2.removeEventListener(PopStateEventType, handlePop), listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(location) {
      let url = createURL(createPath(location));
      return _extends$3({}, location, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
__name(getUrlBasedHistory, "getUrlBasedHistory");
var ResultType;
(function(ResultType2) {
  ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  basename === void 0 && (basename = "/");
  let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null)
    return null;
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i)
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  return matches;
}
__name(matchRoutes, "matchRoutes");
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  return branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = ""), routes.forEach((route2, index) => {
    let meta = {
      relativePath: route2.path || "",
      caseSensitive: route2.caseSensitive === !0,
      childrenIndex: index,
      route: route2
    };
    meta.relativePath.startsWith("/") && (invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta.relativePath = meta.relativePath.slice(parentPath.length));
    let path = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta);
    route2.children && route2.children.length > 0 && (invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route2.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
    ), flattenRoutes(route2.children, branches, routesMeta, path)), !(route2.path == null && !route2.index) && branches.push({
      path,
      score: computeScore(path, route2.index),
      routesMeta
    });
  }), branches;
}
__name(flattenRoutes, "flattenRoutes");
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
__name(rankRouteBranches, "rankRouteBranches");
const paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = /* @__PURE__ */ __name((s) => s === "*", "isSplat");
function computeScore(path, index) {
  let segments = path.split("/"), initialScore = segments.length;
  return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
__name(computeScore, "computeScore");
function compareIndexes(a2, b2) {
  return a2.length === b2.length && a2.slice(0, -1).every((n2, i) => n2 === b2[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
__name(compareIndexes, "compareIndexes");
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i], end2 = i === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route2 = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route: route2
    }), match2.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]));
  }
  return matches;
}
__name(matchRouteBranch, "matchRouteBranch");
function matchPath(pattern, pathname) {
  typeof pattern == "string" && (pattern = {
    path: pattern,
    caseSensitive: !1,
    end: !0
  });
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match2.slice(1);
  return {
    params: paramNames.reduce((memo, paramName, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      return memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo;
    }, {}),
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
__name(matchPath, "matchPath");
function compilePath(path, caseSensitive, end2) {
  caseSensitive === void 0 && (caseSensitive = !1), end2 === void 0 && (end2 = !0), warning$p(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_24, paramName) => (paramNames.push(paramName), "([^\\/]+)"));
  return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end2 ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
}
__name(compilePath, "compilePath");
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error3) {
    return warning$p(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error3 + ").")), value;
  }
}
__name(safelyDecodeURI, "safelyDecodeURI");
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error3) {
    return warning$p(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error3 + ").")), value;
  }
}
__name(safelyDecodeURIComponent, "safelyDecodeURIComponent");
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
    return null;
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
  return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
}
__name(stripBasename, "stripBasename");
function invariant(value, message2) {
  if (value === !1 || value === null || typeof value > "u")
    throw new Error(message2);
}
__name(invariant, "invariant");
function warning$p(cond, message2) {
  if (!cond) {
    typeof console < "u" && console.warn(message2);
    try {
      throw new Error(message2);
    } catch {
    }
  }
}
__name(warning$p, "warning$p");
function resolvePath(to, fromPathname) {
  fromPathname === void 0 && (fromPathname = "/");
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to == "string" ? parsePath(to) : to;
  return {
    pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
__name(resolvePath, "resolvePath");
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  return relativePath.split("/").forEach((segment) => {
    segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
  }), segments.length > 1 ? segments.join("/") : "/";
}
__name(resolvePathname, "resolvePathname");
function getInvalidPathError(char2, field2, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field2 + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
__name(getInvalidPathError, "getInvalidPathError");
function getPathContributingMatches(matches) {
  return matches.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
}
__name(getPathContributingMatches, "getPathContributingMatches");
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  isPathRelative === void 0 && (isPathRelative = !1);
  let to;
  typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends$3({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
  let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from2;
  if (isPathRelative || toPathname == null)
    from2 = locationPathname;
  else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      for (; toSegments[0] === ".."; )
        toSegments.shift(), routePathnameIndex -= 1;
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
}
__name(resolveTo, "resolveTo");
const joinPaths = /* @__PURE__ */ __name((paths) => paths.join("/").replace(/\/\/+/g, "/"), "joinPaths"), normalizePathname = /* @__PURE__ */ __name((pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), "normalizePathname"), normalizeSearch = /* @__PURE__ */ __name((search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, "normalizeSearch"), normalizeHash = /* @__PURE__ */ __name((hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2, "normalizeHash"), _ErrorResponse = class _ErrorResponse {
  constructor(status2, statusText, data) {
    this.status = status2, this.statusText = statusText || "", this.data = data;
  }
};
__name(_ErrorResponse, "ErrorResponse");
let ErrorResponse = _ErrorResponse;
function isRouteErrorResponse(e2) {
  return e2 instanceof ErrorResponse;
}
__name(isRouteErrorResponse, "isRouteErrorResponse");
const validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
[...validActionMethods];
/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$2.apply(this, arguments);
}
__name(_extends$2, "_extends$2");
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
__name(isPolyfill, "isPolyfill");
const is$1 = typeof Object.is == "function" ? Object.is : isPolyfill, {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe2, getSnapshot, getServerSnapshot) {
  const value = getSnapshot(), [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  return useLayoutEffect(() => {
    inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  }, [subscribe2, value, getSnapshot]), useEffect(() => (checkIfSnapshotChanged(inst) && forceUpdate({
    inst
  }), subscribe2(/* @__PURE__ */ __name(() => {
    checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  }, "handleStoreChange"))), [subscribe2]), useDebugValue(value), value;
}
__name(useSyncExternalStore$2, "useSyncExternalStore$2");
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is$1(prevValue, nextValue);
  } catch {
    return !0;
  }
}
__name(checkIfSnapshotChanged, "checkIfSnapshotChanged");
function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
__name(useSyncExternalStore$1, "useSyncExternalStore$1");
const canUseDOM$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServerEnvironment = !canUseDOM$1, shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 && ((module) => module.useSyncExternalStore)(React$1);
const DataStaticRouterContext = /* @__PURE__ */ reactExports.createContext(null), DataRouterContext = /* @__PURE__ */ reactExports.createContext(null), DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null), NavigationContext = /* @__PURE__ */ reactExports.createContext(null), LocationContext = /* @__PURE__ */ reactExports.createContext(null), RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
}), RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  useInRouterContext() || invariant(!1);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext), {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  }), joinedPathname = pathname;
  return basename !== "/" && (joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname])), navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
__name(useHref, "useHref");
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
__name(useInRouterContext, "useInRouterContext");
function useLocation() {
  return useInRouterContext() || invariant(!1), reactExports.useContext(LocationContext).location;
}
__name(useLocation, "useLocation");
function useNavigate() {
  useInRouterContext() || invariant(!1);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext), {
    matches
  } = reactExports.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase)), activeRef = reactExports.useRef(!1);
  return reactExports.useEffect(() => {
    activeRef.current = !0;
  }), reactExports.useCallback(function(to, options2) {
    if (options2 === void 0 && (options2 = {}), !activeRef.current)
      return;
    if (typeof to == "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), (options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
}
__name(useNavigate, "useNavigate");
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext), routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
__name(useParams, "useParams");
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2, {
    matches
  } = reactExports.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
__name(useResolvedPath, "useResolvedPath");
function useRoutes(routes, locationArg) {
  useInRouterContext() || invariant(!1);
  let dataRouterStateContext = reactExports.useContext(DataRouterStateContext), {
    matches: parentMatches
  } = reactExports.useContext(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {};
  routeMatch && routeMatch.pathname;
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation(), location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg == "string" ? parsePath(locationArg) : locationArg;
    parentPathnameBase === "/" || (_parsedLocationArg$pa = parsedLocationArg.pathname) != null && _parsedLocationArg$pa.startsWith(parentPathnameBase) || invariant(!1), location = parsedLocationArg;
  } else
    location = locationFromContext;
  let pathname = location.pathname || "/", remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/", matches = matchRoutes(routes, {
    pathname: remainingPathname
  }), renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  return locationArg && renderedMatches ? /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    value: {
      location: _extends$2({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, location),
      navigationType: Action.Pop
    }
  }, renderedMatches) : renderedMatches;
}
__name(useRoutes, "useRoutes");
function DefaultErrorElement() {
  let error3 = useRouteError(), message2 = isRouteErrorResponse(error3) ? error3.status + " " + error3.statusText : error3 instanceof Error ? error3.message : JSON.stringify(error3), stack = error3 instanceof Error ? error3.stack : null, lightgrey = "rgba(200,200,200, 0.5)", preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  }, codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
__name(DefaultErrorElement, "DefaultErrorElement");
const _RenderErrorBoundary = class _RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props), this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error3) {
    return {
      error: error3
    };
  }
  static getDerivedStateFromProps(props, state) {
    return state.location !== props.location ? {
      error: props.error,
      location: props.location
    } : {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error3, errorInfo) {
    console.error("React Router caught the following error during render", error3, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
};
__name(_RenderErrorBoundary, "RenderErrorBoundary");
let RenderErrorBoundary = _RenderErrorBoundary;
function RenderedRoute(_ref3) {
  let {
    routeContext,
    match: match2,
    children: children2
  } = _ref3, dataStaticRouterContext = reactExports.useContext(DataStaticRouterContext);
  return dataStaticRouterContext && match2.route.errorElement && (dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id), /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children2);
}
__name(RenderedRoute, "RenderedRoute");
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0 && (parentMatches = []), matches == null)
    if (dataRouterState != null && dataRouterState.errors)
      matches = dataRouterState.matches;
    else
      return null;
  let renderedMatches = matches, errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    errorIndex >= 0 || invariant(!1), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error3 = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null, errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ reactExports.createElement(DefaultErrorElement, null) : null, getChildren = /* @__PURE__ */ __name(() => /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index + 1))
      }
    }, error3 ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet), "getChildren");
    return dataRouterState && (match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error3,
      children: getChildren()
    }) : getChildren();
  }, null);
}
__name(_renderMatches, "_renderMatches");
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2.UseRevalidator = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2.UseLoaderData = "useLoaderData", DataRouterStateHook2.UseActionData = "useActionData", DataRouterStateHook2.UseRouteError = "useRouteError", DataRouterStateHook2.UseNavigation = "useNavigation", DataRouterStateHook2.UseRouteLoaderData = "useRouteLoaderData", DataRouterStateHook2.UseMatches = "useMatches", DataRouterStateHook2.UseRevalidator = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  return state || invariant(!1), state;
}
__name(useDataRouterState, "useDataRouterState");
function useRouteError() {
  var _state$errors;
  let error3 = reactExports.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook$1.UseRouteError), route2 = reactExports.useContext(RouteContext), thisRoute = route2.matches[route2.matches.length - 1];
  return error3 || (route2 || invariant(!1), thisRoute.route.id || invariant(!1), (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id]);
}
__name(useRouteError, "useRouteError");
function Route(_props) {
  invariant(!1);
}
__name(Route, "Route");
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children: children2 = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = !1
  } = _ref4;
  useInRouterContext() && invariant(!1);
  let basename = basenameProp.replace(/^\/*/, "/"), navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  typeof locationProp == "string" && (locationProp = parsePath(locationProp));
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp, location = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    return trailingPathname == null ? null : {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search, hash2, state, key]);
  return location == null ? null : /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children: children2,
    value: {
      location,
      navigationType
    }
  }));
}
__name(Router, "Router");
function Routes(_ref5) {
  let {
    children: children2,
    location
  } = _ref5, dataRouterContext = reactExports.useContext(DataRouterContext), routes = dataRouterContext && !children2 ? dataRouterContext.router.routes : createRoutesFromChildren(children2);
  return useRoutes(routes, location);
}
__name(Routes, "Routes");
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2.pending = 0] = "pending", AwaitRenderStatus2[AwaitRenderStatus2.success = 1] = "success", AwaitRenderStatus2[AwaitRenderStatus2.error = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children2, parentPath) {
  parentPath === void 0 && (parentPath = []);
  let routes = [];
  return reactExports.Children.forEach(children2, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element))
      return;
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    element.type !== Route && invariant(!1), !element.props.index || !element.props.children || invariant(!1);
    let treePath = [...parentPath, index], route2 = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    element.props.children && (route2.children = createRoutesFromChildren(element.props.children, treePath)), routes.push(route2);
  }), routes;
}
__name(createRoutesFromChildren, "createRoutesFromChildren");
/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$1.apply(this, arguments);
}
__name(_extends$1, "_extends$1");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function isModifiedEvent(event2) {
  return !!(event2.metaKey || event2.altKey || event2.ctrlKey || event2.shiftKey);
}
__name(isModifiedEvent, "isModifiedEvent");
function shouldProcessLinkClick(event2, target) {
  return event2.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event2);
}
__name(shouldProcessLinkClick, "shouldProcessLinkClick");
const _excluded$7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref3) {
  let {
    basename,
    children: children2,
    window: window2
  } = _ref3, historyRef = reactExports.useRef();
  historyRef.current == null && (historyRef.current = createBrowserHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setState] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  return reactExports.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children: children2,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
__name(BrowserRouter, "BrowserRouter");
const Link = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded$7), href = useHref(to, {
    relative
  }), internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event2) {
    onClick && onClick(event2), event2.defaultPrevented || internalOnClick(event2);
  }
  return __name(handleClick, "handleClick"), // eslint-disable-next-line jsx-a11y/anchor-has-content
  /* @__PURE__ */ reactExports.createElement("a", _extends$1({}, rest, {
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  }));
}, "LinkWithRef")), NavLink = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = !1,
    className: classNameProp = "",
    end: end2 = !1,
    style: styleProp,
    to,
    children: children2
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2$2), path = useResolvedPath(to, {
    relative: rest.relative
  }), location = useLocation(), routerState = reactExports.useContext(DataRouterStateContext), toPathname = path.pathname, locationPathname = location.pathname, nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  caseSensitive || (locationPathname = locationPathname.toLowerCase(), nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null, toPathname = toPathname.toLowerCase());
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/", isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/"), ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
  typeof classNameProp == "function" ? className = classNameProp({
    isActive,
    isPending
  }) : className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  let style2 = typeof styleProp == "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$1({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to
  }), typeof children2 == "function" ? children2({
    isActive,
    isPending
  }) : children2);
}, "NavLinkWithRef"));
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2.UseScrollRestoration = "useScrollRestoration", DataRouterHook2.UseSubmitImpl = "useSubmitImpl", DataRouterHook2.UseFetcher = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2.UseFetchers = "useFetchers", DataRouterStateHook2.UseScrollRestoration = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp, navigate2 = useNavigate(), location = useLocation(), path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event2) => {
    if (shouldProcessLinkClick(event2, target)) {
      event2.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate2(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate2, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
__name(useLinkClickHandler, "useLinkClickHandler");
function _assertThisInitialized(self2) {
  if (self2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self2;
}
__name(_assertThisInitialized, "_assertThisInitialized");
function _setPrototypeOf(o2, p2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function(o3, p3) {
    return o3.__proto__ = p3, o3;
  }, "_setPrototypeOf"), _setPrototypeOf(o2, p2);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(subClass, "prototype", {
    writable: !1
  }), superClass && _setPrototypeOf(subClass, superClass);
}
__name(_inherits, "_inherits");
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 == "function"))
    return call2;
  if (call2 !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(self2);
}
__name(_possibleConstructorReturn, "_possibleConstructorReturn");
function _getPrototypeOf(o2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  }, "_getPrototypeOf"), _getPrototypeOf(o2);
}
__name(_getPrototypeOf, "_getPrototypeOf");
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
__name(_iterableToArray, "_iterableToArray");
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
__name(_toArray, "_toArray");
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread, "_objectSpread");
var consoleLogger = {
  type: "logger",
  log: /* @__PURE__ */ __name(function(args) {
    this.output("log", args);
  }, "log"),
  warn: /* @__PURE__ */ __name(function(args) {
    this.output("warn", args);
  }, "warn"),
  error: /* @__PURE__ */ __name(function(args) {
    this.output("error", args);
  }, "error"),
  output: /* @__PURE__ */ __name(function(type2, args) {
    console && console[type2] && console[type2].apply(console, args);
  }, "output")
}, Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2), this.init(concreteLogger, options2);
  }
  return __name(Logger2, "Logger"), _createClass(Logger2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:", this.logger = concreteLogger || consoleLogger, this.options = options2, this.debug = options2.debug;
    }, "init")
  }, {
    key: "setDebug",
    value: /* @__PURE__ */ __name(function(bool) {
      this.debug = bool;
    }, "setDebug")
  }, {
    key: "log",
    value: /* @__PURE__ */ __name(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return this.forward(args, "log", "", !0);
    }, "log")
  }, {
    key: "warn",
    value: /* @__PURE__ */ __name(function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
        args[_key2] = arguments[_key2];
      return this.forward(args, "warn", "", !0);
    }, "warn")
  }, {
    key: "error",
    value: /* @__PURE__ */ __name(function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
        args[_key3] = arguments[_key3];
      return this.forward(args, "error", "");
    }, "error")
  }, {
    key: "deprecate",
    value: /* @__PURE__ */ __name(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
        args[_key4] = arguments[_key4];
      return this.forward(args, "warn", "WARNING DEPRECATED: ", !0);
    }, "deprecate")
  }, {
    key: "forward",
    value: /* @__PURE__ */ __name(function(args, lvl, prefix2, debugOnly) {
      return debugOnly && !this.debug ? null : (typeof args[0] == "string" && (args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0])), this.logger[lvl](args));
    }, "forward")
  }, {
    key: "create",
    value: /* @__PURE__ */ __name(function(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }, "create")
  }]), Logger2;
}(), baseLogger = new Logger(), EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2), this.observers = {};
  }
  return __name(EventEmitter2, "EventEmitter"), _createClass(EventEmitter2, [{
    key: "on",
    value: /* @__PURE__ */ __name(function(events, listener) {
      var _this = this;
      return events.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [], _this.observers[event2].push(listener);
      }), this;
    }, "on")
  }, {
    key: "off",
    value: /* @__PURE__ */ __name(function(event2, listener) {
      if (this.observers[event2]) {
        if (!listener) {
          delete this.observers[event2];
          return;
        }
        this.observers[event2] = this.observers[event2].filter(function(l2) {
          return l2 !== listener;
        });
      }
    }, "off")
  }, {
    key: "emit",
    value: /* @__PURE__ */ __name(function(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        args[_key - 1] = arguments[_key];
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }, "emit")
  }]), EventEmitter2;
}();
function defer() {
  var res, rej, promise = new Promise(function(resolve, reject2) {
    res = resolve, rej = reject2;
  });
  return promise.resolve = res, promise.reject = rej, promise;
}
__name(defer, "defer");
function makeString(object) {
  return object == null ? "" : "" + object;
}
__name(makeString, "makeString");
function copy$1(a2, s, t2) {
  a2.forEach(function(m2) {
    s[m2] && (t2[m2] = s[m2]);
  });
}
__name(copy$1, "copy$1");
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  __name(cleanKey, "cleanKey");
  function canNotTraverseDeeper() {
    return !object || typeof object == "string";
  }
  __name(canNotTraverseDeeper, "canNotTraverseDeeper");
  for (var stack = typeof path != "string" ? [].concat(path) : path.split("."); stack.length > 1; ) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    !object[key] && Empty && (object[key] = new Empty()), Object.prototype.hasOwnProperty.call(object, key) ? object = object[key] : object = {};
  }
  return canNotTraverseDeeper() ? {} : {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
__name(getLastOfPath, "getLastOfPath");
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
__name(setPath, "setPath");
function pushPath(object, path, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [], concat2 && (obj[k2] = obj[k2].concat(newValue)), concat2 || obj[k2].push(newValue);
}
__name(pushPath, "pushPath");
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (obj)
    return obj[k2];
}
__name(getPath, "getPath");
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  return value !== void 0 ? value : getPath(defaultData, key);
}
__name(getPathWithDefaults, "getPathWithDefaults");
function deepExtend(target, source, overwrite) {
  for (var prop in source)
    prop !== "__proto__" && prop !== "constructor" && (prop in target ? typeof target[prop] == "string" || target[prop] instanceof String || typeof source[prop] == "string" || source[prop] instanceof String ? overwrite && (target[prop] = source[prop]) : deepExtend(target[prop], source[prop], overwrite) : target[prop] = source[prop]);
  return target;
}
__name(deepExtend, "deepExtend");
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
__name(regexEscape, "regexEscape");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  return typeof data == "string" ? data.replace(/[&<>"'\/]/g, function(s) {
    return _entityMap[s];
  }) : data;
}
__name(escape, "escape");
var isIE10 = typeof window < "u" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "", keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return !0;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")")), matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    ki2 > 0 && !r2.test(key.substring(0, ki2)) && (matched = !0);
  }
  return matched;
}
__name(looksLikeObjectPath, "looksLikeObjectPath");
function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$1$1, "ownKeys$1$1");
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1$1(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$1, "_objectSpread$1");
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$1, "_createSuper$1");
function _isNativeReflectConstruct$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$1, "_isNativeReflectConstruct$1");
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (obj) {
    if (obj[path])
      return obj[path];
    for (var paths = path.split(keySeparator), current = obj, i = 0; i < paths.length; ++i) {
      if (!current || typeof current[paths[i]] == "string" && i + 1 < paths.length)
        return;
      if (current[paths[i]] === void 0) {
        for (var j2 = 2, p2 = paths.slice(i, i + j2).join(keySeparator), mix = current[p2]; mix === void 0 && paths.length > i + j2; )
          j2++, p2 = paths.slice(i, i + j2).join(keySeparator), mix = current[p2];
        if (mix === void 0)
          return;
        if (path.endsWith(p2)) {
          if (typeof mix == "string")
            return mix;
          if (p2 && typeof mix[p2] == "string")
            return mix[p2];
        }
        var joinedPath = paths.slice(i + j2).join(keySeparator);
        return joinedPath ? deepFind(mix, joinedPath, keySeparator) : void 0;
      }
      current = current[paths[i]];
    }
    return current;
  }
}
__name(deepFind, "deepFind");
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$1(ResourceStore2);
  function ResourceStore2(data) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return _classCallCheck(this, ResourceStore2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.data = data || {}, _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.options.ignoreJSONStructure === void 0 && (_this.options.ignoreJSONStructure = !0), _this;
  }
  return __name(ResourceStore2, "ResourceStore"), _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: /* @__PURE__ */ __name(function(ns2) {
      this.options.ns.indexOf(ns2) < 0 && this.options.ns.push(ns2);
    }, "addNamespaces")
  }, {
    key: "removeNamespaces",
    value: /* @__PURE__ */ __name(function(ns2) {
      var index = this.options.ns.indexOf(ns2);
      index > -1 && this.options.ns.splice(index, 1);
    }, "removeNamespaces")
  }, {
    key: "getResource",
    value: /* @__PURE__ */ __name(function(lng, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure, path = [lng, ns2];
      key && typeof key != "string" && (path = path.concat(key)), key && typeof key == "string" && (path = path.concat(keySeparator ? key.split(keySeparator) : key)), lng.indexOf(".") > -1 && (path = lng.split("."));
      var result = getPath(this.data, path);
      return result || !ignoreJSONStructure || typeof key != "string" ? result : deepFind(this.data && this.data[lng] && this.data[lng][ns2], key, keySeparator);
    }, "getResource")
  }, {
    key: "addResource",
    value: /* @__PURE__ */ __name(function(lng, ns2, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, keySeparator = this.options.keySeparator;
      keySeparator === void 0 && (keySeparator = ".");
      var path = [lng, ns2];
      key && (path = path.concat(keySeparator ? key.split(keySeparator) : key)), lng.indexOf(".") > -1 && (path = lng.split("."), value = ns2, ns2 = path[1]), this.addNamespaces(ns2), setPath(this.data, path, value), options2.silent || this.emit("added", lng, ns2, key, value);
    }, "addResource")
  }, {
    key: "addResources",
    value: /* @__PURE__ */ __name(function(lng, ns2, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var m2 in resources)
        (typeof resources[m2] == "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]") && this.addResource(lng, ns2, m2, resources[m2], {
          silent: !0
        });
      options2.silent || this.emit("added", lng, ns2, resources);
    }, "addResources")
  }, {
    key: "addResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, path = [lng, ns2];
      lng.indexOf(".") > -1 && (path = lng.split("."), deep = resources, resources = ns2, ns2 = path[1]), this.addNamespaces(ns2);
      var pack = getPath(this.data, path) || {};
      deep ? deepExtend(pack, resources, overwrite) : pack = _objectSpread$1(_objectSpread$1({}, pack), resources), setPath(this.data, path, pack), options2.silent || this.emit("added", lng, ns2, resources);
    }, "addResourceBundle")
  }, {
    key: "removeResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      this.hasResourceBundle(lng, ns2) && delete this.data[lng][ns2], this.removeNamespaces(ns2), this.emit("removed", lng, ns2);
    }, "removeResourceBundle")
  }, {
    key: "hasResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      return this.getResource(lng, ns2) !== void 0;
    }, "hasResourceBundle")
  }, {
    key: "getResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      return ns2 || (ns2 = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns2)) : this.getResource(lng, ns2);
    }, "getResourceBundle")
  }, {
    key: "getDataByLanguage",
    value: /* @__PURE__ */ __name(function(lng) {
      return this.data[lng];
    }, "getDataByLanguage")
  }, {
    key: "hasLanguageSomeTranslations",
    value: /* @__PURE__ */ __name(function(lng) {
      var data = this.getDataByLanguage(lng), n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }, "hasLanguageSomeTranslations")
  }, {
    key: "toJSON",
    value: /* @__PURE__ */ __name(function() {
      return this.data;
    }, "toJSON")
  }]), ResourceStore2;
}(EventEmitter), postProcessor = {
  processors: {},
  addPostProcessor: /* @__PURE__ */ __name(function(module) {
    this.processors[module.name] = module;
  }, "addPostProcessor"),
  handle: /* @__PURE__ */ __name(function(processors, value, key, options2, translator) {
    var _this = this;
    return processors.forEach(function(processor) {
      _this.processors[processor] && (value = _this.processors[processor].process(value, key, options2, translator));
    }), value;
  }, "handle")
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$2, "_objectSpread$2");
function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$1$1, "_createSuper$1$1");
function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$1$1, "_isNativeReflectConstruct$1$1");
var checkedLoadedFor = {}, Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1$1(Translator2);
  function Translator2(services) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _classCallCheck(this, Translator2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), copy$1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this)), _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.logger = baseLogger.create("translator"), _this;
  }
  return __name(Translator2, "Translator"), _createClass(Translator2, [{
    key: "changeLanguage",
    value: /* @__PURE__ */ __name(function(lng) {
      lng && (this.language = lng);
    }, "changeLanguage")
  }, {
    key: "exists",
    value: /* @__PURE__ */ __name(function(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key == null)
        return !1;
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }, "exists")
  }, {
    key: "extractFromKey",
    value: /* @__PURE__ */ __name(function(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      nsSeparator === void 0 && (nsSeparator = ":");
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, namespaces = options2.ns || this.options.defaultNS || [], wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1, seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0)
          return {
            key,
            namespaces
          };
        var parts = key.split(nsSeparator);
        (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) && (namespaces = parts.shift()), key = parts.join(keySeparator);
      }
      return typeof namespaces == "string" && (namespaces = [namespaces]), {
        key,
        namespaces
      };
    }, "extractFromKey")
  }, {
    key: "translate",
    value: /* @__PURE__ */ __name(function(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler && (options2 = this.options.overloadTranslationOptionHandler(arguments)), options2 || (options2 = {}), keys == null)
        return "";
      Array.isArray(keys) || (keys = [String(keys)]);
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces, namespace = namespaces[namespaces.length - 1], lng = options2.lng || this.language, appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2), res = resolved && resolved.res, resUsedKey = resolved && resolved.usedKey || key, resExactUsedKey = resolved && resolved.exactUsedKey || key, resType = Object.prototype.toString.apply(res), noObject = ["[object Number]", "[object Function]", "[object RegExp]"], joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays, handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject, handleAsObject = typeof res != "string" && typeof res != "boolean" && typeof res != "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays == "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects)
          return this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]", copy2 = resTypeIsArray ? [] : {}, newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res)
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: !1,
                ns: namespaces
              })), copy2[m2] === deepKey && (copy2[m2] = res[m2]);
            }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays == "string" && resType === "[object Array]")
        res = res.join(joinArrays), res && (res = this.extendTranslation(res, keys, options2, lastKey));
      else {
        var usedDefault = !1, usedKey = !1, needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", hasDefaultValue = Translator2.hasDefaultValue(options2), defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count, options2) : "", defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        !this.isValidLookup(res) && hasDefaultValue && (usedDefault = !0, res = defaultValue), this.isValidLookup(res) || (usedKey = !0, res = key);
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res, updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          if (this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res), keySeparator) {
            var fk2 = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: !1
            }));
            fk2 && fk2.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [], fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0])
            for (var i = 0; i < fallbackLngs.length; i++)
              lngs.push(fallbackLngs[i]);
          else
            this.options.saveMissingTo === "all" ? lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language) : lngs.push(options2.lng || this.language);
          var send2 = /* @__PURE__ */ __name(function(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            _this2.options.missingKeyHandler ? _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2) : _this2.backendConnector && _this2.backendConnector.saveMissing && _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2), _this2.emit("missingKey", l2, namespace, k2, res);
          }, "send");
          this.options.saveMissing && (this.options.saveMissingPlurals && needsPluralHandling ? lngs.forEach(function(language2) {
            _this2.pluralResolver.getSuffixes(language2, options2).forEach(function(suffix) {
              send2([language2], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
            });
          }) : send2(lngs, key, defaultValue));
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey), usedKey && res === key && this.options.appendNamespaceToMissingKey && (res = "".concat(namespace, ":").concat(key)), (usedKey || usedDefault) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? res = this.options.parseMissingKeyHandler(key, usedDefault ? res : void 0) : res = this.options.parseMissingKeyHandler(res));
      }
      return res;
    }, "translate")
  }, {
    key: "extendTranslation",
    value: /* @__PURE__ */ __name(function(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      else if (!options2.skipInterpolation) {
        options2.interpolation && this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
        }));
        var skipOnVariables = typeof res == "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data = options2.replace && typeof options2.replace != "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables && (data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data)), res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2), skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp), nestAft = na && na.length;
          nestBef < nestAft && (options2.nest = !1);
        }
        options2.nest !== !1 && (res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return lastKey && lastKey[0] === args[0] && !options2.context ? (_this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0])), null) : _this3.translate.apply(_this3, args.concat([key]));
        }, options2)), options2.interpolation && this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess, postProcessorNames = typeof postProcess == "string" ? [postProcess] : postProcess;
      return res != null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== !1 && (res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
        i18nResolved: resolved
      }, options2) : options2, this)), res;
    }, "extendTranslation")
  }, {
    key: "resolve",
    value: /* @__PURE__ */ __name(function(keys) {
      var _this4 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, found, usedKey, exactUsedKey, usedLng, usedNS;
      return typeof keys == "string" && (keys = [keys]), keys.forEach(function(k2) {
        if (!_this4.isValidLookup(found)) {
          var extracted = _this4.extractFromKey(k2, options2), key = extracted.key;
          usedKey = key;
          var namespaces = extracted.namespaces;
          _this4.options.fallbackNS && (namespaces = namespaces.concat(_this4.options.fallbackNS));
          var needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi(), needsContextHandling = options2.context !== void 0 && (typeof options2.context == "string" || typeof options2.context == "number") && options2.context !== "", codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
          namespaces.forEach(function(ns2) {
            _this4.isValidLookup(found) || (usedNS = ns2, !checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS) && (checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] = !0, _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), codes.forEach(function(code) {
              if (!_this4.isValidLookup(found)) {
                usedLng = code;
                var finalKeys = [key];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys)
                  _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, options2);
                else {
                  var pluralSuffix;
                  needsPluralHandling && (pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2));
                  var zeroSuffix = "_zero";
                  if (needsPluralHandling && (finalKeys.push(key + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(key + zeroSuffix)), needsContextHandling) {
                    var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options2.context);
                    finalKeys.push(contextKey), needsPluralHandling && (finalKeys.push(contextKey + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(contextKey + zeroSuffix));
                  }
                }
                for (var possibleKey; possibleKey = finalKeys.pop(); )
                  _this4.isValidLookup(found) || (exactUsedKey = possibleKey, found = _this4.getResource(code, ns2, possibleKey, options2));
              }
            }));
          });
        }
      }), {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }, "resolve")
  }, {
    key: "isValidLookup",
    value: /* @__PURE__ */ __name(function(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }, "isValidLookup")
  }, {
    key: "getResource",
    value: /* @__PURE__ */ __name(function(code, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(code, ns2, key, options2) : this.resourceStore.getResource(code, ns2, key, options2);
    }, "getResource")
  }], [{
    key: "hasDefaultValue",
    value: /* @__PURE__ */ __name(function(options2) {
      var prefix2 = "defaultValue";
      for (var option in options2)
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && options2[option] !== void 0)
          return !0;
      return !1;
    }, "hasDefaultValue")
  }]), Translator2;
}(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
__name(capitalize, "capitalize");
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2), this.options = options2, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils");
  }
  return __name(LanguageUtil2, "LanguageUtil"), _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      return p2.length === 2 || (p2.pop(), p2[p2.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(p2.join("-"));
    }, "getScriptPartFromCode")
  }, {
    key: "getLanguagePartFromCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }, "getLanguagePartFromCode")
  }, {
    key: "formatLanguageCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (typeof code == "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], p2 = code.split("-");
        return this.options.lowerCaseLng ? p2 = p2.map(function(part) {
          return part.toLowerCase();
        }) : p2.length === 2 ? (p2[0] = p2[0].toLowerCase(), p2[1] = p2[1].toUpperCase(), specialCases.indexOf(p2[1].toLowerCase()) > -1 && (p2[1] = capitalize(p2[1].toLowerCase()))) : p2.length === 3 && (p2[0] = p2[0].toLowerCase(), p2[1].length === 2 && (p2[1] = p2[1].toUpperCase()), p2[0] !== "sgn" && p2[2].length === 2 && (p2[2] = p2[2].toUpperCase()), specialCases.indexOf(p2[1].toLowerCase()) > -1 && (p2[1] = capitalize(p2[1].toLowerCase())), specialCases.indexOf(p2[2].toLowerCase()) > -1 && (p2[2] = capitalize(p2[2].toLowerCase()))), p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }, "formatLanguageCode")
  }, {
    key: "isSupportedCode",
    value: /* @__PURE__ */ __name(function(code) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (code = this.getLanguagePartFromCode(code)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }, "isSupportedCode")
  }, {
    key: "getBestMatchFromCodes",
    value: /* @__PURE__ */ __name(function(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      return codes.forEach(function(code) {
        if (!found) {
          var cleanedLng = _this.formatLanguageCode(code);
          (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) && (found = cleanedLng);
        }
      }), !found && this.options.supportedLngs && codes.forEach(function(code) {
        if (!found) {
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        }
      }), found || (found = this.getFallbackCodes(this.options.fallbackLng)[0]), found;
    }, "getBestMatchFromCodes")
  }, {
    key: "getFallbackCodes",
    value: /* @__PURE__ */ __name(function(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks == "function" && (fallbacks = fallbacks(code)), typeof fallbacks == "string" && (fallbacks = [fallbacks]), Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks.default || [];
      var found = fallbacks[code];
      return found || (found = fallbacks[this.getScriptPartFromCode(code)]), found || (found = fallbacks[this.formatLanguageCode(code)]), found || (found = fallbacks[this.getLanguagePartFromCode(code)]), found || (found = fallbacks.default), found || [];
    }, "getFallbackCodes")
  }, {
    key: "toResolveHierarchy",
    value: /* @__PURE__ */ __name(function(code, fallbackCode) {
      var _this2 = this, fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code), codes = [], addCode = /* @__PURE__ */ __name(function(c2) {
        c2 && (_this2.isSupportedCode(c2) ? codes.push(c2) : _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2)));
      }, "addCode");
      return typeof code == "string" && code.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && addCode(this.formatLanguageCode(code)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && addCode(this.getScriptPartFromCode(code)), this.options.load !== "currentOnly" && addCode(this.getLanguagePartFromCode(code))) : typeof code == "string" && addCode(this.formatLanguageCode(code)), fallbackCodes.forEach(function(fc2) {
        codes.indexOf(fc2) < 0 && addCode(_this2.formatLanguageCode(fc2));
      }), codes;
    }, "toResolveHierarchy")
  }]), LanguageUtil2;
}(), sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], _rulesPluralsTypes = {
  1: /* @__PURE__ */ __name(function(n2) {
    return +(n2 > 1);
  }, "_"),
  2: /* @__PURE__ */ __name(function(n2) {
    return +(n2 != 1);
  }, "_"),
  3: /* @__PURE__ */ __name(function(n2) {
    return 0;
  }, "_"),
  4: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  5: /* @__PURE__ */ __name(function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
  }, "_"),
  6: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2;
  }, "_"),
  7: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  8: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3;
  }, "_"),
  9: /* @__PURE__ */ __name(function(n2) {
    return +(n2 >= 2);
  }, "_"),
  10: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4;
  }, "_"),
  11: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3;
  }, "_"),
  12: /* @__PURE__ */ __name(function(n2) {
    return +(n2 % 10 != 1 || n2 % 100 == 11);
  }, "_"),
  13: /* @__PURE__ */ __name(function(n2) {
    return +(n2 !== 0);
  }, "_"),
  14: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3;
  }, "_"),
  15: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  16: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2;
  }, "_"),
  17: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1;
  }, "_"),
  18: /* @__PURE__ */ __name(function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : 2;
  }, "_"),
  19: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3;
  }, "_"),
  20: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2;
  }, "_"),
  21: /* @__PURE__ */ __name(function(n2) {
    return n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0;
  }, "_"),
  22: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3;
  }, "_")
}, deprecatedJsonVersions = ["v1", "v2", "v3"], suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  return sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  }), rules;
}
__name(createRules, "createRules");
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2), this.languageUtils = languageUtils, this.options = options2, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules();
  }
  return __name(PluralResolver2, "PluralResolver"), _createClass(PluralResolver2, [{
    key: "addRule",
    value: /* @__PURE__ */ __name(function(lng, obj) {
      this.rules[lng] = obj;
    }, "addRule")
  }, {
    key: "getRule",
    value: /* @__PURE__ */ __name(function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(code, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }, "getRule")
  }, {
    key: "needsPlural",
    value: /* @__PURE__ */ __name(function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return this.shouldUseIntlApi() ? rule && rule.resolvedOptions().pluralCategories.length > 1 : rule && rule.numbers.length > 1;
    }, "needsPlural")
  }, {
    key: "getPluralFormsOfKey",
    value: /* @__PURE__ */ __name(function(code, key) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options2).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }, "getPluralFormsOfKey")
  }, {
    key: "getSuffixes",
    value: /* @__PURE__ */ __name(function(code) {
      var _this = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
        return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
      }).map(function(pluralCategory) {
        return "".concat(_this.options.prepend).concat(pluralCategory);
      }) : rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options2);
      }) : [];
    }, "getSuffixes")
  }, {
    key: "getSuffix",
    value: /* @__PURE__ */ __name(function(code, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(rule.select(count)) : this.getSuffixRetroCompatible(rule, count) : (this.logger.warn("no plural rule found for: ".concat(code)), "");
    }, "getSuffix")
  }, {
    key: "getSuffixRetroCompatible",
    value: /* @__PURE__ */ __name(function(rule, count) {
      var _this2 = this, idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count)), suffix = rule.numbers[idx];
      this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 && (suffix === 2 ? suffix = "plural" : suffix === 1 && (suffix = ""));
      var returnSuffix = /* @__PURE__ */ __name(function() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      }, "returnSuffix");
      return this.options.compatibilityJSON === "v1" ? suffix === 1 ? "" : typeof suffix == "number" ? "_plural_".concat(suffix.toString()) : returnSuffix() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 ? returnSuffix() : this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }, "getSuffixRetroCompatible")
  }, {
    key: "shouldUseIntlApi",
    value: /* @__PURE__ */ __name(function() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }, "shouldUseIntlApi")
  }]), PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$3, "ownKeys$3");
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$3, "_objectSpread$3");
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2), this.logger = baseLogger.create("interpolator"), this.options = options2, this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    }, this.init(options2);
  }
  return __name(Interpolator2, "Interpolator"), _createClass(Interpolator2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      options2.interpolation || (options2.interpolation = {
        escapeValue: !0
      });
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape, this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : !0, this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : !1, this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{", this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}", this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",", this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "", this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",", this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3, this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : !1, this.resetRegExp();
    }, "init")
  }, {
    key: "reset",
    value: /* @__PURE__ */ __name(function() {
      this.options && this.init(this.options);
    }, "reset")
  }, {
    key: "resetRegExp",
    value: /* @__PURE__ */ __name(function() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }, "resetRegExp")
  }, {
    key: "interpolate",
    value: /* @__PURE__ */ __name(function(str, data, lng, options2) {
      var _this = this, match2, value, replaces, defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      __name(regexSafe, "regexSafe");
      var handleFormat = /* @__PURE__ */ __name(function(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator), k2 = p2.shift().trim(), f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
          interpolationkey: k2
        }));
      }, "handleFormat");
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler, skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, todos = [{
        regex: this.regexpUnescape,
        safeValue: /* @__PURE__ */ __name(function(val) {
          return regexSafe(val);
        }, "safeValue")
      }, {
        regex: this.regexp,
        safeValue: /* @__PURE__ */ __name(function(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }, "safeValue")
      }];
      return todos.forEach(function(todo) {
        for (replaces = 0; match2 = todo.regex.exec(str); ) {
          var matchedVar = match2[1].trim();
          if (value = handleFormat(matchedVar), value === void 0)
            if (typeof missingInterpolationHandler == "function") {
              var temp = missingInterpolationHandler(str, match2, options2);
              value = typeof temp == "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar))
              value = "";
            else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str)), value = "";
          else
            typeof value != "string" && !_this.useRawValueToEscape && (value = makeString(value));
          var safeValue = todo.safeValue(value);
          if (str = str.replace(match2[0], safeValue), skipOnVariables ? (todo.regex.lastIndex += safeValue.length, todo.regex.lastIndex -= match2[0].length) : todo.regex.lastIndex = 0, replaces++, replaces >= _this.maxReplaces)
            break;
        }
      }), str;
    }, "interpolate")
  }, {
    key: "nest",
    value: /* @__PURE__ */ __name(function(str, fc2) {
      var _this2 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, match2, value, clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = !1, delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{"))), optionsString = "{".concat(c2[1]);
        key = c2[0], optionsString = this.interpolate(optionsString, clonedOptions), optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString), inheritedOptions && (clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions));
        } catch (e2) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2), "".concat(key).concat(sep).concat(optionsString);
        }
        return delete clonedOptions.defaultValue, key;
      }
      for (__name(handleHasOptions, "handleHasOptions"); match2 = this.nestingRegexp.exec(str); ) {
        var formatters = [], doReduce = !1;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift(), formatters = r2, doReduce = !0;
        }
        if (value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions), value && match2[0] === str && typeof value != "string")
          return value;
        typeof value != "string" && (value = makeString(value)), value || (this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str)), value = ""), doReduce && (value = formatters.reduce(function(v2, f2) {
          return _this2.format(v2, f2, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
            interpolationkey: match2[1].trim()
          }));
        }, value.trim())), str = str.replace(match2[0], value), this.regexp.lastIndex = 0;
      }
      return str;
    }, "nest")
  }]), Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$4, "ownKeys$4");
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$4, "_objectSpread$4");
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim(), formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0)
      formatOptions.currency || (formatOptions.currency = optStr.trim());
    else if (formatName === "relativetime" && optStr.indexOf(":") < 0)
      formatOptions.range || (formatOptions.range = optStr.trim());
    else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (opt) {
          var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1), val = rest.join(":");
          formatOptions[key.trim()] || (formatOptions[key.trim()] = val.trim()), val.trim() === "false" && (formatOptions[key.trim()] = !1), val.trim() === "true" && (formatOptions[key.trim()] = !0), isNaN(val.trim()) || (formatOptions[key.trim()] = parseInt(val.trim(), 10));
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
__name(parseFormatStr, "parseFormatStr");
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2), this.logger = baseLogger.create("formatter"), this.options = options2, this.formats = {
      number: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.NumberFormat(lng, options3).format(val);
      }, "number"),
      currency: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        })).format(val);
      }, "currency"),
      datetime: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options3)).format(val);
      }, "datetime"),
      relativetime: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options3)).format(val, options3.range || "day");
      }, "relativetime"),
      list: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options3)).format(val);
      }, "list")
    }, this.init(options2);
  }
  return __name(Formatter2, "Formatter"), _createClass(Formatter2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }, "init")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }, "add")
  }, {
    key: "format",
    value: /* @__PURE__ */ __name(function(value, _format, lng, options2) {
      var _this = this, formats = _format.split(this.formatSeparator), result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {}, l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else
          _this.logger.warn("there was no format function for ".concat(formatName));
        return mem;
      }, value);
      return result;
    }, "format")
  }]), Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$5, "ownKeys$5");
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$5, "_objectSpread$5");
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$2, "_createSuper$2");
function _isNativeReflectConstruct$2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$2, "_isNativeReflectConstruct$2");
function remove(arr, what) {
  for (var found = arr.indexOf(what); found !== -1; )
    arr.splice(found, 1), found = arr.indexOf(what);
}
__name(remove, "remove");
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this, options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return _classCallCheck(this, Connector2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.backend = backend, _this.store = store, _this.services = services, _this.languageUtils = services.languageUtils, _this.options = options2, _this.logger = baseLogger.create("backendConnector"), _this.state = {}, _this.queue = [], _this.backend && _this.backend.init && _this.backend.init(services, options2.backend, options2), _this;
  }
  return __name(Connector2, "Connector"), _createClass(Connector2, [{
    key: "queueLoad",
    value: /* @__PURE__ */ __name(function(languages, namespaces, options2, callback2) {
      var _this2 = this, toLoad = [], pending2 = [], toLoadLanguages = [], toLoadNamespaces = [];
      return languages.forEach(function(lng) {
        var hasAllNamespaces = !0;
        namespaces.forEach(function(ns2) {
          var name = "".concat(lng, "|").concat(ns2);
          !options2.reload && _this2.store.hasResourceBundle(lng, ns2) ? _this2.state[name] = 2 : _this2.state[name] < 0 || (_this2.state[name] === 1 ? pending2.indexOf(name) < 0 && pending2.push(name) : (_this2.state[name] = 1, hasAllNamespaces = !1, pending2.indexOf(name) < 0 && pending2.push(name), toLoad.indexOf(name) < 0 && toLoad.push(name), toLoadNamespaces.indexOf(ns2) < 0 && toLoadNamespaces.push(ns2)));
        }), hasAllNamespaces || toLoadLanguages.push(lng);
      }), (toLoad.length || pending2.length) && this.queue.push({
        pending: pending2,
        loaded: {},
        errors: [],
        callback: callback2
      }), {
        toLoad,
        pending: pending2,
        toLoadLanguages,
        toLoadNamespaces
      };
    }, "queueLoad")
  }, {
    key: "loaded",
    value: /* @__PURE__ */ __name(function(name, err, data) {
      var s = name.split("|"), lng = s[0], ns2 = s[1];
      err && this.emit("failedLoading", lng, ns2, err), data && this.store.addResourceBundle(lng, ns2, data), this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns2), remove(q2.pending, name), err && q2.errors.push(err), q2.pending.length === 0 && !q2.done && (Object.keys(q2.loaded).forEach(function(l2) {
          loaded2[l2] || (loaded2[l2] = []), q2.loaded[l2].length && q2.loaded[l2].forEach(function(ns3) {
            loaded2[l2].indexOf(ns3) < 0 && loaded2[l2].push(ns3);
          });
        }), q2.done = !0, q2.errors.length ? q2.callback(q2.errors) : q2.callback());
      }), this.emit("loaded", loaded2), this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }, "loaded")
  }, {
    key: "read",
    value: /* @__PURE__ */ __name(function(lng, ns2, fcName) {
      var _this3 = this, tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350, callback2 = arguments.length > 5 ? arguments[5] : void 0;
      return lng.length ? this.backend[fcName](lng, ns2, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns2, fcName, tried + 1, wait2 * 2, callback2);
          }, wait2);
          return;
        }
        callback2(err, data);
      }) : callback2(null, {});
    }, "read")
  }, {
    key: "prepareLoading",
    value: /* @__PURE__ */ __name(function(languages, namespaces) {
      var _this4 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback2 = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), callback2 && callback2();
      typeof languages == "string" && (languages = this.languageUtils.toResolveHierarchy(languages)), typeof namespaces == "string" && (namespaces = [namespaces]);
      var toLoad = this.queueLoad(languages, namespaces, options2, callback2);
      if (!toLoad.toLoad.length)
        return toLoad.pending.length || callback2(), null;
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }, "prepareLoading")
  }, {
    key: "load",
    value: /* @__PURE__ */ __name(function(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {}, callback2);
    }, "load")
  }, {
    key: "reload",
    value: /* @__PURE__ */ __name(function(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {
        reload: !0
      }, callback2);
    }, "reload")
  }, {
    key: "loadOne",
    value: /* @__PURE__ */ __name(function(name) {
      var _this5 = this, prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", s = name.split("|"), lng = s[0], ns2 = s[1];
      this.read(lng, ns2, "read", void 0, void 0, function(err, data) {
        err && _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns2, " for language ").concat(lng, " failed"), err), !err && data && _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns2, " for language ").concat(lng), data), _this5.loaded(name, err, data);
      });
    }, "loadOne")
  }, {
    key: "saveMissing",
    value: /* @__PURE__ */ __name(function(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      key == null || key === "" || (this.backend && this.backend.create && this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
        isUpdate
      })), !(!languages || !languages[0]) && this.store.addResource(languages[0], namespace, key, fallbackValue));
    }, "saveMissing")
  }]), Connector2;
}(EventEmitter);
function get() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: /* @__PURE__ */ __name(function(args) {
      var ret = {};
      if (_typeof(args[1]) === "object" && (ret = args[1]), typeof args[1] == "string" && (ret.defaultValue = args[1]), typeof args[2] == "string" && (ret.tDescription = args[2]), _typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    }, "handle"),
    interpolation: {
      escapeValue: !0,
      format: /* @__PURE__ */ __name(function(value, _format, lng, options2) {
        return value;
      }, "format"),
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
__name(get, "get");
function transformOptions(options2) {
  return typeof options2.ns == "string" && (options2.ns = [options2.ns]), typeof options2.fallbackLng == "string" && (options2.fallbackLng = [options2.fallbackLng]), typeof options2.fallbackNS == "string" && (options2.fallbackNS = [options2.fallbackNS]), options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0 && (options2.supportedLngs = options2.supportedLngs.concat(["cimode"])), options2;
}
__name(transformOptions, "transformOptions");
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$6, "ownKeys$6");
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$6, "_objectSpread$6");
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$3, "_createSuper$3");
function _isNativeReflectConstruct$3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$3, "_isNativeReflectConstruct$3");
function noop$1() {
}
__name(noop$1, "noop$1");
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    typeof inst[mem] == "function" && (inst[mem] = inst[mem].bind(inst));
  });
}
__name(bindMemberFunctions, "bindMemberFunctions");
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
    if (_classCallCheck(this, I18n2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.options = transformOptions(options2), _this.services = {}, _this.logger = baseLogger, _this.modules = {
      external: []
    }, bindMemberFunctions(_assertThisInitialized(_this)), callback2 && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate)
        return _this.init(options2, callback2), _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      setTimeout(function() {
        _this.init(options2, callback2);
      }, 0);
    }
    return _this;
  }
  return __name(I18n2, "I18n"), _createClass(I18n2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function() {
      var _this2 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
      typeof options2 == "function" && (callback2 = options2, options2 = {}), !options2.defaultNS && options2.ns && (typeof options2.ns == "string" ? options2.defaultNS = options2.ns : options2.ns.indexOf("translation") < 0 && (options2.defaultNS = options2.ns[0]));
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation)), options2.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = options2.keySeparator), options2.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = options2.nsSeparator);
      function createClassOnDemand(ClassOrObject) {
        return ClassOrObject ? typeof ClassOrObject == "function" ? new ClassOrObject() : ClassOrObject : null;
      }
      if (__name(createClassOnDemand, "createClassOnDemand"), !this.options.isClone) {
        this.modules.logger ? baseLogger.init(createClassOnDemand(this.modules.logger), this.options) : baseLogger.init(null, this.options);
        var formatter;
        this.modules.formatter ? formatter = this.modules.formatter : typeof Intl < "u" && (formatter = Formatter);
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger, s.resourceStore = this.store, s.languageUtils = lu, s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format) && (s.formatter = createClassOnDemand(formatter), s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new Interpolator(this.options), s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.languageDetector && (s.languageDetector = createClassOnDemand(this.modules.languageDetector), s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = createClassOnDemand(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.external.forEach(function(m2) {
          m2.init && m2.init(_this2);
        });
      }
      if (this.format = this.options.interpolation.format, callback2 || (callback2 = noop$1), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        codes.length > 0 && codes[0] !== "dev" && (this.options.lng = codes[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          return (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments), _this2;
        };
      });
      var deferred = defer(), load2 = /* @__PURE__ */ __name(function() {
        var finish2 = /* @__PURE__ */ __name(function(err, t2) {
          _this2.isInitialized && !_this2.initializedStoreOnce && _this2.logger.warn("init: i18next is already initialized. You should call init just once!"), _this2.isInitialized = !0, _this2.options.isClone || _this2.logger.log("initialized", _this2.options), _this2.emit("initialized", _this2.options), deferred.resolve(t2), callback2(err, t2);
        }, "finish");
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish2(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish2);
      }, "load");
      return this.options.resources || !this.options.initImmediate ? load2() : setTimeout(load2, 0), deferred;
    }, "init")
  }, {
    key: "loadResources",
    value: /* @__PURE__ */ __name(function(language2) {
      var _this3 = this, callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1, usedCallback = callback2, usedLng = typeof language2 == "string" ? language2 : this.language;
      if (typeof language2 == "function" && (usedCallback = language2), !this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [], append2 = /* @__PURE__ */ __name(function(lng) {
          if (lng) {
            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach(function(l2) {
              toLoad.indexOf(l2) < 0 && toLoad.push(l2);
            });
          }
        }, "append");
        if (usedLng)
          append2(usedLng);
        else {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.options.preload && this.options.preload.forEach(function(l2) {
          return append2(l2);
        }), this.services.backendConnector.load(toLoad, this.options.ns, function(e2) {
          !e2 && !_this3.resolvedLanguage && _this3.language && _this3.setResolvedLanguage(_this3.language), usedCallback(e2);
        });
      } else
        usedCallback(null);
    }, "loadResources")
  }, {
    key: "reloadResources",
    value: /* @__PURE__ */ __name(function(lngs, ns2, callback2) {
      var deferred = defer();
      return lngs || (lngs = this.languages), ns2 || (ns2 = this.options.ns), callback2 || (callback2 = noop$1), this.services.backendConnector.reload(lngs, ns2, function(err) {
        deferred.resolve(), callback2(err);
      }), deferred;
    }, "reloadResources")
  }, {
    key: "use",
    value: /* @__PURE__ */ __name(function(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return module.type === "backend" && (this.modules.backend = module), (module.type === "logger" || module.log && module.warn && module.error) && (this.modules.logger = module), module.type === "languageDetector" && (this.modules.languageDetector = module), module.type === "i18nFormat" && (this.modules.i18nFormat = module), module.type === "postProcessor" && postProcessor.addPostProcessor(module), module.type === "formatter" && (this.modules.formatter = module), module.type === "3rdParty" && this.modules.external.push(module), this;
    }, "use")
  }, {
    key: "setResolvedLanguage",
    value: /* @__PURE__ */ __name(function(l2) {
      if (!(!l2 || !this.languages) && !(["cimode", "dev"].indexOf(l2) > -1))
        for (var li2 = 0; li2 < this.languages.length; li2++) {
          var lngInLngs = this.languages[li2];
          if (!(["cimode", "dev"].indexOf(lngInLngs) > -1) && this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
    }, "setResolvedLanguage")
  }, {
    key: "changeLanguage",
    value: /* @__PURE__ */ __name(function(lng, callback2) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = /* @__PURE__ */ __name(function(l2) {
        _this4.language = l2, _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2), _this4.resolvedLanguage = void 0, _this4.setResolvedLanguage(l2);
      }, "setLngProps"), done = /* @__PURE__ */ __name(function(err, l2) {
        l2 ? (setLngProps(l2), _this4.translator.changeLanguage(l2), _this4.isLanguageChangingTo = void 0, _this4.emit("languageChanged", l2), _this4.logger.log("languageChanged", l2)) : _this4.isLanguageChangingTo = void 0, deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        }), callback2 && callback2(err, function() {
          return _this4.t.apply(_this4, arguments);
        });
      }, "done"), setLng = /* @__PURE__ */ __name(function(lngs) {
        !lng && !lngs && _this4.services.languageDetector && (lngs = []);
        var l2 = typeof lngs == "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        l2 && (_this4.language || setLngProps(l2), _this4.translator.language || _this4.translator.changeLanguage(l2), _this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage(l2)), _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      }, "setLng");
      return !lng && this.services.languageDetector && !this.services.languageDetector.async ? setLng(this.services.languageDetector.detect()) : !lng && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(setLng) : setLng(lng), deferred;
    }, "changeLanguage")
  }, {
    key: "getFixedT",
    value: /* @__PURE__ */ __name(function(lng, ns2, keyPrefix) {
      var _this5 = this, fixedT = /* @__PURE__ */ __name(function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)
            rest[_key3 - 2] = arguments[_key3];
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else
          options2 = _objectSpread$6({}, opts);
        options2.lng = options2.lng || fixedT2.lng, options2.lngs = options2.lngs || fixedT2.lngs, options2.ns = options2.ns || fixedT2.ns;
        var keySeparator = _this5.options.keySeparator || ".", resultKey = keyPrefix ? "".concat(keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options2);
      }, "fixedT");
      return typeof lng == "string" ? fixedT.lng = lng : fixedT.lngs = lng, fixedT.ns = ns2, fixedT.keyPrefix = keyPrefix, fixedT;
    }, "getFixedT")
  }, {
    key: "t",
    value: /* @__PURE__ */ __name(function() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }, "t")
  }, {
    key: "exists",
    value: /* @__PURE__ */ __name(function() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }, "exists")
  }, {
    key: "setDefaultNamespace",
    value: /* @__PURE__ */ __name(function(ns2) {
      this.options.defaultNS = ns2;
    }, "setDefaultNamespace")
  }, {
    key: "hasLoadedNamespace",
    value: /* @__PURE__ */ __name(function(ns2) {
      var _this6 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var lng = this.resolvedLanguage || this.languages[0], fallbackLng = this.options ? this.options.fallbackLng : !1, lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return !0;
      var loadNotPending = /* @__PURE__ */ __name(function(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      }, "loadNotPending");
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      return !!(this.hasResourceBundle(lng, ns2) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)));
    }, "hasLoadedNamespace")
  }, {
    key: "loadNamespaces",
    value: /* @__PURE__ */ __name(function(ns2, callback2) {
      var _this7 = this, deferred = defer();
      return this.options.ns ? (typeof ns2 == "string" && (ns2 = [ns2]), ns2.forEach(function(n2) {
        _this7.options.ns.indexOf(n2) < 0 && _this7.options.ns.push(n2);
      }), this.loadResources(function(err) {
        deferred.resolve(), callback2 && callback2(err);
      }), deferred) : (callback2 && callback2(), Promise.resolve());
    }, "loadNamespaces")
  }, {
    key: "loadLanguages",
    value: /* @__PURE__ */ __name(function(lngs, callback2) {
      var deferred = defer();
      typeof lngs == "string" && (lngs = [lngs]);
      var preloaded = this.options.preload || [], newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      return newLngs.length ? (this.options.preload = preloaded.concat(newLngs), this.loadResources(function(err) {
        deferred.resolve(), callback2 && callback2(err);
      }), deferred) : (callback2 && callback2(), Promise.resolve());
    }, "loadLanguages")
  }, {
    key: "dir",
    value: /* @__PURE__ */ __name(function(lng) {
      if (lng || (lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }, "dir")
  }, {
    key: "cloneInstance",
    value: /* @__PURE__ */ __name(function() {
      var _this8 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1, mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: !0
      }), clone = new I18n2(mergedOptions), membersToCopy = ["store", "services", "language"];
      return membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      }), clone.services = _objectSpread$6({}, this.services), clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone.translator = new Translator(clone.services, clone.options), clone.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
          args[_key4 - 1] = arguments[_key4];
        clone.emit.apply(clone, [event2].concat(args));
      }), clone.init(mergedOptions, callback2), clone.translator.options = clone.options, clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone;
    }, "cloneInstance")
  }, {
    key: "toJSON",
    value: /* @__PURE__ */ __name(function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }, "toJSON")
  }]), I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback2);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
var t$1 = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const getNativeLocale = /* @__PURE__ */ __name(() => apiGet("native-locale"), "getNativeLocale"), account$i = {
  disconnect: " .   ...",
  export: "",
  exportTransactions: "        CSV",
  fatalError: "   ",
  incoming: " ",
  initializing: "   ...",
  maybeProxyError: "   .              ",
  reconnecting: " ,    ...",
  syncedAddressesCount: "  {{count}} "
}, accountInfo$i = {
  address: "",
  buyCTA: {
    buy: " {{unit}}",
    buyCrypto: " ",
    information: {
      looksEmpty: "    ",
      start: "              BitBoxApp"
    }
  },
  extendedPublicKey: "  ",
  label: " ",
  scriptType: "  ",
  title: " ",
  verify: "    ",
  xpubTypeChangeBtn: {
    p2pkh: "      P2PKH ",
    p2tr: " ",
    p2wpkh: " Segwit ",
    "p2wpkh-p2sh": "      Segwit "
  },
  xpubTypeInfo: "   {{scriptType}}    ({{current}}  {{numberOfXPubs}})"
}, accountSummary$i = {
  availableBalance: " ",
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: "  ",
  name: " ",
  noAccount: "   ",
  subtotalWithCoinName: " ({{coinName}})",
  title: " ",
  total: "",
  transactionHistory: " "
}, addAccount$j = {
  chooseName: {
    nextButton: " ",
    step: " ",
    title: "  "
  },
  selectCoin: {
    nextButton: "",
    step: " ",
    title: "  "
  },
  success: {
    message: "  <strong>{{accountName}}</strong>  ",
    nextButton: "",
    step: "",
    title: "  "
  },
  title: " "
}, aopp$c = {
  addressRequest: "{{host}}   ",
  addressRequestWithLogo: "  ",
  banner: "  ",
  errorTitle: "     ",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: " ",
  signing: ",      BitBox02",
  success: {
    message: "  {{host}}",
    title: "   "
  },
  syncing: "    ,  ",
  title: " "
}, app$i = {
  upgrade: "     .    {{current}}  {{version}}"
}, backup$i = {
  check: {
    checking: "   ...",
    confirmTitle: "    ",
    notOK: "    ",
    ok: "   ",
    password: {
      label: "  ",
      placeholder: "  ",
      showLabel: "  "
    },
    success: "     ",
    title: "    "
  },
  create: {
    alreadyExists: "    ,     ",
    fail: "    ",
    info: "         ",
    name: {
      label: "  ",
      placeholder: "   "
    },
    password: {
      label: "  ",
      placeholder: "    "
    },
    title: "   ",
    verificationFailed: "      .    .            "
  },
  description: "<strong>   </strong>",
  insert: "   microSD   ",
  insertButton: "    microSD",
  list: "     microSD  ",
  noBackups: "       microSD",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   microSD",
      general: "      "
    },
    password: {
      label: "       ",
      placeholder: "  ",
      repeatPlaceholder: "   ",
      showLabel: "  "
    },
    restoring: "  ...",
    selectedBackup: "<strong>{{backupName}}</strong>    {{createdDateTime}}  ",
    title: "",
    understand: "           "
  },
  showMnemonic: {
    description: `     ,       .      
<strong>           </strong>
<strong>       </strong>
<strong>      </strong>
      `,
    title: "  "
  },
  title: "  "
}, bb02Bootloader$i = {
  abort: "   -  ",
  abort_noUpgrade: " ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: `        
`
  },
  flipscreen: " ",
  orientation: "      ",
  success: "  !    {{rebootSeconds}} ...",
  success_install: "  !    {{rebootSeconds}} ..."
}, bitbox$i = {
  error: {
    e10000: "    ",
    e10001: "     ",
    e102: "         ",
    e112: "            "
  }
}, bitbox02Interact$i = {
  confirmDate: "      BitBox02",
  confirmDateText: "      ",
  confirmName: "     BitBox02",
  followInstructions: "     BitBox02",
  followInstructionsMnemonic: "     BitBox02           ",
  followInstructionsMnemonicTitle: "     "
}, bitbox02Settings$i = {
  deviceName: {
    current: "  ",
    input: " BitBox02",
    placeholder: "  ",
    title: "   BitBox02"
  },
  gotoStartupSettings: {
    description: "      BitBox02      ",
    title: "    "
  }
}, bitbox02Wizard$i = {
  attestationFailed: "   ,              .      .     support@shiftcrypto.ch    ",
  backup: {
    point1: "      microSD",
    point2: "    ",
    restoreText: "    ",
    text1: ",      BitBox02   .       .      microSD   BitBox02  ",
    text2: "           ",
    text3: "       microSD   <strong> </strong>.   microSD    .           BitBox02  .",
    userConfirmation1: "          ",
    userConfirmation2: "       .             ",
    userConfirmation3: "     BitBox02              ",
    userConfirmation4: "          BitBox02    ",
    userConfirmation5: "        microSD             BitBox02"
  },
  create: {
    button: "    ",
    info: "         BitBox  : ",
    inputTitle: " ",
    point1: "  ",
    point2: "    ",
    point3: "   ",
    text: "     "
  },
  createBackupFailed: "       ",
  initialize: {
    passwordText: "     .     BitBox   ",
    passwordTitle: "     BitBox  ",
    text: "    BitBox02  !     .            . <strong>     microSD  BitBox02  </strong>",
    tip: "    ",
    title: "  BitBox  "
  },
  insertSDCard: "<strong>     microSD  BitBox02  .</strong>",
  noPasswordMatch: "   .   ",
  pairing: {
    failed: "   .    BitBox02  ",
    paired: "       .          ",
    title: "   ",
    unpaired: "  BitBox02 .             .         BitBox02           "
  },
  restoreFromMnemonic: {
    failed: "         "
  },
  stepBackup: {
    beforeProceed: "       :",
    createBackup: "       microSD  "
  },
  stepBackupSuccess: {
    fundsSafe: "       :",
    title: "    "
  },
  stepConnected: {
    unlock: "   BitBox02   "
  },
  stepCreate: {
    description: "        ",
    nameLabel: "  BitBox02",
    namePlaceholder: " BitBox02",
    title: "    BitBox02",
    toastMicroSD: "     microSD  BitBox02  "
  },
  stepCreateSuccess: {
    removeMicroSD: "   microSD  BitBox02    ",
    success: "     "
  },
  stepInsertSD: {
    insertSDCard: "   microSD  BitBox02 ",
    insertSDcardTitle: "   microSD"
  },
  stepPassword: {
    title: "    BitBox02",
    useControls: "     BitBox02   "
  },
  stepUninitialized: {
    create: "   BitBox02 ",
    restore: "     ",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "   ",
    title: "  BitBox02  "
  },
  success: {
    text: `!  BitBox02   

       BitBox                `,
    title: "  "
  }
}, blink$i = {
  button: ""
}, bootloader$i = {
  button: "    ",
  button_install: "    ",
  progress: ": {{progress}}",
  progress_install: ": {{progress}}",
  success: "  !    .      "
}, button$m = {
  abort: "",
  back: "",
  buy: "",
  changepin: "    ",
  check: "    ",
  continue: "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: "",
  upgrade: " "
}, buy$e = {
  info: {
    continue: "  ",
    crypto: "",
    disclaimer: {
      intro: [
        "   MoonPay      {{name}}    BitBox.    ",
        " MoonPay    {{name}}      160 "
      ],
      payment: {
        details: "  {{name}}    MoonPay    .               .       .     4   /    ",
        footnote: "     MoonPay        BitBoxApp       ",
        table: {
          "1_description": "       3  ",
          "1_method": "  (SEPA)",
          "2_description": "    ",
          "2_method": "  ",
          description: "",
          fee: "",
          method: ""
        },
        title: "  "
      },
      privacyPolicy: "   MoonPay",
      protection: {
        description: "  BitBoxApp      {{name}}        .  MoonPay      .           ",
        title: " "
      },
      security: {
        description: "  {{name}}  MoonPay     .          BitBox02          BitBoxApp",
        link: "   ",
        title: " "
      },
      title: "      {{name}}"
    },
    next: "",
    selectLabel: " ",
    selectPlaceholder: " ",
    skip: "   ",
    title: " {{name}}"
  },
  title: " {{name}}"
}, changePin$i = {
  newTitle: "   ",
  oldLabel: "   "
}, chart$e = {
  dataMissing: "   ...  ",
  dataUpdating: " ...",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
}, checkSDcard$i = "   microSD", clickHere$i = " ", confirm$k = {
  abortInfo: "  ",
  abortInfoRedText: "",
  approveInfo: "    4    ",
  approveInfoGreenText: "",
  info: "   BitBox  ",
  infoWhenPaired: "       BitBox  "
}, confirmOnDevice$i = "   ", device$i = {
  appUpradeRequired: " BitBox        .     "
}, deviceLock$i = {
  button: "   (2FA)",
  condition1: "   ",
  condition2: "      ",
  condition3: "  2FA        .        2FA!",
  confirm: "    (2FA)",
  title: "    (2FA)"
}, deviceSettings$i = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: " ",
    upToDate: "  ",
    version: {
      label: ""
    }
  },
  hardware: {
    attestation: {
      false: "   ",
      label: "  ",
      true: " BitBox02   "
    },
    sdcard: {
      false: "  ",
      label: " microSD",
      true: " "
    },
    securechip: " ",
    title: ""
  },
  loading: "    ...",
  pairing: {
    lock: {
      false: "",
      label: "   (2FA)",
      true: ""
    },
    mobile: {
      false: "",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: ""
    },
    title: " "
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
}, deviceTampered$i = "   BitBox                .    Shift           ", dialog$j = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
}, error$e = {
  accountAlreadyExists: "  ",
  accountLimitReached: "   .         ",
  aoppCallback: "      {{host}}",
  aoppInvalidRequest: "  ",
  aoppNoAccounts: "   ",
  aoppSigningAborted: "    ",
  aoppUnknown: "   ",
  aoppUnsupportedAsset: "  ",
  aoppUnsupportedFormat: "       ",
  aoppUnsupportedKeystore: "       ",
  aoppVersion: "  "
}, fiat$k = {
  default: " ",
  setDefault: " {{code}}  ",
  title: ""
}, footer$k = {
  appVersion: " :"
}, generic$e = {
  enabled_false: "",
  enabled_true: ""
}, genericError$i = " .         ", goal$i = {
  buttons: {
    create: "  ",
    restore: "    "
  },
  paragraph: "     :",
  step: {
    1: {
      title: " "
    },
    2: {
      description: "    ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$j = {
  accountDescription: {
    text: '         .    ""         ',
    title: "      "
  },
  accountFiat: {
    text: ".         .      ",
    title: "     "
  },
  accountIncomingBalance: {
    text: "             ",
    title: "   "
  },
  accountInfo: {
    multipleXPubs: {
      text: `   xpub "" :  "Segwit (bech32)  "  "Segwit "  "Taproot" ( ).         {{coinName}}.  BitBoxApp           .        xpub    xpub  .

        (Native Segwit)      xpub "bech32".         "Wrapped Segwit"  "Taproot"         "Wrapped Segwit"  "Taproot" `,
      title: "     xpub"
    },
    privacy: {
      text: `              .  xpub      

  xpub                  .              `,
      title: "     xpub"
    },
    verify: {
      text: "        xpub  .             xpub    .           xpub   .          .",
      title: "     xpub  "
    },
    xpub: {
      text: `   (xpub)          .

              Electrum  Sentinel.           xpub        .

         Taproot xpubs  `,
      title: "    "
    }
  },
  accountRates: {
    text: "       CoinGecko",
    title: "    "
  },
  accountReload: {
    text: "  .     ",
    title: "     "
  },
  accountSendDisabled: {
    text: '   ""      ',
    title: "     {{unit}}"
  },
  accountSummaryAmount: {
    text: `        .        coingecko.com

:     MyEtherWallet     BitBoxApp       `,
    title: "    "
  },
  accountSummaryDescription: {
    text: "       .       ",
    title: "      "
  },
  accountTransactionAttributesBTC: {
    text: ` :   .           .
:          .
:      Segwit    .      Segwit        .                 `,
    title: "     "
  },
  accountTransactionAttributesGeneric: {
    text: `:                   .          .                    .
 :           .
:              .       .`,
    title: "      "
  },
  accountTransactionConfirmation: {
    text: "         ",
    title: "   "
  },
  accountTransactionLabel: {
    text: "         ",
    title: "       "
  },
  accountTransactionTime: {
    text: "    ",
    title: "   "
  },
  accounts: {
    howManyAccounts: {
      text: "        ",
      title: "     "
    },
    howtoAddTokens: {
      text: '     ERC20   Ethereum .        " "     Ethereum         ',
      title: "    "
    },
    moveFunds: {
      text: ".             ",
      title: "     "
    },
    recoverAccounts: {
      text: ".   BitBoxApp           ",
      title: "     "
    },
    whatAreAccounts: {
      text: "      .         ",
      title: "  "
    },
    whyIsThisUseful: {
      text: '         .    "  "          .                   ',
      title: "  "
    }
  },
  appendix: {
    link: " !",
    text: " "
  },
  backups: {
    check: {
      text: '  "   "            .             .            ',
      title: '  "  "'
    },
    encrypt: {
      text: "            ",
      title: "    "
    },
    howOften: {
      text: `        .            microSD           microSD  .
         .                  `,
      title: "      "
    },
    whatIsABackup: {
      text: "        microSD.       ",
      title: "   "
    }
  },
  backupsBB02: {
    check: {
      text: '  "   "            ',
      title: '  "  "'
    },
    encrypt: {
      text: '.     microSD            .                   " "',
      title: "    "
    },
    whatIsABackup: {
      text: "        microSD",
      title: "   "
    }
  },
  bitbox: {
    "2FA": {
      text: `    (2FA)              .                      BitBox     .                   

             2FA.       microSD    .        BitBox    `,
      title: "    (2FA)"
    },
    disable2FA: {
      text: '   (2FA)      BitBox          .        microSD          .    "  ".        "   ".            ""         ',
      title: "     (2FA)"
    },
    ejectBitbox: {
      text: "  BitBox        ",
      title: "   BitBox"
    },
    ejectSD: {
      text: "   microSD  BitBox            ",
      title: "    microSD"
    },
    hiddenWallet: {
      text: "                    .                 ",
      title: "   "
    },
    legacyHiddenWallet: {
      text: "      (     BitBox       2FA)     Bitbox         ",
      title: "      "
    },
    pairing: {
      text: "         iOS  Android                  .         ",
      title: "    "
    }
  },
  cointracking: {
    text: '   ""        CSV.          BitBox CSV             CoinTracking   ',
    title: "    CoinTracking"
  },
  device: {
    attestation: {
      link: {
        text: "      "
      },
      text: "  BitBoxApp      BitBox02      .       ",
      title: "     "
    },
    name: {
      text: "     .             .                   ",
      title: "    BitBox02 "
    },
    "secure-chip": {
      link: {
        text: "    "
      },
      text: "      .    ATECC608B       ",
      title: "    "
    }
  },
  receive: {
    address: {
      text: "       .        ",
      title: "  "
    },
    addressChange: {
      text: "              20        ",
      title: "  "
    },
    addressFormats: {
      text: "       Native Segwit.                      .           Taproot ( )                .            Native Segwit ( )        Segwit               .",
      title: '     "  "'
    },
    howVerify: {
      text: `   BitBox01     BitBox          ().          .
   BitBox02             `,
      title: "     "
    },
    plugout: {
      text: "       BitBox        BitBox   .      BitBox  ",
      title: "     BitBox     "
    },
    why20: {
      text: '          (   )         .                  .            20     .   " "  20         .   20     ',
      title: "  20  "
    },
    whyMany: {
      text: "           .               .      20    .      .        .",
      title: "    "
    },
    whyVerify: {
      text: "            .                    .   BitBox01                        .   BitBox02         BitBox02 ",
      title: "      "
    }
  },
  send: {
    change: {
      text: "     Taproot    Taproot UTXO   .        Coin Control      Taproot       Taproot UTXO   UTXOs .           Segwit .",
      title: "    "
    },
    fee: {
      text: `       .             Bitcoin Core     .          .
 :   24  ( 4      )
:   12  (     30  )
:   6  (      15  )
:    ( 20     5  )
(       (2.5   )           )`,
      title: "   "
    },
    plugout: {
      text: "          BitBox   .      BitBox  ",
      title: "    BitBox     "
    },
    priority: {
      text: "             ",
      title: "   "
    },
    revert: {
      text: `    (   )       .    (   )    !
         (   )        `,
      title: "     (  )"
    },
    whyFee: {
      text: `     .          .
    .             (      )              ( ).    ( )            `,
      title: "    "
    }
  },
  "settings-electrum": {
    connection: {
      text: `             (     wifi   )       .
         Electrum    TLS  .
             Tor   .     TLS   .`,
      title: "      TCP  TLS  Tor"
    },
    instructions: {
      link: {
        text: "    "
      },
      text: "       :",
      title: "    BitBox     "
    },
    options: {
      text: `                Bitcoin Core    .
      BitBoxApp          Electrum           .
   Electrs  Electrum Personal Server (EPS)  Bitcoin Wallet Tracker (BTW).`,
      title: "     "
    },
    tor: {
      text: ` Tor  "The Onion Router"                  Bitcoin.
        Tor     Tor         Tor Proxy   BitBoxApp.
        Tor:
1.    Tor:    Tor   .    BitBoxApp   Tor       9150   Tor Proxy .
2.  Tor    :   Tor daemon      .   BitBoxApp        9050   Tor Proxy.`,
      title: "  Tor  Tor proxy      "
    },
    what: {
      text: "              Shift",
      title: " "
    },
    why: {
      text: `               .
      Bitcoin      BitBox                   .
                      .`,
      title: "      "
    }
  },
  settings: {
    sats: {
      text: " ('sat' )     .        (0.00000001 BTC).        ",
      title: "  "
    },
    servers: {
      text: `     Shift Crypto            .
       CoinGecko.                  .
:   Ethereum   ERC20       Etherscan.io.`,
      title: "     "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  trackingModePortfolioChart: {
    text: "        .         ",
    title: "       "
  },
  unlock: {
    forgotDevicePassword: {
      text: "             ",
      title: "      "
    },
    reset: {
      text: "     15 .        ",
      title: "    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `       .     .            .

BitBox01     .    BitBox     BitBox01  `,
      title: "     BitBox01  "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox      :",
      title: "    "
    },
    internet: {
      text: "            ",
      title: "     "
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "     BitBox         ",
      title: "  .   "
    },
    useWithoutDevice: {
      text: "      ",
      title: "     "
    },
    welcome: {
      text: "       Shift Crypto  .       .       ",
      title: "    BitBoxApp!"
    }
  }
}, headerssync$i = {
  blocksSynced: "{{blocks}}     "
}, hiddenWallet$i = {
  info1HTML: "          <strong></strong>    +    ",
  info2HTML: "            .          <strong></strong>      ",
  passwordLabel: "    ",
  passwordPlaceholder: "      ",
  pinLabel: "    ",
  pinRepeatLabel: "     ",
  pinRepeatPlaceholder: "      ",
  success: "    .   BitBox  "
}, initialize$i = {
  create: "   ",
  creating: "     ...",
  error: {
    e102: "       4   "
  },
  info: {
    description1: "   .      BitBox  ",
    description2: "    .       ",
    description3: "               ",
    subtitle: "     ",
    title: "  "
  },
  input: {
    label: "  ",
    labelRepeat: "   ",
    placeholderRepeat: "    "
  }
}, invalidFormat$i = "  ", language$j = {
  title: " "
}, legacyhiddenwallet$i = {
  disable: "     ",
  enable: "     ",
  successDisable: "     ",
  successEnable: "    .   BitBox          "
}, loading$i = " ", manageAccounts$c = {
  editAccount: "",
  editAccountNameTitle: "  ",
  noAccounts: "    ",
  settings: {
    hideTokens: " ",
    showTokens: "  ({{activeTokenCount}})"
  },
  settingsButtonDescription: "    ",
  title: " "
}, mobile$d = {
  usingMobileDataWarning: "   :                   .    Wi-Fi      .          "
}, note$e = {
  input: {
    description: "()",
    placeholder: " "
  },
  title: ""
}, notification$i = {
  newTxs_one: "  : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
}, pairing$i = {
  aborted: {
    text: "      ",
    title: " "
  },
  button: "   ",
  confirm: "      BitBox              ",
  connectOnly: {
    button: "   ",
    title: '             "    "'
  },
  error: {
    text: "  .    ",
    title: ""
  },
  pullFailed: {
    text: "         .          ",
    title: " "
  },
  reconnectOnly: {
    button: "    "
  },
  scanningFailed: {
    text: "       .   ",
    title: " "
  },
  start: {
    hideAppQRCode: "    QR",
    revealAppQRCode: "    QR",
    step1: "            QR  Apple App Store  Google Play Store      ",
    step2: '              "Digital Bitbox 2FA"      iOS  Android:'
  },
  started: {
    text: "        ",
    title: ""
  },
  success: {
    text: "     ()  BitBox     !",
    title: ""
  },
  timeout: {
    text: "   ()  .            ",
    title: " "
  },
  title: "  "
}, passphrase$c = {
  considerations: {
    button: "  ",
    message: `           ( microSD  24 ).                   .

       <strong>    +   </strong>             BitBox02.                 .

              .                 .`,
    title: "  "
  },
  disable: "  ",
  disableInfo: {
    button: "",
    message: `                 BitBox02.      .

                      BitBox02     .

                           BitBox02.

<strong>:</strong>            .`
  },
  enable: "  ",
  error: {
    e104: "     "
  },
  how: {
    button: " ",
    message: `         .          .   <strong>       </strong>.             .             .

  BitBox02       .          .

          .         .`,
    title: " "
  },
  intro: {
    message: `        .
   `,
    title: "  "
  },
  progressDisable: {
    message: "      <strong> </strong>   ",
    title: "   "
  },
  progressEnable: {
    message: "      <strong></strong>   ",
    title: "   "
  },
  successDisabled: {
    message: `<strong>  </strong>   !
       .`,
    messageEnd: "   BitBox02 ",
    title: "    "
  },
  successEnabled: {
    message: `<strong>   </strong>   !

       .`,
    messageEnd: "   BitBox02   ",
    tips: "",
    tipsList: [
      "          .    BitBox02         .          ",
      "                          .      "
    ],
    title: "   "
  },
  summary: {
    button: "  ",
    title: "",
    understand: "        ",
    understandList: [
      "        ",
      "        ",
      "   <strong>     </strong>",
      "          "
    ]
  },
  what: {
    button: "    ",
    message: `  ()           .       BitBox02        microSD  24 .                .

    <strong> </strong>    ( ).               +   ( ).       :           .        +   .

      BIP39            `,
    title: "   "
  },
  why: {
    button: "   ",
    message: ` BitBox02           ( microSD  24 )     .      !

                   <strong>     </strong>.                         .

                 " "    .`,
    title: "   "
  }
}, password$i = {
  show: " {{label}}",
  warning: {
    caps: ":   caps lock ()",
    paste: '    " {{label}}"'
  }
}, random$j = {
  button: "  ",
  description: " BitBox     {{bits}}- :"
}, receive$k = {
  changeScriptType: "  ",
  label: "",
  onlyThisCoin: {
    description: "       .          ",
    warning: "    {{coinName}}    "
  },
  scriptType: {
    p2tr: "Taproot ( )",
    p2wpkh: "Native Segwit ()",
    "p2wpkh-p2sh": " Segwit  ( )"
  },
  showFull: "      ",
  taprootWarning: ": Taproot             .        Taproot       .            Taproot",
  title: " {{accountName}}",
  verify: "    ",
  verifyBitBox01: "      ",
  verifyBitBox02: "    BitBox02",
  verifyInstruction: "          ",
  warning: {
    secureOutput: '  BitBox       .   " "   '
  }
}, reset$i = {
  description: "      .    !",
  notReset: "    ",
  title: "   ",
  understand: "        ",
  understandBB02: "   "
}, securityInformation$i = {
  create: {
    description1: "                   ",
    description2: "      ",
    description3: "  <strong>  </strong>    BitBox     ",
    description4: "  <strong>  </strong>   .       ",
    description5: "            microSD .          <strong>  </strong>.",
    title: " "
  },
  restore: {
    description1: "    microSD     ",
    description2: "         ",
    description3: "       .       .             ",
    title: " "
  }
}, seed$i = {
  agreements: {
    "funds-access": "            ",
    "password-change": "      ",
    "password-required": "        "
  },
  create: " ",
  creating: " ",
  description: "  :",
  error: {
    e102: "      4   ",
    e200: "    microSD  BitBox            "
  },
  info: {
    button: "     ",
    description1: "  microSD  BitBox",
    description2: '       "    "',
    description3: "   microSD             BitBox  ",
    description4: "           ",
    title: "  "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "   "
  },
  walletName: {
    label: " "
  }
}, seedRestore$i = {
  error: {
    e200: "         microSD"
  },
  info: {
    description1: '  microSD  BitBox    ""',
    description2: '      ""',
    description3: "   ",
    description4: "             ",
    title: "     "
  }
}, send$k = {
  abort: "  ",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: " ",
  coincontrol: {
    address: "",
    outpoint: " ",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    erc20InsufficientGasFunds: "           ERC20 .           ",
    feeTooLow: "  ",
    feesNotAvailable: "   ",
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: "  ",
    invalidData: "  "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: " "
  },
  feeTarget: {
    customLabel: " ",
    customLabel_eth: "  ",
    description: {
      economy: "4  (24 )",
      economy_eth: "30   ",
      economy_ltc: "  (24 )",
      high: "20  ()",
      high_eth: "30   ",
      high_ltc: "5  ()",
      low: " (12 )",
      low_eth: "5   ",
      low_ltc: "30  (12 )",
      normal: "1  (6 )",
      normal_eth: "  ",
      normal_ltc: "15  (6 )"
    },
    estimate: "  :",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "   ..."
  },
  maximum: "  ",
  maximumSelectedCoins: "  ",
  priority: "",
  scanQR: "    QR",
  signprogress: {
    description: "      .        {{steps}} ",
    label: ""
  },
  success: "   ",
  title: " {{accountName}}",
  toggleCoinControl: "     coin control",
  transactionDetails: " "
}, settings$j = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: "     {{host}}",
    checking: "",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "    ",
    resetConfirm: "       ",
    servers: "",
    step1: "1",
    "step1-text": "   ",
    step2: "2",
    "step2-text": "     .            ",
    "step2-text-tcp": "         TLS",
    step3: "3",
    "step3-text": "    ",
    step4: "4",
    "step4-text": "  .            ",
    "title-btc": " Electrum   ",
    "title-ltc": " Electrum   ",
    "title-tbtc": " Electrum     ",
    "title-tltc": " Electrum     "
  },
  expert: {
    coinControl: "     coin control",
    electrum: {
      title: "    "
    },
    fee: "   ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: " tor proxy",
    useSats: "    Satoshi"
  },
  header: {
    home: " "
  },
  info: {
    "out-of-date": "  ",
    title: "",
    "up-to-date": "   ",
    version: " "
  },
  restart: "    BitBox    ",
  services: {
    title: ""
  },
  success: "  BitBox      ",
  title: ""
}, setup$i = " ", sidebar$j = {
  buy: "  ",
  device: " ",
  leave: "",
  settings: ""
}, success$p = {
  create: {
    info1: "        microSD.         ",
    info2: "        BitBox",
    info3: "              ",
    summary: "    ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "       ",
    title: ""
  }
}, transaction$j = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "  ()",
    fiatAmount: "   ",
    fiatAtTime: "    ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "   ",
  fee: "",
  fiatHistorical: "",
  gas: " ",
  note: {
    edit: " ",
    save: " "
  },
  pending: "  ",
  size: "",
  status: {
    complete: "",
    failed: " ",
    pending: " "
  },
  tx: {
    received: "  ",
    sent: "  "
  },
  vsize: " ",
  weight: ""
}, transactions$i = {
  placeholder: "    "
}, unknownError$i = "   : {{errorMessage}}", unlock$i = {
  description: "      ",
  error: {
    e109_normal: "   . {{remainingAttempts}}      ",
    e109_touch: "$t(unlock.error.e109_normal)        ",
    e113: "                  4 "
  },
  input: {
    label: "  ",
    placeholder: "      "
  },
  unlocking: "   ..."
}, upgradeFirmware$j = {
  button: "  ",
  description: "       {{currentVersion}}  {{newVersion}}",
  label: "  BitBox   ",
  locked: "  {{currentVersion}}  {{newVersion}}     ",
  title: "  ",
  unlocked: "   .  :",
  unlocked1: "   Bitbox",
  unlocked2: " LED   BitBox  ",
  unlocked3: "       LED"
}, warning$o = {
  receivePairing: '  BitBox     .   " "   ',
  sdcard: "  microSD    BitBox        ",
  sendPairing: "   BitBox        .       "
}, welcome$i = {
  getStarted: "      BitBox02",
  insertBitBox02: "        BitBox02 ",
  insertDevice: "   ",
  title: ""
}, appTranslationsAR = {
  account: account$i,
  accountInfo: accountInfo$i,
  accountSummary: accountSummary$i,
  addAccount: addAccount$j,
  aopp: aopp$c,
  app: app$i,
  backup: backup$i,
  bb02Bootloader: bb02Bootloader$i,
  bitbox: bitbox$i,
  bitbox02Interact: bitbox02Interact$i,
  bitbox02Settings: bitbox02Settings$i,
  bitbox02Wizard: bitbox02Wizard$i,
  blink: blink$i,
  bootloader: bootloader$i,
  button: button$m,
  buy: buy$e,
  changePin: changePin$i,
  chart: chart$e,
  checkSDcard: checkSDcard$i,
  clickHere: clickHere$i,
  confirm: confirm$k,
  confirmOnDevice: confirmOnDevice$i,
  device: device$i,
  deviceLock: deviceLock$i,
  deviceSettings: deviceSettings$i,
  deviceTampered: deviceTampered$i,
  dialog: dialog$j,
  error: error$e,
  fiat: fiat$k,
  footer: footer$k,
  generic: generic$e,
  genericError: genericError$i,
  goal: goal$i,
  guide: guide$j,
  headerssync: headerssync$i,
  hiddenWallet: hiddenWallet$i,
  initialize: initialize$i,
  invalidFormat: invalidFormat$i,
  language: language$j,
  legacyhiddenwallet: legacyhiddenwallet$i,
  loading: loading$i,
  manageAccounts: manageAccounts$c,
  mobile: mobile$d,
  note: note$e,
  notification: notification$i,
  pairing: pairing$i,
  passphrase: passphrase$c,
  password: password$i,
  random: random$j,
  receive: receive$k,
  reset: reset$i,
  securityInformation: securityInformation$i,
  seed: seed$i,
  seedRestore: seedRestore$i,
  send: send$k,
  settings: settings$j,
  setup: setup$i,
  sidebar: sidebar$j,
  success: success$p,
  transaction: transaction$j,
  transactions: transactions$i,
  unknownError: unknownError$i,
  unlock: unlock$i,
  upgradeFirmware: upgradeFirmware$j,
  warning: warning$o,
  welcome: welcome$i
}, account$h = {
  disconnect: "Ztrta spojen. Pokus o optovn pipojen...",
  export: "Export",
  exportTransactions: "Export transakc do sloky ke staen jako soubor CSV",
  fatalError: "Dolo k neoekvan chyb.",
  incoming: "Pichzejc",
  initializing: "Zskvn informac z blockchainu...",
  maybeProxyError: "Tor proxy aktivn. Ujistte se, e proxy server Tor b sprvn, nebo nastaven proxy serveru deaktivujte.",
  reconnecting: "Ztrta spojen. Pokus o optovn pipojen...",
  syncedAddressesCount: "Naskenovno {{count}} adres"
}, accountInfo$h = {
  address: "Adresa",
  buyCTA: {
    buy: "Koupit  {{unit}}",
    buyCrypto: "Koupit Krypto",
    information: {
      looksEmpty: "Zd se, e tato penenka je przdn.",
      start: "Zante vkladem do penenky, nebo nkupem pmo v BitBoxApp."
    }
  },
  extendedPublicKey: "Veejn kl",
  label: "Detaily tu",
  scriptType: "Typ tu",
  title: "Detaily tu",
  verify: "Ovte na zazen",
  xpubTypeChangeBtn: {
    p2pkh: "Zobrazit legacy P2PKH veejn kl",
    p2tr: "Zobrazit Taproot",
    p2wpkh: "Zobrazit nativn Segwit",
    "p2wpkh-p2sh": "Zobrazit star Segwit veejn kl"
  },
  xpubTypeInfo: "Aktuln se zobrazuje {{scriptType}} veejn kl ({{current}} z {{numberOfXPubs}})"
}, accountSummary$h = {
  availableBalance: "Dostupn zstatek",
  balance: "Zstatek",
  exportSummary: "Exportovat pehled t do sloky ke staen jako soubor CSV",
  fiatBalance: "Fiat zstatek",
  name: "Nzev tu",
  noAccount: "dn ty k zobrazen.",
  subtotalWithCoinName: "Celkem ({{coinName}})",
  title: "Moje portfolio",
  total: "Celkem",
  transactionHistory: "Transakn historie"
}, addAccount$i = {
  chooseName: {
    nextButton: "Pidat et",
    step: "Pojmenujte et",
    title: "Pojmenujte svj et"
  },
  selectCoin: {
    nextButton: "Dal",
    step: "Vybrat kryptomnu",
    title: "Vybrat kryptomnu"
  },
  success: {
    addAnotherAccount: "Pidat dal et",
    message: "<strong>{{accountName}}</strong> byl nyn pidn k vaim tm.",
    nextButton: "Hotovo",
    step: "Dokoneno",
    title: "et pidn"
  },
  title: "Pidat et"
}, aopp$b = {
  addressRequest: "{{host}} poaduje pijmac adresu.",
  addressRequestWithLogo: "poaduje pijmac adresu.",
  banner: "Probh dost o adresu.",
  errorTitle: "Chyba pi poadavku na adresu ",
  labelAddress: "Adresa",
  labelMessage: "Zprva",
  reverifyInfoText: "Ovit adresu",
  signing: "Chcete-li pokraovat, podepite zprvu na svm BitBoxu",
  success: {
    message: "Pokraovat na {{host}}",
    title: "Adresa byla spn odeslna"
  },
  syncing: "Synchronizace tu, vykejte prosm.",
  title: "Poadavek na adresu"
}, app$h = {
  upgrade: "K dispozici je nov verze tto aplikace! Aktualizuje prosm z {{current}} na {{version}}."
}, auth$a = {
  authButton: "Ovit",
  title: "Chcete-li pokraovat, provete oven"
}, backup$h = {
  check: {
    checking: "Kontrola zlohy...",
    confirmTitle: "Zkontrolovat zlohu",
    notOK: "Zloha NEODPOVD penence.",
    ok: "Zloha odpovd penence.",
    password: {
      label: "Heslo pro obnoven",
      placeholder: "Heslo pro obnoven",
      showLabel: "heslo pro obnoven"
    },
    success: "Zloha byla spn ovena:",
    title: "Zkontrolovat zlohu"
  },
  create: {
    alreadyExists: "Ji mte platnou zlohu. Chcete ji znovu vytvoit?",
    fail: "Vytvoen zlohy SELHALO!",
    info: "Pro oven zadejte heslo pro obnoven aktuln penenky.",
    name: {
      label: "Nzev zlohy",
      placeholder: "Pojmenujte prosm zlohu"
    },
    password: {
      label: "Heslo pro obnoven",
      placeholder: "Zadejte prosm heslo pro obnoven"
    },
    title: "Vytvoit zlohu",
    verificationFailed: 'Heslo pro obnoven se NESHODUJE s aktuln penenkou. Zloha byla vytvoena. Pro optovn oven hesla pro obnoven pouijte funkci "Zkontrolovat zlohu".'
  },
  description: "Vyberte <strong>soubor zlohy penenky</strong>",
  insert: "Pro sprvu zloh prosm vlote microSD kartu.",
  insertButton: "Vloil jsem microSD kartu.",
  list: "Vae zlohy na microSD kart",
  noBackups: "Na tto microSD kart nejsou dn zlohy.",
  restore: {
    confirmTitle: "Obnovit ze zlohy",
    error: {
      e200: "Karta microSD nenalezena",
      general: "Chyba pi obnov ze zlohy"
    },
    password: {
      label: "Heslo pro obnoven nebo skryt heslo pro obnoven",
      placeholder: "Heslo pro obnoven",
      repeatPlaceholder: "Zopakujte heslo pro obnoven",
      showLabel: "Heslo pro obnoven"
    },
    restoring: "Obnova ze zlohy...",
    selectedBackup: "<strong>{{backupName}}</strong> vytvoena {{createdDateTime}} bude obnovena.",
    title: "Obnovit",
    understand: "Rozumm, e nesprvn heslo pro obnoven vytvo jinou penenku."
  },
  showMnemonic: {
    description: `Zobraz se vm slova pro obnoven - obnovovac seed, ten tvo zlohu va penenky. Napite si je na papr.

<strong>Neukldejte je digitln ani je nefote.</strong>

<strong>Nekejte tato slova nahlas.</strong>

<strong>Tato zloha nen chrnna heslem.</strong>

Pot budete vyzvni k potvrzen kadho slova.
`,
    title: "Zobrazit slova pro obnoven",
    warning: "<strong> Nikdy nikomu nesdlujte sv slova pro obnoven.</strong> Vae slova pro obnoven poskytuj pln pstup k va penence. Pokud vs nkdo d o vae slova pro obnoven, jedn se o podvodnka, nesdlejte je!"
  },
  title: "Spravovat zlohy"
}, bb02Bootloader$h = {
  abort: "Neaktualizovat - zpt",
  abort_noUpgrade: "Zpt",
  advanced: {
    label: "Rozen nastaven",
    toggleShowFirmwareHash: "Zobrazit hash firmwaru pi kadm sputn"
  },
  flipscreen: "Oto obrazovku",
  orientation: "patn orientace zazen?",
  success: "Aktualizace spn! Pokraovn za {{rebootSeconds}} sekund...",
  success_install: "Instalace probhla spn! Pokraovn za {{rebootSeconds}} sekund..."
}, bitbox$h = {
  error: {
    e10000: "Heslo pro aktuln zazen nen sprvn.",
    e10001: "Nepodailo se nahradit heslo zazen",
    e102: "Heslo mus obsahovat alespo 4 znaky.",
    e112: "Skryt heslo zazen neme bt stejn jako heslo hlavnho zazen."
  }
}, bitbox02Interact$h = {
  confirmDate: "Potvrte dnen datum na svm BitBox02",
  confirmDateText: "Toto datum se pouije pro vytvoen zlohy.",
  confirmName: "Potvrte nzev na BitBox02",
  confirmWords: "Zapite si {{amount}} slov pro obnoven z vaeho BitBox02",
  confirmWordsText: "Pot vs BitBox02 pod o potvrzen kadho slova, aby se ovilo, e zloha je sprvn.",
  followInstructions: "Postupujte podle pokyn na vaem BitBox02.",
  followInstructionsMnemonic: "Postupujte dle pokyn na Vaem BitBox02  zadejte slova pro obnoven z va zlohy a obnovte penenku.",
  followInstructionsMnemonicTitle: "Obnovit ze slov pro obnoven"
}, bitbox02Settings$h = {
  deviceName: {
    current: "Aktuln nzev zazen",
    error: "Nzev zazen se nepodailo nastavit",
    error_104: "Potvrzen nzvu zazen bylo na zazen zrueno.",
    input: "Nzev BitBox02",
    placeholder: "Nov nzev zazen",
    title: "Nastavit nzev pro BitBox02"
  },
  gotoStartupSettings: {
    description: "Tm se zazen BitBox02 restartuje a vstoup do nastaven pi sputn.",
    title: "Pejt do nastaven pi sputn"
  }
}, bitbox02Wizard$h = {
  advanced: {
    button: "Pokroil nastaven",
    outOfDate: "Firmware je pro tuto funkci zastaral",
    seed12WordInfo: "Upozorujeme, e poet slov nelze po vytvoen penenky zmnit.",
    seed12WordLabel: "Vytvoit 12slovn namsto 24slovnho seed",
    seed12WordText: "Ve vchozm nastaven pouv BitBox02 seed s 24 slovy. Ob dlky seed jsou v praxi bezpen proti brute force toku. Nkte uivatel mohou msto toho upednostnit 12slovn seed.",
    skipSDCardLabel: "Peskote zlohovn na microSD kartu a msto toho si zapite slova pro obnoven.",
    skipSDCardText: "Po nastaven mte vdy monost vytvoit zlohu karty microSD nebo zapsat slova pro obnoven. To lze provst z nastaven.",
    title: "Pokroil monosti zlohovn"
  },
  attestationFailed: "Kontrola originality selhala, co mohlo bt zpsobeno restartovnm aplikace v dob, kdy zazen ekalo na vstup uivatele. Znovu se pipojte a zkuste to znovu. Pokud tento problm petrvv, obrate se prosm na support@bitbox.swiss.",
  backup: {
    point1: "Vyberte zlohu na microSD kart",
    point2: "Nastavit heslo pro zazen",
    restoreText: "Ok, obnovme ze zlohy!",
    text1: "Skvl, vae heslo pro BitBox02 je nyn nastaveno a penenka vytvoena. Nyn je as vytvoit prvn zlohu. Ujistte se, e je vae microSD karta vloena do vaeho BitBox02 a pokraujte.",
    text2: "Vytvote zlohu podle pokyn na obrazovce zazen.",
    text3: "Po vytvoen zlohy vyjmte microSD kartu a ulote ji na <strong>bezpen msto</strong>. Obsah microSD karty nen chrnn heslem. Nikdy jej nevkldejte do jinho zazen ne do vaeho BitBox02.",
    userConfirmation1: "Zlohu bych ml uloit na bezpenm mst.",
    userConfirmation2: "Moje zloha nen chrnna heslem. Kdokoli, kdo k n m pstup, m pstup k m penence.",
    userConfirmation3: "Pokud ztratm nebo pokodm svj BitBox02, jedin zpsob, jak zskat zpt sv prostedky, je obnovit penenku ze zlohy.",
    userConfirmation4: "Pokud ztratm nebo pokodm zlohu i BitBox02, pijdu o sv prostedky.",
    userConfirmation5: "MicroSD kartu s mou zlohou bych neml vkldat do potae, telefonu, tiskrny nebo jinho zazen ne BitBox02.",
    userConfirmation5mnemonic: "Neml bych vkldat slova pro obnoven do potae, telefonu, tiskrny nebo jinho zazen, ne je BitBox02."
  },
  create: {
    button: "Pojmenujte zazen a pokraujte",
    info: "Zde jsou zkladn kroky, kter je teba udlat pro nastaven vaeho BitBoxu: ",
    inputTitle: "Nzev penenky",
    point1: "Pojmenujte sv zazen",
    point2: "Nastavte heslo pro sv zazen",
    point3: "Vytvoit zlohu",
    text: "Ok, pojme vytvoit novou penenku!"
  },
  createBackupAborted: "Vytven zlohy bylo zrueno.",
  createBackupFailed: "Vytvoen zlohy se nezdailo, zkuste to znovu.",
  initialize: {
    passwordText: "Nyn nastavme heslo pro vae zazen. K zadn a vbru hesla pouijte ovldac prvky na BitBoxu.",
    passwordTitle: "Nastavte heslo pro svj BitBox",
    text: "V BitBox02 byl spn sprovn! Nyn inicializujeme vae zazen. Zante vbrem vytvoit novou penenku nebo obnovit penenku ze zlohy. <strong>Ujistte se, e je v Bitboxu vloena microSD karta</strong>",
    tip: "Doporuujeme, abyste pokraovali na bezpenm mst.",
    title: "Inicializujte svj BitBox"
  },
  insertSDCard: "<strong>Ujistte se, e je ve vaem BitBoxu vloena microSD karta.</strong>",
  noPasswordMatch: "Hesla se neshoduj, zkuste to prosm znovu.",
  pairing: {
    failed: "Sprovn nepotvrzeno. Znovu pipojte svj BitBox02.",
    paired: "Na svm zazen jste potvrdili nsledujc kd. Prosm pokraujte.",
    title: "Ovte provac kd",
    unpaired: "Byl zjitn nesprovan BitBox02. Prosm ovte, e provac kd odpovd tomu, co je zobrazeno na vaem BitBoxu."
  },
  restoreFromMnemonic: {
    e104: "Obnoven ze slov pro obnoven bylo zrueno.",
    failed: "Obnoven ze slov pro obnoven se nezdailo, zkuste to prosm znovu."
  },
  stepBackup: {
    beforeProceed: "Ne budete pokraovat, pette si tato dleit bezpenostn opaten:",
    createBackup: "Nyn vytvote zlohu na microSD kart.",
    createBackupMnemonic: "Nyn si zapete slova pro obnoven."
  },
  stepBackupSuccess: {
    fundsSafe: "Aby byly vae prostedky v bezpe, mjte na pamti nsledujc:",
    title: "Zloha obnovena!"
  },
  stepConnected: {
    unlock: "Pro odemknut zadejte heslo."
  },
  stepCreate: {
    description: "Tento nzev se pouv jako nzev zazen a pro zlohu.",
    nameLabel: "Nzev BitBox02",
    namePlaceholder: "Mj BitBox02",
    title: "Vyberte nzev pro BitBox02",
    toastMicroSD: "Vlote prosm svou microSD kartu do vaeho BitBox02, kter bude pouita k uloen zlohy penenky."
  },
  stepCreateSuccess: {
    removeMicroSD: "Vyjmte microSD kartu z vaeho BitBox02 a ulote ji na bezpen msto.",
    storeMnemonic: "Ulote sv slova pro obnoven na bezpenm mst",
    success: "Vae zloha byla spn vytvoena."
  },
  stepInsertSD: {
    insertSDCard: "Chcete-li pokraovat, vlote do svho BitBox02 microSD kartu.",
    insertSDcardTitle: "Vlote microSD kartu"
  },
  stepPassword: {
    e104: "Nastaven hesla bylo zrueno.",
    title: "Nastavte heslo pro v Bitbox02",
    useControls: "K nastaven hesla pouijte ovldac prvky na vaem BitBox02."
  },
  stepUninitialized: {
    create: "Chci nastavit nov BitBox02.",
    restore: "Chci obnovit svou penenku ze zlohy.",
    restoreMicroSD: "Obnovit z microSD karty",
    restoreMnemonic: "Obnovit ze slov pro obnoven",
    title: "Nastavte svj BitBox02"
  },
  success: {
    text: `Hur! V BitBox02 je nyn pipraven k pouit.

Chcete-li zskat dal informace o tom, jak pouvat BitBoxApp, pouijte prvodce v aplikaci kliknutm na otaznk v pravm hornm rohu.`,
    title: "Jste pipraveni!"
  }
}, blink$h = {
  button: "Blik"
}, bootloader$h = {
  button: "Nyn aktualizujte firmware",
  button_install: "Nyn nainstalujte firmware",
  progress: "Aktualizace: {{progress}}%",
  progress_install: "Instalace: {{progress}}%",
  success: "Aktualizace probhla spn! Zazen znovu zapojte. Tentokrt se tlatka nedotkejte."
}, button$l = {
  abort: "Zruit",
  back: "Zpt",
  buy: "Koupit",
  changepin: "Zmit heslo zazen",
  check: "Zkontrolovat zlohu",
  continue: "Pokraovat",
  copy: "Koprovat",
  create: "Vytvoit",
  dismiss: "Odmtnout",
  done: "Hotovo",
  download: "Sthnout",
  hiddenwallet: "Vytvoit skrytou penenku",
  next: "Dal",
  ok: "OK",
  previous: "Pedchoz",
  receive: "Pijmout",
  restore: "Obnovit",
  select: "Vybrat",
  send: "Poslat",
  unlock: "Odemknout",
  update: "Aktualizovat",
  upgrade: "Aktualizovat"
}, buy$d = {
  exchange: {
    bankTransfer: "Bankovn pevod",
    bestDeal: "Nejvhodnj nabdka",
    creditCard: "Kreditn karta",
    fast: "Rychle",
    fee: "poplatek",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankovn pevod: {{fee}}%",
          creditDebitCard: "Kreditn / Debetn karta: {{fee}}%",
          learnMore: "Zjistte vce o Moonpay",
          title: "Poplatky"
        },
        fullCurrenciesList: "Kompletn seznam mn naleznete zde",
        payment: {
          asteriskText: "* Nen k dispozici pro rezidenty USA",
          bankTransfer: "Bankovn pevod*",
          bankTransferDetails: {
            pix: "PIX (transakce BR pouze v Brazlii)",
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemch SEPA)",
            uk: "Faster Payments - Spojen krlovstv (transakce v GBP pouze ve Spojenm krlovstv)"
          },
          creditDebitCard: "Kreditn / Debetn karta",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa a Maestro"
          },
          learnMore: "Dal podrobnosti o zpsobech platby",
          title: "Platebn metody"
        },
        supportedCurrencies: "Podpora vech hlavnch fiat mn: USD, EUR, CHF a dal."
      },
      pocket: {
        fees: {
          info: "Bankovn pevod: {{fee}}%",
          title: "Poplatky"
        },
        learnMore: "Zjistte vce o slub Pocket",
        payment: {
          bankTransfer: "Bankovn pevod",
          bankTransferDetails: {
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemch SEPA)",
            sic: "Swiss Interbank Clearing (transakce v CHF pouze v CH/LI)",
            uk: "Faster Payments - Spojen krlovstv (transakce v GBP pouze ve Spojenm krlovstv)"
          },
          bankTransferReccuring: "Jak nastavit opakovan nkupy pomoc trvalho pkazu?",
          title: "Platebn metody"
        },
        supportedCurrencies: "Podpora evropskch mn: EUR, GBP a CHF.",
        verification: {
          info: "Vyaduje oven identity pouze pokud jsou pekroeny denn a ron limity.",
          link: "Aktuln limity zde",
          title: "Oven identity"
        }
      },
      region: {
        title: "Vyberte oblast, ve kter je v bankovn et registrovn, a zjistte, kter monosti mte k dispozici."
      }
    },
    noExchanges: "Je nm lto, ale v tto oblasti nejsou k dispozici dn burzy.",
    region: "Oblast",
    selectRegion: "Nen uvedeno",
    title: "Koupit {{name}}"
  },
  info: {
    continue: "Souhlasm, pokraovat",
    crypto: "krypto",
    disclaimer: {
      intro: [
        "Spolupracujeme s MoonPay, abychom vm nabdli bezproblmov zpsob nkupu {{name}} pmo v BitBoxApp. Je to jen pr kliknut.",
        "MoonPay je platforma, kter usnaduje a urychluje nkup {{name}} ve vce ne 160 zemch."
      ],
      payment: {
        details: "{{name}} si mete okamit zakoupit pes MoonPay pomoc nsledujcch platebnch metod. Nkupy kreditn nebo debetn kartou jsou okamit a pohodln, ale dra kvli zvenmu riziku chargebacku. Pro vt stky doporuujeme pout monost bankovnho pevodu. Minimln poplatek je 4 USD/EUR nebo ekvivalentn stka.",
        footnote: "Vezmte prosm na vdom, e smnn kurzy MoonPay se mohou liit od kurz pouvanch v BitBoxApp, co vede k mrn odlinm stkm.",
        table: {
          "1_description": "Nejni poplatky, me trvat a ti pracovn dny",
          "1_method": "Bankovn pevody (SEPA)",
          "2_description": "Vy poplatky, ale rychl a okamit",
          "2_method": "Kreditn a debetn karty",
          description: "Popis",
          fee: "Poplatek",
          method: "Metoda"
        },
        title: "Platebn metody a poplatky"
      },
      privacyPolicy: "Zsady ochrany osobnch daj MoonPay",
      protection: {
        description: "BitBoxApp pi nkupu {{name}} neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. MoonPay potebuje ke sv innosti shromaovat nkter osobn daje. Jejich Zsady ochrany osobnch daj podrobn vysvtluj, jak je s tmito daji nakldno.",
        descriptionGeneric: "BitBoxApp pi nkupu {{name}} neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. Partnersk burzy vak ke svmu fungovn potebuj shromaovat urit informace. Podrobnj informace o tom, jak je s daty nakldno, naleznete v jejich zsadch ochrany osobnch daj.",
        title: "Ochrana dat"
      },
      security: {
        description: "Pi nkupu {{name}} pes MoonPay vyuvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputena BitBoxApp.",
        descriptionGeneric: "Pi nkupu {{name}} prostednictvm partnersk burzy vyuvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputena BitBoxApp.",
        link: "Model bezpenostnch hrozeb",
        title: "Bezpenostn model"
      },
      title: "Vtejte ve vaem obchod pro nkup {{name}}"
    },
    next: "Dal",
    selectLabel: "Vyberte svj et",
    selectPlaceholder: "Vyberte mnu",
    skip: "Znovu nezobrazovat",
    title: "Koupit {{name}}"
  },
  pocket: {
    data: {
      link: "Zsady ochrany osobnch daj Pocket",
      p1: "BitBoxApp pi nkupu bitcoin neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. Pocket potebuje ke svmu fungovn shromaovat nkter osobn daje. Jejich zsady ochrany osobnch daj podrobn vysvtluj, jak se s tmito daji nakld.",
      title: "Ochrana dat"
    },
    kyc: {
      link: "Pette si Pocket FAQ",
      p1: "Pocket se sna omezit KYC na minimum. U nkup do 950 EUR (1000 CHF) denn nejsou vyadovny dn dal dokumenty. Pi nkupech nad tuto stku si budete muset s Pocket domluvit hovor, abyste mohli dokonit potebn proces KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin si mete koupit okamit pomoc sluby Pocket bankovnm pevodem SEPA. Poplatek in 1,5 % a bitcoiny jsou poslny do vaeho BitBoxu ihned pot, co Pocket obdr bankovn pevod (obvykle bhem tho dne).",
      p2: "Upozorujeme, e smnn kurzy v aplikaci Pocket se mohou liit od kurz pouvanch v aplikaci BitBoxApp, co vede k mrn odlinm stkm.",
      title: "Platebn metody a poplatky"
    },
    previousTransactions: "Historie transakc tohoto tu nen przdn. Sdlenm tohoto tu se vechny jeho minul a budouc transakce stanou viditelnmi pro Pocket. Pokraovat?",
    security: {
      link: "Model bezpenostnch hrozeb BitBox02",
      p1: "Pi nkupu bitcoin pes Pocket pouvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputn BitBoxApp. Spolen pracujeme na zven bezpenosti pomoc dvoufaktorovho ovovacho mechanismu, kter ovuje adresu, na kterou pijmte.",
      title: "Bezpenostn model"
    },
    usedAddress: "Adresa {{address}} ji byla pouita, zante prosm znovu s novou adresou.",
    verifyBitBox02: "Zkontrolujte, zda adresa, kterou jste obdreli e-mailem, odpovd adrese zobrazen na vaem Bitboxu. Pokud je to mon, mli byste e-mail otevt na druhm zazen kvli lepmu zabezpeen.",
    welcome: {
      p1: "Spolupracujeme se spolenost Pocket, abychom vm nabdli bezproblmov zpsob nkupu bitcoin pmo v BitBoxApp. Je to jen pr kliknut.",
      p2: "Pocket je vcarsk platforma, kter umouje rychl a snadn nkup bitcoin ve vtin Evropy (kdekoli, kde jsou podporovny bankovn pevody SEPA).",
      p3: "S Pocket mete tak provdt pravideln nkupy prostednictvm trvalch bankovnch pkaz, take mete snadno zprmrovat sv nklady (DCA - dollar-cost averaging).",
      title: "Vtejte ve svm obchod pro nkup bitcoin"
    }
  },
  title: "Koupit {{name}}"
}, changePin$h = {
  newTitle: "Nov heslo zazen",
  oldLabel: "Aktuln heslo zazen"
}, chart$d = {
  dataMissing: "Sbrme historick data... zstate s nmi.",
  dataOldTimestamp: "Aktualizace historickch smnnch kurz. V grafu se nezobrazuj data po {{time}}.",
  dataUpdating: "aktualizace dat...",
  filter: {
    all: "Vechny",
    month: "Msc",
    week: "Tden",
    year: "Rok"
  }
}, checkSDcard$h = "kontrola microSD karty", clickHere$h = "Kliknte zde.", confirm$j = {
  abortInfo: "Klepnte na ",
  abortInfoRedText: "zruit",
  approveInfo: "Podrte 4 a vce sekund ",
  approveInfoGreenText: "potvrdit",
  info: "Pokraujte na svm BitBoxu. ",
  infoWhenPaired: "Nejprve na sprovanm mobilu a pot na vaem BitBoxu"
}, confirmOnDevice$h = "Potvrte na svm zazen.", connectKeystore$a = {
  promptNoName: "Chcete-li pokraovat, pipojte svj BitBox02",
  promptWithName: 'Chcete-li pokraovat, pipojte prosm svj BitBox02 s nzvem "{{name}}" '
}, darkmode$b = {
  toggle: "Tmav reim"
}, device$h = {
  appUpradeRequired: "V BitBox nen kompatibiln s touto aplikac. Sthnte si a nainstalujte nejnovj verzi."
}, deviceLock$h = {
  button: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  condition1: "Mte zlohu?",
  condition2: "Funguje oven mobiln aplikace?",
  condition3: "2FA ZABRN zlohovn a provn s mobiln aplikaci. Pro ukonen 2FA je nutn zazen RESETOVAT!",
  confirm: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  title: "Aktivovat dvoufaktorovou autorizaci (2FA)"
}, deviceSettings$h = {
  backups: {
    manageBackups: {
      description: "Vytvote nebo ovte zlohu na microSD kart."
    },
    showRecoveryWords: {
      description: "Zobrazit a ovit slova pro obnoven."
    },
    title: "Zlohy"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp kontroluje, zda je vae zazen prav."
    },
    deviceName: {
      description: "Zmte nzev zazen."
    },
    rootFingerprint: {
      description: "Otisk je jedinen identifiktor prv pouvan penenky. Me vm pomoci rozliit rzn penenky, pokud pouvte pstupov frze."
    },
    securechip: {
      description: "Model bezpenho ipu."
    },
    title: "Informace o zazen"
  },
  expert: {
    factoryReset: {
      description: "Obnovte zazen do tovrnho nastaven. Tm se smae penenka z vaeho BitBox02!",
      title: "Obnovit do tovrnho nastaven"
    },
    goToStartupSettings: {
      description: "Vstoupit do bootloaderu BitBox02. Zde mete povolit hash firmwaru."
    },
    passphrase: {
      description: "Aktivovat nebo deaktivovat funkci pstupov frze.",
      title: "Pstupov frze"
    }
  },
  firmware: {
    firmwareVersion: "Verze firmwaru",
    newVersion: {
      label: "Dostupn verze"
    },
    title: "Firmware",
    upToDate: "Vae zazen je aktuln",
    upgradeAvailable: "K dispozici je nov aktualizace",
    version: {
      label: "Verze"
    }
  },
  hardware: {
    attestation: {
      false: "Kontrola pravosti se nezdaila",
      label: "Kontrola pravosti",
      true: "V BitBox02 je autentick"
    },
    sdcard: {
      false: "Nen vloena",
      label: "microSD karta",
      true: "Vloena"
    },
    securechip: "Bezpen ip",
    title: "Hardware"
  },
  loading: "Natn informac o zazen",
  pairing: {
    lock: {
      false: "Vypnuto",
      label: "Dvoufaktorov autorizace (2FA)",
      true: "Zapnuto"
    },
    mobile: {
      false: "Zaveno",
      label: "Mobiln aplikace",
      true: "Oteveno"
    },
    status: {
      false: "Nesprovno",
      label: "Stav",
      true: "Sprovno"
    },
    title: "Provn"
  },
  secrets: {
    manageBackups: "Spravovat zlohy",
    title: "Secrets"
  }
}, deviceTampered$h = "Bylo k vaemu BitBoxu dodno heslo pro obnoven? Pokud ano, zastavte proces nastaven a okamit kontaktujte podporu. Spolenost Shift vm nikdy neposkytne hotovou penenku ani vm ned doporuen ohledn hesla.", dialog$i = {
  cancel: "Zruit",
  confirm: "Potvrdit",
  confirmTitle: "Potvrzen"
}, error$d = {
  accountAlreadyExists: "et ji existuje.",
  accountLimitReached: "Nelze pidat et. Maximln poet t pro tuto mnu byl dosaen.",
  aoppCallback: "Pi doruovn adresy na {{host}} dolo k chyb.",
  aoppInvalidRequest: "Neplatn poadavek.",
  aoppNoAccounts: "Nejsou k dispozici dn ty.",
  aoppSigningAborted: "dost o potvrzen vlastnictv adresy zruena.",
  aoppUnknown: "Nastala neznm chyba.",
  aoppUnsupportedAsset: "Toto aktivum nen podporovno.",
  aoppUnsupportedFormat: "Nejsou k dispozici dn ty, kter by podporovaly poadovan formt adresy.",
  aoppUnsupportedKeystore: "Pipojen zazen neme podepisovat zprvy pro toto aktivum.",
  aoppVersion: "Neznm verze.",
  wrongKeystore: "Byla pipojena patn penenka. Ujistte se, e jste vloili sprvn zazen odpovdajc tomuto tu.",
  wrongKeystore2: " Pokud pouvte pstupovou frzi, zkontrolujte, zda jste zadali sprvnou pstupovou frzi pro tento et."
}, fiat$j = {
  default: "vchoz",
  setDefault: "Nastavit {{code}} jako vchoz",
  title: "Mny"
}, footer$j = {
  appVersion: "Verze aplikace:"
}, generic$d = {
  enabled_false: "Vypnuto",
  enabled_true: "Zapnuto"
}, genericError$h = "Dolo k chyb. Pokud zaznamente njak problmy, restartujte prosm aplikaci.", goal$h = {
  buttons: {
    create: "Vytvoit novou penenku",
    restore: "Obnovte penenku ze zlohy"
  },
  paragraph: "Vyberte prosm jednu z nsledujcch monost:",
  step: {
    1: {
      title: "Informace o zabezpeen"
    },
    2: {
      description: "Nastavit heslo zazen",
      title: "Zazen"
    },
    "3-create": {
      description: "Vytvoit novou penenku",
      title: "Penenka"
    },
    "3-restore": {
      description: "ze zlohy",
      title: "Obnovit"
    },
    "4-create": {
      title: "Pehled"
    },
    "4-restore": {
      title: "Pehled"
    }
  }
}, guide$i = {
  accountDescription: {
    text: 'V pehledu tu se zobrazuje disponibiln zstatek a pchoz a odchoz transakce. Vce informac o jednotlivch typech t najdete v naem prvodci v sti "Nastaven". ',
    title: "Co se mi na tto strnce zobrazuje?"
  },
  accountFiat: {
    text: "Ano. Kliknutm na libovoln ticker mete volit mezi fiat mnami. Seznam mn mete zmnit v nastaven.",
    title: "Mohu zobrazit jin smnn kurzy?"
  },
  accountIncomingBalance: {
    text: "Pichzejc transakce zahrnuj stky, kter vm byly pevedeny, ale jet nebyly potvrzeny st.",
    title: "Co znamen pichzejc transakce?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Kad xpub je svzn se zobrazenm typem: bu "Native Segwit (bech32)", "Wrapped Segwit" nebo "Taproot" (pouze u Bitcoinu). Jedn se o typy skript, kter pouv {{coinName}}. BitBoxApp je kombinuje a podporuje vce typ skript v rmci jednoho tu. Protoe kad typ skriptu dv jin xpub, existuje vce xpub pro jeden et.

Pokud soustavn pijmte na vchoz adrese (Native Segwit), potebujete pouze "bech32" xpub. Pokud vak pijmte prostedky tak na "Wrapped Segwit" nebo "Taproot", muste pouvat tak dal veejn kle "Wrapped Segwit", xpub respektive "Taproot" xpub.`,
      title: "Pro existuje vce xpub?"
    },
    privacy: {
      text: `U tohoto konkrtnho tu odhaluje xpub veejn kl celou finann historii, zstatek na tu a vechny budouc transakce. Xpub vak nikomu neumouje utrcet vae prostedky.

Pokud xpub nkomu pedte, mli byste si bt vdomi toho, e tato osoba nebo spolenost me vidt vechny ostatn transakce tohoto tu. Proto je dobr pouvat tento et pouze k tomuto elu a ostatn prostedky dret na jinch tech.`,
      title: "Musm svj xpub dret v tajnosti?"
    },
    verify: {
      text: "Ano, vdy je dobr si xpub pekontrolovat. Pokud z tohoto xpubu bude nkdo jin generovat adresy a poslat vm penze, je to obzvl dleit. Muste ho ovit na zazen, abyste se ujistili, e tento xpub pat vm; jinak by vechny prostedky mohly jt na nesprvn adresy.",
      title: "Musm ovit xpub na zazen?"
    },
    xpub: {
      text: `Veejn kl (xpub) je zkladn kl, z nho jsou odvozeny vechny adresy tu.

Je zde uveden pro pokroil pouvn a interoperabilitu s penenkami urenmi pouze pro sledovn (watch-only wallets), jako je Electrum nebo Sentinel. Pokud jste pijmali na rzn typy adres, importujte prosm vechny rzn formty xpub do watch-only penenky, abyste vidli vechny sv prostedky.

Upozorujeme, e penenky tetch stran nemus zatm podporovat Taproot xpub.`,
      title: "Co je veejn kl (xpub)?"
    }
  },
  accountRates: {
    text: "Smnn kurzy aktualizujeme kadou minutu z CoinGecko.",
    title: "Jak smnn kurzy plat?"
  },
  accountReload: {
    text: "To nen poteba. Informace o transakci se aktualizuj automaticky.",
    title: "Mohu znovu nast historii transakc?"
  },
  accountSendDisabled: {
    text: "Tlatko Odeslat se aktivuje, kdy je v zstatek vy ne nula.",
    title: "Pro nemu poslat dn {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Celkov stka je soutem vech vaich t. Smnn kurzy jsou zskvny z coingecko.com.

Poznmka: Pokud pouvte MyEtherWallet pro tokeny, kter nejsou podporovny v aplikaci BitBoxApp, nebudou do zobrazen stky zahrnuty.`,
    title: "Jak se vypot celkov stka?"
  },
  accountSummaryDescription: {
    text: "Zde mete sledovat vkonnost svho portfolia v prbhu asu. Pod grafem se zobrazuje pehled vaich jednotlivch t.",
    title: "Co se mi na tto strnce zobrazuje?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtuln velikost: Uruje sov poplatek. spn jste uetili na poplatcch, pokud je men ne velikost transakce.
Velikost: Skuten velikost transakce v bajtech pi serializaci podle pslunho blockchainu.
Vha: Nov metrika zaveden se Segwitem pro vyhodnocovn velikosti transakc a blok. Kad byte segregovanho svdka {segregated witness) se pot jako jedna, ve ostatn jako tyi jednotky vhy. Msto jednoho megabajtu ve skuten velikosti je nyn limit velikosti bloku tyi miliony vhovch jednotek.`,
    title: "A co podrobnosti transakce specifick pro bitcoiny?"
  },
  accountTransactionAttributesGeneric: {
    text: `Potvrzen: Vae prvn transakce je nepotvrzen, dokud ji ta nezaad do bloku, pot m jedno potvrzen. Kad dal blok v sti pidv k va transakci dal potvrzen. Obecn plat, e obchodnci a dal astnci st akceptuj transakce jako vypodan s minimem t a esti potvrzen.
ID transakce: Jedinen identifikan slo, kter umouje vyhledat transakci v blok exploreru.
Poplatek: Tam se plat transakn poplatek jako pobdka k zahrnut transakc do blok, kter vyt. Chcete-li se dozvdt vce, kliknte na tlatko odeslat.`,
    title: "Jak jsou informace v detailech transakce?"
  },
  accountTransactionConfirmation: {
    text: "Transakce odeslan do st, ale dosud nepotvrzen.",
    title: "Co je to ekajc transakce?"
  },
  accountTransactionLabel: {
    text: "Je to adresa, ze kter jste obdreli prostedky nebo na kterou jste je odeslali.",
    title: "Jak adresa se zobrazuje u kad transakce?"
  },
  accountTransactionTime: {
    text: "Doba potvrzen transakce v blockchainu.",
    title: "Jak as se zobrazuje?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin a Litecoin mohou mt libovoln mnostv t. Po pti tech mete pidat dal et pouze v ppad, e pedchoz et byl pouit. 
Ostatn mny mohou mt maximln pt t.`,
      title: "Kolik t mohu vytvoit?"
    },
    howtoAddTokens: {
      text: 'Tokeny vyuvajc standard ERC20 jsou vzny na konkrtn et Etherea. Chcete-li aktivovat nebo deaktivovat konkrtn token, otevete obrazovku "Sprva t", rozbalte svj et Ethereum a zapnte nebo vypnte poadovan token.',
      title: "Jak mohu pidat dal tokeny?"
    },
    moveFunds: {
      text: "Ano, ale protoe jsou ty nezvisl, muste sv prostedky poslat pomoc bn transakce.",
      title: "Mohu pesouvat prostedky mezi ty?"
    },
    recoverAccounts: {
      text: "Ano, BitBoxApp vytv ty pomoc zavedench standard kompatibilnch s vtinou ostatnch kryptopenenek.",
      title: "Mohu obnovit sv ty v jinch penenkch?"
    },
    whatAreAccounts: {
      text: "Vae penenka um spravovat vce t jedn mny. ty jsou uiten, kdy chcete mt prostedky oddlen.",
      title: "Co jsou ty?"
    },
    whyIsThisUseful: {
      text: "ty jsou skvl pro sprvu prostedk pro rzn osoby nebo ely, protoe jsou oddlen. Mete tak sdlet veejn kl (xpub) tu, ani byste prozradili cokoli o svch ostatnch tech. To vm umouje opakovan pijmat finann prostedky bez opakovanho pouvn adres, napklad pi pobrn mzdy nebo pravidelnm nkupu kryptomn.",
      title: "Pro je to uiten?"
    }
  },
  appendix: {
    link: "Kontaktujte ns!",
    text: "Dal otzka?"
  },
  backups: {
    check: {
      text: '"Zkontrolovat zlohu" umouje ovit, zda mte funkn zlohu odpovdajc va aktuln penence. Lze ji tak pout k oven, zda mte stle sprvn heslo pro obnoven. Mete zkontrolovat hlavn heslo pro obnoven nebo skryt heslo pro obnoven.',
      title: "Co je to Zkontrolovat zlohu?"
    },
    encrypt: {
      text: "Ne, ale k zskn penenky z uloenho seedu {slov pro obnoven) je nutn vae heslo pro obnoven.",
      title: "Mohu zlohu zaheslovat?"
    },
    howOften: {
      text: `Zloha se generuje automaticky pi vytvoen nov penenky. Novou zlohu muste vytvoit pouze v ppad, e microSD kartu ztratte nebo pokodte, nebo pokud chcete jako zlohu pout vce microSD karet.
Po uskutenn transakc nemuste vytvet nov zlohy. Vechna data transakc lze znovu vytvoit pomoc jedin zlohy, kter byla pro vs automaticky vytvoena.`,
      title: "Jak asto musm vytvet zlohu?"
    },
    whatIsABackup: {
      text: "Jedn se o kopii obnovovacho seedu na microSD kart. Seed {slova pro obnoven) spolu s heslem pro obnoven vytv vai penenku.",
      title: "Co je zloha?"
    }
  },
  backupsBB02: {
    check: {
      text: "Zkontrolovat zlohu vm umouje ovit, e mte funkn zlohu odpovdajc va aktuln penence.",
      title: "Co je to Zkontrolovat zlohu?"
    },
    encrypt: {
      text: 'Ne. microSD kartu uchovvejte v bezpe, protoe obsahuje nezaifrovan obnovovac seed k obnoven penenky. Pokud si pejete chrnit seed heslem, mete aktivovat volitelnou pstupovou frzi v expertnm nastaven v sti "Sprva zazen".',
      title: "Mohu zlohu zaifrovat?"
    },
    whatIsABackup: {
      text: "Jedn se o kopii obnovovacho seedu na microSD kart.",
      title: "Co je zloha?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Kdy je aktivn funkce 2FA, mus bt vechny transakce schvleny na sprovanm mobilnm telefonu, aby bylo mon utrcet prostedky. Do mobiln aplikace je odeslno zaifrovan jednorzov slo, kter je tam deifrovno a po stisknut tlatka Pijmout je odeslno zpt do BitBoxu. Tato komunikace se zazenm probh prostednictvm kanlu mezi mobilnm telefonem a touto desktopovou aplikac vytvoenho bhem provn.

Ped zapnutm funkce 2FA nezapomete zlohovat penenku a sprovat mobiln aplikaci. Po aktivovn jsou microSD slot a provn s mobiln aplikac vypnuty. Lze je znovu aktivovat resetovnm BitBoxu, m se zazen vymae.`,
      title: "Jak funguje dvoufaktorov autorizace (2FA)?"
    },
    disable2FA: {
      text: `Chcete-li 2FA deaktivovat, muste resetovat BitBox a pot obnovit penenku ze zlohy. Ujistte se, e stle mte microSD kartu se zlohou a e si stle pamatujete heslo pro obnoven. Pot stisknte tlatko "Resetovat zazen". Nastavte nov heslo zazen a zvolte 'Nebo obnovit ze zlohy'. Vyberte zlohu penenky, kliknte na 'Obnovit' a zadejte heslo pro obnoven, kter jste pouili pi vytven penenky.`,
      title: "Jak mohu deaktivovat dvoufaktorovou autorizaci (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox mete kdykoli odpojit, ani byste jej museli nejprve vysunout.",
      title: "Jak mohu vysunout BitBox?"
    },
    ejectSD: {
      text: "MicroSD kartu mete z BitBoxu kdykoli vyjmout, pokud prv nevytvte nebo neobnovujete zlohu.",
      title: "Jak mohu microSD kartu vysunout?"
    },
    hiddenWallet: {
      text: "Jedn se o druhou penenku na stejnm zazen chrnnou jinm heslem zazen a heslem pro obnoven, kter mete pout pro hodnovrn popen (plausible deniability). Pro normln i skrytou penenku se pouv stejn seed, take nen teba dn dal zlohovn.",
      title: "Co je to skryt penenka?"
    },
    legacyHiddenWallet: {
      text: "Nejprve kliknte na ne uveden tlatko (je k dispozici, pokud je BitBox odemen hlavnm heslem zazen a funkce 2FA je vypnut), pot Bitbox znovu pipojte a odemknte jej skrytm heslem.",
      title: "Jak se dostanu k legacy skryt penence?"
    },
    pairing: {
      text: "Po staen na mobiln aplikace pro iOS nebo Android naskenujete zobrazen QR kd, m se vytvo zabezpeen kanl mezi mobiln aplikac a touto aplikac. Po naskenovn postupujte podle pokyn v mobiln aplikaci.",
      title: "Jak bezpen sprovat s telefonem"
    }
  },
  cointracking: {
    text: 'Kliknte na tlatko "Export" a otevete sloku se staenmi soubory, kde najdete export CSV. Pot kliknte na ne uveden odkaz, nahrajte svj BitBox CSV soubor a importujte data, abyste je mohli pout pro sprvce portfolia CoinTracking a pro vytven daovch vkaz.',
    title: "Jak importovat m transakce do sluby CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Pette si vce o kontrole pravosti"
      },
      text: "BitBoxApp provede atestan kontrolu BitBox02, aby ovila, zda je zazen prav. Kontrola se provd lokln a nepipojuje se k dnm serverm.",
      title: "Jak probh kontrola pravosti?"
    },
    name: {
      text: "Jedn se o nzev va penenky a zlohy. Nzev se pouv pro budouc zlohy a me slouit k rozlien rznch penenek. Lze jej kdykoli zmnit, ale mjte na pamti, e zlohy vytvoen ped zmnou budou stle pouvat pedchoz nzev.",
      title: "K emu slou nzev BitBoxu?"
    },
    "secure-chip": {
      link: {
        text: "Dal informace o bezpenm ipu"
      },
      text: "Tato informace zobrazuje slo modelu zabezpeenho ipu, nejnovj ip je ATECC608B s vylepenmi bezpenostnmi funkcemi ve srovnn se starmi modely.",
      title: "Pro zobrazovat model bezpenho ipu?"
    }
  },
  receive: {
    address: {
      text: "Adresu mete dt ostatnm, aby vm poslali njak prostedky. Jen se ujistte, e je poslaj na sprvnou adresu.",
      title: "Co mohu dlat s adresou?"
    },
    addressChange: {
      text: "Jakmile provedete transakci, do seznamu se automaticky pid nov adresa, take je vdy k dispozici 20 adres, kter nikdy neobdrely dn prostedky.",
      title: "Kdy se adresy mn?"
    },
    addressFormats: {
      text: "Ve vchozm nastaven je typ adresy Native Segwit. Tento typ adresy je iroce rozen mezi ostatnmi penenkami/burzami poskytuje nejlep sazby poplatk za kadodenn transakce. Mete si vak tak zvolit odesln na Taproot (jen pro Bitcoin), co je nejnovj typ adresy, kter vak jet nemus bt vude podporovn. Ppadn, pokud mte problmy s odeslnm na Native Segwit (vchoz typ), mete zkusit pejt na star typ adresy Wrapped Segwit, kter me bt kompatibiln s vce penenkami/burzami.",
      title: 'Kdy mm pout "Zmnit typ adresy"?'
    },
    howVerify: {
      text: `V ppad BitBox01 kliknte na ikonu BitBox v postrannm panelu vlevo a podvejte se do sti Provn. Prvodce se aktualizuje a vy mete pokraovat podle pokyn odtud.
U BitBox02 mete adresy ovit pmo v zazen bhem procesu odesln/pijmn.`,
      title: "Jak mohu bezpen ovit adresu?"
    },
    plugout: {
      text: "Ne, po odesln prostedk na adresu BitBoxu nemuste nechvat BitBox pipojen. Svj BitBox mete kdykoli odpojit.",
      title: "Musm nechat svj BitBox bhem pijmn zapojen?"
    },
    why20: {
      text: 'Bhem sputn aplikace generuje adresy odvozen z vaeho seedu a zjiuje, zda obdrely prostedky. Protoe aplikace me generovat tm nekonen mnostv adres, mohla by zjiovnm zstatku strvit roky. Aby se toto hledn omezilo, zastav se, jakmile uvid 20 adres, kter nikdy neobdrely dn prostedky. To je "gap limit" a 20 je de facto standard, i kdy toto slo je libovoln. Z tchto 20 adres si mete vybrat.',
      title: "Pro jenom 20 adres?"
    },
    whyMany: {
      text: "V zjmu zachovn soukrom a bezpenosti nikdy pro pijman nepouvejte stejnou adresu dvakrt. Pokud jste adresu pouili, kliknte na ipku vpravo pro novou adresu. Najednou mete vygenerovat a 20 adres. Pedstavte si adresy jako sla faktur. Vechny adresy jsou odvozeny z vaeho jedinho obnovovacho seedu.",
      title: "Pro tolik adres?"
    },
    whyVerify: {
      text: "Nemli byste vit, e v pota generuje a zobrazuje autentick adresy. Jeho ton plocha (attack surface) jej in podstatn zranitelnjm ne hardwarovou penenku. U BitBox01 Tlatko pro oven adresy bezpen odele adresu do sprovanho mobilnho telefonu, ze kterho mete tak naskenovat a ovit kd QR. U BitBox02 lze adresu ovit pmo na displeji BitBoxu.",
      title: "Pro bych ml adresu bezpen ovit?"
    }
  },
  send: {
    change: {
      text: "Zstatek bude vrcen na adresu Taproot, pokud mte alespo jedno  Taproot UTXO. Pokud pouijete coin control, bude zstatek vrcen na adresu Taproot, pokud je mezi vybranmi UTXO alespo jedno Taproot UTXO. Ve vech ostatnch ppadech se zmna vrt na nativn adresu Segwit.",
      title: "Jak se uruje change output (hodnota zstatku)?"
    },
    fee: {
      text: `Poplatek se odvj od velikosti dat transakce, nikoli od jej ve. Clov hodnoty poplatk jsou vypotvny algoritmem pro odhad poplatk v Bitcoin Core pro kadou vmi zvolenou prioritu st. Jsou zobrazeny, pokud maj jinou hodnotu ne cl uveden ne.
sporn: 24 blok (piblin 4 hodiny u Bitcoinu, 1 hodina u Litecoinu).
Nzk: 12 blok (piblin 2 hodiny pro Bitcoin, 30 minut pro Litecoin).
Normln: 6 blok (piblin 1 hodina pro Bitcoin, 15 minut pro Litecoin).
Vysok: 2 bloky (piblin 20 minut pro Bitcoin, 5 minut pro Litecoin)
(Vyten jednoho bloku trv u Bitcoinu v prmru deset minut (u Litecoinu 2,5 minuty) a zaten st se me ve ve uvedench obdobch znan liit).`,
      title: "Jak se uruje poplatek?"
    },
    plugout: {
      text: "Ne, jakmile provedete transakci, nemuste nechvat svj BitBox pipojen. Mete svj BitBox kdykoli odpojit.",
      title: "Musm nechat svj BitBox bhem odesln pipojen?"
    },
    priority: {
      text: "m vy poplatek jste ochotni zaplatit, tm rychleji je obvykle vae transakce potvrzena st.",
      title: "Co je to priorita st (network priority)?"
    },
    revert: {
      text: `Jakmile je transakce podepsna a odeslna (tj. vyslna do st), nelze ji ji vrtit zpt. Ped podpisem transakce (vetn poplatku) ji podn ovte!
Pokud pjemce znte a je ochoten vm poslat stejnou stku (po odeten transaknch poplatk) zpt, mete mu poslat novou pijmac adresu.`,
      title: "Mohu transakci vrtit zpt?"
    },
    whyFee: {
      text: `Transakce sout o jejich potvrzen taem. Tai vybraj transakce, kter maj bt zaazeny do blockchainu, na zklad jejich poplatk.
Tai hlasuj o historii transakc. Protoe neexistuje dvryhodn tet strana, kter by vynucovala jeden hlas na osobu (co je cel smysl blockchain), hlasuj tai o transakcch tak, e obtuj nkladn zdroj, jako je vpoetn vkon. Jako odmnu za svou prci si mohou nrokovat nov vytvoen mince a poplatek za vechny zahrnut transakce.`,
      title: "Pro se plat sov poplatek?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Pokud se k uzlu hodlte pipojit pouze tehdy, kdy jste ve stejn sti (nap. domc wifi), pak vm posta bn sov komunikace.
V takovm ppad je vhodn, aby v Electrum server poskytoval certifikt TLS pro ifrovn komunikace.
Pokud se hodlte k uzlu pipojit odkudkoli, je lep volbou pouit st Tor. V takovm ppad nen certifikt TLS nutn.`,
      title: "Mm pout clearnet TCP, TLS nebo Tor?"
    },
    instructions: {
      link: {
        text: "Prvodce pro pipojen uzlu"
      },
      text: "pln nvod naleznete v naem prvodci:",
      title: "Jak pipojm BitBoxApp k vlastnmu uzlu?"
    },
    options: {
      text: `Existuje vce monost, jak provozovat vlastn uzel, napklad zakoupit hotov zazen, postavit si vlastn nebo pouvat Bitcoin Core.
Pokud chcete k uzlu pipojit BitBoxApp, ujistte se, e na nm b server Electrum. Jedn se o specializovan program, kter umouje  penence komunikovat s vam uzlem.
Mezi podporovan monosti pat Electrs, Electrum Personal Server (EPS) nebo Bitcoin Wallet Tracker (BTW).`,
      title: "Jak jsou monosti provozovn uzlu?"
    },
    tor: {
      text: `Tor je zkratka pro "The Onion Router", co je bezplatn software s open source kdem, kter nabz mnoho vhod v oblasti ochrany soukrom a je uiten zejmna pi pouvn Bitcoinu.
Pokud se hodlte pipojit k uzlu prostednictvm Toru, ujistte se, e je Tor na vaem potai nainstalovn, a pot aktivujte Tor Proxy v nastaven BitBoxApp.
U vtiny operanch systm existuj dva zpsoby, jak Tor spustit:
1. Prohle Tor: Sthnte si a otevete prohle Tor Browser. To umon aplikaci BitBoxApp pipojit se k sti Tor nastavenm portu 9150 v nastaven proxy serveru Tor.
2. Sluba Tor na pozad: nainstalujte Tor daemon, kter vdy b na pozad. BitBoxApp se pak me pipojit nastavenm portu 9050 v nastaven proxy serveru Tor.`,
      title: "Co je Tor, Tor proxy a jak port mm pout?"
    },
    what: {
      text: "Penenku je mon provozovat s vlastnm uzlem namsto server Shift.",
      title: "Co to je?"
    },
    why: {
      text: `Provozovn vlastnho uzlu nen nutn, ale zlepuje soukrom a sniuje potebu dvovat nkomu jinmu.
Zaprv to znamen, e pouvte Bitcoin soukromji, protoe BitBoxApp se nebude pipojovat k naim serverm, aby zskala historii vaich transakc; msto toho bude tyto informace zskvat z vaeho vlastnho uzlu.
Za druh, sputn vlastnho uzlu znamen, e v uzel sm ovuje vechny transakce a zajiuje tak dodrovn pravidel konsensu (consensus rules).`,
      title: "Pro bych ml provozovat vlastn uzel?"
    }
  },
  settings: {
    sats: {
      text: 'Satoshi (zkrcen "sat") je nejmen jednotka bitcoinu. Jeden satoshi je jedna stamiliontina bitcoinu (0,00000001 BTC). Je pojmenovna po tvrci bitcoinu Satoshi Nakamotovi.',
      title: "Co je to Satoshi?"
    },
    servers: {
      text: `Tato aplikace komunikuje se servery Shift Crypto a kontroluje aktualizace, nat transakce a odesl informace sprovanm mobilnm aplikacm.
Aplikace tak nat nejnovj smnn kurzy z CoinGecko. Vechny konverze se potaj lokln, co znamen, e se nikdy neodeslaj dn daje o vi va transakce.
Poznmka: Pro tokeny Ethereum a ERC20 pouvme Etherscan.io API.`,
      title: "S ktermi servery tato aplikace komunikuje?"
    }
  },
  title: "Prvodce",
  toggle: {
    close: "Zavt prvodce",
    open: "Prvodce"
  },
  trackingModePortfolioChart: {
    text: "Na potai najete kurzorem na graf. Na mobilnm telefonu podrte prst na grafu a pothnte vodorovn.",
    title: "Jak zobrazit historick hodnoty na grafu?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Muste zazen resetovat a obnovit penenku ze zlohy pomoc hesla pro obnoven.",
      title: "Co mm dlat, kdy jsem zapomnl heslo k zazen?"
    },
    reset: {
      text: "Zadejte 15krt patn heslo zazen. Nkolik poslednch pokus vyaduje dlouh dotyk na zazen.",
      title: "Jak resetuji zazen?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Zazen by mlo po pipojen jednou bliknout. Ujistte se, e je zapojeno sprvnou stranou. Pokud mte pote, kontaktujte ns prostednictvm ne uvedenho odkazu.

Zazen BitBox01 nen podporovno v mobilnch zazench. K pipojen zazen BitBox01 pouijte aplikaci BitBoxApp na stolnm potai.`,
      title: "Mj BitBox01 nebyl rozpoznn"
    },
    getDevice: {
      link: {
        text: "Objednejte si BitBox"
      },
      text: "BitBox si mete zakoupit v naem internetovm obchod:",
      title: "Jak si mohu zazen podit?"
    },
    internet: {
      text: "Ano, k synchronizaci penenky, odesln transakc a natn nejnovjch smnnch kurz je nutn pipojen k internetu.",
      title: "Vyaduje tato aplikace pipojen k internetu?"
    },
    lostDevice: {
      link: {
        text: "Centrum zlohovn"
      },
      text: "Sv ty mete obnovit na novm BitBoxu nebo v naem centru zlohovn.",
      title: "Ztratil jsem zazen. Co te?"
    },
    useWithoutDevice: {
      text: "V souasn dob to bohuel nen mon.",
      title: "Mohu aplikaci pouvat i bez zazen?"
    },
    welcome: {
      text: "Dkujeme za pouvn tto aplikace vytvoen spolenost Shift Crypto ve vcarsku. Jsme rdi za jakkoli pspvek, o kter se s nmi podlte. Poskytnte prosm zptnou vazbu pomoc odkazu v doln sti.",
      title: "Vtejte v BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Pokud pouvte nov telefon/pota s BitBoxApp, budete se muset k dapps pipojit znovu. Pot opt uvidte sv prostedky v dapp jako obvykle.",
      title: "Nevidm sv pedchoz spojen."
    },
    supportedNetworks: {
      text: "V souasn dob je pomoc WalletConnect v BitBoxApp podporovn pouze Ethereum mainnet . Chcete-li pouvat jin st kompatibiln s EVM, pouijte prosm penenku z rozen prohlee Rabby.",
      title: "Kter st jsou podporovny?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikan protokol pro aplikace web3. Umouje pohodln pipojen k DApps a webovm penenkm zaloenm na Ethereu bez pouit aplikace tet strany, co je uiten zejmna pro uivatele BitBoxApp pro Android.",
      title: "Co je WalletConnect?"
    }
  }
}, headerssync$h = {
  blocksSynced: "{{blocks}} blok zesynchronizovno"
}, hiddenWallet$h = {
  info1HTML: "Pro ely hodnovrnho popen (plausible deniability) lze skrytou penenku vytvoit na zklad kombinace <strong>odlinho</strong> hesla zazen + hesla pro obnoven.",
  info2HTML: "Ne definujte heslo zazen a heslo pro obnoven, kter chcete piadit ke sv skryt penence. Heslo zazen a heslo pro obnoven mus bt <strong>odlin</strong> od tch, kter jste definovali pro svou primrn penenku.",
  passwordLabel: "Skryt heslo pro obnoven",
  passwordPlaceholder: "Potvrte prosm skryt heslo pro obnoven",
  pinLabel: "Heslo pro skryt zazen",
  pinRepeatLabel: "Zopakujte heslo pro skryt zazen",
  pinRepeatPlaceholder: "Potvrte prosm heslo pro skryt zazen",
  success: "Skryt penenka byla spn vytvoena. Znovu pipojte svj BitBox, abyste jej odemkli."
}, initialize$h = {
  create: "Nastavit heslo zazen",
  creating: "Nastavovn hesla zazen",
  error: {
    e102: "Heslo zazen mus obsahovat alespo 4 znaky."
  },
  info: {
    description1: "Zvolte heslo zazen. To bude pouito k odemknut vaeho BitBoxu.",
    description2: "Mete pouvat sla, psmena a symboly. Del hesla poskytuj vy bezpenost.",
    description3: "Pokud heslo k zazen ztratte, budete muset zazen resetovat a obnovit ze zlohy.",
    subtitle: "Nyn nastavte heslo svho zazen",
    title: "Inicializace zazen"
  },
  input: {
    label: "Heslo zazen",
    labelRepeat: "Opakujte heslo zazen",
    placeholderRepeat: "Potvrte heslo zazen"
  }
}, invalidFormat$h = "Nesprvn formt", language$i = {
  title: "Zvolte jazyk"
}, legacyhiddenwallet$h = {
  disable: "Deaktivovat legacy skrytou penenku",
  enable: "Aktivovat legacy skrytou penenku",
  successDisable: "spn deaktivovna legacy skryt penenka.",
  successEnable: "Star legacy penenka byla spn aktivovna. Znovu zapojte svj BitBox a zadejte heslo skrytho zazen pro pstup k legacy skryt penence."
}, loading$h = "natn", manageAccounts$b = {
  accountHidden: "Tento et byl skryt z vaich watch-only t. Chcete-li jej znovu zobrazit, pipojte prosm svj BitBox02.",
  editAccount: "Upravit",
  editAccountNameTitle: "Upravit nzev tu",
  noAccounts: "nebyly nalezeny dn ty",
  settings: {
    hideTokens: "Skrt tokeny",
    showTokens: "Zobrazit tokeny ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Pidat a zobrazit/skrt ty",
  title: "Spravovat ty",
  watchAccount: "Sledovat et",
  watchAccountDescription: "Tento et je soust watch-only t. Mete jej skrt ze svch watch-only t pomoc pepnae."
}, mobile$c = {
  usingMobileDataWarning: "Vyuit mobilnch dat: tato aplikace me po odemen tu sthnout a nkolik set megabajt dat z blockchainu. Abyste se vyhnuli pouvn mobilnch dat, pipojte se k Wi-Fi. Po jejm zaven se tato zprva ji nebude zobrazovat."
}, newSettings$a = {
  about: {
    appVersion: {
      title: "Verze aplikace"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Uzamen pstupu k aplikaci pomoc zmku obrazovky/otisku prstu.",
      title: "Uzamen obrazovky"
    },
    coinControl: {
      description: "Vyberte, kter UTXO jsou soust transakce, abyste zlepili soukrom."
    },
    customFees: {
      description: "Umouje zadat vlastn poplatek pi odesln."
    },
    torProxy: {
      description: "Pipojte se pes Tor pro lep soukrom."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Tyto dal mny mete pepnat na strnce svho tu.",
      title: "Aktivn mny"
    },
    darkmode: {
      description: "Podvejte se na BitBoxApp v tmavm reimu."
    },
    defaultCurrency: {
      description: "Vyberte vchoz mnu",
      title: "Vchoz mna"
    },
    hideAmounts: {
      description: "Zobrazuje pepna pro skryt zstatku a stek pro ochranu soukrom pi pouvn aplikace na veejnosti.",
      hideAmounts: "Skrt stky",
      showAmounts: "Zobrazit stky",
      title: "Povolit skryt stek"
    },
    language: {
      description: "Jak jazyk chcete v BitBoxApp pouvat.",
      title: "Jazyk"
    },
    toggleSats: {
      description: "Aktivovat nebo deaktivovat Satoshi."
    }
  }
}, note$d = {
  input: {
    description: "(voliteln)",
    placeholder: "Pidat poznmku"
  },
  title: "Poznmka"
}, notification$h = {
  newTxs_one: "Nov transakce v: {{accountName}}",
  newTxs_other: "{{count}} nov transakce v: {{accountName}}"
}, pairing$h = {
  aborted: {
    text: "Provn bylo z mobiln aplikace zrueno.",
    title: "Zrueno"
  },
  button: "Sprovat mobiln aplikaci",
  confirm: "Jste si jisti, e chcete sprovat svj BitBox? Pamatujte, e pot je k proveden transakce vyadovn mobiln telefon.",
  connectOnly: {
    button: "Pipojte mobiln aplikaci",
    title: 'Naskenujte pomoc na mobiln aplikace vbrem poloky "Pipojit k nov aplikaci".'
  },
  error: {
    text: "Nco se pokazilo. Zante prosm znovu.",
    title: "Chyba"
  },
  pullFailed: {
    text: "Nepodailo se sthnout zprvu z mobilnho telefonu prostednictvm serveru. Server me bt offline, kontaktujte prosm podporu.",
    title: "Vytaen se nezdailo"
  },
  reconnectOnly: {
    button: "Znovu pipojte mobiln aplikaci"
  },
  scanningFailed: {
    text: "Mobiln telefon nebyl schopen zprvu spn naskenovat. Zkuste to prosm znovu.",
    title: "Skenovn se nezdailo "
  },
  start: {
    hideAppQRCode: "Skrt QR kd",
    revealAppQRCode: "Zobrazit QR kd",
    step1: "Pokud mobiln aplikaci nemte, mete naskenovat QR kd pro Apple App Store nebo Google Play Store podle toho, kter telefon mte.",
    step2: 'Naskenujte pomoc na mobiln aplikace, kterou najdete pod nzvem "Digital Bitbox 2FA" v obchodech s aplikacemi pro iOS a Android:'
  },
  started: {
    text: "Nyn postupujte podle pokyn v mobiln aplikaci.",
    title: "Skvl"
  },
  success: {
    text: "Gratulujeme, spn jste sprovali svj BitBox s mobiln aplikac!",
    title: "Hotovo"
  },
  timeout: {
    text: "Provn se po dvou minutch peruilo. Pokud chcete jet sprovat mobiln aplikaci, spuste ji znovu.",
    title: "Timeout"
  },
  title: "Provn mobilnho telefonu"
}, passphrase$b = {
  considerations: {
    button: "vahy ohledn zlohovn",
    message: `Pstupov frze pidv vrstvu ochrany k va zloze penenky (zloha na microSD kart nebo obnovovac slova). Pokud m nkdo pstup k va zloze, bude k pstupu do penenky potebovat tak pstupovou frzi.

To vak znamen, e v ppad ztrty nebo rozbit vaeho BitBoxu budete potebovat <strong>i pstupovou frzi i zlohu penenky</strong> pro obnoven va penenky s pstupovou frz. Pokud zapomenete nebo ztratte svou pstupovou frzi, ztratte pstup ke vem prostedkm v tto penence.

Pi ukldn pstupov frze zvate jej umstn na jin msto ne kde mte zlohu. Pokud nkdo najde vai zlohu, nenajde tak vai pstupovou frzi.`,
    title: "vahy ohledn zlohovn"
  },
  disable: "Deaktivovat pstupovou frzi",
  disableInfo: {
    button: "Deaktivovat",
    message: `Po vypnut pstupov frze ji nebudete po odemknut BitBoxu vyzvni k zadn pstupov frze. Proto vstoupte do sv vchoz penenky.

Veker prostedky ve va penence s pstupovou frz budou stle v tto penence, avak nebudete k nim mt pstup, protoe po odemknut vaeho BitBoxu otevete svou vchoz penenku.

Pro optovn pstup k vaim penenkm s pstupovou frz jednodue znovu zapnte funkci pstupov frze a po odemknut BitBoxu zadejte pslunou pstupovou frzi.

<strong>Tip:</strong> Do sv vchoz penenky mete pistoupit i ponechnm przdn pstupov frze, kdy ji mte aktivovanou.`
  },
  enable: "Aktivovat pstupovou frzi",
  error: {
    e104: "Zmna nastaven pstupov frze byla zruena."
  },
  how: {
    button: "Jak to vypad",
    message: `A pstupov frze nefunguje jako heslo, na kter jste zvykl. Pokud heslo zadte chybn, nebudete na to upozornni. Je to proto, e <strong>kad pstupov frze vytv jinou, avak platnou penenku.</strong> To znamen, e mete pouvat vce pstupovch frz pro libovoln poet penenek. Kad penenka je vak pstupn pouze po zadn pslun pstupov frze.

Po pipojen BitBoxu budete jako obvykle vyzvni k zadn hesla zazen. Pot budete vyzvni k zadn pstupov frze.

Po zadn pstupov frze se zobraz vmi zadan pstupov frze. To proto, abyste mohli potvrdit, e jste ji zadali sprvn.`,
    title: "Jak to funguje"
  },
  intro: {
    message: `Pstupov frze poskytuje dal vrstvu zabezpeen nad va penenkou.
Pojme se nauit, jak to funguje.`,
    title: "Nastaven pstupov frze"
  },
  progressDisable: {
    message: "Potvrte na svm BitBoxu, e chcete <strong>deaktivovat</strong> volitelnou pstupovou frzi.",
    title: "Potvrte na zazen"
  },
  progressEnable: {
    message: "Potvrte na svm BitBoxu, e chcete <strong>aktivovat</strong> volitelnou pstupovou frzi.",
    title: "Potvrte na zazen"
  },
  successDisabled: {
    message: `Voliteln pstupov frze <strong>byla spn aktivovna</strong>!
Od tto chvle budete vyzvni k zadn pstupov frze.`,
    messageEnd: "Nyn znovu pipojte BitBox02.",
    title: "Pstupov frze aktivn"
  },
  successEnabled: {
    message: `Voliteln pstupov frze <strong>byla spn deaktivovna</strong>!

Ji nebudete vyzvni k zadn pstupov frze.`,
    messageEnd: "Nyn znovu pipojte svj BitBox02.",
    tips: "Tipy",
    tipsList: [
      "Doporuujeme nejprve odeslat malou stku do penenky s pstupovou frz. Pot odpojte a znovu zapojte BitBox02 a zadejte heslo a pstupovou frzi. Pokud jste zadali pstupovou frzi sprvn, mli byste prostedky vidt ve sv penence.",
      "Pokud chcete vstoupit do sv pvodn penenky bez pstupov frze, mete to provst tak, e po vzv k zadn pstupov frze nezadte nic. Nebo mete funkci pstupov frze vypnout."
    ],
    title: "Pstupov frze deaktivovna"
  },
  summary: {
    button: "Aktivovat pstupovou frzi",
    title: "Pehled",
    understand: "Rozumm fungovn pstupov frze a rizikm s tm spojenm.",
    understandList: [
      "Pstupov frze pedstavuje dal vrstvu zabezpeen nad va zlohou.",
      "Zadnm jin pstupov frze se vdy vygeneruje jin penenka.",
      "K obnoven penenky potebujete <strong>pstupovou frzi i zlohu</strong>.",
      "Pokud zapomenete pstupovou frzi, <strong>ztratte pstup ke svm prostedkm</strong>."
    ]
  },
  what: {
    button: "Pette si, jak to funguje",
    message: `Penenka je vytvoena (odvozena) z velmi velkho nhodnho sla, znmho tak jako seed. Tento seed, nebo slova pro obnoven, je vytvoen pi prvnm nastaven BitBoxu a je zlohovn pomoc microSD karty anebo prostednictvm jin zlohy (papr, steelwallet apod.). Kad, kdo m pstup k seedu, m plnou kontrolu nad prostedky v tto penence.

Pstupov frze je <strong>voliteln tajemstv</strong>, kter se pidv k seedu. Pi pouit pstupov frze se pi kadm pouit vytvo nov penenka na zklad seedu + pstupov frze (nepovinnho tajemstv). Passphrase me bt jakkoli: psmena, slova, speciln znaky nebo me bt i przdn. Vchoz penenka je ve skutenosti odvozena od seedu + przdn pstupov frze.

Pstupov frze je soust standardu BIP39, co znamen, e je kompatibiln se vemi penenkami, kter tento standard podporuj.`,
    title: "Co je pstupov frze?"
  },
  why: {
    button: "Pro pouvat pstupovou frzi",
    message: `BitBox02 chrn seed ped staenm ze samotnho zazen, ale zloha (uloena na microSD kart nebo obnovovac slova zapsan na pape) umouje pln pstup k penence. Proto by mla bt uloena na bezpenm mst!

Vzhledem k tomu, e pstupov frze vytv novou penenku pomoc vaeho stvajcho seedu, vyaduje penenka s pstupovou frz k obnoven <strong>zlohu i pstupovou frzi</strong>. Vhodou je, e pokud nkdo najde vai zlohu, bude k pstupu do penenky s pstupovou frz stle potebovat pstupovou frzi.

Funkce pstupov frze navc umouje vytvoit na stejnm zazen vce penenek nebo "skrytch penenek" krom t vchoz.`,
    title: "Pro pouvat pstupovou frzi?"
  }
}, password$h = {
  show: "Zobrazit {{label}}",
  warning: {
    caps: "VAROVN: Caps Lock () je zapnut",
    paste: 'pro vloen textu povolte "ZOBRAZIT {{label}}"'
  }
}, random$i = {
  button: "Vygenerujovat nhodn slo",
  description: "V BitBox vygeneroval nsledujc {{bits}}-bit nhodn slo:"
}, receive$j = {
  changeScriptType: "Zmit typ adresy",
  label: "Vae adresa",
  onlyThisCoin: {
    description: "Chcete-li pijmat dal tokeny, aktivujte je v nastaven. Pokud vlote jin tokeny, nemus bt pstupn.",
    warning: "Ujistte se, e pijmte pouze {{coinName}} na tto adrese."
  },
  scriptType: {
    p2tr: "Taproot (nejnovj formt)",
    p2wpkh: "Nativn Segwit (vchoz)",
    "p2wpkh-p2sh": "Wrapped Segwit (kompatibiln formt)"
  },
  selectAccount: "Vybrat et",
  showFull: "Zobrazit a ovit celou adresu na zazen",
  taprootWarning: "Poznmka: Taproot je nov funkce Bitcoinu a zatm nen iroce pouvna. Prostedky pijat na adresy Taproot nemus bt viditeln v penenkch tetch stran, kter jsou ureny pouze pro sledovn (watch-only wallets). Mnoho penenek a burz zatm nen schopno poslat na adresy Taproot.",
  title: "Pijmout {{accountName}}",
  verify: "Bezpen ovit adresu",
  verifyBitBox01: "Ovit adresu v mobiln aplikaci",
  verifyBitBox02: "Ovit adresu na BitBox02",
  verifyInstruction: "Zkontrolujte, zda se nsledujc adresa shoduje s adresou zobrazenou na vaem zazen.",
  warning: {
    secureOutput: 'Sprujte prosm svj BitBox s mobilnm zazenm, abyste mohli bezpen ovit adresu. Pejdte na "Spravovat zazen" v postrannm panelu.'
  }
}, reset$h = {
  description: "Vechna data v zazen budou smazna. Vetn vaeho soukromho kle!",
  notReset: "Zazen nebylo resetovno",
  title: "Resetovat zazen do tovrnho nastaven",
  understand: "Mm zlohu a znm heslo pro obnoven",
  understandBB02: "Mm platnou zlohu"
}, securityInformation$h = {
  create: {
    description1: "Doporuujeme nastavovat zazen v bezpenm prosted, to znamen mimo dosah dalch osob, kter by mohly vidt vmi zvolen heslo.",
    description2: "Budete vyzvni k vytvoen dvou hesel.",
    description3: "Prvn je <strong>heslo zazen</strong>, kter odemkne v BitBox a kter lze pozdji zmnit.",
    description4: "Druhm je <strong>heslo pro obnoven</strong>, kter odemkne vai penenku. Toto heslo nelze pozdji zmnit.",
    description5: "Penenka, kterou vytvote, bude zlohovna do souboru na dodan microSD kart. Ten mete v ppad nouze pout k obnoven svch prostedk pomoc hesla pro obnoven.",
    title: "Informace o zabezpeen"
  },
  restore: {
    description1: "Budete vyzvni k vloen microSD karty, kterou jste pouili k uloen zlohy.",
    description2: "K obnoven zazen budete potebovat heslo pro obnoven. ",
    description3: "Pi zadvn hesla pro obnoven bute opatrn. Jakkoli zadan heslo vytvo platnou penenku. Pokud zadte patn heslo, me se vm zobrazit zstatek penenky, kter neoekvte.",
    title: "Informace o zabezpeen"
  }
}, seed$h = {
  agreements: {
    "funds-access": "Pokud zapomenu heslo pro obnoven, ZTRATM pstup ke svm finannm prostedkm.",
    "password-change": "Heslo pro obnoven NEMU pozdji zmnit",
    "password-required": "Heslo pro obnoven je nutn pro obnoven penenky ze zlohy."
  },
  create: "Vytvoit penenku",
  creating: "Vytven penenky",
  description: "Rozumm, e:",
  error: {
    e102: "Heslo mus obsahovat alespo 4 znaky.",
    e200: "Pro vytvoen penenky je teba do BitBoxu vloit microSD kartu, aby se mohla automaticky vytvoit zloha."
  },
  info: {
    button: "Nastavit heslo pro obnoven",
    description1: "Vlote microSD kartu do zazen BitBox",
    description2: 'Zvolte heslo pro obnoven penenky a vyberte monost "Nastavit heslo pro obnoven".',
    description3: "Zlohovn na microSD kartu a heslo pro obnoven je jedinou metodou, jak obnovit sv prostedky v ppad ztrty nebo krdee BitBoxu.",
    description4: "Heslo pro obnoven nelze pozdji zmnit bez pevodu finannch prostedk.",
    title: "Vytvoit novou penenku"
  },
  password: {
    label: "Heslo pro obnoven",
    repeatPlaceholder: "Zopakujte heslo pro obnoven"
  },
  walletName: {
    label: "Nzev penenky"
  }
}, seedRestore$h = {
  error: {
    e200: "Obnoven penenky ze zlohy vyaduje microSD kartu."
  },
  info: {
    description1: 'Vlote microSD kartu do BitBoxu a kliknte na tlatko "Pokraovat".',
    description2: 'Vyberte zlohu a kliknte na tlatko "Obnovit".',
    description3: "Zadejte heslo pro obnoven",
    description4: "Je zapoteb potvrdit, abyste si uvdomili, e nesprvn heslo vytvo jinou penenku.",
    title: "Jak obnovit penenku ze zlohy"
  }
}, send$j = {
  abort: "Transakce byla zruena.",
  address: {
    label: "Adresa pijemce",
    placeholder: "Zadejte adresu"
  },
  amount: {
    label: "stka",
    placeholder: "Zadejte stku"
  },
  availableBalance: "Dostupn zstatek",
  button: "Pekontrolovn",
  coincontrol: {
    address: "Adresa",
    outpoint: "Outpoint",
    title: "Odeslat z outputu"
  },
  confirm: {
    "selected-coins": "Vybran mince",
    title: "Potvrte a odelete transakci",
    total: "Celkem"
  },
  error: {
    erc20InsufficientGasFunds: "Zd se, e nemte dostatek ether na zaplacen tto ERC20 transakce. Ujistte se prosm, e mte v penence dostatek ether.",
    feeTooLow: "poplatek pli nzk",
    feesNotAvailable: "Nelze odhadnout poplatky",
    insufficientFunds: "nedostatek finannch prostedk",
    invalidAddress: "neplatn adresa",
    invalidAmount: "neplatn stka",
    invalidData: "neplatn data"
  },
  fee: {
    customPlaceholder: "Zadejte stku",
    label: "Sov poplatek",
    placeholder: "Nen dostupn"
  },
  feeTarget: {
    customLabel: "Ve poplatku",
    customLabel_eth: "Gas cena",
    description: {
      economy: "4 hodiny (24 blok)",
      economy_eth: "30 minut nebo mn",
      economy_ltc: "1 hodina (24 blok)",
      high: "20 minut (2 bloky)",
      high_eth: "30 sekund nebo mn",
      high_ltc: "5 minut (2 bloky)",
      low: "2 hodiny (12 blok)",
      low_eth: "5 minut nebo mn",
      low_ltc: "30 minut (12 blok)",
      normal: "1 hodina (6 blok)",
      normal_eth: "2 minuty nebo mn",
      normal_ltc: "15 minut (6 blok)"
    },
    estimate: "Odhadovan as potvrzen:",
    label: {
      custom: "Vlastn",
      economy: "sporn",
      high: "Vysok",
      low: "Nzk",
      normal: "Normln"
    },
    placeholder: "Vpoet poplatku"
  },
  maximum: "Poslat ve",
  maximumSelectedCoins: "Poslat vybran mince",
  noFeeTargets: "Odhady ve poplatk nejsou v souasn dob k dispozici. Zkuste to prosm pozdji nebo zadejte vlastn poplatek.",
  priority: "Priorita",
  scanQR: "Naskenujte QR kd",
  signprogress: {
    description: "Jedn se o transakci obsahujc velk mnostv dat. Chcete-li transakci pln podepsat, budete vyzvni k potvrzen {{steps}}krt.",
    label: "Prbh"
  },
  success: "Transakce byla podepsna a odeslna.",
  title: "Poslat {{accountName}}",
  toggleCoinControl: "Pepnout na coin control",
  transactionDetails: "Detaily transakce"
}, settings$i = {
  about: "O aplikaci",
  accounts: "ty",
  advancedSettings: "Pokroil nastaven",
  appearance: "Vzhled",
  electrum: {
    add: "Pidat server",
    "add-server": "Pidat",
    check: "Kontrola",
    checkFailed: "Kontrola selhala",
    checkSuccess: "spn navzno spojen s {{host}}",
    checking: "Kontroluji",
    "download-cert": "Sthnout vzdlen certifikt",
    "remove-server": "Odstranit",
    removeConfirm: "Odstranit {{server}}?",
    reset: "Obnovit do zkladnho nastaven",
    resetConfirm: "Chcete odebrat vechny servery a nainstalovat vchoz servery?",
    servers: "Servery",
    step1: "1",
    "step1-text": "Zadejte endpoint.",
    step2: "2",
    "step2-text": "Zadejte certifikt etzce certifikt serveru. Ppadn sthnte vzdlen certifikt a vizuln jej porovnejte.",
    "step2-text-tcp": "Pokud nechcete pouvat TLS, mete tento krok peskoit.",
    step3: "3",
    "step3-text": "Zkontrolujte pipojen a pidejte server.",
    step4: "4",
    "step4-text": "Restartujte penenku. Pokud neodstrante vchoz servery, bude v vlastn uzel pidn jako nadbyten.",
    "title-btc": "Bitcoinov Electrum servery",
    "title-ltc": "Litecoin Electrum servery",
    "title-tbtc": "Bitcoin Testnet Electrum servery",
    "title-tltc": "Litecoin Testnet Electrum servery"
  },
  expert: {
    coinControl: "Aktivovat coin control",
    electrum: {
      description: "Mete se pipojit ke svmu vlastnmu Electrum uzlu (full node).",
      title: "Pipojte svj vlastn uzel (full node)"
    },
    fee: "Aktivovat vlastn poplatky",
    setProxyAddress: "Nastavit adresu proxy",
    title: "Expertn nastaven",
    useProxy: "Aktivovat tor proxy",
    useSats: "Zobrazit hodnoty BTC v satoshi"
  },
  header: {
    home: "Dom"
  },
  info: {
    "out-of-date": "K dispozici je nov aktualizace",
    title: "Info",
    "up-to-date": "Vae aplikace je aktuln",
    version: "Verze aplikace"
  },
  restart: "Restartujte BitBoxApp, aby se zmny projevily.",
  services: {
    title: "Sluby"
  },
  success: "Aby se zmny projevily, odpojte a znovu pipojte BitBox.",
  title: "Nastaven"
}, setup$h = "Nastaven zazen", sidebar$i = {
  buy: "Koupit krypto",
  device: "Spravovat zazen",
  leave: "Odejt",
  settings: "Nastaven"
}, success$o = {
  create: {
    info1: "Vae penenka byla bezpen zlohovna na microSD kartu. Vyjmte ji a uschovejte v bezpe.",
    info2: "Vytvoili jste bezpen heslo zazen, kter odemyk BitBox.",
    info3: "Pro svou penenku jste si vytvoili bezpen heslo pro obnoven, kter odemkne vae prostedky a obnov vae zlohy.",
    summary: "Zde je shrnut toho, co jste udlali",
    title: "Hotovo"
  },
  getstarted: "Zante",
  restore: {
    summary: "spn jste obnovili penenku ze zlohy.",
    title: "Hotovo"
  }
}, transaction$i = {
  confirmation: "Konfirmace",
  details: {
    activity: "Pehled aktivit",
    address: "Adresa",
    amount: "stka",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "stka ve fiatu",
    fiatAtTime: "Fiat v dob transakce",
    status: "Stav",
    type: "Typ"
  },
  explorer: "ID transakce",
  explorerTitle: "Otevt v externm block exploreru",
  fee: "Poplatek",
  fiatHistorical: "Historick",
  gas: "Gas",
  note: {
    edit: "Upravit poznmku",
    save: "Uloit poznmku"
  },
  pending: "ekajc transakce",
  size: "Velikost",
  status: {
    complete: "Dokonen",
    failed: "Nespn",
    pending: "ekajc"
  },
  tx: {
    received: "Pijata na",
    sent: "Odeslna na"
  },
  vsize: "Virtuln velikost",
  weight: "Vha"
}, transactions$h = {
  errorLoadTransactions: "Pi natn transakc dolo k chyb",
  placeholder: "Zatm dn transakce."
}, unknownError$h = "Nastala neznm chyba: {{errorMessage}}", unlock$h = {
  description: "Pro odemknut zadejte heslo zazen.",
  error: {
    e109_normal: "Nesprvn heslo. Zbv jet {{remainingAttempts}} pokus, ne bude zazen resetovno.",
    e109_touch: "$t(unlock.error.e109_normal) Dal pihlen vyaduje podren dotykovho tlatka.",
    e113: "Vzhledem k mnoha pokusm o pihlen vyaduje dal pihlen podren dotykovho tlatka po dobu 4 sekund."
  },
  input: {
    label: "Heslo zazen",
    placeholder: "Zadejte heslo zazen pro odemknut"
  },
  unlocking: "Odemykn..."
}, upgradeFirmware$i = {
  button: "Aktualizovat firmware",
  description: "Chcete aktualizovat firmware z {{currentVersion}} verze na {{newVersion}}?",
  label: "V BitBox vyaduje upgrade firmwaru.",
  locked: "Chcete-li provst upgrade z {{currentVersion}} na {{newVersion}}, provete dlouh dotyk.",
  title: "Upgradovat firmware",
  unlocked: "Bootloader je odemen. Chcete-li pokraovat, prosm:",
  unlocked1: "Odpojte a znovu zapojte v Bitbox",
  unlocked2: "Po optovnm zapojen vaeho BitBoxu se rozsvt LED dioda.",
  unlocked3: "Kdy se rozsvt LED dioda, klepnte na dotykov tlatko"
}, walletConnect$b = {
  connect: {
    button: "Pipojit",
    dappLabel: "Zadejte URI adresu dapp",
    invalidPairingUri: "Neplatn provn uri"
  },
  dashboard: {
    allSessions: "Vechny relace",
    disclaimer: "Walletconnect je protokol pro pipojen k Dapps zaloenm na Ethereu. Tyto dapps jsou provozovny slubami tetch stran, take se pipojujte pouze k dapps, kterm dvujete, a vdy se ujistte, e vte, co podepisujete pi provdn transakce.",
    newConnection: "Nov pipojen",
    noConnectedSessions: "V tto chvli nejsou k dapps pipojeny dn ty."
  },
  invalidPairingChain: "Chyba pi schvalovn provn. Ujistte se, e pouvte jednu z podporovanch st: {{chains}}",
  pairingRequest: {
    approve: "Schvlit pipojen",
    reject: "Odmtnout",
    title: "Nov poadavek na pipojen od"
  },
  pairingSuccess: "Dapp se spn pipojil. Pokraovat mete na dapp webu",
  signingRequest: {
    account: "et",
    chain: "S",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Nepodailo se zpracovat data",
    decodeError: "Zprvu se nepodailo dekdova",
    method: {
      sendTransaction: "Podepite a odelete transakci",
      signMessage: "Podepsat zprvu",
      signTransaction: "Podepsat transakci",
      signTypedData: "Podepite zadan data"
    },
    successfullySigned: "dost byla spn podepsna",
    walletConnectRequest: "dost o pipojen k WalletConnect"
  },
  useNewUri: "Tento URI ji byl pouit k pokusu o pipojen. Pouijte prosm nov URI.",
  walletConnect: "WalletConnect"
}, warning$n = {
  receivePairing: 'Sprujte BitBox, abyste mohli bezpen ovit adresu. Pejdte na "Spravovat zazen" v postrannm panelu.',
  sdcard: "MicroSD kartu mjte uloenou oddlen od BitBoxu, pokud ovem nechcete spravovat zlohy.",
  sendPairing: 'Sprujte prosm BitBox a bezpen ovte daje o transakci. Pejdte na "Spravovat zazen" v postrannm panelu.'
}, welcome$h = {
  connect: "Pipojte BitBox02",
  getStarted: "Zanme instalac firmwaru na v BitBox02.",
  insertBitBox02: "Pro BitBox02 klepnte na zazen a pokraujte.",
  insertDevice: "Pipojte sv zazen a zante",
  title: "Vtejte"
}, appTranslationsCS = {
  account: account$h,
  accountInfo: accountInfo$h,
  accountSummary: accountSummary$h,
  addAccount: addAccount$i,
  aopp: aopp$b,
  app: app$h,
  auth: auth$a,
  backup: backup$h,
  bb02Bootloader: bb02Bootloader$h,
  bitbox: bitbox$h,
  bitbox02Interact: bitbox02Interact$h,
  bitbox02Settings: bitbox02Settings$h,
  bitbox02Wizard: bitbox02Wizard$h,
  blink: blink$h,
  bootloader: bootloader$h,
  button: button$l,
  buy: buy$d,
  changePin: changePin$h,
  chart: chart$d,
  checkSDcard: checkSDcard$h,
  clickHere: clickHere$h,
  confirm: confirm$j,
  confirmOnDevice: confirmOnDevice$h,
  connectKeystore: connectKeystore$a,
  darkmode: darkmode$b,
  device: device$h,
  deviceLock: deviceLock$h,
  deviceSettings: deviceSettings$h,
  deviceTampered: deviceTampered$h,
  dialog: dialog$i,
  error: error$d,
  fiat: fiat$j,
  footer: footer$j,
  generic: generic$d,
  genericError: genericError$h,
  goal: goal$h,
  guide: guide$i,
  headerssync: headerssync$h,
  hiddenWallet: hiddenWallet$h,
  initialize: initialize$h,
  invalidFormat: invalidFormat$h,
  language: language$i,
  legacyhiddenwallet: legacyhiddenwallet$h,
  loading: loading$h,
  manageAccounts: manageAccounts$b,
  mobile: mobile$c,
  newSettings: newSettings$a,
  note: note$d,
  notification: notification$h,
  pairing: pairing$h,
  passphrase: passphrase$b,
  password: password$h,
  random: random$i,
  receive: receive$j,
  reset: reset$h,
  securityInformation: securityInformation$h,
  seed: seed$h,
  seedRestore: seedRestore$h,
  send: send$j,
  settings: settings$i,
  setup: setup$h,
  sidebar: sidebar$i,
  success: success$o,
  transaction: transaction$i,
  transactions: transactions$h,
  unknownError: unknownError$h,
  unlock: unlock$h,
  upgradeFirmware: upgradeFirmware$i,
  walletConnect: walletConnect$b,
  warning: warning$n,
  welcome: welcome$h
}, account$g = {
  disconnect: "Verbindung unterbrochen. Erneut verbinden... ",
  export: "Export",
  exportTransactions: "Exportiere Transaktionen im Download Ordner als CSV Datei",
  fatalError: "Ein unerwarteter Fehler ist aufgetreten.",
  incoming: "Eingehend",
  initializing: "Informationen werden von der Blockchain geladen",
  maybeProxyError: "Tor-Proxy aktiviert. Stelle sicher, dass Tor-Proxy ordnungsgem ausgefhrt wird, oder deaktiviere die Proxy-Einstellung.",
  reconnecting: "Verbindung abgebrochen, neue Verbindung wird aufgebaut",
  syncedAddressesCount: "{{count}} Adressen gescannt"
}, accountInfo$g = {
  address: "Adresse",
  buyCTA: {
    buy: "{{unit}} kaufen",
    buyCrypto: "Krypto kaufen",
    information: {
      looksEmpty: "Sieht so aus, als wre dieses Wallet leer.",
      start: "Lege los, indem du einige Coins auf das Wallet einzahlst oder direkt in der BitBoxApp kaufst."
    }
  },
  extendedPublicKey: "Erweiterter Public Key",
  label: "Konto Informationen",
  scriptType: "Script-Typ",
  title: "Konto Informationen",
  verify: "Auf Gert besttigen",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy-P2PKH erweiterten Public Key anzeigen",
    p2tr: "Taproot anzeigen",
    p2wpkh: "Native Segwit anzeigen",
    "p2wpkh-p2sh": "lteren Segwit erweiterten ffentlichen Schlssel anzeigen"
  },
  xpubTypeInfo: "Derzeit wird der {{scriptType}} erweiterte Public Key angezeigt ({{current}} von {{numberOfXPubs}})"
}, accountSummary$g = {
  availableBalance: "Kontostand",
  balance: "Saldo",
  exportSummary: "Kontozusammenfassung als CSV Datei zum Download Ordner exportieren",
  fiatBalance: "Fiat Kontostand",
  name: "Konto Name",
  noAccount: "Keine Konten verfgbar",
  subtotalWithCoinName: "Summe ({{coinName}})",
  title: "Kontenbersicht",
  total: "Gesamt",
  transactionHistory: "Transaktionsbersicht"
}, addAccount$h = {
  chooseName: {
    nextButton: "Konto hinzufgen",
    step: "Konto benennen",
    title: "Benenne dein Konto"
  },
  selectCoin: {
    nextButton: "Weiter",
    step: "Coin whlen",
    title: "Kryptowhrung whlen"
  },
  success: {
    addAnotherAccount: "Neues Konto hinzufgen",
    message: "<strong>{{accountName}}</strong> wurde zu deinen Konten hinzugefgt.",
    nextButton: "Fertig",
    step: "Erledigt",
    title: "Konto hinzugefgt"
  },
  title: "Konto hinzufgen"
}, aopp$a = {
  addressRequest: "{{host}} fordert eine Empfangsadresse an.",
  addressRequestWithLogo: "fordert eine Empfangsadresse an",
  banner: "Adressanfrage in Bearbeitung. Bitte verbinde dein Gert um fortzufahren.",
  errorTitle: "Fehler whrend Adressanfrage",
  labelAddress: "Adresse",
  labelMessage: "Nachricht",
  reverifyInfoText: "Adresse berprfen",
  signing: "Signiere die Nachricht auf deiner BitBox um fortzufahren",
  success: {
    message: "Weiter auf {{host}}",
    title: "Adresse erfolgreich bermittelt"
  },
  syncing: "Konto wird synchronisiert, bitte warten.",
  title: "Adressanfrage"
}, app$g = {
  upgrade: "Eine neue Version der App ist verfgbar! Bitte aktualisiere von {{current}} auf {{version}}."
}, auth$9 = {
  authButton: "Authentifizieren",
  title: "Bitte authentifiziere dich, um fortzufahren"
}, backup$g = {
  check: {
    checking: "Backup wird geprft",
    confirmTitle: "Backup berprfen",
    notOK: "Dein Backup entspricht NICHT deiner aktuellen Wallet.",
    ok: "Erfolg! Dein Backup entspricht deiner aktuellen Wallet.",
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Wiederherstellungspasswort",
      showLabel: "Wiederherstellungspasswort"
    },
    success: "Backup erfolgreich berprft:",
    title: "Backup berprfen"
  },
  create: {
    alreadyExists: "Du hast schon ein gltiges Backup. Willst du trotzdem ein weiteres Backup erstellen?",
    fail: "Erstellung des Backups FEHLGESCHLAGEN!",
    info: "Bitte gib dein Wiederherstellungspasswort ein, um deine aktuelle Wallet zu verifizieren.",
    name: {
      label: "Backup Name",
      placeholder: "Bitte benenne dein Backup."
    },
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Bitte gib dein Wiederherstellungspasswort ein."
    },
    title: "Backup erstellen",
    verificationFailed: "Das Wiederherstellungspasswort entspricht NICHT der aktuellen Wallet. Das Backup wurde erstellt. Bitte nutze Backup prfen um dein Wiederherstellungspasswort erneut zu berprfen. "
  },
  description: "Whle eine  <strong>Wallet Backup</strong> Datei aus.",
  insert: "Bitte stecke die Micro-SD-Karte ein um deine Backups zu verwalten.",
  insertButton: "Ich habe die Mikro-SD-Karte eingesteckt.",
  list: "Deine Backups auf der microSD Karte",
  noBackups: "Es befinden sich keine Backups auf der microSD Karte.",
  restore: {
    confirmTitle: "Von Backup wiederherstellen",
    error: {
      e200: "microSD Karte nicht gefunden",
      general: "Fehler beim Wiederherstellen von Backup"
    },
    password: {
      label: "Wiederherstellungspasswort oder verstecktes Wiederherstellungspasswort. ",
      placeholder: "Wiederherstellungspasswort",
      repeatPlaceholder: "Wiederherstellungspasswort erneut eingeben",
      showLabel: "Wiederherstellungspasswort"
    },
    restoring: "Wiederherstellen des Backups",
    selectedBackup: "<strong>{{backupName}}</strong>, erstellt am {{createdDateTime}}, wird wiederhergestellt.",
    title: "Wiederherstellen",
    understand: "Ich habe verstanden, dass ein falsches Wiederherstellungspasswort eine neue/andere Wallet erstellt."
  },
  showMnemonic: {
    description: `Dir werden Wiederherstellungswrter angezeigt, die ein Backup deiner Wallet sind. Schreibe diese auf ein Stck Papier. 

<strong>Bewahre diese Wrter nicht digital auf und mache kein Foto von ihnen.</strong>

<strong>Sprich die Wrter nicht laut aus.</strong>

<strong>Dieses Backup ist nicht Passwort geschtzt.</strong>

Nachdem du die Wrter aufgeschrieben hast wirst du gefragt werden sie nochmals zu besttigen.
`,
    title: "Recovery-Wrter anzeigen",
    warning: "<strong>Teile deine Wiederherstellungswrter niemals mit irgendjemandem.</strong> Deine Wiederherstellungswrter ermglichen vollen Zugriff zu deinem Wallet . Wenn dich jemand nach deinen Wiederherstellungswrtern fragt, handelt es sich um einen Betrger. Gebe diese nicht weiter!"
  },
  title: "Backups verwalten"
}, bb02Bootloader$g = {
  abort: "Nicht upgraden - Zurck!",
  abort_noUpgrade: "Zurck",
  advanced: {
    label: "Erweiterte Einstellungen",
    toggleShowFirmwareHash: "Zeig mir den Hash der Firmware bei jedem Anstecken der BitBox"
  },
  flipscreen: "Bildschirm spiegeln",
  orientation: "Ist der Bildschirm kopfber?",
  success: "Upgrade erfolgreich. In {{rebootSeconds}}  geht es weiter....",
  success_install: "Installation erfolgreich! Es geht weiter in {{rebootSeconds}} Sekunden..."
}, bitbox$g = {
  error: {
    e10000: "Aktuelles Gertepasswort ist falsch.",
    e10001: "Fehler beim ndern des Gertepassworts",
    e102: "Das Passwort muss aus 4 Zeichen bestehen.",
    e112: "Das versteckte Gertepasswort und das normale Gertepasswort knnen nicht identisch sein."
  }
}, bitbox02Interact$g = {
  confirmDate: "Besttige das heutige Datum auf deiner BitBox02",
  confirmDateText: "Dieses Datum wird mit deinem Backup gespeichert. ",
  confirmName: "Besttige den Namen auf deiner BitBox02",
  confirmWords: "Notiere die {{amount}} Wiederherstellungswrter von deiner BitBox02",
  confirmWordsText: "Danach fordert dich die BitBox02 auf, jedes Wort zu besttigen, um zu berprfen, ob dein Backup korrekt ist.",
  followInstructions: "Bitte folge den Anweisungen auf deiner BitBox02.",
  followInstructionsMnemonic: "Bitte folge den Anweisungen auf deiner BitBox02 um deine Wallet mit deinen Wiederherstellungswrtern wieder herzustellen.",
  followInstructionsMnemonicTitle: "Mit Wiederherstellungs-Wrtern wiederherstellen"
}, bitbox02Settings$g = {
  deviceName: {
    current: "Aktueller Gertename",
    error: "Gertename konnte nicht festgelegt werden",
    error_104: "Die Besttigung des Gertenamens wurde auf dem Gert abgebrochen.",
    input: "BitBox02 Name",
    placeholder: "Neuer Gertename",
    title: "BitBox02 Namen einstellen"
  },
  gotoStartupSettings: {
    description: "Dadurch wird deine BitBox02 neu gestartet und die Starteinstellungen angezeigt.",
    title: "Gehe zu den Starteinstellungen"
  }
}, bitbox02Wizard$g = {
  advanced: {
    button: "Erweiterte Optionen",
    outOfDate: "Die Firmware ist fr diese Funktion zu veraltet",
    seed12WordInfo: "Bitte beachte, dass die Anzahl der Wrter nach dem Erstellen des Wallets nicht mehr gendert werden kann.",
    seed12WordLabel: "Erstelle einen Seed mit 12 Wrtern statt mit 24 Wrtern",
    seed12WordText: "Standardmig verwendet die BitBox02 einen 24-Wrter-Seed. Beide Seed-Lngen sind in der Praxis sicher gegen Brute-Forcing. Einige Benutzer bevorzugen mglicherweise die Bequemlichkeit eines 12-Wrter-Seeds.",
    skipSDCardLabel: "berspringe die Sicherung auf der MicroSD-Karte und notiere stattdessen die Wiederherstellungswrter",
    skipSDCardText: "Du hast jederzeit die Mglichkeit, nach der Einrichtung ein Backup auf der MicroSD-Karte zu erstellen und deine Wiederherstellungswrter aufzuschreiben. Dies kannst ber die Einstellungen tun.",
    title: "Erweiterte Backup-Optionen"
  },
  attestationFailed: "Echtheitsprfung fehlgeschlagen. Bitte stecke die BitBox aus und wieder ein.  Bitte kontaktiere support@bitbox.swiss, falls dieses Problem weiterhin besteht.",
  backup: {
    point1: "Whle ein Backup von der microSD Karte aus",
    point2: "Setze ein Passwort fr dein Gert",
    restoreText: "Ok, lass uns deine Wallet von deinem Backup wiederherstellen!",
    text1: "Perfekt, dein BitBox02 Passwort ist jetzt festgelegt und deine Wallet wurde erstellt. Jetzt ist es Zeit ein Backup der Wallet zu erstellen. Bitte stelle dazu sicher, dass die microSD Karte eingesteckt ist. ",
    text2: 'Sobald du "Backup erstellen" geklickt hast folge bitte den Anweisungen auf deiner BitBox um ein Backup zu erstellen. ',
    text3: "Nachdem das Backup erstellt wurde, bewahre die microSD-Karte bitte an einem <strong>sicheren Ort auf und stecke die microSD-Karte niemals in ein anderes Gert, das nicht eine BitBox ist. </strong> Das Backup auf der microSD-Karte ist nicht Passwort-geschtzt!",
    userConfirmation1: "Ich muss mein Backup an einem sicheren Ort aufbewahren.",
    userConfirmation2: "Mein Backup ist nicht passwortgeschtzt. Jeder, der Zugriff darauf hat, kann auf meine Wallet zugreifen.",
    userConfirmation3: "Wenn ich meine BitBox02 verliere oder beschdige, ist die Wiederherstellung von meinem Backup der einzige Weg wieder Zugriff auf mein Guthaben zu bekommen. ",
    userConfirmation4: "Sollte ich sowohl meine BitBox02 als auch mein Backup verlieren oder zerstren ist der Zugang zu meinen Coins fr immer verloren. ",
    userConfirmation5: "Ich darf meine microSD Karte nicht in einen Computer, Handy, Drucker oder anderes (nicht BitBox02) Gert stecken. ",
    userConfirmation5mnemonic: "Ich sollte meine Wiederherstellungswrter nicht in einen Computer, ein Telefon, einen Drucker oder irgendein anderes Gert als eine BitBox02 stecken."
  },
  create: {
    button: "Gert bennenen & weiter",
    info: "Hier sind die Schritte, die wir dazu durchlaufen werden:",
    inputTitle: "Wallet Name ",
    point1: "Gert benennen",
    point2: "Gertepasswort einstellen",
    point3: "Backup erstellen",
    text: "Ok, lass uns eine neue Wallet erstellen!"
  },
  createBackupAborted: "Backup-Erstellung abgebrochen.",
  createBackupFailed: "Erstellung des Backups fehlgeschlagen, erneut versuchen.",
  initialize: {
    passwordText: "Lass uns nun ein Passwort fr deine BitBox festlegen. Schaue dir die Animation unten an und benutze dann die Touch Slider auf den Seiten deiner BitBox, um ein Passwort einzugeben. ",
    passwordTitle: "Setze ein Passwort fr deine BitBox",
    text: "BitBox02 erfolgreich gekoppelt. Jetzt initialisieren wir deine BitBox02. Whle zuerst aus, ob du eine neue Wallet erstellen oder von einem Backup wieder herstellen mchtest.  <strong>Wenn du von einem Backup wieder herstellen mchtest, stelle sicher, dass deine microSD Karte in deiner BitBox02 eingesteckt ist.</strong>",
    tip: "Bitte fahre in einer sichern Umgebung fort. ",
    title: "Initialisiere deine BitBox"
  },
  insertSDCard: "<strong>Bitte stelle sicher, dass du die microSD Karte in der BitBox02 eingesteckt hast.</strong>",
  noPasswordMatch: "Passwrter stimmen nicht berein. Bitte versuche es erneut.",
  pairing: {
    failed: "Kopplungscode nicht besttigt. Bitte BitBox02 aus und wieder ein stecken.",
    paired: "Kopplungscode besttigt. Bitte fahre fort.",
    title: "Kopplungscode besttigen",
    unpaired: "Eine nicht gekoppelte BitBox02 wurde erkannt. Bitte besttige, dass der Kopplungscode mit dem auf der BitBox02 bereinstimmt. "
  },
  restoreFromMnemonic: {
    e104: "Die Wiederherstellung durch Wiederherstellungswrter wurde abgebrochen.",
    failed: "Wiederherstellung von Wiederherstellungswrtern fehlgeschlagen. Bitte versuche es erneut."
  },
  stepBackup: {
    beforeProceed: "Bevor du fortfhrst, lies bitte die folgenden wichtigen Sicherheitsaspekte:",
    createBackup: "Du erstellst jetzt ein Backup auf deiner microSD-Karte.",
    createBackupMnemonic: "Du wirst nun die Wiederherstellungswrter notieren."
  },
  stepBackupSuccess: {
    fundsSafe: "Beachte bitte Folgendes, um deine Coins zu schtzen:",
    title: "Backup wiederhergestellt!"
  },
  stepConnected: {
    unlock: "BitBox02 Passwort eingeben "
  },
  stepCreate: {
    description: "Dieser Name wird als Gertename und fr das Backup verwendet.",
    nameLabel: "BitBox02 Name",
    namePlaceholder: "Meine BitBox02",
    title: "Whle BitBox02 Name",
    toastMicroSD: "Bitte stelle sicher, dass deine microSD Karte in die BitBox02 eingesteckt ist. "
  },
  stepCreateSuccess: {
    removeMicroSD: "Bitte entnehme deine microSD Karte und bewahre diese an einem sicheren Ort auf.",
    storeMnemonic: "Bitte bewahre deine Wiederherstellungs-Wrter an einem sicheren Ort auf.",
    success: "Dein Backup wurde erfolgreich erstellt."
  },
  stepInsertSD: {
    insertSDCard: "Bitte stecke die microSD Karte in deine BitBox02 um fortzufahren",
    insertSDcardTitle: "MicroSD Karte einstecken"
  },
  stepPassword: {
    e104: "Das Festlegen des Passworts wurde abgebrochen.",
    title: "BitBox02 Passwort whlen",
    useControls: "Verwende die Touch Sensoren an den Seiten deiner BitBox02 um ein Passwort zu whlen."
  },
  stepUninitialized: {
    create: "Ich mchte eine neue BitBox02 einrichten.",
    restore: "Ich mchte meine Wallet von einem Backup wiederherstellen.",
    restoreMicroSD: "Von microSD Karte wiederherstellen",
    restoreMnemonic: "Von Wiederherstellungswrtern wiederherstellen",
    title: "BitBox02 einrichten"
  },
  success: {
    text: `Hurra! Deine BitBox02 ist bereit.

Fr weitere Informationen klicke auf das Fragezeichen Symbol in der oberen rechten Ecke. `,
    title: "Es kann los gehen!"
  }
}, blink$g = {
  button: "Blinken"
}, bootloader$g = {
  button: "Firmware jetzt aktualisieren",
  button_install: "Firmware jetzt installieren",
  progress: "Aktualisiere: {{progress}}%",
  progress_install: "Installation: {{progress}}%",
  success: "Aktualisierung erfolgreich! Bitte ziehe das Gert ab und stecke es dann wieder ein. Dieses mal brauchst du den Knopf nicht zu berhren. "
}, button$k = {
  abort: "Abbrechen",
  back: "Zurck",
  buy: "Kaufen",
  changepin: "Gertepasswort ndern",
  check: "Backup berprfen",
  continue: "Weiter",
  copy: "Kopieren",
  create: "Erstellen",
  dismiss: "Ausblenden",
  done: "Fertig",
  download: "Herunterladen",
  hiddenwallet: "Versteckte Wallet erstellen",
  next: "Weiter",
  ok: "OK",
  previous: "Zurck",
  receive: "Erhalten",
  restore: "Wiederherstellen",
  select: "Auswhlen",
  send: "Senden",
  unlock: "Entsperren",
  update: "Update",
  upgrade: "Aktualisieren"
}, buy$c = {
  exchange: {
    bankTransfer: "berweisung",
    bestDeal: "Bestes Angebot",
    creditCard: "Kreditkarte",
    fast: "Schnell",
    fee: "Gebhr",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankberweisung: {{fee}}%",
          creditDebitCard: "Kredit-/Debitkarte: {{fee}}%",
          learnMore: "Erfahre mehr ber Moonpay",
          title: "Gebhren"
        },
        fullCurrenciesList: "Eine vollstndige Liste der Whrungen findest du hier",
        payment: {
          asteriskText: "* Nicht verfgbar fr Einwohner der USA",
          bankTransfer: "Bankberweisung*",
          bankTransferDetails: {
            pix: "PIX (BR-Transaktionen nur in Brasilien)",
            sepa: "SEPA und SEPA Instant (EUR-Transaktionen nur in SEPA-Lndern)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Grobritannien)"
          },
          creditDebitCard: "Kredit-/Debitkarte",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa und Maestro"
          },
          learnMore: "Weitere Details zu den Zahlungsmethoden findest du hier",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Untersttzt alle gngigen Fiat-Whrungen: USD, EUR, CHF und mehr."
      },
      pocket: {
        fees: {
          info: "Bankberweisung: {{fee}}%",
          title: "Gebhren"
        },
        learnMore: "Erfahre mehr ber Pocket",
        payment: {
          bankTransfer: "Bankberweisung",
          bankTransferDetails: {
            sepa: "SEPA und SEPA Echtzeit (EUR-Transaktionen nur in SEPA-Lndern)",
            sic: "Swiss Interbank Clearing (CHF-Transaktionen nur in CH/LI)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Grobritannien)"
          },
          bankTransferReccuring: "Wie richte ich wiederkehrende Kufe mit einem Dauerauftrag ein?",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Untersttzt europische Whrungen: EUR, GBP und CHF.",
        verification: {
          info: "Identittsprfung nur bei berschreitung der tglichen und jhrlichen Schwellenwerte ntig.",
          link: "Aktuelle Schwellenwerte hier einsehen",
          title: "Identittsprfung"
        }
      },
      region: {
        title: "Whle die Region aus, in der dein Bankkonto registriert ist, um zu sehen, welche Optionen dir zur Verfgung stehen."
      }
    },
    noExchanges: "Leider sind in dieser Region keine Brsen verfgbar.",
    region: "Region",
    selectRegion: "Nicht angegeben",
    title: "{{name}} kaufen "
  },
  info: {
    continue: "Zustimmen und fortfahren",
    crypto: "Krypto",
    disclaimer: {
      intro: [
        "Wir arbeiten mit MoonPay zusammen, damit du mit nur ein paar Klicks ganz einfach {{name}} direkt in der BitBoxApp kaufen kannst. ",
        "MoonPay ist eine vollstndig regulierte Finanzdienstleistungsplattform, die den Kauf von {{name}} in ber 160 Lndern einfach und schnell macht."
      ],
      payment: {
        details: "Du kannst {{name}} ber MoonPay mit den folgenden Zahlungsmethoden kaufen. Mit Kredit- oder Debitkarten geht es sofort und bequem, ist aber aufgrund des erhhten Rckbuchungsrisikos teurer. Wir empfehlen die Verwendung der berweisungsoption fr grere Betrge. Die Mindestgebhr betrgt 4 USD / EUR oder gleichwertig.",
        footnote: "Bitte beachte, dass die Wechselkurse von MoonPay von den in der BitBoxApp verwendeten abweichen knnen, was zu geringfgig unterschiedlichen Betrgen fhren kann.",
        table: {
          "1_description": "Niedrigste Gebhren, kann bis zu 3 Werktage dauern",
          "1_method": "Bankberweisungen (SEPA)",
          "2_description": "Hhere Gebhren, aber schnell und sofort",
          "2_method": "Kredit & Debitkarten",
          description: "Beschreibung",
          fee: "Gebhr",
          method: "Methode"
        },
        title: "Zahlungsmethoden und Gebhren"
      },
      privacyPolicy: "MoonPay-Datenschutzrichtlinie",
      protection: {
        description: "Die BitBoxApp sammelt beim Kauf von {{name}} keine Daten. Die eingehenden Transaktionen werden wie regulre Transaktion behandelt. MoonPay muss einige persnliche Daten sammeln, um funktionieren zu knnen. In deren Datenschutzbestimmungen wird ausfhrlich erlutert, wie mit diesen Daten umgegangen wird.",
        descriptionGeneric: "Die BitBoxApp erhebt beim Kauf von {{name}} keinerlei Daten, die eingehenden Gelder werden wie eine normale Transaktion behandelt. Partnerbrsen mssen jedoch einige Informationen sammeln, um zu funktionieren. Einzelheiten zum Umgang mit Daten kannst du der jeweiligen Datenschutzerklrung entnehmen.",
        title: "Datenschutz"
      },
      security: {
        description: "Wenn du {{name}} ber MoonPay kaufst, dann nutzt du einen externen Dienst. Dieser Dienst liegt auerhalb des Anwendungsbereichs des BitBox02 Sicherheitsbedrohungsmodells und verlsst sich auf die Sicherheit des Gerts, auf dem die BitBoxApp Software luft.",
        descriptionGeneric: "Wenn du {{name}} ber eine Partnerbrse kaufst, nutzt du einen externen Dienst. Dieser Dienst liegt auerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hngt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgefhrt wird.",
        link: "Sicherheitsbedrohungsmodells",
        title: "Sicherheitsmodell"
      },
      title: "Willkommen in deinem One-Stop-Shop zum Kauf von {{name}}"
    },
    next: "Weiter",
    selectLabel: "Konto whlen",
    selectPlaceholder: "Whle einen Coin",
    skip: "Nicht mehr anzeigen",
    title: "{{name}} kaufen "
  },
  pocket: {
    data: {
      link: "Pocket-Datenschutzrichtlinie",
      p1: "Die BitBoxApp sammelt beim Kauf von Bitcoin keine Daten. Die eingehenden Gelder werden wie eine regulre Transaktion behandelt. Pocket muss einige personenbezogene Daten sammeln, um zu agieren. Ihre Datenschutzrichtlinie erklrt im Detail, wie diese Daten verwendet werden.",
      title: "Datenschutz"
    },
    kyc: {
      link: "Pocket-FAQ lesen",
      p1: "Pocket versucht, KYC auf ein Minimum zu beschrnken. Fr Einkufe unter 950 EUR (1000 CHF) pro Tag sind keine zustzlichen Dokumente erforderlich. Fr Kufe ber diesem Betrag musst du einen Anruf bei Pocket vereinbaren, um den erforderlichen KYC/AML-Prozess abzuschlieen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Du kannst Bitcoin sofort mit Pocket per SEPA-berweisung kaufen. Die Gebhr betrgt 1,5 % und die Bitcoin werden so schnell wie mglich nach Eingang der Bankberweisung bei Pocket (normalerweise am selben Tag) auf deiner BitBox hinterlegt.",
      p2: "Bitte beachte, dass die Wechselkurse von Pocket von denen in der BitBoxApp abweichen knnen, was zu leicht unterschiedlichen Betrgen fhren kann.",
      title: "Zahlungsmethoden und Gebhren"
    },
    previousTransactions: "Der Transaktionsverlauf dieses Kontos ist nicht leer. Durch die gemeinsame Nutzung dieses Kontos werden alle vergangenen und zuknftigen Transaktionen fr Pocket sichtbar. Dennoch fortfahren?",
    security: {
      link: "BitBox02 Bedrohungsmodell",
      p1: "Wenn du Bitcoin ber Pocket kaufst, verwendest du einen externen Dienst. Dieser Dienst liegt auerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hngt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgefhrt wird. Wir arbeiten jedoch zusammen, um die Sicherheit zu verbessern, indem wir einen Zwei-Faktor-Authentifizierungsmechanismus verwenden, um deine Empfangs-Adresse zu berprfen.",
      title: "Sicherheitsmodell"
    },
    usedAddress: "Die Adresse {{address}} wurde bereits verwendet. Bitte beginne erneut mit einer neuen Adresse.",
    verifyBitBox02: "Bitte vergewissere dich, dass die Adresse, die du per E-Mail erhalten hast, mit der auf deiner Bitbox angezeigten bereinstimmt. Wenn mglich, solltest du die E-Mail zur besseren Sicherheit auf einem zweiten Gert ffnen.",
    welcome: {
      p1: "Wir arbeiten mit Pocket zusammen, um dir eine nahtlose Mglichkeit zu bieten, Bitcoins direkt in der BitBoxApp zu kaufen. Es sind nur ein paar Klicks.",
      p2: "Pocket ist eine schweizer Plattform, mit der man fast in ganz Europa schnell und einfach Bitcoin kaufen kann (berall dort, wo SEPA-Bankberweisungen untersttzt werden).",
      p3: "Mit Pocket kannst du auch Sparplne ber Dauerauftrge betreiben, sodass du mit Leichtigkeit DCA (Dollar-Cost-Average) durchfhren kannst.",
      title: "Willkommen in deinem One-Stop-Shop fr den Kauf von Bitcoin"
    }
  },
  title: "{{name}} kaufen"
}, changePin$g = {
  newTitle: "Neues Gertepasswort",
  oldLabel: "Aktuelles Gertepasswort"
}, chart$c = {
  dataMissing: "Historische Daten werden gesammelt... gleich fertig.",
  dataOldTimestamp: "Historische Wechselkurse werden aktualisiert. Das Diagramm zeigt nach {{time}} keine Daten mehr an.",
  dataUpdating: "Daten aktualisieren",
  filter: {
    all: "Alles",
    month: "Monat",
    week: "Woche",
    year: "Jahr"
  }
}, checkSDcard$g = "Micro-SD-Karte wird berprft", clickHere$g = "Hier klicken.", confirm$i = {
  abortInfo: "Tippe zum ",
  abortInfoRedText: "abbrechen",
  approveInfo: "4 Sekunden lang halten um zu ",
  approveInfoGreenText: "besttigen",
  info: "Fahre auf deiner BitBox fort.",
  infoWhenPaired: "Zuerst auf deinem gepaarten Mobiltelefon und dann auf deiner BitBox"
}, confirmOnDevice$g = "Bitte besttige auf deinem Gert.", connectKeystore$9 = {
  promptNoName: "Bitte verbinde deine BitBox02 um fortzufahren",
  promptWithName: 'Bitte verbinde deine BitBox02 mit dem Namen {{name}}" um fortzufahren'
}, darkmode$a = {
  toggle: "Dark mode"
}, device$g = {
  appUpradeRequired: "Deine BitBox ist mit dieser Desktopanwendung nicht kompatibel. Bitte lade die neueste Version herunter und installiere diese..",
  keystoreConnected: "Verbundenes Wallet"
}, deviceLock$g = {
  button: "Zwei-Faktor-Autorisierung (2FA) aktivieren",
  condition1: "Hast du ein Backup?",
  condition2: "Funktioniert die Verifikation auf deinem Smartphone?",
  condition3: 'Wenn du 2FA aktivierst wird "Backups verwalten", "Versteckte Wallet erstellen" und "Mit Smartphone App" koppeln deaktiviert. Um 2FA zu deaktivieren muss das Gert auf Werkseinstellungen zurck gesetzt werden.   ',
  confirm: `Zwei-Faktor Authentifizierung (2FA) aktivieren
`,
  title: "Zwei-Faktor-Autorisierung (2FA) aktivieren"
}, deviceSettings$g = {
  backups: {
    manageBackups: {
      description: "Erstelle oder berprfe das MicroSD-Karten-Backup."
    },
    showRecoveryWords: {
      description: "Zeige und berprfe die Wiederherstellungswrter."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "Die BitBoxApp prft, ob dein Gert authentisch ist."
    },
    deviceName: {
      description: "ndere den Namen deines Gerts."
    },
    rootFingerprint: {
      description: "Der Root-Fingerabdruck ist eine eindeutige Kennung fr das aktuell verwendete Wallet. Es kann dir helfen, zwischen verschiedenen Wallets zu unterscheiden, falls du Passphrasen verwendest."
    },
    securechip: {
      description: "Das Modell des Secure-Chips."
    },
    title: "Gerteinformationen"
  },
  expert: {
    factoryReset: {
      description: "Setze dein Gert auf die Werkseinstellungen zurck. Dadurch wird das Wallet auf deiner BitBox02 gelscht!",
      title: "Auf Werkseinstellungen zurcksetzen"
    },
    goToStartupSettings: {
      description: "Den Bootloader der BitBox02 starten. Dort kannst du den Firmware-Hash aktivieren."
    },
    passphrase: {
      description: "Aktiviere oder deaktiviere die Passphrasen-Funktion.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Verfgbare Version"
    },
    title: "Firmware",
    upToDate: "Dein Gert ist auf dem aktuellen Stand  ",
    upgradeAvailable: "Neues Upgrade verfgbar",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "Echtheitscheck fehlgeschlagen",
      label: "Echtheitsprfung",
      true: "Deine BitBox02 ist echt"
    },
    sdcard: {
      false: "Nicht eingesteckt",
      label: "microSD Karte",
      true: "Eingesteckt"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: `Gerteinformationen werden abgerufen...

`,
  pairing: {
    lock: {
      false: "Deaktiviert",
      label: "Zwei-Faktor Autorisierung (2FA)",
      true: "Eingeschaltet"
    },
    mobile: {
      false: "Geschlossen",
      label: "Smartphone App",
      true: "Offen"
    },
    status: {
      false: "Nicht gekoppelt",
      label: "Status",
      true: "Gekoppelt"
    },
    title: "Zwei-Faktor Autorisierung (2FA)"
  },
  secrets: {
    manageBackups: "Backups verwalten",
    title: "Sicherheit"
  }
}, deviceTampered$g = `Falls deine BitBox mit einem Wiederherstellungspasswort geliefert wurde, beende das Setup SOFORT und kontaktiere den Support. 
SHIFT versendet niemals BitBoxen, die schon ein Passwort haben und wird nie Passwortempfehlungen aussprechen. 
Benutze diese BitBox auf keinen Fall !`, dialog$h = {
  cancel: "Abbrechen",
  confirm: "Besttigen",
  confirmTitle: "Besttigung"
}, error$c = {
  accountAlreadyExists: "Dieses Konto existiert bereits.",
  accountLimitReached: "Konto kann nicht hinzugefgt werden. Die maximale Kontenanzahl fr diese Whrung wurde erreicht.",
  aoppCallback: "Beim bermitteln der Adresse an {{host}} ist ein Fehler aufgetreten.",
  aoppInvalidRequest: "Ungltige Anfrage.",
  aoppNoAccounts: "Es sind keine Konten verfgbar.",
  aoppSigningAborted: "Adressinhaberanfrage wurde abgebrochen.",
  aoppUnknown: "Ein unbekannter Fehler ist aufgetreten.",
  aoppUnsupportedAsset: "Diese Kryptowhrung wird nicht untersttzt.",
  aoppUnsupportedFormat: "Es sind keine Konten verfgbar, die das angeforderte Adressformat untersttzen.",
  aoppUnsupportedKeystore: "Das verbundene Gert kann keine Nachrichten fr diese Kryptowhrung signieren.",
  aoppVersion: "Unbekannte Version.",
  wrongKeystore: "Falsches Wallet verbunden. Bitte verbinde das richtige Gert, zu dem diese Konto gehrt.",
  wrongKeystore2: "Falls du ein optionale Passphrase nutzt, stelle sicher, dass du die richtige Passphrase fr dieses Konto eingegeben hast."
}, fiat$i = {
  default: "Standard",
  setDefault: `{{code}} als Standard speichern
`,
  title: "Whrungen"
}, footer$i = {
  appVersion: "App Version:"
}, generic$c = {
  enabled_false: "Deaktiviert",
  enabled_true: "Aktiviert"
}, genericError$g = "Ein Fehler ist aufgetreten. Falls du Probleme bemerkst, starte die Applikation bitte neu.", goal$g = {
  buttons: {
    create: "Neue Wallet erstellen",
    restore: "Wallet von Backup wiederherstellen "
  },
  paragraph: "Bitte whle eine der folgenden Optionen:",
  step: {
    1: {
      title: "Sicherheitsinformationen"
    },
    2: {
      description: "Passwort",
      title: "Gert"
    },
    "3-create": {
      description: "Neue Wallet erstellen",
      title: "Wallet"
    },
    "3-restore": {
      description: "von einem Backup",
      title: "Wiederherstellen"
    },
    "4-create": {
      title: "Zusammenfassung"
    },
    "4-restore": {
      title: "Zusammenfassung"
    }
  }
}, guide$h = {
  accountDescription: {
    text: "Deine Kontobersicht zeigt deinen Kontostand und deine Transaktionen an. Stbere durch diesen Guide um mehr ber die verschiedenen Kontoarten zu erfahren. ",
    title: "Was wird mir auf dieser Seite angezeigt?"
  },
  accountFiat: {
    text: "Ja, du kannst auf das Whrungssymbol klicken, um zwischen den verschiedenen Whrungen zu wechseln. Die verfgbaren Whrungen kannst du in den Einstellungen anpassen.",
    title: "Knnen auch andere Wechselkurse angezeigt werden?"
  },
  accountIncomingBalance: {
    text: "Eingehend summiert alle eingehenden Transaktionen, die noch nicht besttigt sind. ",
    title: 'Was bedeutet "Eingehend"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: `Jeder xpub ist an den angezeigten "Typ" gebunden: Entweder "Native SegWit (bech32)", "Wrapped segwit" oder "Taproot". Dies sind Skripttypen, die von {{coinName}} verwendet werden. Die BitBoxApp kombiniert sie und untersttzt mehrere Skripttypen im selben Konto. Da jeder Skripttyp einen anderen xpub verwendet, gibt es mehrere xpubs pro Konto.

Wenn du nur auf den Standardadressen empfngst, bentigst du nur den "bech32" xpub. Wenn du jedoch auch Coins auf "kompatible Adresse" erhltst, werden diese auf dem xpub "wrapped SegWit" angezeigt.`,
      title: "Warum gibt es mehrere xpubs?"
    },
    privacy: {
      text: `Fr dieses Konto zeigt der erweiterte ffentliche Schlssel die gesamte Transaktionshistorie, deinen Kontostand und alle zuknftigen Transaktionen an. Aber der xpub erlaubt niemandem, deine Coins auszugeben.

Wenn du jemandem ein xpub gibst, solltest du dir bewusst sein, dass diese Person oder Firma alle anderen Transaktionen desselben Kontos sehen kann. Daher ist es eine gute Idee, dieses Konto nur fr diesen Zweck zu verwenden und andere Coins in anderen Konten zu halten.`,
      title: "Muss ich mein xpub geheim halten?"
    },
    verify: {
      text: "Ja, es ist immer eine gute Idee, deinen xpub zu berprfen. Wenn jemand anderes Empfangsadressen von diesem xpub generiert, um dir Coins zu senden, ist dies besonders wichtig. Du musst ihn auf deiner BitBox berprfen, um sicherzustellen, dass dieser xpub dir gehrt. Andernfalls knnten alle Coins an die falschen Adressen gehen.",
      title: "Muss ich den xpub auf dem Gert berprfen?"
    },
    xpub: {
      text: `Ein erweiterter ffentlicher Schlssel (xpub) ist ein Stammschlssel, von dem alle Empfngeradressen eines Kontos abgeleitet werden.

Er wird hier fr die erweiterte Nutzung und die Interoperabilitt mit Watch-Only-Wallets wie Electrum oder Sentinel bereitgestellt. Wenn du auf verschiedene Adresstypen empfngst, importiere bitte alle verschiedenen xpub-Formate in die Watch-only-Wallet, damit du alle deine Coins sehen kannst.

Bitte beachte, dass Wallets von Drittanbietern Taproot xpubs mglicherweise noch nicht untersttzen.
`,
      title: "Was ist ein erweiterter Public Key?"
    }
  },
  accountRates: {
    text: "Die Wechselkurse werden mintlich von CoinGecko aktualisiert.",
    title: "Welche Wechselkurse werden benutzt?"
  },
  accountReload: {
    text: "Das ist nicht ntig. Alle Transaktionsinformationen werden automatisch aktualisiert. ",
    title: "Wie kann ich die Transaktionshistorie erneut laden?"
  },
  accountSendDisabled: {
    text: 'Der "Senden" Knopf wird aktiviert, wenn dein Guthaben grer als Null ist.',
    title: "Warum kann ich keine {{unit}} senden?"
  },
  accountSummaryAmount: {
    text: `Der Gesamtbetrag ist die Summe aller deiner Kryptokonten. Die Wechselkurse werden von coingecko.com abgerufen.

Hinweis: Wenn du MyEtherWallet fr Token verwendest, die in der BitBoxApp nicht untersttzt werden, dann sind diese nicht in dem angezeigten Gesamtbetrag einberechnet.`,
    title: "Wie berechnet sich der Gesamtbetrag?"
  },
  accountSummaryDescription: {
    text: "Hier kannst du die Entwicklung deines Portfolios im Laufe der Zeit sehen. Eine bersicht ber deine einzelnen Krypto-Konten wird unter dem Diagramm angezeigt.",
    title: "Was kann ich auf dieser Seite sehen?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtuelle Gre: Wird zur Ermittlung der Netzwerkgebhr verwendet. Du hast erfolgreich Gebhren gespart, wenn sie kleiner als die Transaktion sind.
Gre: Aktuelle Transaktionsgre in Bytes nach der Serialisierung gem der zugrunde liegenden Blockchain.
Gewicht: Mit Segwit eingefhrt, ist dies eine neue Metrik zur Bewertung von Transaktions- und Blockgren. Jedes Segwit Byte zhlt als eins, alles andere als vier "Gewichtseinheiten". Statt eines Megabytes, betrgt die Blockgrenbegrenzung nun vier Millionen "Gewichtseinheiten".`,
    title: "Was hat es mit den Bitcoin-spezifischen Transaktionsdetails  auf sich?"
  },
  accountTransactionAttributesGeneric: {
    text: `Besttigungen: Nachdem du deine Transaktion gesendet hast ist diese zuerst unbesttigt. Du musst warten, bis sie von einem Miner in einen Block aufgenommen wird. Dann hat deine Transaktion die erste Besttigung. Jeder nachfolgende Block fgt deiner Transaktion eine weitere Besttigung hinzu. Meist sehen Hndler und andere Netzwerkakteure Transaktionen erst mit 3 bis 6 Besttigungen als erledigt.
Transaktions-ID: Eine eindeutige Identifikationsnummer, die zum Nachschlagen einer Transaktion in einem Blockexplorer verwendet werden kann.
Gebhr: Miner erhalten eine Transaktionsgebhr als Anreiz, Transaktionen in die von ihnen erzeugten Blcke aufzunehmen. Um mehr zu erfahren, klicke auf  "Senden".`,
    title: "Welche Informationen werden in den Transaktionsdetails angezeigt?"
  },
  accountTransactionConfirmation: {
    text: "Dies ist eine Transaktionen die ins Netzwerk geschickt wurde und darauf wartet besttigt zu werden.",
    title: "Was ist eine ausstehende Transaktion?"
  },
  accountTransactionLabel: {
    text: "Es ist die Adresse an die du Coins erhalten oder geschickt hast.",
    title: "Welche Adresse wird bei jeder Transaktion angezeigt?"
  },
  accountTransactionTime: {
    text: "Der Zeitpunkt, zu dem die Transaktion in der Blockchain besttigt wurde.",
    title: "Welche Zeit wird angezeigt?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin und Litecoin knnen eine beliebige Anzahl an Konten haben. Nach fnf Konten kannst du nur dann ein weiteres Konto hinzufgen, wenn das vorherige Konto verwendet wurde.
Andere Coins knnen maximal fnf Konten haben.`,
      title: "Wie viele Konten kann ich erstellen?"
    },
    howtoAddTokens: {
      text: 'ERC-20 Token sind an ein bestimmtes Ethereum-Konto gebunden. Um einen Token zu aktivieren oder zu deaktivieren, gehe zu "Konten verwalten", klicke auf das Ethereum-Konto und schalte den gewnschten Token ein oder aus.',
      title: "Wie kann ich zustzliche Token hinzufgen?"
    },
    moveFunds: {
      text: "Ja. Da Konten jedoch eigenstndig sind, mssen Coins mit einer regulre Transaktion zwischen den Konten verschoben werden.",
      title: "Kann ich Geld zwischen Konten verschieben?"
    },
    recoverAccounts: {
      text: "Ja. Die BitBoxApp erstellt Konten nach bewhrten Standards, die mit den meisten Krypto-Wallets kompatibel sind.",
      title: "Kann ich meine Konten in anderen Wallets wiederherstellen?"
    },
    whatAreAccounts: {
      text: "Deine Wallet kann mehrere Konten derselben Whrung verwalten. Konten machen es einfach, Coins separiert zu halten.",
      title: "Was sind Konten?"
    },
    whatIsRememberWallet: {
      text: `Durch die Aktivierung von Wallet merken kannst du die Konten von diesem Wallet in der BitBoxApp sehen, auch wenn die BitBox02 nicht verbunden ist. So kannst du deinen Kontostand und dein Portfolio jederzeit berprfen. Zum Senden oder Empfangen von Coins muss die BitBox02 jedoch eingesteckt und entsperrt werden.

Wenn du Wallet merken deaktivierst, musst du die BitBox02 (oder Passphrase-Wallet) verbinden, um diese Konten in der BitBoxApp zu sehen.`,
      title: "Was passiert, wenn ich Wallet merken aktiviere/deaktiviere?"
    },
    whyIsThisUseful: {
      text: 'Separate Konten eignen sich hervorragend fr die Verwaltung von Coins fr verschiedene Personen oder Zwecke. Du kannst auch den "erweiterten ffentlichen Schlssel" (extended public key) eines Kontos freigeben, ohne etwas ber deine anderen Konten preiszugeben. Auf diese Weise kannst du wiederholt Geld erhalten, ohne Adressen wiederzuverwenden, z. B. um deinen Lohn zu erhalten oder um regelmig Krypto zu kaufen.',
      title: "Warum ist das ntzlich?"
    }
  },
  appendix: {
    link: "Kontaktiere uns!",
    text: "Du hast Fragen?"
  },
  backups: {
    check: {
      text: 'Mit "Check Backup" kannst du berprfen, ob du ber ein gltiges Backup fr deine aktuelle Wallet verfgst. Es kann auch verwendet werden, um zu berprfen, ob du das korrekte Wiederherstellungspasswort kennst.',
      title: 'Was bedeutet "Check Backup"?'
    },
    encrypt: {
      text: "Nein, aber dein Wiederherstellungspasswort wird bentigt, um deine Wallet aus dem gespeicherten Seed zu erzeugen.",
      title: "Kann ich mein Backup verschlsseln?"
    },
    howOften: {
      text: `Das Backup wird automatisch erstellt, wenn eine neue Wallet erstellt wird. Du musst nur dann ein neues Backup erstellen, wenn deine microSD-Karte verloren ist, beschdigt wurde oder wenn du dein Backup auf mehreren microSD Karten speichern willst.
Du musst nach der Transaktionsaktivitt keine neuen Backups erstellen. Alle deine Transaktionsdaten knnen durch ein einzelnes Backup, das automatisch fr dich erstellt wurde, wiederhergestellt werden.`,
      title: "Wie oft muss ich ein Backup erstellen?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie des Seed auf einer microSD-Karte. Der Seed zusammen mit deinem Wiederherstellungspasswort stellen dein Wallet wieder her.",
      title: "Was ist ein Backup?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Backup berprfen" checkt, dass sich auf deiner microSD Karte ein gtiges Backup zu deiner aktuell verwendeten Wallet befindet.',
      title: 'Was bedeutet "Backup berprfen"?'
    },
    encrypt: {
      text: 'Nein. Bitte bewahre deine microSD-Karte sicher auf, da sie den unverschlsseltes Seed enthlt, der zur Wiederherstellung deiner Wallet bentigt wird. Falls du dein Backup mit einem Passwort schtzen willst, aktiviere die "Optionale Passphrase" in den Gerteeinstellungen.',
      title: "Kann ich das Backup verschlsseln?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie deines Seeds auf deiner microSD Karte.",
      title: "Was ist das Backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Wenn 2FA aktiviert ist, mssen alle Transaktionen auf dem gekoppelten Mobiltelefon genehmigt werden, um Coins zu versenden. Unter der Haube: Eine verschlsselte einmalige Nummer wird an die App gesendet, dort wird sie entschlsselt und beim Drcken der Schaltflche "Akzeptieren" zur BitBox zurckgegeben. Diese Kommunikation mit der BitBox erfolgt ber den Kanal zwischen dem Mobiltelefon und dieser Desktop-App, der whrend des Pairings eingerichtet wurde.  

Stelle sicher, dass du ein Backup deiner Wallet erstellst und die App verbindest, bevor du 2FA aktivierst. Nach der Aktivierung werden der Mikro-SD Kartenslot und das Mobile-App-Pairing deaktiviert. Du kannst es nur erneut aktivieren, indem du die BitBox zurcksetzt, wodurch das Gert gelscht wird.`,
      title: "Wie funktioniert die Zwei-Faktor-Autorisierung (2FA)?"
    },
    disable2FA: {
      text: `Um 2FA zu deaktivieren, musst du deine BitBox zurcksetzen und anschlieend deine Wallet von deinem Backup wiederherstellen. Stelle sicher, dass du deine MicroSD-Karte mit deinem Backup hast und du das Wiederherstellungspasswort kennst. Dann drcke 'Reset Device'. Lege ein neues Gertekennwort fest und whle "Backup wiederherstellen". Whle Backup aus und klicke auf "Wiederherstellen". Dann gib dein Wiederherstellungskennwort ein, das du beim Erstellen der Wallet verwendet hast.`,
      title: "Wie schalte ich die Zwei-Faktor-Autorisierung (2FA) aus?"
    },
    ejectBitbox: {
      text: "Du kannst deine BitBox einfach aus dem Computer ziehen ohne sie vorher auszuwerfen.",
      title: "Wie werfe ich meine BitBox aus?"
    },
    ejectSD: {
      text: "Du kannst die Micro SD Karte jederzeit aus der BitBox entfernen, solange du nicht dabei bist, ein Backup zu erstellen oder zu berprfen",
      title: "Wie kann ich die Micro-SD-Karte auswerfen?"
    },
    hiddenWallet: {
      text: "Es ist eine sekundre Wallet, auf der selben BitBox, das mit einem anderen Passwort geschtzt ist. Dies erlaubt dir, einem Erpresser ein anderes Wallet zu ffnen, in welchem sich nur eine geringe Menge Coins befindet. Info: Fr beide Wallets, normal und versteckt, wird der selbe Seed verwendet, somit muss kein weiteres Backup erzeugt werden",
      title: "Was ist eine versteckte Wallet?"
    },
    legacyHiddenWallet: {
      text: "Klicke zunchst auf den Knopf unten (dazu muss die BitBox mit dem Hauptgertekennwort entsperrt sein und 2FA deaktiviert sein), schliee dann deine Bitbox an und entsperre diese mit deinem versteckten Gertekennwort.",
      title: "Wie greife ich auf die versteckte Wallet des Legacy Kontos zu?"
    },
    pairing: {
      text: "Nachdem du unsere mobile App fr iOS oder Android heruntergeladen hast, scanne den angezeigten QR-Code. Dadurch wird ein sicherer Kanal zwischen der mobilen App und dieser Anwendung eingerichtet. Befolge nach dem Scannen die Anweisungen in der Smartphone App.",
      title: "So, koppelst du dein Telefon sicher mit der BitBox"
    }
  },
  cointracking: {
    text: 'Klicke auf "Exportieren" und ffne den Download-Ordner. Dort findest du die exportierte CSV Datei. Klicke dann auf den untenstehenden Link, lade deine BitBox-CSV-Datei hoch und importiere die Daten, um sie fr deinen CoinTracking-Portfoliomanager zu verwenden und deine Steuerberichte zu erstellen.',
    title: "Wie importiere ich meine Transaktionen in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lese mehr ber den Echtheitscheck"
      },
      text: "Die BitBoxApp fhrt eine berprfung der BitBox02 durch, um festzustellen, ob das Gert echt ist. Die Prfung wird lokal durchgefhrt und stellt keine Verbindung zu unseren Servern her.",
      title: "Wie funktioniert die Echtheitsprfung?"
    },
    name: {
      text: "Dies ist der Name deiner Wallet und deines Backups. Der Name wird fr zuknftige Backups verwendet und kann dazu dienen, verschiedene Wallets zu unterscheiden. Er kann jederzeit gendert werden, aber beachte, dass Backups, die vor der nderung erstellt wurden, weiterhin den vorherigen Namen verwenden.",
      title: "Wofr wird der BitBox02-Name verwendet?"
    },
    "secure-chip": {
      link: {
        text: "Lese mehr ber den Secure-Chip"
      },
      text: "Diese Information zeigt die Modellnummer des Sicherheitschips. Der aktuellste Chip ist der ATECC608B mit verbesserten Sicherheitsfunktionen im Vergleich zu lteren Modellen.",
      title: "Warum das Modell des Secure-Chips anzeigen?"
    }
  },
  receive: {
    address: {
      text: "Du kannst die Adresse an andere weitergeben, damit sie dir Coins schicken knnen. Achte darauf, dass sie an die richtige Adresse schicken.",
      title: "Was mache ich mit einer Adresse?"
    },
    addressChange: {
      text: "Sobald eine Adresse fr eine Transaktion benutzt wurde, wird eine neue Adresse zu der Liste hinzugefgt um die Alte zu ersetzen. Es werden immer 20 ungenutzte Adressen angezeigt. ",
      title: "Wann ndern sich die Adressen?"
    },
    addressFormats: {
      text: "Standardmig ist der Adresstyp Native Segwit. Dieser Adresstyp wird von vielen anderen Wallets/Brsen akzeptiert und bietet dir die besten Gebhrenstze fr alltgliche Transaktionen. Du kannst aber auch an Taproot (nur Bitcoin) senden, den neuesten Adresstyp, der aber noch nicht berall untersttzt wird. Wenn du Probleme hast, an Native Segwit (den Standard-Adresstyp) zu senden, kannst du auch auf den lteren Wrapped Segwit-Adresstyp umsteigen, der mglicherweise mit mehr Wallets/Brsen kompatibel ist.",
      title: "Wann sollte ich den Adresstyp ndern?"
    },
    howVerify: {
      text: `BitBox01: Klicke auf das BitBox-Symbol in der Seitenleiste links und siehe dir den Abschnitt "Zwei-Faktor Autorisierung" an. Die Anleitung wird aktualisiert und du kannst von dort aus den Anweisungen folgen.

BitBox02: Dank des eingebauten Displays kannst du die Adresse direkt auf dem Gert whrend des Send-/Empfangsprozesses verifizieren. `,
      title: "Wie kann ich die Adresse sicher verifizieren?"
    },
    plugout: {
      text: "Nein, sobald du die Adresse auf dem Display besttigt und kopiert hast, musst du deine BitBox nicht mehr eingesteckt haben. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox whrend des Empfangs eingesteckt lassen?"
    },
    why20: {
      text: 'Die BitBoxApp generiert automatisch eine gewisse Anzahl an Adressen, die von deinem Seed abgeleitet werden. Sie berprft dann, ob diese Adressen schon Coins erhalten haben. Die App kann theoretisch eine nahezu unbegrenzte Anzahl von Adressen generieren, wodurch es Jahre dauern wrde, bis dein Kontostand ermittelt ist. Um diese Suche einzuschrnken stoppt die App diesen Prozess, nachdem sie 20 Adressen generiert hat, die noch nie Coins erhalten haben. Dies wird "gap-limit" genannt und 20 ist ein der de-facto-Standard. Deswegen siehst du immer nur 20 Adressen, aus denen du auswhlen kannst. ',
      title: "Warum werden nur 20 Adressen angezeigt?"
    },
    whyMany: {
      text: "Aus Grnden des Datenschutzes und der Sicherheit solltest du niemals dieselbe Empfangsadresse zweimal verwenden. Klicke auf 'Weiter', um eine neue Adresse zu erhalten. Du kannst bis zu 20 Adressen gleichzeitig generieren. Alle Adressen werden von deinem Backup abgeleitet. (Stell dir Adressen wie Rechnungsnummern vor.)",
      title: "Warum gibt es mehrere Adressen?"
    },
    whyVerify: {
      text: `Einer der Grnde fr den Kauf einer Hardwarewallet, ist dass du deinem Computer aufgrund der groen Angriffsflche nicht vertrauen solltest. Daher solltest du nicht darauf vertrauen, dass dein Computer authentische Adressen generiert und anzeigt. 
Bitbox01: Mit dem Knopf zur sicheren berprfung der Adresse sendet die BitBox01 die Adresse an ein gekoppeltes Mobiltelefon, auf welchem du die Adresse  berprfen kannst. 
BitBox02: Die BitBox02 hat ein eingebautes Display, auf dem die Adresse sicher angezeigt werden kann. `,
      title: "Warum sollte ich die Adresse verifizieren?"
    }
  },
  send: {
    change: {
      text: "Der Change wird an eine Taproot-Adresse gesendet, wenn du mindestens eine Taproot UTXO besitzt. Wenn du Coin-Control verwendest, wird der Change an eine Taproot-Adresse gesendet, wenn mindestens eine der ausgewhlten UTXOs eine Taproot-UTXO ist. In allen anderen Fllen wird der Change an eine Native-Segwit-Adresse gesendet. ",
      title: "Wie wird der Change-Output bestimmt?"
    },
    fee: {
      text: `Die Gebhr basiert auf der Transaktionsdatengre und nicht auf dem Transaktionsbetrag. Die Gebhren werden durch den Gebhrenschtzungsalgorithmus von Bitcoin Core fr jede von dir gewhlte Netzwerkprioritt berechnet. Sie werden explizit angezeigt, wenn du einen anderen Wert als die unten stehenden Ziele haben.
Economy: 24 Blcke (ca. 4 Stunden fr Bitcoin, 1 Stunde fr Litecoin)
Niedrig: 12 Blcke (etwa 2 Stunden fr Bitcoin, 30 Minuten fr Litecoin)
Normal: 6 Blcke (ca. 1 Stunde fr Bitcoin, 15 Minuten fr Litecoin)
Hoch: 2 Blcke (ca. 20 Minuten fr Bitcoin, 5 Minuten fr Litecoin)
(Ein Block bentigt durchschnittlich zehn Minuten fr Bitcoin (2,5 Minuten fr Litecoin)), und die Netzwerklast kann in den oben genannten Zeitrumen erheblich variieren.)`,
      title: "Wie wird die Gebhr ermittelt?"
    },
    plugout: {
      text: "Nein, nachdem du eine Transaktion durchgefhrt hast, musst du deine BitBox nicht eingesteckt lassen. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox beim Senden eingesteckt lassen?"
    },
    priority: {
      text: "Je hher die Gebhr ist, die du bereit bist zu zahlen, desto schneller wird deine Transaktion vom Netzwerk besttigt. ",
      title: "Was ist Netzwerk Prioritt?"
    },
    revert: {
      text: `Sobald eine Transaktion signiert und gesendet (d.h. An das Netzwerk gesendet) wurde, kann sie nicht mehr rckgngig gemacht werden. berprfe die Transaktionen (einschlielich der Gebhr) deswegen, bevor du die Transaktion besttigst!
Wenn du den Empfnger kennst und dieser bereit ist, denselben Betrag (abzglich der Transaktionsgebhren) an dich zurckzuschicken, kannst du ihm eine neue Empfngeradresse senden.`,
      title: "Kann ich eine Transaktion rckgngig machen?"
    },
    whyFee: {
      text: `Transaktionen stehen im Wettbewerb, um von einem Miner besttigt zu werden. Die Miner whlen Transaktionen, die in die Blockchain aufgenommen werden sollen, basierend auf ihrer Gebhr aus. Miner bevorzugen Transaktionen mit hheren Gebhren. Deswegen wird eine Transaktion die bereit ist, eine hhere Gebhr zu bezahlen auch schneller in einem Block aufgenommen. 
Da es keinen Mittelsmann gibt, der eine Regelung, wie eine Stimme pro Person erzwingen kann, stimmen die Miner ber Transaktionen ab, indem sie eine kostspielige Ressource, wie Rechenleistung opfern. Als Belohnung dafr erhalten sie neu erstellte Coins und die Gebhren der Transaktionen in dem von ihnen "gemineten" Block (english: to mine a Block) .`,
      title: "Warum gibt es eine Netzwerk Gebhr?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Wenn du nur dann eine Verbindung zu deinem Full Node herstellen mchtest, wenn du dich im selben Netzwerk befindest (z. B. in deinem Heim-WLAN), ist die Verwendung einer regulren Netzwerkkommunikation ausreichend.
In diesem Fall ist es ratsam, dass dein Electrum-Server ein TLS-Zertifikat zum Verschlsseln der Kommunikation bereitstellt.
Wenn du von berall aus eine Verbindung zu deinem Full Node herstellen mchtest, ist die Verwendung von Tor die bessere Option. In diesem Fall ist kein TLS-Zertifikat erforderlich.`,
      title: "Soll ich Clearnet TCP, TLS oder Tor verwenden?"
    },
    instructions: {
      link: {
        text: "Anleitung zum Verbinden deines Full Nodes"
      },
      text: "Fr eine vollstndiges Anleitung, besuche bitte unseren Guide:",
      title: "Wie verbinde ich meine BitBoxApp mit meinem Full Node?"
    },
    options: {
      text: `Es gibt mehrere Mglichkeiten, einen eigenen Full Node zu betreiben, z. B. ein fertiges Gert zu kaufen, einen eigenen zu bauen oder Bitcoin Core auszufhren.
Wenn du deine BitBoxApp mit deinem Full Node verbinden mchtest, stelle sicher, dass dieser einen Electrum-Server bereitstellt. Dies ist ein spezielles Programm, mit dem eine Wallet-App mit deinem Full Node kommunizieren kann.
Untersttzte Optionen sind Electrs, Electrum Personal Server (EPS) oder Bitcoin Wallet Tracker (BTW).`,
      title: "Welche Optionen gibt es, um einen Full Node zu betreiben?"
    },
    tor: {
      text: `Tor steht fr "The Onion Router", eine kostenlose Open-Source-Software, die viele Datenschutzvorteile bietet und besonders bei der Verwendung von Bitcoin ntzlich ist.
Wenn du ber Tor eine Verbindung zu deinem Full Node herstellen mchtest, stelle sicher, dass Tor auf deinem Computer installiert ist, und aktiviere dann den Tor-Proxy in den BitBoxApp-Einstellungen.
Auf den meisten Betriebssystemen gibt es zwei Mglichkeiten, Tor auszufhren:
1. Tor Browser: Lade den Tor Browser herunter und ffne ihn. Dadurch kann die BitBoxApp eine Verbindung zum Tor-Netzwerk herstellen, indem Port 9150 in den Tor-Proxy-Einstellungen festgelegt wird.
2. Tor-Hintergrunddienst: Installiere den Tor-Daemon, der immer im Hintergrund ausgefhrt wird. Die BitBoxApp kann dann eine Verbindung herstellen, indem Port 9050 in den Tor-Proxy-Einstellungen festgelegt wird.`,
      title: "Was ist Tor, Tor-Proxy und welchen Port soll ich verwenden?"
    },
    what: {
      text: "Es ist mglich, deine Wallet mit einem eigenen Fullnode zu betreiben, anstatt den Shift-Server zu verwenden.",
      title: "Was ist das?"
    },
    why: {
      text: `Einen eigenen Full Node zu betreiben ist nicht erforderlich. Er verbessert jedoch deine Privatsphre und verringert die Notwendigkeit, anderen Netzwerkteilnehmern zu vertrauen.
Zum einen erlaubt er dir Bitcoin privater verwenden, da die BitBoxApp dann keine Verbindung zu unseren Servern herstellt, um deinen Transaktionsverlauf abzurufen. Stattdessen werden diese Informationen von deinem eigenen Full Node abgerufen.
Des Weiteren, verifiziert dein Full Node alle Transaktionen selbst, wodurch sichergestellt wird, dass die Konsensregeln eingehalten werden. `,
      title: "Warum sollte ich meinen eigenen Full Node betreiben?"
    }
  },
  settings: {
    sats: {
      text: 'Ein Satoshi (kurz "sat") ist die kleinste Einheit eines Bitcoins. Ein Satoshi ist ein Hundertmillionstel eines Bitcoins (0,00000001 BTC). Benannt ist er nach dem Erfinder von Bitcoin, Satoshi Nakamoto.',
      title: "Was ist ein Satoshi?"
    },
    servers: {
      text: `Diese App kommuniziert mit Servern von Shift Crypto, um nach Updates zu suchen, Transaktionen zu laden und Informationen an verbundene Smartphone Apps zu senden.
Auerdem werden die neuesten Wechselkurse von CoinGecko abgerufen. (Die Conversions werden lokal berechnet, es werden keine Betrge von dir bertragen.)
Info: Fr Ethereum und ERC-20 tokens verwenden wir die Etherscan.io APIs.`,
      title: "Mit welchen Servern kommuniziert die Applikation?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Guide schlieen",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Bewege auf dem Desktop den Mauszeiger ber das Diagramm. Halte auf Mobilgerten deinen Finger auf dem Diagramm und ziehe ihn horizontal.",
    title: "Wie kann man historische Werte auf dem Chart sehen?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Du musst das Gert zurcksetzen und die Wallet mithilfe des Wiederherstellungskennworts aus deinem Backup wiederherstellen.",
      title: "Was mache ich, wenn ich mein Passwort vergessen habe?"
    },
    reset: {
      text: "Gib 15 Mal ein falsches Gertekennwort ein. Die letzten Versuche erfordern eine lange Berhrung des Gerts.",
      title: "Wie stelle ich mein Gert wieder her?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Das Gert sollte beim Einstecken einmal blinken. Stelle sicher, dass es richtig herum eingesetzt ist. Bei Problemen kontaktiere uns bitte ber den untenstehenden Link.",
      title: "Meine BitBox01 wurde nicht erkannt"
    },
    getDevice: {
      link: {
        text: "Bestellen einer BitBox"
      },
      text: "Du kannst eine BitBox in unserem Online Shop bestellen:",
      title: "Wie bekomme ich ein Gert?"
    },
    internet: {
      text: "Ja, eine Internetverbindung ist erforderlich, um die Wallet zu synchronisieren, Transaktionen zu senden und die neuesten Wechselkurse abzurufen.",
      title: "Braucht diese Applikation eine Internet Verbindung?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Du kannst deine Konten auf einer neuen BitBox oder in unserem Backup-center wiederherstellen.",
      title: "Ich habe mein Gert verloren. Was nun?"
    },
    useWithoutDevice: {
      text: "Leider ist dies zum aktuellen Zeitpunkt nicht mglich. ",
      title: "Kann ich die App auch ohne Gert benutzen?"
    },
    welcome: {
      text: "Vielen Dank, dass du diese App benutzt. Sie wird von Shift Crypto in der Schweiz entwickelt. Wir freuen uns ber Anregungen und Fragen. Zgere nicht, uns zu kontaktieren.",
      title: "Willkommen in der BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Wenn du ein neues Telefon/Computer mit der BitBoxApp verwendest, musst du dich erneut mit den DApps verbinden. Anschlieend siehst du deine Coins wieder wie gewohnt auf der DApp.",
      title: "Ich sehe meine vorherigen Verbindungen nicht."
    },
    supportedNetworks: {
      text: "Derzeit wird nur das Ethereum-Mainnet mit WalletConnect in der BitBoxApp untersttzt. Um andere EVM-kompatible Netzwerke zu verwenden, verwende bitte das Rabby Browser-Extension Wallet.",
      title: "Welche Netzwerke werden untersttzt?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ist ein Kommunikationsprotokoll fr Web3-Anwendungen. Damit kannst du bequem eine Verbindung zu Ethereum basierten DApps und Web-Wallets herstellen, ohne eine Drittanbieter-App zu verwenden. Dies ist besonders ntzlich fr Android Nutzer der BitBoxApp.",
      title: "Was ist WalletConnect?"
    }
  }
}, headerssync$g = {
  blocksSynced: `{{blocks}} Blcke synchronisiert
`
}, hiddenWallet$g = {
  info1HTML: "Zur glaubhaften Abstreitbarkeit kann eine versteckte Wallet erstellt werden, das auf einer <strong> anderen </strong> Gerte- und Wiederherstellungspasswort Kombination basiert.",
  info2HTML: "Gib das Gertepasswort und das Wiederherstellungspasswort ein, die du fr deine versteckte Wallet verwenden mchtest. Das Gertepasswort und das Wiederherstellungspasswort mssen sich von <strong> denen unterscheiden </strong> , die du fr dein primres Wallet verwendest.",
  passwordLabel: "Versteckte Wallet Passwort",
  passwordPlaceholder: "Bitte besttige das versteckte Wiederherstellungspasswort",
  pinLabel: "Verstecktes Gertepasswort",
  pinRepeatLabel: "Wiederhole das versteckte Gertepasswort",
  pinRepeatPlaceholder: "Bitte besttige das versteckte Gertepasswort",
  success: "Versteckte Wallet erfolgreich erstellt. Stecke die BitBox erneut ein und gib das versteckete Gertepasswort ein, um diese zu entsperren."
}, initialize$g = {
  create: "Gertepasswort speichern",
  creating: "Gertekennwort wird eingestellt...",
  error: {
    e102: "Das Gertekennwort muss aus mindestens 4 Zeichen bestehen."
  },
  info: {
    description1: "Whle dein Gertekennwort. Dieses wird zum Entsperren deiner BitBox verwendet.",
    description2: "Du kannst Zahlen und Buchstaben verwenden. Lngere Passwrter sind in der Regel sicherer.",
    description3: "Wenn du das Gertepasswort vergisst, musst du dein Gert zurcksetzen und deine Wallet von deinem Backup wiederherstellen.",
    subtitle: "Jetzt legst du dein Gertepasswort fest",
    title: "Initialisierung deines Gertes"
  },
  input: {
    label: "Gertepasswort",
    labelRepeat: "Wiederhole das Gertepasswort",
    placeholderRepeat: "Bitte besttige das Gertepasswort"
  }
}, invalidFormat$g = "Ungltiges Format", language$h = {
  title: "Sprache auswhlen"
}, legacyhiddenwallet$g = {
  disable: "Versteckte Legacy Wallet deaktivieren",
  enable: "Versteckte Legacy Wallet aktivieren",
  successDisable: "Versteckte Legacy Wallet erfolgreich deaktiviert",
  successEnable: "Die versteckte legacy Wallet wurde erfolgreich aktiviert. Stecke deine BitBox erneut ein und gib das versteckte Gertepasswort ein, um auf die versteckte Wallet zuzugreifen."
}, loading$g = "laden...", manageAccounts$a = {
  accountHidden: "Dieses Konto wurde aus deinen watch-only Konten ausgeblendet. Verbinde deine BitBox02 um es wieder anzuzeigen.",
  editAccount: "Bearbeiten",
  editAccountNameTitle: "Kontonamen bearbeiten",
  noAccounts: "Keine Konten gefunden",
  settings: {
    hideTokens: "Token ausblenden",
    showTokens: "Token anzeigen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Konten hinzufgen und aktivieren / deaktivieren",
  title: "Konten verwalten",
  watchAccount: "Konto merken",
  watchAccountDescription: "Dieses Konto ist Teil deines watch-only Kontos. Du kannst es mit diesem Schalter vor den watch-only Konten verstecken."
}, mobile$b = {
  usingMobileDataWarning: "Mobile Datennutzung: Diese App downloaded ein paar hundert Megabytes an Blockchain Daten nachdem ein Konto geffnet wurde. Bitte verbinde dein Handy fr diesen einmaligen Download mit deinem Wifi. "
}, newSettings$9 = {
  about: {
    appVersion: {
      title: "App-Version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Sperre den Zugriff zur App mit Displaysperre/Fingerabdruck.",
      title: "Displaysperre"
    },
    coinControl: {
      description: "Whle aus, welche UTXOs Teil einer Transaktion sind, um die Privatsphre zu verbessern."
    },
    customFees: {
      description: "Ermglicht es dir, beim Senden deine eigene Gebhr festzulegen."
    },
    torProxy: {
      description: "Stelle fr mehr Privatsphre eine Verbindung ber Tor her."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Diese zustzlichen Whrungen knnen auf Ihrer Kontoseite eingeschaltet werden.",
      title: "Aktive Whrungen"
    },
    darkmode: {
      description: "Aktiviere den dunklen Modus der BitBoxApp."
    },
    defaultCurrency: {
      description: "Whle deine Standardwhrung aus",
      title: "Standardwhrung"
    },
    enableWallet: {
      description: "Wenn du dein Konto deaktivierst, wird es weder in der Seitenleiste noch im Portfolio angezeigt. Du kannst es hier jederzeit wieder aktivieren. Coins auf diesem Konto werden nicht beeinflusst und bleiben sicher.",
      title: "Wallet aktivieren/deaktivieren"
    },
    hideAmounts: {
      description: "Zeigt einen Schalter zum Ausblenden deines Guthabens und Betrgen an, um deine Privatsphre zu verbessern, wenn du die App in der ffentlichkeit nutzt.",
      hideAmounts: "Betrge ausblenden",
      showAmounts: "Betrge anzeigen",
      title: "Ausblenden von Betrgen zulassen"
    },
    language: {
      description: "Welche Sprache die BitBoxApp verwenden soll.",
      title: "Sprache"
    },
    remebmerWallet: {
      name: "Wallet merken",
      warning: "Dies wird dein gemerktes Wallet entfernen. Um es wieder zu sehen musst du die BitBox02 fr dieses Wallet verbinden. Alle Coins auf diesem Wallet werden nicht beeinflusst. Mchtest du fortfahren?",
      warningTitle: 'Deaktiviere "Wallet merken"'
    },
    toggleSats: {
      description: "Aktiviere oder deaktiviere Satoshis."
    }
  }
}, note$c = {
  input: {
    description: "(optional)",
    placeholder: "Notiz hinzufgen..."
  },
  title: "Notiz"
}, notification$g = {
  newTxs_one: "Neue Transaktion in: {{accountName}}",
  newTxs_other: "{{count}} neue Transaktionen in: {{accountName}}"
}, pairing$g = {
  aborted: {
    text: "Der Kopplungsprozess wurde von der Smartphone App abgebrochen.",
    title: "Abgebrochen"
  },
  button: "Mit Smartphone App koppeln",
  confirm: "Mchtest du deine BitBox wirklich koppeln? Danach wird dein Mobiltelefon zur Durchfhrung einer Transaktion unbedingt erforderlich sein.",
  connectOnly: {
    button: "Smartphone App verbinden",
    title: "Scanne den Code mit der Smartphone App. "
  },
  error: {
    text: "Etwas ist schief gelaufen. Bitte fang erneut an.",
    title: "Fehler"
  },
  pullFailed: {
    text: "Fehler beim Abrufen einer Nachricht von deinem Mobiltelefon ber den Relay-Server. Der Relay-Server ist mglicherweise offline. Wende dich an den Support.",
    title: "Laden fehlgeschlagen"
  },
  reconnectOnly: {
    button: "Smartphone App erneut verbinden"
  },
  scanningFailed: {
    text: "Das Handy konnte die Nachricht nicht scannen. Bitte versuche es erneut.",
    title: "Scannen fehlgeschlagen"
  },
  start: {
    hideAppQRCode: "QR Code ausblenden",
    revealAppQRCode: "QR Code anzeigen",
    step1: "Wenn du nicht ber die Smartphone App verfgst, kannst du den QR-Code fr den Apple App Store oder den Google Play Store scannen.",
    step2: "Scanne den Code mit der Smartphone App, die du im App Stores fr iOS und Android findst, wenn du nach 'Digital Bitbox 2FA' suchst."
  },
  started: {
    text: "Folge nun den Anweisungen in der mobilen App.",
    title: "Gut gemacht!"
  },
  success: {
    text: "Herzlichen Glckwunsch, du hast deine BitBox erfolgreich mit der mobilen App gekoppelt!",
    title: "Erfolg"
  },
  timeout: {
    text: "Der Kopplungsprozess ist nach 2 Minuten abgelaufen. Bitte versuche es erneut.",
    title: "Zeitberschreitung"
  },
  title: "Smartphone Kopplung"
}, passphrase$a = {
  considerations: {
    button: "Backup-Hinweise",
    message: `Die Passphrase bietet zustzlichen Schutz fr dein Wallet-Backup (MicroSD oder 24 Wrter). Falls jemand Zugriff auf dein Backup hat, bentigt er zustzlich die Passphrase, um auf dein Wallet zuzugreifen. 

Dies bedeutet jedoch, dass du <strong>sowohl die Passphrase als auch das Wallet Backup</strong> bentigst, um dein Passphrase-Wallet wiederherzustellen, falls deine BitBox02 verloren oder kaputt geht. Falls du die Passphrase verlierst, verlierst du auch Zugriff auf alle Coins in diesem Wallet.

Erwge, deine Passphrase an einem anderen Ort als dein Backup zu sichern. Falls jemand dein Backup findet, fehlt ihm immer noch die Passphrase. `,
    title: "Backup-Hinweise"
  },
  disable: "Passphrase deaktivieren",
  disableInfo: {
    button: "Deaktivieren",
    message: `Nachdem du die Passphrase deaktiviert hast, wirst du nach dem Entsperren deiner BitBox02 nicht mehr aufgefordert, eine Passphrase einzugeben. Daher wirst du deine Standard-Wallet aufrufen.

Alle Coins in deiner Passphrase-Wallet befinden sich weiterhin in dieser Wallet, aber du kannst nicht darauf zugreifen, weil du nach dem Entsperren deiner BitBox02 deine Standard-Wallet ffnest.

Um wieder auf deine Passphrase-Wallet zuzugreifen, aktiviere einfach wieder die Passphrase-Funktion und gib die entsprechende Passphrase ein, nachdem du die BitBox02 entsperrt hast.

<strong>Tipp:</strong> Du kannst deine ursprngliche Wallet immer noch ffnen, indem du die Passphrase leer lsst.`
  },
  enable: "Passphrase aktivieren",
  error: {
    e104: "nderung der Passphrase-Einstellung wurde abgebrochen. "
  },
  how: {
    button: "So sieht es aus",
    message: `Eine Passphrase funktioniert nicht wie ein Passwort, wie du es kennst. Wenn du deine Passphrase falsch eingibst, wirst du nicht benachrichtigt. Das liegt daran, dass <strong>jede Passphrase eine andere, aber gltige Wallet</strong> erstellt. Das heit, du kannst mehrere Passphrasen fr so viele Wallets verwenden, wie du willst. Auf jede Wallet kannst du aber nur zugreifen, wenn du die entsprechende Passphrase eingibst.

Wenn du deine BitBox02 einsteckst, wirst du wie blich nach dem Gertepasswort gefragt. Danach wirst du aufgefordert, eine Passphrase auf dem Gert einzugeben.

Nachdem du die Passphrase eingegeben hast, wird dir die eingegebene Passphrase angezeigt. So kannst du besttigen, dass du sie richtig eingegeben hast.`,
    title: "Wie funktioniert die Passphrase?"
  },
  intro: {
    message: `Eine Passphrase bietet zustzliche Sicherheit fr deine Wallet.
Hier erfhrst du, wie sie funktioniert.`,
    title: "Passphrase einrichten"
  },
  progressDisable: {
    message: "Besttige auf deiner BitBox, dass du die optionale Passphrase <strong>deaktivieren</strong> mchtest.",
    title: "Besttige am Gert"
  },
  progressEnable: {
    message: "Besttige auf deiner BitBox, dass du die optionale Passphrase <strong>aktivieren</strong> mchtest.",
    title: "Besttige am Gert"
  },
  successDisabled: {
    message: `Optionale Passphrase <strong>erfolgreich aktiviert</strong>!
Von nun an wirst du dazu aufgefordert, eine Passphrase anzugeben.`,
    messageEnd: "Bitte stecke die BitBox02 jetzt wieder ein.",
    title: "Passphrase aktiviert"
  },
  successEnabled: {
    message: `Optionale Passphrase <strong>erfolgreich deaktiviert</strong>!
Von nun an wirst du nicht mehr dazu aufgefordert, eine Passphrase anzugeben.`,
    messageEnd: "Bitte stecke deine BitBox02 jetzt wieder ein.",
    tips: "Tipps",
    tipsList: [
      "Wir empfehlen, zuerst einen kleinen Betrag in die Passphrase-Wallet zu senden. Dann musst du die BitBox02 aus- und wieder einstecken und dein Passwort und deine Passphrase eingeben. Wenn du die Passphrase richtig eingegeben hast, solltest du die Coins in deinem Wallet sehen.",
      "Wenn du deine ursprngliche Wallet ohne Passphrase betreten willst, kannst du das immer noch tun, indem du nichts eingibst, wenn du zur Eingabe der Passphrase aufgefordert wirst. Oder du kannst die Passphrase-Funktion deaktivieren."
    ],
    title: "Passphrase deaktiviert"
  },
  summary: {
    button: "Passphrase aktivieren",
    title: "bersicht",
    understand: "Ich verstehe, wie die Passphrase funktioniert und welche Risiken damit verbunden sind.",
    understandList: [
      "Die Passphrase ist eine zustzliche Sicherheitsmanahme fr mein Backup.",
      "Wenn ich eine andere Passphrase eingebe, wird immer ein anderes Wallet erstellt.",
      "Um mein Wallet wiederherzustellen bentige ich <strong>sowohl die Passphrase als auch das Backup</strong>.",
      "Wenn ich meine Passphrase vergesse, habe ich <strong>keinen Zugriff mehr auf meine Coins</strong>."
    ]
  },
  what: {
    button: "Verstehe, wie es funktioniert",
    message: `Eine Wallet wird aus einer sehr groen Zufallszahl erstellt (abgeleitet), die auch als Seed bezeichnet wird. Dieser Seed wird erstellt, wenn du deine BitBox02 zum ersten Mal einrichtest, und mit der microSD-Karte oder 24 Wrtern gesichert. Jeder, der Zugriff auf den Seed hat, hat die volle Kontrolle ber das Geld auf dieser Wallet.

Eine Passphrase ist ein <strong>optionales Geheimnis</strong>, das zum Seed hinzugefgt wird. Wenn du eine Passphrase verwendest, erstellt jede Passphrase eine neue Wallet, die auf dem Seed + Passphrase (optionales Geheimnis) basiert. Eine Passphrase kann alles sein: Buchstaben, Wrter, Sonderzeichen oder auch leer. Die Standard-Wallet wird aus dem Seed und der leeren Passphrase erstellt.

Die Passphrase ist Teil des BIP39-Standards, was bedeutet, dass sie mit allen Wallets kompatibel ist, die denselben Standard untersttzen.`,
    title: "Was ist eine Passphrase?"
  },
  why: {
    button: "Warum sollte man eine Passphrase benutzen?",
    message: `Die BitBox02 schtzt den Seed vor der Extraktion aus dem Gert selbst, doch das Backup (microSD-Karte oder 24 Wrter) gibt vollen Zugriff auf die Wallet. Deshalb sollte es an einem sicheren Ort aufbewahrt werden!

Da eine Passphrase eine neue Wallet mit deinem bestehenden Seed erstellt, bentigt die Passphrase-Wallet <strong>sowohl dein Backup als auch deine Passphrase zur Wiederherstellung</strong>. Das hat den Vorteil, dass jemand, der dein Backup findet, trotzdem die Passphrase braucht, um auf die Passphrase-Wallet zuzugreifen.

Auerdem kannst du mit der Passphrase-Funktion mehrere Wallets auf demselben Gert erstellen, also "versteckte Wallets" zustzlich zur Standard-Wallet.`,
    title: "Warum sollte man eine Passphrase benutzen?"
  }
}, password$g = {
  show: "{{label}} anzeigen",
  warning: {
    caps: "WARNUNG: Feststelltaste  () ist aktiviert",
    paste: 'Um Text einzufgen, aktiviere "Anzeigen" {{label}}".'
  }
}, random$h = {
  button: "Zufallszahl generieren",
  description: "Deine BitBox hat die folgende {{bits}}-Bit-Zufallszahl generiert:"
}, receive$i = {
  changeScriptType: "Adresstyp ndern",
  label: "Meine Adresse",
  onlyThisCoin: {
    description: "Um andere Token empfangen zu knnen, aktiviere diese in den Einstellungen. Solltest du Token empfangen, welche die BitBoxApp nicht untersttzt, hast du mglicherweise keinen Zugang mehr zu diesen. ",
    warning: "Stelle sicher, dass du nur {{coinName}} auf diese Adresse sendest."
  },
  scriptType: {
    p2tr: "Taproot (neuestes Format)",
    p2wpkh: "Native-Segwit (standard)",
    "p2wpkh-p2sh": "Wrapped-Segwit (kompatibles Format)"
  },
  selectAccount: "Konto auswhlen",
  showFull: "Adresse auf BitBox besttigen",
  taprootWarning: "Hinweis: Taproot ist ein neues Adressformat und noch nicht weit verbreitet. Gelder, die ber Taproot-Adressen eingehen, sind mglicherweise nicht in Watch-Only-Wallets von Drittanbietern sichtbar. Viele Wallets und Brsen sind noch nicht in der Lage, an Taproot-Adressen zu senden.",
  title: "{{accountName}} empfangen",
  verify: "Adresse sicher verifizieren",
  verifyBitBox01: "Adresse auf Smartphone berprfen",
  verifyBitBox02: "Adresse auf BitBox02 berprfen",
  verifyInstruction: "Bitte besttige, dass die folgende Adresse mit der Adresse auf deinem Gert bereinstimmt.",
  warning: {
    secureOutput: 'Bitte koppele deine BitBox mit deinem Smartphone, um eine sichere Adressberprfung zu ermglichen. Klicke in der Seitenleiste auf "Gert verwalten".'
  }
}, reset$g = {
  description: "Alle Daten auf dem Gert werden gelscht. Inklusive deiner Private-Keys!",
  notReset: "Gert NICHT zurck gesetzt.",
  title: "Gert in Werkszustand zurcksetzen",
  understand: "Ich habe ein Backup und kenne mein Wiederherstellungskennwort",
  understandBB02: "Ich habe ein valides Backup"
}, securityInformation$g = {
  create: {
    description1: "Bitte richte dein Gert in einer sicheren Umgebung ein, sodass niemand sehen kann, welches Passwort du whlst.",
    description2: "Whrend der Einrichtung wirst du aufgefordert, zwei verschiendene Passworter zu erstellen. ",
    description3: "Das erste Passwort ist das <strong> Gertepasswort </strong>, welches deine BitBox entsperrt und spter gendert werden kann.",
    description4: "Das zweite ist das <strong> Wiederherstellungspasswort </strong>, mit dem dein Wallet gesichert wird. Dieses Passwort kann spter nicht gendert werden",
    description5: "Die von dir erstellte Wallet wird in einer Datei auf der mitgelieferten microSD Karte gespeichert. Dieses Backup kann im Notfall verwendet werden, um den Zugriff auf deine Coins mithilfe deines <strong> Wiederherstellungskennworts </strong> wieder herzustellen.",
    title: "Sicherheitsinformationen"
  },
  restore: {
    description1: "Du wirst aufgefordert, die Micro-SD-Karte einzustecken, die du zum Speichern deines Backups verwendet hast.",
    description2: "Um dein Gert wiederherzustellen, bentigst du dein Wiederherstellungskennwort.",
    description3: "Bitte sei bei der Eingabe des Wiederherstellungskennworts aufmerksam. Jedes von dir eingegebene Passwort erstellt eine gltige Wallet, welche dann aber leer sind. Gibst du also ein falsches Kennwort ein, wird dir nicht die erwartete Wallet, sondern eine andere Wallet angezeigt.",
    title: "Sicherheitsinformationen"
  }
}, seed$g = {
  agreements: {
    "funds-access": "Ich kann NICHT auf mein Geld zugreifen, wenn ich mein Wiederherstellungspasswort vergessen habe.",
    "password-change": "Ich kann das Wiederherstellungspasswort spter NICHT ndern.",
    "password-required": "Ich brauche mein Wiederherstellungspasswort, um meine Wallet von meinem Backup wiederherzustellen."
  },
  create: "Neue Wallet erstellen",
  creating: "Wallet wird erstellt",
  description: "Ich besttige, dass ich folgendes zu Kenntnis genommen habe:",
  error: {
    e102: "Das Passwort muss aus mindestens 4 Zeichen bestehen.",
    e200: "Du musst eine microSD Karte in deine BitBox einsetzen, damit ein Backup deiner Wallet erstellt und auf der Micro-SD Karte gespeichert werden kann."
  },
  info: {
    button: " Wiederherstellungspasswort festlegen",
    description1: "Steck die microSD Karte in die BitBox ein.",
    description2: 'Whle ein Wiederherstellungspasswort fr die Wallet und klicke "Wiederherstellungspasswort speichern".',
    description3: "Das Backup auf der microSD Karte, zusammen mit deinem Wiederherstellungspasswort, ist die einzige Methode, wie deine Wallet (= der Zugang zu deinen Coins) wieder hergestellt werden kann, falls deine BitBox gestohlen wird oder du dein Gertepasswort vergisst!",
    description4: "Das Wiederherstellungspasswort lsst sich spter nicht ohne Weiteres ndern. Dazu msstest du dein Coins auf ein neues Konto transferieren. Deswegen solltest du von Anfang an ein gutes Passwort whlen.",
    title: "Neue Wallet erstellen "
  },
  password: {
    label: "Wiederherstellungspasswort",
    repeatPlaceholder: "Wiederhestellungspasswort wiederholen"
  },
  walletName: {
    label: "Wallet Name"
  }
}, seedRestore$g = {
  error: {
    e200: "Um eine Wallet von einem Backup wieder herzustellen wird deine microSD Karte bentigt."
  },
  info: {
    description1: 'Stecke die microSD-Karte in die BitBox ein und klicke auf "Weiter".',
    description2: 'Whle ein Backup aus und klicke "Wiederherstellen"',
    description3: "Gib das Wiederherstellungspasswort ein",
    description4: "Du musst besttigen, dass du zu Kenntnis genommen hast, dass ein falsches Passwort eine andere Wallet erstellt/ffnet.",
    title: "Wie wird eine Wallet von einem Backup wieder hergestellt?"
  }
}, send$i = {
  abort: "Die Transaktion wurde abgebrochen",
  address: {
    label: "Empfangsadresse",
    placeholder: "Adresse eingeben oder scannen"
  },
  amount: {
    label: "Betrag",
    placeholder: "Betrag eingeben"
  },
  availableBalance: "Kontostand",
  button: "Prfen",
  coincontrol: {
    address: "Adresse",
    outpoint: "ID",
    title: "Outputs whlen"
  },
  confirm: {
    "selected-coins": "Ausgewhlte Coins",
    title: "Besttige und sende die Transaktion",
    total: "Gesamt"
  },
  error: {
    erc20InsufficientGasFunds: "Es scheint, als httest du nicht genug Ether, um fr diese ERC20-Transaktion zu bezahlen. Bitte vergewissere dich, dass du genug Ether in deiner Wallet hast.",
    feeTooLow: "Gebhr zu niedrig",
    feesNotAvailable: "Gebhren konnten nicht geschtzt werden",
    insufficientFunds: "Unzureichende Mittel",
    invalidAddress: "ungltige Adresse",
    invalidAmount: "ungltige Menge",
    invalidData: "ungltige Daten"
  },
  fee: {
    customPlaceholder: "Betrag eingeben",
    label: "Netzwerk Gebhr",
    placeholder: "Nicht verfgbar"
  },
  feeTarget: {
    customLabel: "Gebhren-Rate",
    customLabel_eth: "Gas-Preis",
    description: {
      economy: "4 Stunden (24 Blcke)",
      economy_eth: "30 Minuten oder weniger",
      economy_ltc: "1 Stunde (24 Blcke)",
      high: "20 Minuten (2 Blcke)",
      high_eth: "30 Sekunden oder weniger",
      high_ltc: "5 Minuten (2 Blcke)",
      low: "2 Stunden (12 Blcke)",
      low_eth: "5 Minuten oder weniger",
      low_ltc: "30 Minuten (12 Blcke)",
      normal: "1 Stunde (6 Blcke)",
      normal_eth: "2 Minuten oder weniger",
      normal_ltc: "15 Minuten (6 Blcke)"
    },
    estimate: "Geschtzte Wartezeit:",
    label: {
      custom: "Eigene Gebhr",
      economy: "Sehr niedrig",
      high: "Hoch",
      low: "Niedrig",
      normal: "Normal"
    },
    placeholder: "Gebhr wird berechnet...."
  },
  maximum: "Alles senden",
  maximumSelectedCoins: "Ausgewhlte Coins senden",
  noFeeTargets: "Gebhrenschtzungen sind derzeit nicht verfgbar. Bitte versuche es spter erneut oder gib eine benutzerdefinierte Gebhr ein.",
  priority: "Prioritt",
  scanQR: "QR Code scannen",
  signprogress: {
    description: "Dies ist eine Transaktion, die viele Daten enthlt. Um die Transaktion vollstndig zu signieren, wirst du aufgefordert, {{steps}} mal auf der BitBox zu besttigen.",
    label: "Fortschritt"
  },
  success: "Die Transaktion wurde signiert und versendet.",
  title: "{{accountName}} senden",
  toggleCoinControl: "Coin Control",
  transactionDetails: "Transaktionsdetails"
}, settings$h = {
  about: "ber die App",
  accounts: "Konten",
  advancedSettings: "Erweiterte Einstellungen",
  appearance: "Ansicht",
  electrum: {
    add: "Server hinzufgen",
    "add-server": "Hinzufgen",
    check: "berprfen",
    checkFailed: "Fehlgeschlagen",
    checkSuccess: "Verbindung zu {{host}} wurde erfolgreich hergestellt",
    checking: "berprfen",
    "download-cert": "Remote-Zertifikat herunterladen",
    "remove-server": "Entfernen",
    removeConfirm: "Entfernen {{server}}?",
    reset: "In Werkszustand zurcksetzen",
    resetConfirm: "Mchtest du alle Server entfernen und die Standardserver installieren?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Gib den Endpunkt ein",
    step2: "2",
    "step2-text": "Gib ein Zertifikat der Zertifikatskette des Servers ein. Lade alternativ das Remote-Zertifikat herunter und vergleiche es visuell.",
    "step2-text-tcp": "berspringe diesen Schritt, wenn du kein TLS verwenden mchtest.",
    step3: "3",
    "step3-text": "berprfe die Verbindung und fge den Server hinzu.",
    step4: "4",
    "step4-text": "Starte die BitBoxApp neu. Wenn du die Standardserver nicht entfernst, wird dein eigener Node als Redundanz hinzugefgt.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Coin Control aktivieren",
    electrum: {
      description: "Du kannst dich mit deinem eigenen Electrum-Fullnode verbinden.",
      title: "Eigenen Full Node verbinden"
    },
    fee: "Eigene Gebhr aktivieren",
    setProxyAddress: "Proxy Adresse eingeben",
    title: "Erweiterte Einstellungen",
    useProxy: "Tor Proxy aktivieren",
    useSats: "BTC-Werte in Satoshis anzeigen"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Neues Update verfgbar",
    title: "Info",
    "up-to-date": "Deine App ist auf dem neuesten Stand",
    version: "App-Version"
  },
  restart: "Bitte starte die BitBoxApp neu, damit die nderungen wirksam werden.",
  services: {
    title: "Dienste"
  },
  success: "Bitte trenne die BitBox und stecke sie wieder ein, damit die nderungen wirksam werden.",
  title: "Einstellungen"
}, setup$g = "Gertepasswort festlegen", sidebar$h = {
  buy: "Krypto kaufen",
  device: "Gert verwalten",
  leave: "Verlassen",
  settings: "Einstellungen"
}, success$n = {
  create: {
    info1: "Ein Backup deiner Wallet wurde sicher auf der microSD Karte gesichert. Entferne die Karte und bewahre diese an einem sicheren Ort auf.",
    info2: "Du hast ein Gertepasswort erstellt, mit dem die BitBox entsperrt wird.",
    info3: "Du hast ein Wiederherstellungspasswort fr deine Wallet erstellt, das deine Coins freigibt und dein Backup wiederherstellt.",
    summary: "Hier ist eine Zusammenfassung von dem, was du getan hast:",
    title: "Erfolg"
  },
  getstarted: "Loslegen",
  restore: {
    summary: "Du hast erfolgreich deine Wallet aus einem Backup wiederhergestellt.",
    title: "Erfolg"
  }
}, transaction$h = {
  confirmation: "Besttigungen",
  details: {
    activity: "Aktivitt",
    address: "Adresse",
    amount: "Betrag",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Fiatbetrag",
    fiatAtTime: "Fiat zur Transaktionszeit",
    status: "Status",
    type: "Typ"
  },
  explorer: "Transaktions ID",
  explorerTitle: "In externem Block Explorer ffnen.",
  fee: "Gebhr",
  fiatHistorical: "Historisch",
  gas: "Gas",
  note: {
    edit: "Notiz bearbeiten",
    save: "Notiz speichern"
  },
  pending: "Ausstehende Transaktion",
  size: "Gre",
  status: {
    complete: "Besttigt",
    failed: "Fehlgeschlagen",
    pending: "Ausstehend"
  },
  tx: {
    received: "Empfangen an",
    sent: "Gesendet an"
  },
  vsize: "Virtuelle Gre",
  weight: "Gewicht"
}, transactions$g = {
  errorLoadTransactions: "Beim Laden der Transaktionen ist ein Fehler aufgetreten",
  placeholder: "Noch keine Transaktionen."
}, unknownError$g = `Ein unbekannter Fehler ist aufgetreten {{errorMessage}}

`, unlock$g = {
  description: "Gib dein Gertepasswort ein um dein Gert zu entsperren.",
  error: {
    e109_normal: "Gertepasswort inkorrekt.  {{remainingAttempts}} Versuche verbleibend, bevor sich das Gert in den Werkszustand zurcksetzt. ",
    e109_touch: "$t(unlock.error.e109_normal) Beim nchsten Loginversuch musst du die LED lange halten.",
    e113: "Aufgrund zu vieler Loginversuche musst du beim nchsten Versuch die LED 4 Sekunden lang drcken."
  },
  input: {
    label: "Gertepasswort",
    placeholder: "Gib dein Gertepasswort ein um das Gert zu entsperren."
  },
  unlocking: "Entsperren..."
}, upgradeFirmware$h = {
  button: "Firmware aktualisieren",
  description: "Mchtest du von Version  {{currentVersion}} zu Version {{newVersion}} upgraden?",
  label: "Deine BitBox bentigt eine Firmware Aktualisierung.",
  locked: "Um von Version  {{currentVersion}} zu Version  {{newVersion}} upzugraden, drcke die LED bitte lange. ",
  title: "Firmware upgraden",
  unlocked: "Der Bootloader ist gesperrt. Um fortzufahren:",
  unlocked1: "Steck deine BitBox aus und dann wieder ein.",
  unlocked2: "Die LED wird aufleuchten, wenn deine BitBox wieder eingesteckt ist.",
  unlocked3: "Tippe auf die LED, wenn diese aufleuchtet."
}, walletConnect$a = {
  connect: {
    button: "Verbinden",
    dappLabel: "Gebe die URI-Adresse der Dapp ein",
    invalidPairingUri: "Ungltige Pairing-URI"
  },
  dashboard: {
    allSessions: "Alle Sitzungen",
    disclaimer: "Walletconnect ist ein Protokoll zur Verbindung mit Ethereum basierten Dapps. Diese Dapps werden von Drittanbieterdiensten betrieben. Stelle daher nur eine Verbindung zu Dapps her, denen du vertraust, und stelle sicher, dass du bei einer Transaktion immer weit, was du signierst.",
    newConnection: "Neue Verbindung",
    noConnectedSessions: "Derzeit sind keine Konten mit Dapps verbunden."
  },
  invalidPairingChain: "Fehler beim Genehmigen des Pairing. Bitte stelle sicher, dass du eines der untersttzten Netzwerke verwendest: {{chains}}",
  pairingRequest: {
    approve: "Verbindung erlauben",
    reject: "Ablehnen",
    title: "Neue Verbindungsanfrage von"
  },
  pairingSuccess: "Dapp erfolgreich verbunden. Du kannst auf der Dapp-Website fortfahren.",
  signingRequest: {
    account: "Konto",
    chain: "Netzwerk",
    dapp: "Dapp",
    data: "Daten",
    dataParsingError: "Parsen der Daten fehlgeschlagen",
    decodeError: "Nachricht konnte nicht dekodiert werden",
    method: {
      sendTransaction: "Transaktion signieren und senden",
      signMessage: "Nachricht signieren",
      signTransaction: "Transaktion signieren",
      signTypedData: "Signiere eingegebene Daten"
    },
    successfullySigned: "Anfrage erfolgreich signiert",
    walletConnectRequest: "WalletConnect Anfrage"
  },
  useNewUri: "Dieser URI wurde bereits fr den Verbindungsversuch verwendet. Bitte verwende eine neue URI.",
  walletConnect: "WalletConnect"
}, warning$m = {
  receivePairing: 'Bitte aktiviere 2FA, um Adressen sicher zu verifizieren. Klicke dazu auf "Gerte verwalten" im Men auf der linken Seite.',
  sdcard: "Bewahre deine microSD Karte separat von deiner BitBox auf. Die microSD Karte wird nur bentigt, wenn du deine Backups verwalten willst. Fr den normalen Betrieb ist sie nicht erforderlich.",
  sendPairing: 'Bitte koppele deine BitBox mit einem Smartphone um Transaktionen sicher verifizieren zu knnen. Klicke dazu auf "Gerte verwalten" im Men auf der linken Seite.'
}, welcome$g = {
  connect: "Verbinde eine BitBox02",
  getStarted: "Beginnen wir mit der Installation der Firmware auf deiner BitBox02.",
  insertBitBox02: "Tippe dann auf die BitBox02 zum weiter machen. ",
  insertDevice: "Bitte verbinde dein Gert, um loszulegen",
  title: "Willkommen"
}, appTranslationsDE = {
  account: account$g,
  accountInfo: accountInfo$g,
  accountSummary: accountSummary$g,
  addAccount: addAccount$h,
  aopp: aopp$a,
  app: app$g,
  auth: auth$9,
  backup: backup$g,
  bb02Bootloader: bb02Bootloader$g,
  bitbox: bitbox$g,
  bitbox02Interact: bitbox02Interact$g,
  bitbox02Settings: bitbox02Settings$g,
  bitbox02Wizard: bitbox02Wizard$g,
  blink: blink$g,
  bootloader: bootloader$g,
  button: button$k,
  buy: buy$c,
  changePin: changePin$g,
  chart: chart$c,
  checkSDcard: checkSDcard$g,
  clickHere: clickHere$g,
  confirm: confirm$i,
  confirmOnDevice: confirmOnDevice$g,
  connectKeystore: connectKeystore$9,
  darkmode: darkmode$a,
  device: device$g,
  deviceLock: deviceLock$g,
  deviceSettings: deviceSettings$g,
  deviceTampered: deviceTampered$g,
  dialog: dialog$h,
  error: error$c,
  fiat: fiat$i,
  footer: footer$i,
  generic: generic$c,
  genericError: genericError$g,
  goal: goal$g,
  guide: guide$h,
  headerssync: headerssync$g,
  hiddenWallet: hiddenWallet$g,
  initialize: initialize$g,
  invalidFormat: invalidFormat$g,
  language: language$h,
  legacyhiddenwallet: legacyhiddenwallet$g,
  loading: loading$g,
  manageAccounts: manageAccounts$a,
  mobile: mobile$b,
  newSettings: newSettings$9,
  note: note$c,
  notification: notification$g,
  pairing: pairing$g,
  passphrase: passphrase$a,
  password: password$g,
  random: random$h,
  receive: receive$i,
  reset: reset$g,
  securityInformation: securityInformation$g,
  seed: seed$g,
  seedRestore: seedRestore$g,
  send: send$i,
  settings: settings$h,
  setup: setup$g,
  sidebar: sidebar$h,
  success: success$n,
  transaction: transaction$h,
  transactions: transactions$g,
  unknownError: unknownError$g,
  unlock: unlock$g,
  upgradeFirmware: upgradeFirmware$h,
  walletConnect: walletConnect$a,
  warning: warning$m,
  welcome: welcome$g
}, account$f = {
  disconnect: "Connection lost. Retrying",
  export: "Export",
  exportTransactions: "Export transactions to downloads folder as CSV file",
  fatalError: "There was an unexpected error.",
  incoming: "Incoming",
  initializing: "Getting information from the blockchain",
  maybeProxyError: "Tor proxy enabled. Ensure that your Tor proxy is running properly, or disable the proxy setting.",
  reconnecting: "Lost connection, trying to reconnect",
  syncedAddressesCount: "Scanned {{count}} addresses"
}, accountInfo$f = {
  address: "Address",
  buyCTA: {
    buy: "Buy {{unit}}",
    buyCrypto: "Buy Crypto",
    information: {
      looksEmpty: "Looks like this wallet is empty.",
      start: "Get started by depositing some coins to the wallet or buying directly in the BitBoxApp."
    }
  },
  extendedPublicKey: "Extended public key",
  label: "Account info",
  scriptType: "Script type",
  title: "Account information",
  verify: "Verify on device",
  xpubTypeChangeBtn: {
    p2pkh: "View legacy P2PKH extended public key",
    p2tr: "View Taproot",
    p2wpkh: "View Native Segwit",
    "p2wpkh-p2sh": "View older Segwit extended public key"
  },
  xpubTypeInfo: "Currently displaying {{scriptType}} extended public key ({{current}} of {{numberOfXPubs}})"
}, accountSummary$f = {
  availableBalance: "Available balance",
  balance: "Balance",
  exportSummary: "Export accounts summary to downloads folder as CSV file",
  fiatBalance: "Fiat balance",
  name: "Account name",
  noAccount: "There are no accounts to show.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "My portfolio",
  total: "Total",
  transactionHistory: "Transaction history"
}, addAccount$g = {
  chooseName: {
    nextButton: "Add account",
    step: "Name account",
    title: "Name your account"
  },
  selectCoin: {
    nextButton: "Next",
    step: "Select coin",
    title: "Select cryptocurrency"
  },
  success: {
    addAnotherAccount: "Add another account",
    message: "<strong>{{accountName}}</strong> has now been added to your accounts.",
    nextButton: "Done",
    step: "Finished",
    title: "Account added"
  },
  title: "Add account"
}, aopp$9 = {
  addressRequest: "{{host}} is requesting a receiving address.",
  addressRequestWithLogo: "is requesting a receiving address",
  banner: "Address request in progress. Please connect your device to continue.",
  errorTitle: "Error during address request ",
  labelAddress: "Address",
  labelMessage: "Message",
  reverifyInfoText: "Verify address",
  signing: "To proceed, sign message on your BitBox02",
  success: {
    message: "Proceed on {{host}}",
    title: "Address successfully sent"
  },
  syncing: "Syncing the account, please wait.",
  title: "Address request"
}, app$f = {
  upgrade: "A new version of this app is available! Please upgrade from {{current}} to {{version}}."
}, auth$8 = {
  authButton: "Authenticate",
  title: "Please authenticate to continue"
}, backup$f = {
  check: {
    checking: "Checking backup",
    confirmTitle: "Check backup",
    notOK: "Backup does NOT match the wallet.",
    ok: "Backup matches the wallet.",
    password: {
      label: "Recovery password",
      placeholder: "Recovery password",
      showLabel: "recovery password"
    },
    success: "Successfully verified backup:",
    title: "Check backup"
  },
  create: {
    alreadyExists: "You already have a valid backup. Do you wish to re-create it?",
    fail: "Creating the backup FAILED!",
    info: "Please enter the recovery password of the current wallet for verification.",
    name: {
      label: "Backup name",
      placeholder: "Please name the backup"
    },
    password: {
      label: "Recovery password",
      placeholder: "Please enter your recovery password"
    },
    title: "Create backup",
    verificationFailed: "The recovery password does NOT MATCH the current wallet. The backup has been created. Please use 'Check backup' to verify your recovery password again."
  },
  description: "Select <strong>wallet backup file</strong>",
  insert: "Please insert the microSD card to manage backups.",
  insertButton: "I have inserted the microSD card",
  list: "Your microSD card backups",
  noBackups: "There are no backups on this microSD card.",
  restore: {
    confirmTitle: "Restore backup",
    error: {
      e200: "microSD card not found",
      general: "Error restoring the backup"
    },
    password: {
      label: "Recovery password or hidden recovery password",
      placeholder: "Recovery password",
      repeatPlaceholder: "Repeat recovery password",
      showLabel: "Recovery password"
    },
    restoring: "Restoring backup",
    selectedBackup: "<strong>{{backupName}}</strong> created on {{createdDateTime}} will be restored.",
    title: "Restore",
    understand: "I understand that an incorrect recovery password will create a different wallet"
  },
  showMnemonic: {
    description: `You will be presented with your recovery words, which form a backup of your wallet. Write them down on paper.

<strong>Do not store them digitally or take pictures of it.</strong>

<strong>Do not say the words out loud.</strong>

<strong>This backup is not password-protected.</strong>

Afterwards, you will be asked to confirm each word.`,
    title: "Show recovery words",
    warning: "<strong>Never share your recovery words with anyone.</strong> Your recovery words give full access to your wallet. If someone is asking you for your recovery words, it's a scammer, do not share them!"
  },
  title: "Manage backups"
}, bb02Bootloader$f = {
  abort: "Don't upgrade  take me back",
  abort_noUpgrade: "Take me back",
  advanced: {
    label: "Advanced settings",
    toggleShowFirmwareHash: "Show the firmware hash every time on startup"
  },
  flipscreen: "Flip screen",
  orientation: "Device oriented the wrong way?",
  success: "Upgrade successful! Continuing in {{rebootSeconds}} seconds...",
  success_install: "Installation successful! Continuing in {{rebootSeconds}} seconds..."
}, bitbox$f = {
  error: {
    e10000: "Current device password incorrect.",
    e10001: "Failed to replace device password",
    e102: "The password must consist of at least 4 characters.",
    e112: "Hidden device password cannot be the same as the main device password."
  }
}, bitbox02Interact$f = {
  confirmDate: "Confirm today's date on your BitBox02",
  confirmDateText: "This date will be used to create your backup.",
  confirmName: "Confirm name on BitBox02",
  confirmWords: "Write down the {{amount}} recovery words from your BitBox02",
  confirmWordsText: "After that the BitBox02 asks you to confirm each word to verify that the backup is correct.",
  followInstructions: "Please follow the instructions on your BitBox02.",
  followInstructionsMnemonic: "Follow the instructions on your BitBox02 to enter the recovery words from your backup and restore your wallet.",
  followInstructionsMnemonicTitle: "Restore from recovery words"
}, bitbox02Settings$f = {
  deviceName: {
    current: "Current device name",
    error: "Device name could not be set",
    error_104: "Confirming device name was aborted on device.",
    input: "BitBox02 name",
    placeholder: "New device name",
    title: "Set BitBox02 name"
  },
  gotoStartupSettings: {
    description: "This will reboot your BitBox02 and enter the startup settings.",
    title: "Go to startup settings"
  }
}, bitbox02Wizard$f = {
  advanced: {
    button: "Advanced options",
    outOfDate: "Firmware out of date for this feature",
    seed12WordInfo: "Please note that the number of words cannot be changed after creating the wallet.",
    seed12WordLabel: "Create 12-word instead of 24-word seed",
    seed12WordText: "By default the BitBox02 uses a 24-word seed. Both seed lengths are secure against brute forcing in practice. Some users may prefer the convenience of the 12-word seed instead.",
    skipSDCardLabel: "Skip microSD card backup and write down recovery words instead",
    skipSDCardText: "You always have the option to create a microSD card backup or write your recovery words after setup. This can be done from settings.",
    title: "Advanced backup options"
  },
  attestationFailed: "Genuine check failed, which could be due to restarting the app while the device was waiting for user input. Please reconnect and try again. Please contact support@bitbox.swiss if this persists.",
  backup: {
    point1: "Select a backup on the microSD card",
    point2: "Set a password for your device",
    restoreText: "Ok, let's restore a backup!",
    text1: "Great, your BitBox02 password is now set and wallet created. Now it's time to create your first backup. Please make sure your microSD card is inserted into your BitBox02 and continue.",
    text2: "Please follow the on-screen instruction on your device to create a backup.",
    text3: "After your backup is created, please remove the microSD card and store it in a <strong>secure location</strong>. The contents of the microSD card is not password-protected. Never insert it into any other device but your BitBox02.",
    userConfirmation1: "I should store my backup in a secure location.",
    userConfirmation2: "My backup is not password protected. Anyone with access to it can access my wallet.",
    userConfirmation3: "If I lose or damage my BitBox02, the only way to recover my funds is to restore from my backup.",
    userConfirmation4: "If I lose or damage both my backup and my BitBox02 then my funds will be lost.",
    userConfirmation5: "I should not insert my microSD card backup into a computer, phone, printer or any device other than a BitBox02.",
    userConfirmation5mnemonic: "I should not put my recovery words in a computer, phone, printer or any device other than a BitBox02."
  },
  create: {
    button: "Name device & continue",
    info: "Here are the basics steps you will be taking to set up your BitBox: ",
    inputTitle: "Wallet name",
    point1: "Name your device",
    point2: "Set a password for your device",
    point3: "Create a backup",
    text: "Ok, let's create a new wallet!"
  },
  createBackupAborted: "Creating backup aborted.",
  createBackupFailed: "Creating backup failed, try again.",
  initialize: {
    passwordText: "Now let's set a password for your device. Use the controls on your BitBox to enter and choose a password.",
    passwordTitle: "Set a password for your BitBox",
    text: "Successfully paired your BitBox02! Now let's initialize your device. Get started by choosing to create a new wallet, or to restore a wallet from an existing backup. <strong>Please make sure you have a microSD card inserted in your BitBox02</strong>",
    tip: "We recommend that you proceed in a secure location.",
    title: "Initialize your BitBox"
  },
  insertSDCard: "<strong>Please make sure you have a microSD card inserted in your BitBox02.</strong>",
  noPasswordMatch: "Passwords did not match, please try again.",
  pairing: {
    failed: "Unconfirmed pairing. Please replug your BitBox02.",
    paired: "You have confirmed the following code on your device. Please continue.",
    title: "Verify pairing code",
    unpaired: "An unpaired BitBox02 has been detected. Please verify the pairing code matches what is shown on your BitBox02."
  },
  restoreFromMnemonic: {
    e104: "Restoring from recovery words was canceled.",
    failed: "Restoring from recovery words failed, please try again."
  },
  stepBackup: {
    beforeProceed: "Before proceeding, please read these important security considerations:",
    createBackup: "You will now create a backup on your microSD card.",
    createBackupMnemonic: "You will now write down the recovery words."
  },
  stepBackupSuccess: {
    fundsSafe: "To keep your funds safe, please remember the following:",
    title: "Backup Restored!"
  },
  stepConnected: {
    unlock: "Enter BitBox02 password to unlock."
  },
  stepCreate: {
    description: "This name is used as the device name and for the backup.",
    nameLabel: "BitBox02 name",
    namePlaceholder: "My BitBox02",
    title: "Choose BitBox02 name",
    toastMicroSD: "Please insert your microSD card into your BitBox02 which will be used to store a backup of the wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Please remove the microSD card from your BitBox02 and store it in a secure location.",
    storeMnemonic: "Please store your recovery words in a secure location",
    success: "Youve successfully created your backup."
  },
  stepInsertSD: {
    insertSDCard: "Please insert a microSD card into your BitBox02 to continue.",
    insertSDcardTitle: "Insert microSD card"
  },
  stepPassword: {
    e104: "Setting password was canceled.",
    title: "Set BitBox02 password",
    useControls: "Use the controls on your BitBox02 to set a password."
  },
  stepUninitialized: {
    create: "I want to setup a new BitBox02.",
    restore: "I want to restore my wallet from a backup.",
    restoreMicroSD: "Restore from microSD card",
    restoreMnemonic: "Restore from recovery words",
    title: "Setup your BitBox02"
  },
  success: {
    text: `Hooray! Your BitBox02 is now ready to use. 

For further information on how to use the BitBoxApp, please use the in-app guide by clicking the question mark on the top right corner.`,
    title: "You're ready to go!"
  }
}, blink$f = {
  button: "Blink"
}, bootloader$f = {
  button: "Upgrade firmware now",
  button_install: "Install firmware now",
  progress: "Upgrading: {{progress}}%",
  progress_install: "Installing: {{progress}}%",
  success: "Upgrade successful! Please replug the device. This time, do not touch the button."
}, button$j = {
  abort: "Abort",
  back: "Back",
  buy: "Buy",
  changepin: "Change device password",
  check: "Check backup",
  continue: "Continue",
  copy: "Copy",
  create: "Create",
  dismiss: "Dismiss",
  done: "Done",
  download: "Download",
  hiddenwallet: "Create hidden wallet",
  next: "Next",
  ok: "OK",
  previous: "Previous",
  receive: "Receive",
  restore: "Restore",
  select: "Select",
  send: "Send",
  unlock: "Unlock",
  update: "Update",
  upgrade: "Upgrade"
}, buy$b = {
  exchange: {
    bankTransfer: "Bank transfer",
    bestDeal: "Best deal",
    creditCard: "Credit card",
    fast: "Fast",
    fee: "fee",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bank Transfer: {{fee}}%",
          creditDebitCard: "Credit/debit card: {{fee}}%",
          learnMore: "Learn more about Moonpay",
          title: "Fees"
        },
        fullCurrenciesList: "See full list of currencies here",
        payment: {
          asteriskText: "* Not available for US residents",
          bankTransfer: "Bank transfer*",
          bankTransferDetails: {
            pix: "PIX (BR transactions in Brazil only)",
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          creditDebitCard: "Credit/debit Card",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "See more details about payment methods",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports all major fiat currencies: USD, EUR, CHF, and more."
      },
      pocket: {
        fees: {
          info: "Bank transfer: {{fee}}%",
          title: "Fees"
        },
        learnMore: "Learn more about Pocket",
        payment: {
          bankTransfer: "Bank transfer",
          bankTransferDetails: {
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            sic: "Swiss Interbank Clearing (CHF transactions in CH/LI only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          bankTransferReccuring: "How to set up recurring purchases with a standing order?",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports European currencies: EUR, GBP, and CHF.",
        verification: {
          info: "Only requires identity verification above daily and annual thresholds.",
          link: "Find current thresholds here",
          title: "Identity verification"
        }
      },
      region: {
        title: "Select the region your bank account is registered in to see which options are available to you."
      }
    },
    noExchanges: "Sorry, there are no available exchanges in this region.",
    region: "Region",
    selectRegion: "Not specified",
    title: "Buy {{name}}"
  },
  info: {
    continue: "Agree and continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "We partner with MoonPay to offer you a seamless way to buy {{name}} directly within the BitBoxApp. It's just a few clicks.",
        "MoonPay is a platform that makes it easy and quick to buy {{name}} in over 160+ countries."
      ],
      payment: {
        details: "You can buy {{name}} instantly via MoonPay with the following payment methods. Credit or debit card orders are instant and convenient, but more expensive due to increased chargeback risk. We recommend using the bank transfer option for larger amounts. The minimum fee is 4 USD/EUR or equivalent.",
        footnote: "Please note that MoonPay's exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
        table: {
          "1_description": "Lowest fees, can take up to 3 working days",
          "1_method": "Bank transfers (SEPA)",
          "2_description": "Higher fees but quick and instant",
          "2_method": "Credit & debit cards",
          description: "Description",
          fee: "Fee",
          method: "Method"
        },
        title: "Payment methods and fees"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. MoonPay needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
        descriptionGeneric: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. However partner exchanges need to collect some information to operate. Please refer to their respective privacy policies to see in more detail how the data is handled.",
        title: "Data protection"
      },
      security: {
        description: "When you buy {{name}} via MoonPay, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        descriptionGeneric: "When you buy {{name}} via a partner exchange, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        link: "Security threat model",
        title: "Security model"
      },
      title: "Welcome to your one stop shop for buying {{name}}"
    },
    next: "Next",
    selectLabel: "Choose your account",
    selectPlaceholder: "Select a coin",
    skip: "Do not show again",
    title: "Buy {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket privacy policy",
      p1: "The BitBoxApp does not collect any data when buying bitcoin, the incoming funds are treated like a regular transaction. Pocket needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
      title: "Data protection"
    },
    kyc: {
      link: "Read Pocket FAQs",
      p1: "Pocket tries to keep KYC to a minimum. For purchases under 950 EUR (1000 CHF) a day, no additional documents are required. For purchases over this amount, you will need to schedule a call with Pocket to complete the necessary KYC/AML process.",
      title: "KYC/AML"
    },
    payment: {
      p1: "You can buy bitcoin instantly with Pocket via SEPA bank transfer. The fee is 1.5% and the bitcoin is deposited to your BitBox as soon as possible after Pocket receives the bank transfer (usually within the same day).",
      p2: "Please note that Pockets exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
      title: "Payment methods and fees"
    },
    previousTransactions: "The transaction history of this account is not empty. Sharing this account will make all its past and future transactions visible for Pocket. Proceed anyway?",
    security: {
      link: "BitBox02 security threat model",
      p1: "When you buy bitcoin via Pocket, you are using an external service. This service is out of scope of the BitBox02 Security Threat model and relies on the safety and security of the environment which the BitBoxApp software is running in. However we work together to improve security by using a two factor authentication mechanism to verify the address you are receiving to.",
      title: "Security model"
    },
    usedAddress: "The address {{address}} has been already used, please start again with a new address.",
    verifyBitBox02: "Please verify that the address you received via email matches the one displayed on your Bitbox. If possible, you should open the email on a second device for better security.",
    welcome: {
      p1: "We partner with Pocket to offer you a seamless way to buy bitcoin directly within the BitBoxApp. It's just a few clicks.",
      p2: "Pocket is a Swiss platform that makes it quick and easy to buy bitcoin in most of Europe (anywhere where SEPA bank transfers are supported).",
      p3: "With Pocket, you can also do regular buys through standing bank orders, so you can DCA (dollar-cost averaging) with ease.",
      title: "Welcome to your one stop shop for buying bitcoin"
    }
  },
  title: "Buy {{name}}"
}, changePin$f = {
  newTitle: "New device password",
  oldLabel: "Current device password"
}, chart$b = {
  dataMissing: "Gathering historical data... stay tuned.",
  dataOldTimestamp: "Historical exchange rates updating. The chart is not displaying data after {{time}}.",
  dataUpdating: "updating data",
  filter: {
    all: "All",
    month: "Month",
    week: "Week",
    year: "Year"
  }
}, checkSDcard$f = "checking microSD card", clickHere$f = "Click here.", confirm$h = {
  abortInfo: "Tap to ",
  abortInfoRedText: "abort",
  approveInfo: "Hold 4+ secs to ",
  approveInfoGreenText: "confirm",
  info: "Continue on your BitBox. ",
  infoWhenPaired: "First on the paired mobile and then your BitBox"
}, confirmOnDevice$f = "Please confirm on your device.", connectKeystore$8 = {
  promptNoName: "Please connect your BitBox02 to continue",
  promptWithName: 'Please connect your BitBox02 named "{{name}}" to continue'
}, darkmode$9 = {
  toggle: "Dark mode"
}, device$f = {
  appUpradeRequired: "Your BitBox is not compatible with this desktop application. Please download and install the latest version.",
  keystoreConnected: "Connected wallet"
}, deviceLock$f = {
  button: "Enable two factor authorization (2FA)",
  condition1: "Do you have a backup?",
  condition2: "Is mobile app verification working?",
  condition3: "2FA DISABLES backups and mobile app pairing. The device must be RESET to exit 2FA!",
  confirm: "Enable two factor authorization (2FA)",
  title: "Enable two factor authorization (2FA)"
}, deviceSettings$f = {
  backups: {
    manageBackups: {
      description: "Create or verify your microSD card backup."
    },
    showRecoveryWords: {
      description: "Show and verify recovery words."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "The BitBoxApp checks if your device is authentic."
    },
    deviceName: {
      description: "Change the name of your device."
    },
    rootFingerprint: {
      description: "The root fingerprint is a unique identifier for the wallet currently in use. It can help you distinguish between different wallets if you use passphrases."
    },
    securechip: {
      description: "The model of the secure chip."
    },
    title: "Device information"
  },
  expert: {
    factoryReset: {
      description: "Reset your device to factory settings. This deletes the wallet from your BitBox02!",
      title: "Factory reset"
    },
    goToStartupSettings: {
      description: "Enter the bootloader of the BitBox02. You can enable the firmware hash from here."
    },
    passphrase: {
      description: "Enable or disable the passphrase feature.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Available version"
    },
    title: "Firmware",
    upToDate: "Your device is up to date",
    upgradeAvailable: "New upgrade available",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "Authenticity check failed",
      label: "Authenticity check",
      true: "Your BitBox02 is authentic"
    },
    sdcard: {
      false: "Not inserted",
      label: "microSD card",
      true: "Inserted"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Retrieving device info",
  pairing: {
    lock: {
      false: "Disabled",
      label: "Two factor authorization (2FA)",
      true: "Enabled"
    },
    mobile: {
      false: "Closed",
      label: "Mobile app",
      true: "Open"
    },
    status: {
      false: "Not paired",
      label: "Status",
      true: "Paired"
    },
    title: "Pairing"
  },
  secrets: {
    manageBackups: "Manage backups",
    title: "Secrets"
  }
}, deviceTampered$f = "Has your BitBox been supplied with a recovery password? If so, stop the setup process and contact support immediately. Shift will never give you a ready made wallet or make password recommendations.", dialog$g = {
  cancel: "Cancel",
  confirm: "Confirm",
  confirmTitle: "Confirmation"
}, error$b = {
  accountAlreadyExists: "The account already exists.",
  accountLimitReached: "Cannot add account. The maximum number of accounts for this coin has been reached.",
  aoppCallback: "There was an error delivering the address to {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "There are no available accounts.",
  aoppSigningAborted: "Address ownership request cancelled.",
  aoppUnknown: "An unknown error occurred.",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "There are no available accounts that support the requested address format.",
  aoppUnsupportedKeystore: "The connected device cannot sign messages for this asset.",
  aoppVersion: "Unknown version.",
  wrongKeystore: "Wrong wallet connected. Please make sure to insert the correct device matching this account.",
  wrongKeystore2: " If you are using the optional passphrase, make sure you have entered the correct passphrase for the account."
}, fiat$h = {
  default: "default",
  setDefault: "Set {{code}} as default",
  title: "Currencies"
}, footer$h = {
  appVersion: "App version:"
}, generic$b = {
  enabled_false: "Disabled",
  enabled_true: "Enabled"
}, genericError$f = "An error occurred. If you notice any issues, please restart the application.", goal$f = {
  buttons: {
    create: "Create a new wallet",
    restore: "Restore a wallet from a backup"
  },
  paragraph: "Please select one of the following options:",
  step: {
    1: {
      title: "Security information"
    },
    2: {
      description: "Set a device password",
      title: "Device"
    },
    "3-create": {
      description: "Create a new wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "from a backup",
      title: "Restore"
    },
    "4-create": {
      title: "Summary"
    },
    "4-restore": {
      title: "Summary"
    }
  }
}, guide$g = {
  accountDescription: {
    text: "Your account overview shows your available balance as well as incoming and outgoing transactions. Our guide in Settings has more information about each account type. ",
    title: "What does this page show me?"
  },
  accountFiat: {
    text: "Yes. Click on any ticker to rotate through fiat currencies. You can change the list of currencies in the settings.",
    title: "Can I display other conversion rates?"
  },
  accountIncomingBalance: {
    text: "Incoming sums up the amounts transferred to you but not yet confirmed by the network.",
    title: "What does incoming mean?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Each xpub is tied to the "Type" shown: either "Native Segwit (bech32)", "Wrapped Segwit" or Taproot (Bitcoin only). These are script types used by {{coinName}}. The BitBoxApp combines them, supporting multiple script types in the same account. Because each script type gives a different xpub, there are multiple xpubs per account.

If you consistently receive on the default address (Native Segwit), you only need the "bech32" xpub. However, if you also receive funds to "Wrapped Segwit" or Taproot, you also need to use the "Wrapped Segwit" and Taproot extended public keys respectively.`,
      title: "Why are there multiple xpubs?"
    },
    privacy: {
      text: `For this specific account, the extended public key reveals the entire financial history, your account balance, and all future transactions. But the xpub does not allow anyone to spend your coins.

If you give an xpub to someone, you should be aware that this person or company can see all other transactions of the same account. Therefore, its a good idea to use that account only for this purpose and keep other funds in different accounts.`,
      title: "Do I need to keep my xpub secret?"
    },
    verify: {
      text: "Yes, its always a good idea to double-check your xpub. If someone else will generate receive addresses from this xpub to send you money, this is especially important. You need to verify it on the device to ensure that this xpub belongs to you; otherwise, all funds could go to the wrong addresses.",
      title: "Do I need to verify the xpub on the device?"
    },
    xpub: {
      text: `An extended public key (xpub) is a root key from which all receiving addresses of an account are derived.

It is provided here for advanced use and interoperability with watch-only wallets, such as Electrum or Sentinel. If you received to different address types, please import all the different xpub formats into the watch-only wallet in order to see all your coins.

Please note, third party wallets may not support Taproot xpubs yet.`,
      title: "What is an extended public key?"
    }
  },
  accountRates: {
    text: "We update exchange rates every minute from CoinGecko.",
    title: "Which exchange rates apply?"
  },
  accountReload: {
    text: "Theres no need. Your transaction information is updated automatically.",
    title: "Can I reload the transaction history?"
  },
  accountSendDisabled: {
    text: "The Send button is activated when your balance is more than zero.",
    title: "Why can't I send any {{unit}}?"
  },
  accountSummaryAmount: {
    text: `The total amount is the sum of all your crypto accounts. Exchange rates are obtained from coingecko.com.

Note: If you use MyEtherWallet for tokens not supported in the BitBoxApp, they will not be included in the amount displayed.`,
    title: "How is the total amount calculated?"
  },
  accountSummaryDescription: {
    text: "Here you can see the performance of your portfolio over time. A summary of your individual crypto accounts is displayed under the chart.",
    title: "What does this page show me?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtual size: Determines the network fee. You successfully saved on fees if it is smaller than the transaction size.
Size: Actual transaction size in bytes when serialized according to the underlying blockchain.
Weight: A new metric introduced with Segwit to evaluate transaction and block sizes. Each segregated witness byte counts as one, everything else as four weight units. Instead of one megabyte in actual size, the block size limit is now four million weight units.`,
    title: "What about the Bitcoin-specific transaction details?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmations: Your first transaction broadcast is unconfirmed until a miner includes it in a block, after which it has one confirmation. Each block broadcast on the network adds another confirmation to your transaction. Generally merchants and other network actors will only settle transactions with between three to six confirmations.
Transaction ID: A unique identification number that allows you to look up a transaction in a block explorer.
Fee: Miners are paid a transaction fee as an incentive to include transactions in the blocks they mine. To learn more, click on the send button.`,
    title: "Whats the information in the transaction details?"
  },
  accountTransactionConfirmation: {
    text: "A transaction broadcast to the network but not yet confirmed.",
    title: "What is a pending transaction?"
  },
  accountTransactionLabel: {
    text: "Its the address you received coins from or sent coins to.",
    title: "Which address is displayed for each transaction?"
  },
  accountTransactionTime: {
    text: "The blockchain transaction confirmation time.",
    title: "What time is displayed?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin and Litecoin can have an arbitrary amount of accounts. After five accounts, you can only add another account if the previous account has been used. 
Other coins can have a maximum of five accounts.`,
      title: "How many accounts can I create?"
    },
    howtoAddTokens: {
      text: 'Tokens using the ERC20 standard are tied to a specific Ethereum account. To enable or disable a particular token, open the "Manage accounts" screen, expand your Ethereum account and switch the desired token on or off.',
      title: "How can I add additional tokens?"
    },
    moveFunds: {
      text: "Yes. But because accounts are independent, you need to send your funds using a regular transaction.",
      title: "Can I move funds between accounts?"
    },
    recoverAccounts: {
      text: "Yes. The BitBoxApp creates accounts using well-established standards compatible with most other crypto wallets.",
      title: "Can I recover my accounts with other wallets?"
    },
    whatAreAccounts: {
      text: "Your wallet can manage multiple accounts of the same coin. Accounts are helpful when you want to keep funds separate.",
      title: "What are accounts?"
    },
    whatIsRememberWallet: {
      text: `Enabling Remember wallet lets you see the accounts for this wallet in the BitBoxApp even when the BitBox02 is not plugged in. This allows you to check your balance and portfolio whenever you want. The BitBox02 still needs to be plugged in and unlocked to send or receive coins.

Disabling Remember wallet requires you to plug in the respective BitBox02 (or passphrase wallet) to see those accounts in the BitBoxApp.`,
      title: "What happens when I enable/disable Remember wallet?"
    },
    whyIsThisUseful: {
      text: 'Accounts are great for managing funds for different people or purposes because they are separated. You can also share the "extended public key" of an account without revealing anything about your other accounts. This allows you to repeatedly receive funds without reusing addresses, such as receiving your wage or regularly buying crypto.',
      title: "Why is this useful?"
    }
  },
  appendix: {
    link: "Contact us!",
    text: "Another question?"
  },
  backups: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet. It can also be used to verify that you still have the correct recovery password. You can check your main recovery password or your hidden recovery password.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: "No but your recovery password is required to derive the wallet from the stored seed.",
      title: "Can I encrypt the backup?"
    },
    howOften: {
      text: `The backup is automatically generated when a new wallet is created. You only have to make a new backup if your microSD card is lost or damaged, or if you want to use multiple microSD cards as backups.
You do not need to create new backups after transaction activity. All your transaction data can be recreated by your single backup that was automatically generated for you.`,
      title: "How often do I have to make a backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card. The seed together with your recovery password generates your wallet.",
      title: "What is a backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: 'No. Please keep the microSD card safe, as it contains the unencrypted seed to recover your wallet. If you wish to password-protect your seed, you can enable an optional passphrase in the expert settings under "Manage device".',
      title: "Can I encrypt the backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card.",
      title: "What is a backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `When 2FA is enabled, all transactions have to be approved on the paired mobile phone in order to spend coins. Under the hood, an encrypted single-use number is sent to the mobile app, decrypted there, and returned to the BitBox when pressing the Accept button. This communication with the device is done via the channel between the mobile phone and this desktop app established during pairing.

Be sure to backup your wallet and pair the mobile app before enabling 2FA. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.`,
      title: "How does Two factor authorization (2FA) work?"
    },
    disable2FA: {
      text: "In order to disable 2FA, you need to reset your BitBox and then restore the wallet from its backup. Make sure that you still have the microSD card with the backup and that you still remember the recovery password. Then press 'Reset device'. Set a new device password and choose 'Or restore a backup'. Select the backup you have made from the wallet, click 'Restore' and enter the recovery password you used when creating the wallet.",
      title: "How can I disable two factor authorization (2FA)?"
    },
    ejectBitbox: {
      text: "You can unplug the BitBox at any time without having to eject it first.",
      title: "How can I eject the BitBox?"
    },
    ejectSD: {
      text: "You can remove the microSD card from the BitBox at any time as long as you are not in the process of creating or restoring a backup.",
      title: "How can I eject the microSD card?"
    },
    hiddenWallet: {
      text: "It is a second wallet on the same device protected by a different device password and recovery password, which you can use for plausible deniability. The same backup seed is used for both your normal and hidden wallet, so no additional backup is required.",
      title: "What is a hidden wallet?"
    },
    legacyHiddenWallet: {
      text: "First click the button below (available if the BitBox is unlocked with the main device password and 2FA is disabled), then replug your Bitbox and unlock it with your hidden device password.",
      title: "How do I access the legacy hidden wallet?"
    },
    pairing: {
      text: "After having downloaded our mobile app for either iOS or Android, you scan the displayed QR code, which sets up a secure channel between the mobile app and this application. Once scanned, follow the instructions in the mobile app.",
      title: "How to securely pair with your phone"
    }
  },
  cointracking: {
    text: 'Click the "Export" button and open the downloads folder where you will find the CSV export. Then click the link below, upload your BitBox CSV file and import the data in order to use it for your CoinTracking portfolio manager and to create your tax reports.',
    title: "How to import my transactions into CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Read more about the authenticity check"
      },
      text: "The BitBoxApp performs an attestation check on the BitBox02 to verify if the device is genuine. The check is done locally and does not connect to any servers.",
      title: "How does the authenticity check work?"
    },
    name: {
      text: "This is the name of your wallet and backup. The name is used for future backups and can be used to help distinguish between different wallets. It can be changed at any time but note that backups made before the change will still use the previous name.",
      title: "What is the BitBox02 name used for?"
    },
    "secure-chip": {
      link: {
        text: "Read more about the secure chip"
      },
      text: "This information shows the model number of the secure chip, the most up to date chip is ATECC608B with improved security features compared to older models.",
      title: "Why show the secure chip model?"
    }
  },
  receive: {
    address: {
      text: "You can give the address to others to send you some coins. Just make sure they are sending to the correct address.",
      title: "What do I do with an address?"
    },
    addressChange: {
      text: "As soon as you transact, a new address is automatically added to the list so there are always 20 addresses available which have never received any coins.",
      title: "When do the addresses change?"
    },
    addressFormats: {
      text: "By default, the address type is Native Segwit. This address type is widely adopted by other wallets/exchanges and gives you the best fee rates for everyday transactions. However, you may also choose to send to Taproot (Bitcoin only), which is the newest address type, but may not be widely supported yet. Alternatively, if you are having issues sending to Native Segwit (the default type), you can try switching to the older Wrapped Segwit address type that may be compatible with more wallets/exchanges.",
      title: "When do I use Change address type?"
    },
    howVerify: {
      text: `For the BitBox01, click on the BitBox icon in the sidebar on the left and see the Pairing section. The guide will update and you can continue following the instructions from there.
For the BitBox02, you can verify addresses directly on the device during the send/receive process.`,
      title: "How can I verify an address securely?"
    },
    plugout: {
      text: "No, once you sent coins to your BitBox address, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while receiving?"
    },
    why20: {
      text: 'During start-up the app generates addresses derived from your seed to see if they have received funds. As the app can generate an almost infinite number of addresses, it could spend years determining the balance. To limit this search it stops after it sees 20 addresses that have never received funds. This is the "gap limit" and 20 is a de-facto standard though the number is arbitrary. These are the 20 addresses you can choose from.',
      title: "Why only 20 addresses?"
    },
    whyMany: {
      text: "To maintain privacy and security, never hand out the same address twice. If you have used an address, click on on the right arrow for a new address. You can generate up to 20 addresses at a time. Think of addresses like invoice numbers. All addresses are derived from your single backup seed.",
      title: "Why so many addresses?"
    },
    whyVerify: {
      text: "You shouldnt trust your computer to generate and display authentic addresses. Its big attack surface makes it significantly more vulnerable than a hardware wallet. For the BitBox01, The button to verify the address securely sends the address to a paired mobile phone, from which you can also scan and verify the QR code. For the BitBox02, the address can be verified directly on the BitBox02 display.",
      title: "Why should I verify the address securely?"
    }
  },
  send: {
    change: {
      text: "The change will be returned to a Taproot address if you have at least one Taproot UTXO. If you use coin control, the change will be returned to a Taproot address if there is at least one Taproot UTXO among the selected UTXOs. In all other cases, the change is returned to a Native Segwit address.",
      title: "How is the change output determined?"
    },
    fee: {
      text: `The fee is based on the transaction data size and not its amount. The fee targets are calculated by Bitcoin Core's fee estimation algorithm for each network priority you chose. They are shown if they have a different value from the target below.
Economy: 24 blocks (around 4 hours for Bitcoin, 1 hour for Litecoin)
Low: 12 blocks (around 2 hours for Bitcoin, 30 minutes for Litecoin)
Normal: 6 blocks (around 1 hour for Bitcoin, 15 minutes for Litecoin)
High: 2 blocks (around 20 minutes for Bitcoin, 5 minutes for Litecoin)
(A block takes on average ten minutes for Bitcoin (2.5 minutes in Litecoin) to mine and the network load may vary considerably in the above periods.)`,
      title: "How is the fee determined?"
    },
    plugout: {
      text: "No, once you have made a transaction, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while sending?"
    },
    priority: {
      text: "The higher fee you are willing to pay, the faster your transaction is typically confirmed by the network.",
      title: "What is the network priority?"
    },
    revert: {
      text: `Once a transaction is signed and sent (i.e. broadcasted to the network), it can no longer be reverted. Verify the transactions (including the fee) properly before signing!
If you know the recipient and he or she is willing to send the same amount (minus the transaction fees) back to you, you can send them a new receiving address.`,
      title: "Can I revert a transaction?"
    },
    whyFee: {
      text: `Transactions are competing to be confirmed by a miner. Miners choose transactions to be included in the blockchain based on their fee.
Miners vote on the history of transactions. Since there is no trusted third party to enforce one vote per person (which is the whole point of blockchains), miners vote on transactions by sacrificing a costly resource like computing power. As a reward for their work, they can claim newly created coins and the fee of all the transactions they included.`,
      title: "Why is there a network fee?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `If you intend to only connect to your node when you are on the same network (e.g. your home wifi), then using regular network communication is sufficient.
In this case it is advisable that your Electrum server provides a TLS certificate to encrypt the communication.
If you intend to connect to your node from anywhere, using Tor is the better option. No TLS certificate is necessary in that case.`,
      title: "Should I use clearnet TCP, TLS or Tor?"
    },
    instructions: {
      link: {
        text: "Guide to connect your node"
      },
      text: "For a full tutorial, please visit our guide:",
      title: "How do I connect my BitBoxApp to my own full node?"
    },
    options: {
      text: `There are multiple options to run your own node such as buying a finished device, building your own or running Bitcoin Core.
If you want to connect your BitBoxApp to your node, make sure that it runs an Electrum server. This is a dedicated program that allows a wallet app to communicate with your full node.
Supported options include Electrs, Electrum Personal Server (EPS) or Bitcoin Wallet Tracker (BTW).`,
      title: "What options are there to run a node?"
    },
    tor: {
      text: `Tor stands for 'The Onion Router', which is a free and open source software that offers a lot of privacy benefits and is especially useful when using Bitcoin.
If you intend to connect to your node via Tor, make sure that Tor is installed on your computer and then enable the Tor Proxy in the BitBoxApp settings.
On most operating systems there are two ways to run Tor:
1. Tor Browser: download and open the Tor Browser. This will allow the BitBoxApp to connect to the Tor network by setting port 9150 in the Tor proxy settings.
2. Tor background service: install the Tor daemon, which always runs in the background. The BitBoxApp can then connect by setting port 9050 in the Tor proxy settings.`,
      title: "What is Tor, Tor proxy and which port should I use?"
    },
    what: {
      text: "It is possible to power your wallet with your own full nodes instead of using Shift servers.",
      title: "What is this?"
    },
    why: {
      text: `Running your own node is not necessary but improves privacy and reduces the need to trust others.
Firstly, it means that you are using Bitcoin more privately as the BitBoxApp won't connect to our servers to fetch your transaction history; instead it will fetch that information from your own node.
Secondly, running your own node means that your node verifies all transactions itself, making sure that the consensus rules are enforced.`,
      title: "Why should I run my own node?"
    }
  },
  settings: {
    sats: {
      text: "A Satoshi ('sat' for short) is the smallest unit of Bitcoin. One Satoshi is a hundred millionth of a bitcoin (0.00000001 BTC). It is named after the creator of Bitcoin, Satoshi Nakamoto.",
      title: "What is a Satoshi?"
    },
    servers: {
      text: `This app communicates with the Shift Crypto servers to check for updates, load transactions, and send information to paired mobile apps.
The app also retrieves the latest exchange rates from CoinGecko. All conversions are calculated locally which means no data about the amount of your transaction is ever transmitted.
Note: For Ethereum and ERC20 Tokens, we use Etherscan.io APIs.`,
      title: "Which servers does this app talk to?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Close guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "On desktop, hover the cursor over the chart. On mobile, hold your finger on the chart and drag horizontally.",
    title: "How to see historical values on the chart?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "You have to reset the device and restore the wallet from a backup, using the recovery password.",
      title: "What do I do if I forgot the device password?"
    },
    reset: {
      text: "Enter a wrong device password 15 times. The last few attempts require a long touch on the device.",
      title: "How do I reset the device?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `The device should blink once when inserted. Make sure that it is inserted the right way around. If you are having trouble, please contact us through the link below.

The BitBox01 is not supported on mobile. Please use the BitBoxApp on desktop to connect your BitBox01.`,
      title: "My BitBox01 is not recognized"
    },
    getDevice: {
      link: {
        text: "Order a BitBox"
      },
      text: "You can buy a BitBox in our online shop:",
      title: "How can I get a device?"
    },
    internet: {
      text: "Yes, an internet connection is required to synchronize the wallet, send transactions and retrieve the latest exchange rates.",
      title: "Does this app require an internet connection?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "You can recover your accounts on a new BitBox or with our backup center.",
      title: "I lost my device. Now what?"
    },
    useWithoutDevice: {
      text: "Unfortunately, this is not yet possible at the moment.",
      title: "Can I use the app without a device?"
    },
    welcome: {
      text: "Thanks for using this app built by Shift Crypto in Switzerland. We appreciate any input you have to share. Please give feedback using the link at the bottom.",
      title: "Welcome to the BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "If you are using a new phone/computer with the BitBoxApp, then you will need to connect to the DApps again. You will then see your coins on the dapp again like usual.",
      title: "I don't see my previous connections."
    },
    supportedNetworks: {
      text: "Currently, only Ethereum mainnet is supported using WalletConnect in the BitBoxApp. To use other EVM compatible chains please use the Rabby browser extension wallet.",
      title: "What networks are supported?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is a communication protocol for web3 applications. It allows you to conveniently connect to Ethereum based DApps and web wallets without using a third party app, which is particularly useful for Android users of the BitBoxApp.",
      title: "What is WalletConnect?"
    }
  }
}, headerssync$f = {
  blocksSynced: "{{blocks}} blocks synced"
}, hiddenWallet$f = {
  info1HTML: "For plausible deniability purposes, a hidden wallet can be created based on a <strong>different</strong> device password + recovery password combination.",
  info2HTML: "Define the device password and recovery password you want to associate with your hidden wallet below. The device password and recovery password must be <strong>different</strong> from the ones you defined for your primary wallet.",
  passwordLabel: "Hidden recovery password",
  passwordPlaceholder: "Please confirm hidden recovery password",
  pinLabel: "Hidden device password",
  pinRepeatLabel: "Repeat hidden device password",
  pinRepeatPlaceholder: "Please confirm hidden device password",
  success: "Hidden wallet created successfully. Replug your BitBox to unlock it."
}, initialize$f = {
  create: "Set device password",
  creating: "Setting device password",
  error: {
    e102: "The device password must consist of at least 4 characters."
  },
  info: {
    description1: "Choose your device password. This will be used to unlock your BitBox.",
    description2: "You can use numbers, letters & symbols. Longer passwords offer higher security.",
    description3: "If you lose the device password you will have to reset your device and restore your wallet backup.",
    subtitle: "Now you will set your device password",
    title: "Initializing your device"
  },
  input: {
    label: "Device password",
    labelRepeat: "Repeat device password",
    placeholderRepeat: "Please confirm device password"
  }
}, invalidFormat$f = "Invalid format", language$g = {
  title: "Select language"
}, legacyhiddenwallet$f = {
  disable: "Disable legacy hidden wallet",
  enable: "Enable legacy hidden wallet",
  successDisable: "Successfully disabled the legacy hidden wallet.",
  successEnable: "Successfully enabled the legacy hidden wallet. Replug your BitBox and enter the hidden device password to access the legacy hidden wallet."
}, loading$f = "loading", manageAccounts$9 = {
  accountHidden: "This account has been hidden from your watch-only accounts. To see it again, please plug in your BitBox02.",
  editAccount: "Edit",
  editAccountNameTitle: "Edit account name",
  noAccounts: "no accounts found",
  settings: {
    hideTokens: "Hide tokens",
    showTokens: "Show tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Add and show/hide accounts",
  title: "Manage accounts",
  watchAccount: "Watch account",
  watchAccountDescription: "This account is part of your watch-only accounts. You can hide it from your watch-only accounts using the toggle."
}, mobile$a = {
  usingMobileDataWarning: "Mobile data usage: this app may download up to a few hundred megabytes of blockchain header data after unlocking an account. Please connect to Wi-Fi to avoid using mobile data. After dismissing it, this message won't be shown again."
}, newSettings$8 = {
  about: {
    appVersion: {
      title: "App version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Lock access to the app with screen lock/fingerprint.",
      title: "Screen lock"
    },
    coinControl: {
      description: "Select which UTXOs are part of a transaction to help improve privacy."
    },
    customFees: {
      description: "Lets you enter your own fee when sending."
    },
    torProxy: {
      description: "Connect over Tor for better privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "These additional currencies can be toggled through on your account page.",
      title: "Active currencies"
    },
    darkmode: {
      description: "See the BitBoxApp in dark mode."
    },
    defaultCurrency: {
      description: "Select your default currency",
      title: "Default currency"
    },
    enableAccount: {
      description: "Disabling your account means it will not appear in the sidebar or the portfolio. You can always enable it again from here. Coins on this account will not be affected and will remain safe.",
      title: "Enable/disable account"
    },
    hideAmounts: {
      description: "Displays a toggle to hide your balance and amounts to improve your privacy when using the app in public.",
      hideAmounts: "Hide amounts",
      showAmounts: "Show amounts",
      title: "Allow hiding amounts"
    },
    language: {
      description: "Which language you want the BitBoxApp to use.",
      title: "Language"
    },
    remebmerWallet: {
      name: "Remember wallet",
      warning: "This will remove your remembered wallet. To see it again, you will need to plug in the BitBox02 for this wallet. Any coins on this wallet are not affected. Do you want to continue?",
      warningTitle: "Disable remember wallet"
    },
    toggleSats: {
      description: "Enable or disable Satoshis."
    }
  }
}, note$b = {
  input: {
    description: "(optional)",
    placeholder: "Add note"
  },
  title: "Note"
}, notification$f = {
  newTxs_one: "New transaction in: {{accountName}}",
  newTxs_other: "{{count}} new transactions in: {{accountName}}"
}, pairing$f = {
  aborted: {
    text: "The pairing has been aborted from the mobile app.",
    title: "Aborted"
  },
  button: "Pair mobile app",
  confirm: "Are you sure you want to pair your BitBox? Note that after, the mobile phone is required to perform a transaction.",
  connectOnly: {
    button: "Connect mobile app",
    title: "Scan with our mobile app by selecting the menu item 'Connect to new desktop app'"
  },
  error: {
    text: "Something went wrong. Please start again.",
    title: "Error"
  },
  pullFailed: {
    text: "Failed to pull a message from your mobile through the relay server. The relay server might be offline, please contact support.",
    title: "Pull failed"
  },
  reconnectOnly: {
    button: "Reconnect mobile app"
  },
  scanningFailed: {
    text: "Mobile was not able to scan the message successfully. Please try again.",
    title: "Scanning Failed"
  },
  start: {
    hideAppQRCode: "Hide QR code",
    revealAppQRCode: "Show QR code",
    step1: "If you do not have the mobile app, you can scan the QR code for the Apple App Store or the Google Play Store depending on which phone you have.",
    step2: "Scan with our mobile app, which you can find under the name 'Digital Bitbox 2FA' in the app stores for iOS and Android:"
  },
  started: {
    text: "Now please follow the instructions in the mobile app.",
    title: "Great"
  },
  success: {
    text: "Congratulations, you successfully paired your BitBox with the mobile app!",
    title: "Success"
  },
  timeout: {
    text: "The pairing timed out after two minutes. Start again if you still want to pair the mobile app.",
    title: "Timeout"
  },
  title: "Mobile pairing"
}, passphrase$9 = {
  considerations: {
    button: "Backup considerations",
    message: `The passphrase adds a layer of protection to your wallet backup (microSD card or recovery words). If someone has access to your backup they will also need the passphrase to access your wallet.

However, this means you will need <strong>both the passphrase + wallet backup</strong> to restore your passphrase-enabled wallet, in case your BitBox02 is lost or broken. If you forget or lose your passphrase, you will lose access to all the coins on that wallet.

When storing your passphrase, consider putting it in a separate location than your backup. That way if someone finds your backup they dont find your passphrase as well.`,
    title: "Backup considerations"
  },
  disable: "Disable passphrase",
  disableInfo: {
    button: "Disable",
    message: `After disabling the passphrase, you will no longer be asked to enter a passphrase after unlocking your BitBox02. Therefore, you will enter your default wallet.

Any coins on your passphrase-wallet will still be on that wallet, however you wont be able to access them because after unlocking your BitBox02, you will open your default wallet.

To access your passphrase-wallets again, simply re-enable the passphrase feature and enter the relevant passphrase after unlocking the BitBox02.

<strong>Tip:</strong> You can still enter your original wallet by leaving the passphrase empty.`
  },
  enable: "Enable passphrase",
  error: {
    e104: "Changing the passphrase setting was aborted."
  },
  how: {
    button: "What it looks like",
    message: `A passphrase doesnt work like a password that youre used to. If you mistype your passphrase, you will not be notified. This is because <strong>every passphrase creates a different, yet valid, wallet</strong>. This means you can use multiple passphrases for as many wallets as you want. But each wallet can only be accessed when typing in the corresponding passphrase.

When plugging in your BitBox02, youll be prompted for the device password as usual. After that, youll be asked to enter a passphrase on the device.

After entering the passphrase, youll be shown the passphrase you entered. This is so you can confirm you entered it correctly.`,
    title: "How does it work"
  },
  intro: {
    message: `A passphrase provides an additional layer of security on top of your wallet.
Lets learn how it works.`,
    title: "Setup passphrase"
  },
  progressDisable: {
    message: "Confirm on your BitBox that you want to <strong>disable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  progressEnable: {
    message: "Confirm on your BitBox that you want to <strong>enable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  successDisabled: {
    message: `Optional passphrase <strong>successfully enabled</strong>!
Youll be asked to provide a passphrase from now on.`,
    messageEnd: "Please replug the BitBox02 now.",
    title: "Passphrase enabled"
  },
  successEnabled: {
    message: `Optional passphrase <strong>successfully disabled</strong>!

You will not be asked to provide a passphrase anymore.`,
    messageEnd: "Please replug your BitBox02 now.",
    tips: "Tips",
    tipsList: [
      "We suggest sending a small amount to the passphrase wallet first. Then unplug and replug the BitBox02 and enter your password and passphrase. If you entered the passphrase correctly, you should see the coins in your wallet.",
      "If you want to enter your original wallet without a passphrase, you can still do this by entering nothing when prompted to enter the passphrase. Or you can disable the passphrase feature."
    ],
    title: "Passphrase disabled"
  },
  summary: {
    button: "Enable passphrase",
    title: "Summary",
    understand: "I understand how the passphrase works and the risks associated with it.",
    understandList: [
      "The passphrase is an additional layer of security on top of your backup.",
      "Entering a different passphrase will always generate a different wallet.",
      "To restore your wallet you need <strong>both the passphrase and backup</strong>.",
      "If you forget your passphrase, you can <strong>no longer access your coins</strong>."
    ]
  },
  what: {
    button: "Learn how this works",
    message: `A wallet is created (derived) from a very big random number, also known as a seed. This seed is created when you first set up your BitBox02 and is backed up with the microSD card or recovery words. Anyone who has access to the seed has full control over the funds on that wallet.

A passphrase is an <strong>optional secret</strong>, added to the seed. When using a passphrase, each passphrase creates a new wallet based on the seed + passphrase (optional secret). A passphrase can be anything: letters, words, special characters or it can even be empty. The default wallet is in fact derived from the seed + empty passphrase.

The passphrase is part of the BIP39 standard, which means it is compatible with all wallets that support the same standard.`,
    title: "What is a passphrase?"
  },
  why: {
    button: "Why use a passphrase",
    message: `The BitBox02 protects the seed against extraction from the device itself, but the backup (microSD card or recovery words) gives full access to the wallet. That is why it should be stored in a secure location!

Since a passphrase creates a new wallet using your existing seed, the passphrase-wallet requires both your <strong>backup AND passphrase to restore</strong>. The benefit of this is if someone finds your backup, they still need the passphrase to access the passphrase-wallet.

Additionally, the passphrase feature allows you to create multiple wallets on the same device, or hidden wallets in addition to the default one.`,
    title: "Why use a passphrase?"
  }
}, password$f = {
  show: "Show {{label}}",
  warning: {
    caps: "WARNING: caps lock () is enabled",
    paste: 'to paste text, enable "SHOW {{label}}"'
  }
}, random$g = {
  button: "Generate random number",
  description: "Your BitBox generated the following {{bits}}-bit random number:"
}, receive$h = {
  changeScriptType: "Change address type",
  label: "Your address",
  onlyThisCoin: {
    description: "To receive other tokens, enable them in the settings. If you deposit other tokens, they might not be accessible.",
    warning: "Make sure to only receive {{coinName}} on this address."
  },
  scriptType: {
    p2tr: "Taproot (newest format)",
    p2wpkh: "Native Segwit (default)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatible format)"
  },
  selectAccount: "Select account",
  showFull: "Show and verify full address on device",
  taprootWarning: "Note: Taproot is a new Bitcoin feature and is not yet widely adopted. Funds received on Taproot addresses may not be visible in third party watch-only wallets. Many wallets and exchanges are not yet able to send to Taproot addresses.",
  title: "Receive {{accountName}}",
  verify: "Verify address securely",
  verifyBitBox01: "Verify address on mobile app",
  verifyBitBox02: "Verify address on BitBox02",
  verifyInstruction: "Please verify that the following address matches the one displayed on your device.",
  warning: {
    secureOutput: "Please pair your BitBox with your mobile device to enable secure address verification. Go to 'Manage device' in the sidebar."
  }
}, reset$f = {
  description: "All data will be deleted from this device. That includes your Private Key!",
  notReset: "Device NOT reset.",
  title: "Factory reset device",
  understand: "I have a backup and know my recovery password",
  understandBB02: "I have a valid backup"
}, securityInformation$f = {
  create: {
    description1: "We recommend you set up your device in a safe environment, meaning you are away from other people that could see what password you choose.",
    description2: "You will be asked to create two passwords.",
    description3: "The first is the <strong>device password</strong> which unlocks your BitBox device and can be changed later.",
    description4: "The second is the <strong>recovery password</strong> which unlocks your wallet. This password cannot be changed later.",
    description5: "The wallet you create will be backed up to a file on the microSD card provided. This can be used in an emergency to recover your funds using your <strong>recovery password</strong>.",
    title: "Security information"
  },
  restore: {
    description1: "You will be asked to insert the microSD card you used to store you backup.",
    description2: "To restore your device you will need your recovery password. ",
    description3: "Please take care when entering the recovery password. Any password you enter will create a valid wallet. If you enter the wrong password you may be shown a wallet balance that you do not expect.",
    title: "Security information"
  }
}, seed$f = {
  agreements: {
    "funds-access": "I will NOT be able to access my funds if I forget my recovery password",
    "password-change": "I can NOT change the recovery password later",
    "password-required": "The recovery password is required to restore a wallet from a backup"
  },
  create: "Create wallet",
  creating: "Creating wallet",
  description: "I understand that:",
  error: {
    e102: "The password must consist of at least 4 characters.",
    e200: "You need to insert a microSD card into your BitBox in order to create a wallet, so a backup can be created automatically."
  },
  info: {
    button: "Set recovery password now",
    description1: "Insert the microSD card into the BitBox",
    description2: "Choose a recovery password for the wallet and select Set recovery password now",
    description3: "The back up to microSD card and your recovery password is the only method to recover your funds in case of lost or stolen BitBox device.",
    description4: "You cannot change your recovery password later on without transferring your funds.",
    title: "Create a new wallet"
  },
  password: {
    label: "Recovery password",
    repeatPlaceholder: "Repeat recovery password"
  },
  walletName: {
    label: "Wallet name"
  }
}, seedRestore$f = {
  error: {
    e200: "Restoring a wallet from a backup requires the microSD card."
  },
  info: {
    description1: "Insert the microSD card into the BitBox and click Continue",
    description2: "Choose a backup and click Restore",
    description3: "Enter the recovery password",
    description4: "You need to confirm to understand that an incorrect password will create a different wallet.",
    title: "How to restore a wallet from a backup"
  }
}, send$h = {
  abort: "The transaction has been aborted.",
  address: {
    label: "Receiver address",
    placeholder: "Enter address"
  },
  amount: {
    label: "Amount",
    placeholder: "Enter amount"
  },
  availableBalance: "Available balance",
  button: "Review",
  coincontrol: {
    address: "Address",
    outpoint: "Outpoint",
    title: "Send from output"
  },
  confirm: {
    "selected-coins": "Selected coins",
    title: "Confirm and send transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "It seems like you do not have enough Ether to pay for this ERC20 transaction. Please make sure you hold enough Ether in your wallet",
    feeTooLow: "fee too low",
    feesNotAvailable: "Could not estimate fees",
    insufficientFunds: "insufficient funds",
    invalidAddress: "invalid address",
    invalidAmount: "invalid amount",
    invalidData: "invalid data"
  },
  fee: {
    customPlaceholder: "Enter amount",
    label: "Network fee",
    placeholder: "Not available"
  },
  feeTarget: {
    customLabel: "Fee rate",
    customLabel_eth: "Gas price",
    description: {
      economy: "4 hours (24 blocks)",
      economy_eth: "30 minutes or less",
      economy_ltc: "1 hour (24 blocks)",
      high: "20 minutes (2 blocks)",
      high_eth: "30 seconds or less",
      high_ltc: "5 minutes (2 blocks)",
      low: "2 hours (12 blocks)",
      low_eth: "5 minutes or less",
      low_ltc: "30 minutes (12 blocks)",
      normal: "1 hour (6 blocks)",
      normal_eth: "2 minutes or less",
      normal_ltc: "15 minutes (6 blocks)"
    },
    estimate: "Estimated confirmation time:",
    label: {
      custom: "Custom",
      economy: "Economy",
      high: "High",
      low: "Low",
      normal: "Normal"
    },
    placeholder: "Calculating fee"
  },
  maximum: "Send all",
  maximumSelectedCoins: "Send selected coins",
  noFeeTargets: "Fee rate estimations are currently unavailable. Please try again later or enter a custom fee.",
  priority: "Priority",
  scanQR: "Scan QR code",
  signprogress: {
    description: "This is a transaction containing a lot of data. To fully sign the transaction, you will be asked to confirm {{steps}} times.",
    label: "Progress"
  },
  success: "The transaction has been signed and sent.",
  title: "Send {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Transaction details"
}, settings$g = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Advanced settings",
  appearance: "Appearance",
  electrum: {
    add: "Add a server",
    "add-server": "Add",
    check: "Check",
    checkFailed: "Failed",
    checkSuccess: "Successfully established a connection to {{host}}",
    checking: "Checking",
    "download-cert": "Download remote certificate",
    "remove-server": "Remove",
    removeConfirm: "Remove {{server}}?",
    reset: "Reset to default",
    resetConfirm: "Do you want to remove all servers and install the default servers?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Enter the endpoint.",
    step2: "2",
    "step2-text": "Enter a certificate of the server's certificate chain. Alternatively, download the remote certificate and compare it visually.",
    "step2-text-tcp": "You can skip this step if you do not want to use TLS.",
    step3: "3",
    "step3-text": "Check the connection and add the server.",
    step4: "4",
    "step4-text": "Restart the wallet. If you do not remove the default servers, your own node will be added as a redundancy.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Enable coin control",
    electrum: {
      description: "You can connect to your own Electrum full node.",
      title: "Connect your own full node"
    },
    fee: "Enable custom fees",
    setProxyAddress: "Set proxy address",
    title: "Expert settings",
    useProxy: "Enable tor proxy",
    useSats: "Display BTC values in Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "New update available",
    title: "Info",
    "up-to-date": "Your app is up to date",
    version: "App Version"
  },
  restart: "Please re-start the BitBoxApp for the changes to take effect.",
  services: {
    title: "Services"
  },
  success: "Please unplug and replug the BitBox for the changes to take effect.",
  title: "Settings"
}, setup$f = "Setup device", sidebar$g = {
  buy: "Buy crypto",
  device: "Manage device",
  leave: "Leave",
  settings: "Settings"
}, success$m = {
  create: {
    info1: "Your wallet has been securely backed up to the microSD Card. Remove it and keep it safe.",
    info2: "You have created a secure device password that unlocks the BitBox.",
    info3: "You have created a secure recovery password for your wallet that unlocks your funds and restores your backups.",
    summary: "Here is a summary of what you have done",
    title: "Success"
  },
  getstarted: "Get started",
  restore: {
    summary: "You have successfully restored a wallet from your backup.",
    title: "Success"
  }
}, transaction$g = {
  confirmation: "Confirmations",
  details: {
    activity: "Activity",
    address: "Address",
    amount: "Amount",
    date: "Date",
    fiat: "Fiat",
    fiatAmount: "Fiat amount",
    fiatAtTime: "Fiat at time of transaction",
    status: "Status",
    type: "Type"
  },
  explorer: "Transaction ID",
  explorerTitle: "Open in external block explorer",
  fee: "Fee",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "Edit note",
    save: "Save note"
  },
  pending: "Pending transaction",
  size: "Size",
  status: {
    complete: "Complete",
    failed: "Failed",
    pending: "Pending"
  },
  tx: {
    received: "Received to",
    sent: "Sent to"
  },
  vsize: "Virtual size",
  weight: "Weight"
}, transactions$f = {
  errorLoadTransactions: "There was an error loading the transactions",
  placeholder: "No transactions yet."
}, unknownError$f = "An unknown error occurred: {{errorMessage}}", unlock$f = {
  description: "Enter your device password to unlock your device.",
  error: {
    e109_normal: "Wrong device password. {{remainingAttempts}} attempts remain before the device is reset.",
    e109_touch: "$t(unlock.error.e109_normal) The next login requires holding the touch button.",
    e113: "Due to many login attempts, the next login requires holding the touch button for 4 seconds."
  },
  input: {
    label: "Device password",
    placeholder: "Enter your device password to unlock the device"
  },
  unlocking: "Unlocking"
}, upgradeFirmware$g = {
  button: "Upgrade firmware",
  description: "Do you want to upgrade the firmware from version {{currentVersion}} to {{newVersion}}?",
  label: "Your BitBox requires a firmware upgrade.",
  locked: "To upgrade from {{currentVersion}} to {{newVersion}}, please do a long touch.",
  title: "Upgrade firmware",
  unlocked: "The bootloader is unlocked. To continue, please:",
  unlocked1: "Unplug and replug your Bitbox",
  unlocked2: "The LED will light up when your BitBox is plugged back in",
  unlocked3: "Tap the touch button when the LED lights up"
}, walletConnect$9 = {
  connect: {
    button: "Connect",
    dappLabel: "Enter URI address of dapp",
    invalidPairingUri: "Invalid pairing uri"
  },
  dashboard: {
    allSessions: "All sessions",
    disclaimer: "Walletconnect is a protocol to connect to Ethereum based Dapps. These dapps are run by third-party services, so only connect to dapps you trust and be sure to always know what you are signing when making a transaction.",
    newConnection: "New connection",
    noConnectedSessions: "No accounts are currently connected to any dapps."
  },
  invalidPairingChain: "Error in approving pairing. Please make sure to use one of the supported chains: {{chains}}",
  pairingRequest: {
    approve: "Approve Connection",
    reject: "Reject",
    title: "New connection request from"
  },
  pairingSuccess: "Dapp successfully connected. You can continue on the dapp website.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Failed to parse data",
    decodeError: "Failed to decode message",
    method: {
      sendTransaction: "Sign and send transaction",
      signMessage: "Sign message",
      signTransaction: "Sign transaction",
      signTypedData: "Sign typed data"
    },
    successfullySigned: "Request succesfully signed",
    walletConnectRequest: "WalletConnect request"
  },
  useNewUri: "This URI has already been used to attempt a connection. Please use a new URI.",
  walletConnect: "WalletConnect"
}, warning$l = {
  receivePairing: "Please pair the BitBox to enable secure address verification. Go to 'Manage device' in the sidebar.",
  sdcard: "Keep the microSD card stored separate from the BitBox, unless you want to manage backups.",
  sendPairing: "Please pair the BitBox to securely verify transaction details. Go to 'Manage device' in the sidebar."
}, welcome$f = {
  connect: "Connect BitBox02",
  getStarted: "Let's get started by installing firmware on your BitBox02.",
  insertBitBox02: "For the BitBox02, please tap the device to continue.",
  insertDevice: "Please connect your device to get started",
  title: "Welcome"
}, appTranslationsEN = {
  account: account$f,
  accountInfo: accountInfo$f,
  accountSummary: accountSummary$f,
  addAccount: addAccount$g,
  aopp: aopp$9,
  app: app$f,
  auth: auth$8,
  backup: backup$f,
  bb02Bootloader: bb02Bootloader$f,
  bitbox: bitbox$f,
  bitbox02Interact: bitbox02Interact$f,
  bitbox02Settings: bitbox02Settings$f,
  bitbox02Wizard: bitbox02Wizard$f,
  blink: blink$f,
  bootloader: bootloader$f,
  button: button$j,
  buy: buy$b,
  changePin: changePin$f,
  chart: chart$b,
  checkSDcard: checkSDcard$f,
  clickHere: clickHere$f,
  confirm: confirm$h,
  confirmOnDevice: confirmOnDevice$f,
  connectKeystore: connectKeystore$8,
  darkmode: darkmode$9,
  device: device$f,
  deviceLock: deviceLock$f,
  deviceSettings: deviceSettings$f,
  deviceTampered: deviceTampered$f,
  dialog: dialog$g,
  error: error$b,
  fiat: fiat$h,
  footer: footer$h,
  generic: generic$b,
  genericError: genericError$f,
  goal: goal$f,
  guide: guide$g,
  headerssync: headerssync$f,
  hiddenWallet: hiddenWallet$f,
  initialize: initialize$f,
  invalidFormat: invalidFormat$f,
  language: language$g,
  legacyhiddenwallet: legacyhiddenwallet$f,
  loading: loading$f,
  manageAccounts: manageAccounts$9,
  mobile: mobile$a,
  newSettings: newSettings$8,
  note: note$b,
  notification: notification$f,
  pairing: pairing$f,
  passphrase: passphrase$9,
  password: password$f,
  random: random$g,
  receive: receive$h,
  reset: reset$f,
  securityInformation: securityInformation$f,
  seed: seed$f,
  seedRestore: seedRestore$f,
  send: send$h,
  settings: settings$g,
  setup: setup$f,
  sidebar: sidebar$g,
  success: success$m,
  transaction: transaction$g,
  transactions: transactions$f,
  unknownError: unknownError$f,
  unlock: unlock$f,
  upgradeFirmware: upgradeFirmware$g,
  walletConnect: walletConnect$9,
  warning: warning$l,
  welcome: welcome$f
}, account$e = {
  disconnect: "Connexion perdue. Tentative de reconnexion",
  export: "Exporter",
  exportTransactions: "Exporter les transactions vers le dossier Tlchargements sous forme de fichier CSV",
  fatalError: "Une erreur inattendue s'est produite.",
  incoming: "Entrant",
  initializing: "Rcupration d'informations de la blockchain",
  maybeProxyError: "Proxy Tor activ. Assurez-vous que votre proxy Tor fonctionne correctement, ou dsactivez la configuration du proxy.",
  reconnecting: "Connexion perdue, tentative de reconnexion",
  syncedAddressesCount: "{{count}} adresses scannes"
}, accountInfo$e = {
  address: "Adresse",
  buyCTA: {
    buy: "Acheter {{unit}}",
    buyCrypto: "Acheter de la Crypto",
    information: {
      looksEmpty: "On dirait que ce portefeuille est vide",
      start: "Commencez par dposer des fonds dans le portefeuille ou bien achetez en directement dans l'application BitBoxApp."
    }
  },
  extendedPublicKey: "Cl publique tendue",
  label: "Informations du compte",
  scriptType: "Type de scrypt",
  title: "Informations sur le compte",
  verify: "Vrifier sur l'appareil",
  xpubTypeChangeBtn: {
    p2pkh: "Afficher la cl publique tendue (xpub) P2PKH legacy",
    p2tr: "Voir Taproot",
    p2wpkh: "Voir Native Segwit",
    "p2wpkh-p2sh": "Afficher l'ancienne cl publique tendue (xpub) Segwit"
  },
  xpubTypeInfo: "Affichage actuellement de la cl publique tendue {{scriptType}} ({{current}} de {{numberOfXPubs}})"
}, accountSummary$e = {
  availableBalance: "Solde disponible",
  balance: "Solde",
  exportSummary: "Exporter un extrait des comptes vers le dossier de Tlchargements sous forme de fichier CSV",
  fiatBalance: "Solde en devise",
  name: "Nom du compte",
  noAccount: "Il n'y a pas de compte  montrer.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Vue globale de mon portefeuille",
  total: "Total",
  transactionHistory: "Historique des transactions"
}, addAccount$f = {
  chooseName: {
    nextButton: "Ajouter un compte",
    step: "Donner un nom au compte",
    title: "Donnez un nom  votre compte"
  },
  selectCoin: {
    nextButton: "Suivant",
    step: "Slectionner un coin (pice)",
    title: "Slectionnez une crypto-monnaie"
  },
  success: {
    addAnotherAccount: "Ajouter un autre compte",
    message: "<strong>{{accountName}}</strong> a maintenant t ajout  vos comptes.",
    nextButton: "Termin",
    step: "Fini",
    title: "Compte ajout"
  },
  title: "Ajouter un compte"
}, aopp$8 = {
  addressRequest: "{{host}} exige une adresse de rception.",
  addressRequestWithLogo: "exige une adresse de rception.",
  banner: "Demande d'adresse en cours",
  errorTitle: "Erreur durant la demande d'adresse",
  labelAddress: "Adresse",
  labelMessage: "Message",
  reverifyInfoText: "Vrification de l'adresse",
  signing: "Afin de continuer, veuillez signer le message  l'aide de votre BitBox02",
  success: {
    message: "Continuer sur {{host}}",
    title: "Adresse envoye avec succs"
  },
  syncing: "Synchronisation du compte, veuillez patienter.",
  title: "Demande d'adresse"
}, app$e = {
  upgrade: "Une nouvelle version de cette application est disponible ! Veuillez mettre  jour de la {{current}}  la {{version}}."
}, auth$7 = {
  authButton: "Authentification",
  title: "Veuillez vous authentifier pour continuer"
}, backup$e = {
  check: {
    checking: "Vrification de la sauvegarde",
    confirmTitle: "Vrifier la sauvegarde",
    notOK: "La sauvegarde ne correspond PAS  ce portefeuille.",
    ok: "La sauvegarde correspond au portefeuille.",
    password: {
      label: "Mot de passe de rcupration",
      placeholder: "Mot de passe de rcupration",
      showLabel: "mot de passe de rcupration"
    },
    success: "Sauvegarde vrifie avec succs :",
    title: "Vrifier la sauvegarde"
  },
  create: {
    alreadyExists: "Vous avez dj une sauvegarde valide. Souhaitez-vous la recrer ?",
    fail: "La cration de la sauvegarde a chou !",
    info: "Veuillez saisir le mot de passe de rcupration du portefeuille actuel pour vrification.",
    name: {
      label: "Nom de la sauvegarde",
      placeholder: "Veuillez nommer la sauvegarde"
    },
    password: {
      label: "Mot de passe de rcupration",
      placeholder: "Veuillez entrer votre mot de passe de rcupration"
    },
    title: "Crer une sauvegarde",
    verificationFailed: "Le mot de passe de rcupration NE CORRESPOND PAS  ce portefeuille. La sauvegarde a t cre. Veuillez utiliser Vrifier la sauvegarde pour vrifier  nouveau votre mot de passe de rcupration."
  },
  description: "Slectionnez le <strong>fichier de sauvegarde du portefeuille</strong>.",
  insert: "Veuillez insrer la carte microSD pour grer les sauvegardes.",
  insertButton: "J'ai insr la carte microSD",
  list: "Vos sauvegardes sur la carte microSD",
  noBackups: "Il n'existe aucune sauvegarde sur cette carte micro SD.",
  restore: {
    confirmTitle: "Restaurer la sauvegarde",
    error: {
      e200: "Carte microSD non trouve",
      general: "Erreur lors de la restauration de la sauvegarde"
    },
    password: {
      label: "Mot de passe de rcupration ou mot de passe de rcupration cach",
      placeholder: "Mot de passe de rcupration",
      repeatPlaceholder: "Rpter le mot de passe de rcupration",
      showLabel: "Mot de passe de rcupration"
    },
    restoring: "Restauration de la sauvegarde",
    selectedBackup: "<strong>{{backupName}}</strong> cr le {{createdDateTime}} sera restaur.",
    title: "Restaurer",
    understand: "Je comprends qu'un mot de passe de rcupration incorrect crera un portefeuille diffrent."
  },
  showMnemonic: {
    description: `24 mots de rcupration vont vous tre prsents; ils constituent une sauvegarde de votre portefeuille. Notez-les sur papier.

<strong>Ne les stockez pas sur un support numrique et ne les prenez pas en photo.</strong>

<strong>Ne prononcez pas les mots  haute voix.</strong>

<strong>Cette sauvegarde n'est pas protge par un mot de passe.</strong>.

Il vous sera demand ensuite de confirmer chacun de ces mots.`,
    title: "Montrer les mots de rcupration",
    warning: "<strong>Ne partagez jamais vos mots de rcupration avec qui que ce soit.</strong> Vos mots de rcupration permettent un accs intgral  votre portefeuille. Si on vous demande vos mots de rcupration, il sagit dune escroquerie, ne les partagez jamais !"
  },
  title: "Grer les sauvegardes"
}, bb02Bootloader$e = {
  abort: "Ne pas mettre  jour - Revenir en arrire",
  abort_noUpgrade: "Retour en arrire",
  advanced: {
    label: "Paramtres avancs",
    toggleShowFirmwareHash: "Afficher le hash du firmware  chaque dmarrage de l'application"
  },
  flipscreen: "Retourner l'cran",
  orientation: "Appareil dans le mauvais sens ?",
  success: "Mise  jour russie ! Continue dans {{rebootSeconds}} secondes...",
  success_install: "Installation russie ! Poursuite dans {{rebootSeconds}} secondes..."
}, bitbox$e = {
  error: {
    e10000: "Mot de passe de l'appareil incorrect.",
    e10001: "La tentative de remplacer le mot de passe de l'appareil a chou",
    e102: "Le mot de passe doit comporter au minimum 4 caractres.",
    e112: "Le mot de passe cach ne peut pas tre identique au mot de passe principal de l'appareil."
  }
}, bitbox02Interact$e = {
  confirmDate: "Confirmez la date du jour sur votre BitBox02",
  confirmDateText: "Cette date sera utilise pour crer votre sauvegarde.",
  confirmName: "Confirmez le nom sur le BitBox02",
  confirmWords: "Notez les {{amount}} mots de rcupration depuis votre BitBox02",
  confirmWordsText: "Ensuite, la BitBox02 vous demandera de confirmer chaque mot afin de sassurer que la sauvegarde a t correctement effectue.",
  followInstructions: "Veuillez suivre les instructions sur votre BitBox02.",
  followInstructionsMnemonic: "Suivez les instructions sur votre BitBox02 afin de saisir les mots de rcupration de votre sauvegarde et restaurer ainsi votre portefeuille.",
  followInstructionsMnemonicTitle: "Restaurer  partir des mots de rcupration"
}, bitbox02Settings$e = {
  deviceName: {
    current: "Nom du priphrique actuel",
    error: "Le nom de l'appareil n'a pas pu tre configur",
    error_104: "La confirmation du nom de l'appareil a t interrompu sur celui-ci.",
    input: "Nom du BitBox02",
    placeholder: "Nouveau nom de priphrique",
    title: "Dfinir le nom de votre BitBox02"
  },
  gotoStartupSettings: {
    description: "Cela va rebooter votre BitBox02 et entrer les paramtres de dmarrage.",
    title: "Aller aux paramtres de dmarrage"
  }
}, bitbox02Wizard$e = {
  advanced: {
    button: "Options avances",
    outOfDate: "Le micrologiciel n'est pas  jour et ne permet pas cette fonctionnalit",
    seed12WordInfo: "Veuillez noter que le nombre de mots ne peut pas tre modifi aprs la cration du portefeuille.",
    seed12WordLabel: "Crer une seed de 12 mots plutt que de 24 mots",
    seed12WordText: "Par dfaut, la BitBox02 utilise une seed de 24 mots. Dans la pratique, les deux longueurs de seed sont fiables contre les attaques par force brute. Toutefois, certains utilisateurs peuvent prfrer la commodit inhrente  une seed de 12 mots.",
    skipSDCardLabel: "Sauter ltape de sauvegarde sur la carte microSD et crire les mots de rcupration plutt.",
    skipSDCardText: "Vous avez toujours la possibilit de crer une sauvegarde sur la carte microSD ou d'crire vos mots de rcupration aprs la configuration. Vous pouvez le faire  partir des paramtres.",
    title: "Options de sauvegarde avances"
  },
  attestationFailed: "L'authentification a chou. Ceci est potentiellement d au redmarrage de l'application alors que l'appareil attendait une saisie de la part de l'utilisateur. Veuillez vous reconnecter et essayer  nouveau. Si cela persiste, veuillez contacter support@bitbox.swiss",
  backup: {
    point1: "Slectionner une sauvegarde sur la carte micro SD",
    point2: "Dfinissez un mot de passe pour votre appareil",
    restoreText: "Ok, restaurons une sauvegarde !",
    text1: "Parfait, le mot de passe pour votre BitBox02 est dfini et votre portefeuille est cr. Il est maintenant temps de procder  votre premire sauvegarde. Assurez-vous que la carte micro SD soit bien insre dans l'appareil et continuez.",
    text2: "Veuillez suivre les instructions sur l'cran de votre appareil pour crer une sauvegarde.",
    text3: "Une fois votre sauvegarde cre, veuillez retirer la carte micro SD et la conserver dans un endroit <strong>scuris</strong>. Le contenu de la carte micro SD n'est pas protg par mot de passe. Ne l'insrez jamais dans un appareil autre que votre BitBox02.",
    userConfirmation1: "Je devrais stocker ma sauvegarde dans un endroit sr.",
    userConfirmation2: "Ma sauvegarde n'est pas protge par mot de passe. Quiconque y a accs peut accder  mon portefeuille.",
    userConfirmation3: "Si je perds ou endommage mon BitBox02, la seule faon de rcuprer mes fonds est de restaurer  partir de ma sauvegarde.",
    userConfirmation4: "Si je perds ou endommage  la fois ma sauvegarde et ma BitBox02, mes fonds seront perdus.",
    userConfirmation5: "Je ne dois pas insrer ma carte de sauvegarde microSD dans un ordinateur, un tlphone, une imprimante ou tout appareil autre qu'un BitBox02.",
    userConfirmation5mnemonic: "Je ne dois pas saisir mes mots de rcupration dans un ordinateur, un tlphone, une imprimante ou tout autre appareil autre qu'une BitBox02."
  },
  create: {
    button: "Nommer l'appareil et continuer",
    info: "Voici les tapes de base  suivre pour configurer votre BitBox :",
    inputTitle: "Nom du portefeuille",
    point1: "Nommez votre appareil",
    point2: "Dfinir un mot de passe pour votre appareil",
    point3: "Crer une sauvegarde",
    text: "Ok, crons un nouveau portefeuille !"
  },
  createBackupAborted: "Cration de la sauvegarde interrompue.",
  createBackupFailed: "La cration de la sauvegarde a chou, veuillez ressayer.",
  initialize: {
    passwordText: "Dfinissons maintenant un mot de passe pour votre appareil. Utilisez les commandes de votre BitBox pour entrer et choisir un mot de passe.",
    passwordTitle: "Dfinissez un mot de passe pour votre BitBox",
    text: "Votre BitBox02 a t appair avec succs ! Initialisons maintenant votre appareil. Commencez par choisir de crer un nouveau portefeuille ou de restaurer un portefeuille  partir d'une sauvegarde existante. <strong>Veuillez vous assurer que vous avez une carte micro SD insre dans votre BitBox02</strong>.",
    tip: "Nous recommandons de continuer dans un environnement scuris.",
    title: "Initialiser votre BitBox"
  },
  insertSDCard: "<strong>Assurez-vous d'avoir une carte micro SD insre dans votre BitBox02.</strong>",
  noPasswordMatch: "Le mot de ",
  pairing: {
    failed: "Appariement non confirm. Veuillez rebrancher votre BitBox02.",
    paired: "Vous avez confirm le code suivant sur votre appareil. Veuillez continuer.",
    title: "Vrifier le code d'appairage",
    unpaired: "Une BitBox02 non-associe a t dtecte. Veuillez vrifier que le code dassociation correspond  celui indiqu sur votre BitBox02."
  },
  restoreFromMnemonic: {
    e104: "La restauration  partir des mots de rcupration a t annule.",
    failed: "La restauration  partir des mots de rcupration a chou, veuillez ressayer."
  },
  stepBackup: {
    beforeProceed: "Avant de continuer, veuillez lire ces importantes mesures de scurit :",
    createBackup: "Vous allez maintenant crer une sauvegarde sur votre carte microSD.",
    createBackupMnemonic: "Vous allez  prsent noter les mots de rcupration."
  },
  stepBackupSuccess: {
    fundsSafe: "Pour assurer la scurit de vos fonds, n'oubliez pas ce qui suit :",
    title: "Sauvegarde restaure !"
  },
  stepConnected: {
    unlock: "Entrez le mot de passe du BitBox02 pour le dverrouiller."
  },
  stepCreate: {
    description: "Ce nom est utilis comme celui de l'appareil et pour la sauvegarde.",
    nameLabel: "Nom du BitBox02",
    namePlaceholder: "Mon BitBox02",
    title: "Choisissez le nom du BitBox02",
    toastMicroSD: "Veuillez insrer votre carte microSD dans votre BitBox02, elle sera utilise pour stocker une sauvegarde du portefeuille."
  },
  stepCreateSuccess: {
    removeMicroSD: "Veuillez retirer la carte microSD de votre BitBox02 et la stocker dans un endroit sr.",
    storeMnemonic: "Veuillez conserver vos mots de rcupration dans un emplacement sr",
    success: "Vous avez cr votre sauvegarde avec succs."
  },
  stepInsertSD: {
    insertSDCard: "Veuillez insrer une carte microSD dans votre BitBox02 pour continuer.",
    insertSDcardTitle: "Insrer une carte microSD"
  },
  stepPassword: {
    e104: "Le paramtrage du mot de passe a t abandonn.",
    title: "Dfinissez le mot de passe du BitBox02",
    useControls: "Utilisez les touches de votre BitBox02 pour dfinir un mot de passe."
  },
  stepUninitialized: {
    create: "Je veux configurer un nouveau BitBox02.",
    restore: "Je veux restaurer mon portefeuille  partir d'une sauvegarde.",
    restoreMicroSD: "Restauration  partir d'une carte microSD",
    restoreMnemonic: "Restaurer  partir des mots de rcupration",
    title: "Configurez votre BitBox02"
  },
  success: {
    text: `Hourra ! Votre BitBox02 est maintenant prt  l'emploi. 

Pour plus d'informations sur l'utilisation de l'application BitBox, veuillez utiliser le guide d'utilisation en cliquant sur le point d'interrogation situ dans le coin suprieur droit.`,
    title: "Vous tes prt !"
  }
}, blink$e = {
  button: "Clignoter"
}, bootloader$e = {
  button: "Mettre  jour le micrologiciel maintenant",
  button_install: "Installer le firmware maintenant",
  progress: "Mise  jour : {{progress}}%",
  progress_install: "Installation : {{progress}}%",
  success: "Mise  jour russie ! Veuillez rebrancher l'appareil. Cette fois, ne touchez pas le bouton."
}, button$i = {
  abort: "Abandonner",
  back: "Retour",
  buy: "Acheter",
  changepin: "Changer le mot de passe de l'appareil",
  check: "Vrifier la sauvegarde",
  continue: "Continuer",
  copy: "Copie",
  create: "Crer",
  dismiss: "Ignorer",
  done: "Termin",
  download: "Tlcharger",
  hiddenwallet: "Crer un portefeuille cach",
  next: "Suivant",
  ok: "D'accord",
  previous: "Prcdent",
  receive: "Recevoir",
  restore: "Restaurer",
  select: "Slectionner",
  send: "Envoyer",
  unlock: "Dverrouiller",
  update: "Mise  jour",
  upgrade: "Mettre  jour"
}, buy$a = {
  exchange: {
    bankTransfer: "Virement bancaire",
    bestDeal: "Meilleure offre",
    creditCard: "Carte de crdit",
    fast: "Rapide",
    fee: "frais",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Virement Bancaire: {{fee}}%",
          creditDebitCard: "Carte de crdit/dbit: {{fee}}%",
          learnMore: "En savoir plus sur Moonpay",
          title: "Frais"
        },
        fullCurrenciesList: "Voir la liste complte des devises ici",
        payment: {
          asteriskText: "* Non disponible pour les rsidents amricains",
          bankTransfer: "Virement bancaire*",
          bankTransferDetails: {
            pix: "PIX (transactions BR au Brsil uniquement)",
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          creditDebitCard: "Carte de crdit/dbit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "Voir plus de dtails sur les mthodes de paiement",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte toutes les principales devises fiat : USD, EUR, CHF, et autres."
      },
      pocket: {
        fees: {
          info: "Virement bancaire : {{fee}}%",
          title: "Frais"
        },
        learnMore: "En savoir plus sur Pocket",
        payment: {
          bankTransfer: "Virement bancaire",
          bankTransferDetails: {
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            sic: "SIC - Swiss Interbank Clearing (Transactions CHF en Suisse/Liechtenstein uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          bankTransferReccuring: "Comment mettre en place des achats rcurrents avec un ordre permanent?",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte les devises Europennes : EUR, GBP et CHF",
        verification: {
          info: "La vrification de l'identit n'est requise qu'au-del des limites quotidiennes et annuelles.",
          link: "Consulter les limites en vigueur, ici.",
          title: "Vrification de l'identit"
        }
      },
      region: {
        title: "Slectionnez la zone gographique de domiciliation de votre compte bancaire afin de dterminer les options  votre disposition."
      }
    },
    noExchanges: "Dsol, aucun change disponible dans cette zone gographique",
    region: "Zone Gographique",
    selectRegion: "Non spcifi",
    title: "Acheter du {{name}}"
  },
  info: {
    continue: "Accepter et continuer",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nous avons un partenariat avec MoonPay afin de vous permettre d'acheter simplement des {{name}} directement depuis BitBoxApp. Quelques clics suffisent.",
        "MoonPay est une plateforme qui permet dacheter des {{name}} de manire simple et rapide dans plus de 160 pays."
      ],
      payment: {
        details: "Vous pouvez acheter des {{name}} instantanment via MoonPay avec les mthodes de paiement suivantes. Les achats par carte de crdit ou de dbit sont faciles et instantans, mais plus chers en raison du risque de rtro-facturation plus lev. Nous vous recommandons d'utiliser l'option du virement bancaire pour les montants plus importants. Les frais minimum sont de 4 USD/EUR ou quivalent.",
        footnote: "Veuillez noter que les taux de change de MoonPay peuvent diffrer de ceux utiliss dans BitBoxApp, ce qui peut entraner potentiellement des montants lgrement diffrents.",
        table: {
          "1_description": "Frais les plus bas, peut prendre jusqu' 3 jours ouvrables",
          "1_method": "Virements bancaires (SEPA)",
          "2_description": "Frais plus levs mais rapides et directs",
          "2_method": "Cartes de crdit et de dbit",
          description: "Description",
          fee: "Frais",
          method: "Mthode"
        },
        title: "Modes de paiement et frais"
      },
      privacyPolicy: "Politique de confidentialit de MoonPay",
      protection: {
        description: "BitBoxApp ne collecte aucune donne lors de l'achat de {{name}}, les fonds entrants sont traits comme une transaction normale. MoonPay a besoin de collecter certaines donnes personnelles afin de fonctionner. Leur politique de confidentialit dcrit en dtail la faon dont ces donnes sont traites.",
        descriptionGeneric: "BitBoxapp ne collecte aucune donne lors de l'achat de {{nom}}, les fonds entrants sont traits comme une transaction normale. Cependant, les exchanges partenaires ont besoin de recueillir certaines informations pour fonctionner. Veuillez vous rfrer  leurs politiques de confidentialit respectives pour voir plus en dtail comment sont traites ces donnes.",
        title: "Protection des donnes"
      },
      security: {
        description: "Lorsque vous achetez du {{name}} via MoonPay, vous utilisez un service externe. Ce service est hors de porte du modle scurit contre les menaces de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy.",
        descriptionGeneric: "Lorsque vous achetez du {{nom}} via un exchange partenaire, vous utilisez un service externe. Ce service est hors de porte du modle scurit contre les menaces de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy.",
        link: "Modle de menace  la scurit",
        title: "Modle de scurit"
      },
      title: "Bienvenue sur la boutique de votre site cl en main pour acheter du {{name}}"
    },
    next: "Suivant",
    selectLabel: "Slectionnez votre compte",
    selectPlaceholder: "Slectionnez un coin (monnaie)",
    skip: "Ne plus montrer",
    title: "Acheter du {{name}}"
  },
  pocket: {
    data: {
      link: "Politique de confidentialit de Pocket",
      p1: "BitBoxApp ne recueille aucune donne lors de l'achat de bitcoins, les fonds entrants sont traits comme une transaction ordinaire. Pocket a besoin de collecter certaines donnes personnelles pour son fonctionnement. La politique de confidentialit de Pocket expose en dtail la manire dont elles sont exploites.",
      title: "Protection des donnes"
    },
    kyc: {
      link: "Lire la FAQ de Pocket",
      p1: "Pocket s'efforce de rduire au minimum le processus didentification (KYC). Pour les achats infrieurs  950 EUR (1000 CHF) par jour, aucun document supplmentaire n'est requis. Pour les achats suprieurs  ce montant, vous devrez fixer un rendez-vous tlphonique avec Pocket au pralable afin de complter le processus Identification/Lutte Contre le Blanchiment (KYC/AML) ncessaire.",
      title: "Identification/Lutte Contre le Blanchiment (KYC/AML)"
    },
    payment: {
      p1: "Vous avez la possibilit dacheter des bitcoins instantanment avec Pocket via un transfert bancaire SEPA. Les frais sont de 1,5% et les bitcoins sont dposs dans votre BitBox ds que possible, une fois le virement bancaire  reu par Pocket (gnralement le jour mme).",
      p2: "Veuillez noter que les taux de change de Pocket peuvent diffrer de ceux utiliss par BitBoxApp,et avoir pour effet des montants lgrement diffrents.",
      title: "Modes de paiement et frais"
    },
    previousTransactions: "L'historique des transactions de ce compte n'est pas vierge. En partageant ce compte, toutes ses transactions passes et futures seront exposes  Pocket. Souhaitez-vous continuer malgr tout ?",
    security: {
      link: "Modle de menace de scurit de BitBox02",
      p1: "Lorsque vous achetez des bitcoins via Pocket, vous utilisez un service externe. Ce service est hors de porte du modle de menace de scurit de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy. Cependant, nous collaborons dans le but de renforcer la scurit en utilisant un mcanisme d'authentification  deux facteurs pour vrifier l'adresse sur laquelle vous les recevez.",
      title: "Modle de scurit"
    },
    usedAddress: "L'adresse {{adresse}} a dj t utilise, veuillez recommencer avec une nouvelle adresse.",
    verifyBitBox02: "Veuillez vrifier que l'adresse que vous avez reue par email correspond  celle affiche sur votre Bitbox. Si vous en avez la possibilit, vous devriez ouvrir l'email sur un deuxime appareil pour plus de scurit.",
    welcome: {
      p1: "Nous collaborons avec Pocket afin de vous offrir un processus simplifi pour vos achats de bitcoins directement dans l'application BitBox. Quelques clics suffisent.",
      p2: "Pocket est une plateforme suisse qui permet d'acheter rapidement et facilement des bitcoins depuis la plupart des pays europens (partout o les transferts bancaires SEPA sont disponibles).",
      p3: "Avec Pocket, vous pouvez galement effectuer des achats rguliers par le biais d'ordres bancaires rcurrents, vous donnant ainsi la possibilit d'effectuer facilement un lissage de votre prix d'acquisition (DCA).",
      title: "Bienvenue dans votre espace unique et complet ddi  l'achat de bitcoins."
    }
  },
  title: "Acheter du {{name}}"
}, changePin$e = {
  newTitle: "Nouveau mot de passe de l'appareil",
  oldLabel: "Mot de passe actuel de l'appareil"
}, chart$a = {
  dataMissing: "Rcupration de lhistorique des donnes soyez patients.",
  dataOldTimestamp: "Mise  jour de lhistorique des taux de change. Le graphique ne tient pas compte des donnes aprs {{time}}.",
  dataUpdating: "mise  jour des donnes...",
  filter: {
    all: "Tout",
    month: "Mois",
    week: "Semaine",
    year: "Anne"
  }
}, checkSDcard$e = "vrification de la carte microSD", clickHere$e = "Cliquez ici.", confirm$g = {
  abortInfo: "Appuyez pour",
  abortInfoRedText: "abandonner",
  approveInfo: "Appuyez 4+ secondes pour",
  approveInfoGreenText: "confirmer",
  info: "Continuez sur votre BitBox",
  infoWhenPaired: "D'abord sur le mobile appair, puis sur votre BitBox"
}, confirmOnDevice$e = "Veuillez confirmer sur l'appareil.", connectKeystore$7 = {
  promptNoName: "Veuillez connecter votre BitBox02 pour continuer",
  promptWithName: 'Veuillez connecter votre BitBox02 dnomme "{{name}}" pour continuer'
}, darkmode$8 = {
  toggle: "Dark mode"
}, device$e = {
  appUpradeRequired: "Votre BitBox n'est pas compatible avec cette version de l'application de bureau. Veuillez tlcharger et installer la dernire version."
}, deviceLock$e = {
  button: "Activer la double authentification (2FA)",
  condition1: "Avez-vous une sauvegarde ?",
  condition2: "Est-ce que la vrification avec l'application mobile fonctionne-t-elle ?",
  condition3: "Le 2FA DSACTIVE les sauvegardes et l'appariement  l'application mobile. L'appareil doit tre RINITIALIS pour enlever le 2FA !",
  confirm: "Activer la double authentification (2FA)",
  title: "Activer la double authentification (2FA)"
}, deviceSettings$e = {
  backups: {
    manageBackups: {
      description: "Crez ou vrifiez la sauvegarde de votre carte microSD."
    },
    showRecoveryWords: {
      description: "Afficher et vrifier les mots de rcupration."
    },
    title: "Sauvegardes"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp vrifie l'authenticit de votre appareil."
    },
    deviceName: {
      description: "Modifiez le nom de votre appareil."
    },
    rootFingerprint: {
      description: "L'empreinte digitale racine est un identifiant unique du portefeuille en cours d'utilisation. Elle peut vous aider  distinguer les diffrents portefeuilles si vous utilisez des passsphrases."
    },
    securechip: {
      description: "Modle de la puce scurise."
    },
    title: "Informations sur l'appareil"
  },
  expert: {
    factoryReset: {
      description: "Rinitialisez votre appareil aux paramtres d'usine. Cela supprimera le wallet de votre BitBox02 !",
      title: "Rinitialisation aux paramtres d'usine"
    },
    goToStartupSettings: {
      description: "Entrez le bootloader de la BitBox02. Vous pouvez activer le hachage du micrologiciel  partir de l."
    },
    passphrase: {
      description: "Activer ou dsactiver la fonction de passphrase (phrase secrte)",
      title: "Passphrase (phrase secrte)"
    }
  },
  firmware: {
    firmwareVersion: "Version du Firmware",
    newVersion: {
      label: "Version disponible"
    },
    title: "Micrologiciel",
    upToDate: "Votre appareil est  jour",
    upgradeAvailable: "Nouvelle mise  jour disponible",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "chec du contrle d'authenticit",
      label: "Contrle d'authenticit",
      true: "Votre BitBox02 est authentique"
    },
    sdcard: {
      false: "Non insre",
      label: "carte microSD",
      true: "Insre"
    },
    securechip: "Puce scurise",
    title: "Matriel informatique"
  },
  loading: "Rcupration des informations sur l'appareil",
  pairing: {
    lock: {
      false: "Dsactiv",
      label: "Double authentification (2FA)",
      true: "Activ"
    },
    mobile: {
      false: "Ferm",
      label: "Application mobile",
      true: "Ouvrir"
    },
    status: {
      false: "Non appair",
      label: "Statut",
      true: "Appair"
    },
    title: "Appariement"
  },
  secrets: {
    manageBackups: "Grer les sauvegardes",
    title: "Secrets"
  }
}, deviceTampered$e = "Est-ce que votre BitBox a t fourni avec un mot de passe de rcupration ? Si c'est le cas, arrtez la procdure d'installation et contactez immdiatement le support. Shift ne vous donnera jamais un portefeuille prt  l'emploi ni de recommandation de mot de passe.", dialog$f = {
  cancel: "Annuler",
  confirm: "Confirmer",
  confirmTitle: "Confirmation"
}, error$a = {
  accountAlreadyExists: "Ce compte existe dj.",
  accountLimitReached: "Impossible d'ajouter un compte. Le nombre maximum de comptes pour ce coin (monaie) a t atteint.",
  aoppCallback: "Une erreur s'est produite lors de la transmission de l'adresse  {{host}}.",
  aoppInvalidRequest: "Requte invalide.",
  aoppNoAccounts: "Aucun comptes disponibles.",
  aoppSigningAborted: "Demande de possession de l'adresse annule.",
  aoppUnknown: "Une erreur inconnue s'est produite.",
  aoppUnsupportedAsset: "Cet actif n'est pas pris en charge.",
  aoppUnsupportedFormat: "Aucun des comptes disponibles ne supporte le format d'adresse requis.",
  aoppUnsupportedKeystore: "Lappareil connect ne peut pas signer de messages pour cet asset.",
  aoppVersion: "Version inconnue.",
  wrongKeystore: "Portefeuille connect incorrect. Veuillez vous assurer d'insrer le bon appareil correspondant  ce compte",
  wrongKeystore2: "Si vous utilisez la passphrase facultative, assurez-vous bien que vous avez saisi la passphrase correspondant  ce compte."
}, fiat$g = {
  default: "dfaut",
  setDefault: "Dfinir {{code}} comme paramtre par dfaut",
  title: "Devises"
}, footer$g = {
  appVersion: "Version de l'application :"
}, generic$a = {
  enabled_false: "Dsactiv",
  enabled_true: "Activ"
}, genericError$e = "Une erreur est survenue. Si vous rencontrez des problmes, veuillez redmarrez l'application.", goal$e = {
  buttons: {
    create: "Crer un nouveau portefeuille",
    restore: "Restaurer un portefeuille  partir d'une sauvegarde"
  },
  paragraph: "Veuillez slectionner l'une des options suivantes :",
  step: {
    1: {
      title: "Information de scurit"
    },
    2: {
      description: "Dfinir un mot de passe pour l'appareil",
      title: "Appareil"
    },
    "3-create": {
      description: "Crer un nouveau portefeuille",
      title: "Portefeuille"
    },
    "3-restore": {
      description: " partir d'une sauvegarde",
      title: "Restaurer"
    },
    "4-create": {
      title: "Rsum"
    },
    "4-restore": {
      title: "Rsum"
    }
  }
}, guide$f = {
  accountDescription: {
    text: `La vue d'ensemble de votre compte affiche votre solde disponible ainsi que les transactions entrantes et sortantes. Notre guide dans "Paramtres" contient plus d'informations sur chaque type de compte. `,
    title: "Que me montre cette page ?"
  },
  accountFiat: {
    text: "Oui. Cliquez sur n'importe quel symbol pour changer la devise. Vous pouvez modifier la liste des devises dans les paramtres.",
    title: "Puis-je afficher d'autres taux de conversion ?"
  },
  accountIncomingBalance: {
    text: "Entrant est la somme des montants qui vous ont t transfrs mais qui n'ont pas encore t confirms par le rseau.",
    title: "Que veut dire entrant ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Chaque xpub est lie au "Type" indiqu : soit "Native Segwit (bech32)", "Wrapped Segwit" ou "Taproot" (Bitcoin uniquement). Ce sont les types de script utiliss par {{coinName}}. BitBoxApp les combine, prenant en charge plusieurs types de script dans le mme compte. Comme chaque type de script donne une xpub diffrente, il y a plusieurs xpubs par compte.

Si vous recevez systmatiquement sur l'adresse par dfaut (Native Segwit), vous n'avez besoin que de la xpub "bech32". Cependant, si vous recevez galement des fonds sur "Wrapped Segwit" ou "Taproot", vous devez galement utiliser respectivement les cls publiques tendues "Wrapped Segwit" et "Taproot".`,
      title: "Pourquoi y a-t-il plusieurs xpubs ?"
    },
    privacy: {
      text: `Pour ce compte spcifique, la cl publique tendue rvle l'ensemble de l'historique des oprations, le solde de votre compte et toutes les transactions futures. Mais la xpub ne permet  personne de dpenser vos coins (monnaie).

Si vous communiquez une xpub  quelqu'un, vous devez tre conscient que cette personne ou entreprise peut visualiser toutes les autres transactions de ce mme compte. Par consquent, c'est une bonne ide d'utiliser ce compte uniquement  cette fin et de garder les autres fonds sur des comptes distincts.`,
      title: "Est-ce que je dois garder ma xpub secrte ?"
    },
    verify: {
      text: "Oui, c'est toujours une bonne initiative de revrifier votre xpub. Si un tiers va gnrer des adresses de rception  partir de cette xpub pour vous envoyer de l'argent, c'est tout particulirement important. Vous devez la vrifier sur l'appareil afin de vous assurer que cette xpub vous appartient; sinon, l'ensemble des fonds pourraient tre envoys  des adresses non voulues.",
      title: "Est-ce que je dois vrifier la xpub sur l'appareil ?"
    },
    xpub: {
      text: `Une cl publique tendue (xpub) est une cl racine  partir de laquelle toutes les adresses de rception d'un compte sont drives.

Elle sont fournies ici  des fins d'utilisation avance et d'interoprabilit avec les portefeuilles de type "watch-only", comme Electrum ou Sentinel. Si vous recevez des fonds sur diffrents types d'adresses, veuillez importer tous les diffrents formats xpub dans le portefeuille "watch-only" afin de pouvoir visualiser tous vos fonds.

Veuillez noter que certains portefeuilles tiers ne supportent pas encore les xpubs Taproot.`,
      title: "Qu'est-ce qu'une cl publique tendue ?"
    }
  },
  accountRates: {
    text: "Les taux de change sont mis  jour toutes les minutes  partir de CoinGecko.",
    title: "Quels taux de change sont utiliss ?"
  },
  accountReload: {
    text: "Il n'y a pas besoin. Vos informations de transaction sont mises  jour automatiquement.",
    title: "Puis-je recharger l'historique des transactions ?"
  },
  accountSendDisabled: {
    text: 'Le bouton "Envoyer" est activ lorsque votre solde est suprieur  zro.',
    title: "Pourquoi ne puis-je pas envoyer de {{unit}} ?"
  },
  accountSummaryAmount: {
    text: `Le montant total est la somme de tous vos comptes crypto. Les taux de change sont obtenus auprs de coingecko.com.

Remarque : si vous utilisez MyEtherWallet pour des tokens (jetons) non pris en charge par BitBoxApp, ils ne seront pas inclus dans le montant affich.`,
    title: "Comment le montant total est-il calcul ?"
  },
  accountSummaryDescription: {
    text: "Vous pouvez voir ici la performance de votre portefeuille au fil du temps. Un rsum de vos comptes cryptos individuels est affich sous le graphique.",
    title: "Que me montre cette page ?"
  },
  accountTransactionAttributesBTC: {
    text: `Taille virtuelle : dtermine les frais de rseau. Vous avez russi  conomiser sur les frais si elle est infrieure  la taille de la transaction.
Taille : Taille relle de la transaction en octets dpendamment de la blockchain concerne.
Poids : Une nouvelle mesure, introduite avec Segwit, permettant d'valuer la transaction et la taille du bloc. Chaque octet tmoin est spar et compte pour un, le reste en tant que quatre units de poids. Au lieu d'un mgaoctet de taille relle, la limite de taille de bloc est maintenant de quatre millions d'units de poids.`,
    title: "Qu'en est-il des dtails spcifiques de la transaction Bitcoin ?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmations : Lors de l'mission de votre transaction, elle ne sera pas confirme. Vous devrez attendre qu'un mineur l'inclue dans un bloc, elle aura alors une confirmation. Chaque bloc mis sur le rseau par la suite ajoutera une nouvelle confirmation  votre transaction. En gnral, les commerants et autres acteurs de l'cosystme considrent comme valides les transactions ayant entre 3 et 6 confirmations.
Transaction ID : Numro d'identification unique pouvant tre utilis pour rechercher une transaction dans un explorateur de blocs.
Frais : Les mineurs reoivent des frais de transaction afin de les inciter  intgrer les transactions dans les blocs qu'ils minent. Pour en savoir plus, cliquez sur le bouton d'envoi.`,
    title: "Quelles sont les informations affiches dans le dtail de la transaction?"
  },
  accountTransactionConfirmation: {
    text: "Il sagit dune transaction qui a t mise sur le rseau et en attente dtre confirme.",
    title: "Qu'est-ce qu'une transaction en attente ?"
  },
  accountTransactionLabel: {
    text: "C'est l'adresse vous ayant envoy les coins ou  laquelle vous les avez envoys.",
    title: "Quelle adresse est affiche pour chaque transaction?"
  },
  accountTransactionTime: {
    text: "L'heure et la date  laquelle la transaction a t confirme sur la blockchain.",
    title: "Quel horodatage est affich ?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin et Litecoin ne peuvent avoir quun nombre arbitraire de comptes. Au del de cinq comptes, vous ne pouvez en ajouter un supplmentaire que si le compte prcdent a dj t utilis. 
Un maximum de cinq comptes est possible pour les autres coins (jetons).`,
      title: "Combien de comptes puis-je crer ?"
    },
    howtoAddTokens: {
      text: `Les jetons utilisant la norme ERC20 sont rattachs  un compte Ethereum spcifique. Pour activer ou dsactiver un jeton en particulier, ouvrez l'cran "Grer les comptes", largissez votre compte Ethereum et activez ou dsactivez le jeton souhait.`,
      title: "Comment ajouter des jetons supplmentaires ?"
    },
    moveFunds: {
      text: "Oui. Mais comme les comptes sont indpendants, vous devez envoyer vos fonds en utilisant une transaction classique.",
      title: "Est-ce que je peux dplacer des fonds entre les diffrents comptes ?"
    },
    recoverAccounts: {
      text: "Oui. BitBoxApp cre des comptes en utilisant des normes bien tablies et compatibles avec la plupart des autres portefeuilles de crypto-monnaies.",
      title: "Est-ce que je peux rcuprer mes comptes avec d'autres portefeuilles ?"
    },
    whatAreAccounts: {
      text: "Votre portefeuille peut grer plusieurs comptes pour un mme coin (monnaie). Les diffrents comptes sont utiles lorsque vous souhaitez conserver des fonds sparment.",
      title: "Qu'est-ce qu'un compte ?"
    },
    whyIsThisUseful: {
      text: `Les comptes sont parfaits pour grer des fonds destins  des personnes ou des objectifs diffrents, car ils sont distincts. Vous pouvez galement partager la "cl publique tendue" (xpub) d'un compte sans rien dvoiler de vos autres comptes. Cela vous permet de recevoir des fonds de manire rpte sans rutiliser les adresses, par exemple pour recevoir votre salaire ou acheter rgulirement des crypto-monnaies.`,
      title: "Pourquoi est-ce utile ?"
    }
  },
  appendix: {
    link: "Contactez-nous !",
    text: "Vous avez une autre question ?"
  },
  backups: {
    check: {
      text: `"Vrifier la sauvegarde" vous permet de vrifier que vous disposez d'une sauvegarde fonctionnelle correspondant  votre portefeuille actuel. Elle peut galement tre utilise pour vrifier que vous disposez toujours du mot de passe de rcupration correct. Vous pouvez vrifier votre mot de passe de rcupration principal ou votre mot de passe de rcupration cach.`,
      title: 'Que signifie "Vrifier la sauvegarde" ?'
    },
    encrypt: {
      text: "Non, mais votre mot de passe de rcupration est ncessaire pour driver le portefeuille  partir de la graine stocke.",
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    howOften: {
      text: `La sauvegarde est automatiquement gnre lorsqu'un nouveau portefeuille est cr. Vous devez effectuer une nouvelle sauvegarde que si votre carte microSD est perdue ou endommage ou si vous souhaitez utiliser plusieurs cartes microSD pour vos sauvegardes.
Vous n'avez pas besoin de crer une nouvelle sauvegarde aprs avoir effectu des transactions. Toutes les donnes associes  vos transactions peuvent tre recres par votre sauvegarde unique qui a t gnre automatiquement.`,
      title: " quelle frquence dois-je faire une sauvegarde ?"
    },
    whatIsABackup: {
      text: "C'est une copie de la graine sur une carte microSD. La graine combine  votre mot de passe de rcupration gnre votre portefeuille.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Vrifier la sauvegarde" vous permet de vrifier que la sauvegarde correspond bien  votre portefeuille.',
      title: 'Que signifie "Vrifier la sauvegarde" ?'
    },
    encrypt: {
      text: `Non. Veillez  conserver la carte microSD en scurit compte tenu du fait qu'elle contient votre liste de mots permettant la restauration de votre portefeuille. Si vous souhaitez protger votre graine par mot de passe, vous pouvez activer une phrase secrte dans les paramtres avancs du menu "Grer l'appareil".`,
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    whatIsABackup: {
      text: "Il s'agit d'une copie de votre liste de mots BIP39 sur une carte microSD.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Lorsque le 2FA est activ, toutes les transactions doivent tre approuves sur votre tlphone portable appair afin de pouvoir envoyer des jetons. En ralit, un numro chiffr,  usage unique, est envoy  l'application mobile, dchiffr  et renvoy au BitBox lorsque vous appuyez sur le bouton "Accepter". Cette communication avec l'appareil se fait via le canal entre le tlphone mobile et l'application de bureau tablie lors de l'appareillage.

Assurez-vous de sauvegarder votre portefeuille et d'appairer l'application mobile avant d'activer le 2FA. Une fois activ, l'appairage entre l'emplacement de la carte micro SD et l'application mobile est dsactiv. Il peut tre ractiv en rinitialisant le BitBox.`,
      title: "Comment fonctionne la double authentification (2FA) ?"
    },
    disable2FA: {
      text: `Pour dsactiver le 2FA, vous devez rinitialiser votre BitBox, puis restaurer le portefeuille  partir de sa sauvegarde. Assurez-vous que vous tes toujours en possession de la carte micro SD avec la sauvegarde et que vous vous souvenez du mot de passe de rcupration. Puis appuyez sur "Rinitialiser l'appareil". Dfinissez un nouveau mot de passe et choisissez "Ou restaurer une sauvegarde". Slectionnez la sauvegarde que vous avez effectue  partir du portefeuille, cliquez sur "Restaurer" et entrez le mot de passe de rcupration que vous avez utilis lors de la cration du portefeuille.`,
      title: "Comment puis-je dsactiver la double authentification (2FA) ?"
    },
    ejectBitbox: {
      text: "Vous pouvez dbrancher le BitBox  tout moment sans avoir  l'jecter.",
      title: "Comment puis-je jecter le BitBox ?"
    },
    ejectSD: {
      text: "Vous pouvez retirer la carte microSD du BitBox  tout moment, tant que vous n'tes pas en train de crer ou de restaurer une sauvegarde.",
      title: "Comment puis-je jecter la carte microSD ?"
    },
    hiddenWallet: {
      text: "Il sagit dun deuxime portefeuille sur le mme appareil, protg par un mot de passe d'appareil et de rcupration diffrents, qui peut tre utile pour un plausible dni. La mme graine de sauvegarde est utilise pour votre portefeuille normal et votre portefeuille cach. Aucune sauvegarde supplmentaire n'est donc ncessaire.",
      title: "Qu'est-ce qu'un portefeuille cach ?"
    },
    legacyHiddenWallet: {
      text: "Cliquez d'abord sur le bouton ci-dessous (disponible si le BitBox est dverrouill avec le mot de passe principal de l'appareil et si la double authentification est dsactive), puis rebranchez votre BitBox et dverrouillez-le avec le mot de passe du portefeuille cach.",
      title: "Comment accder au portefeuille Legacy cach ?"
    },
    pairing: {
      text: "Aprs avoir tlcharg notre application mobile pour iOS ou Android, vous devez scanner le QR code affich, ce qui tablit un canal scuris entre l'application mobile et l'application de bureau. Une fois scann, suivez les instructions sur l'application mobile.",
      title: "Comment appairer votre tlphone en toute scurit ?"
    }
  },
  cointracking: {
    text: `Cliquez sur le bouton "Exporter" et ouvrez le dossier de tlchargement o vous trouverez l'exportation CSV. Cliquez ensuite sur le lien ci-dessous, tlchargez votre fichier CSV BitBox et importez les donnes afin de les utiliser avec votre gestionnaire de portefeuille CoinTracking et pour crer vos dclaration fiscales.`,
    title: "Comment importer mes transactions dans CoinTracking ?"
  },
  device: {
    attestation: {
      link: {
        text: "En savoir plus sur le contrle d'authenticit"
      },
      text: "BitBoxApp effectue un contrle d'attestation sur la BitBox02 afin de confirmer que le dispositif est bien authentique. La vrification est effectue localement et ne ncessite aucune connexion  un serveur.",
      title: "Comment fonctionne le contrle d'authenticit?"
    },
    name: {
      text: "Ceci est le nom de votre portefeuille et de votre sauvegarde. Ce nom est utilis pour les sauvegardes futures et permet de faire la distinction entre diffrents portefeuilles. Il peut tre modifi  tout moment mais veuillez noter que les sauvegardes effectues avant ce changement continueront d' utiliser le nom prcdent.",
      title: "A quoi sert le nom BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "En savoir plus sur la puce scurise"
      },
      text: "Cette information indique le modle de la puce scurise. La puce la plus rcente est l'ATECC608B, qui bnficie de caractristiques de scurit renforces comparativement aux prcdents modles.",
      title: "Pourquoi indiquer le modle de puce scurise?"
    }
  },
  receive: {
    address: {
      text: "Vous pouvez donner l'adresse  d'autres personnes pour qu'elles vous envoient des coins. Assurez-vous simplement qu'elles envoient  la bonne adresse.",
      title: "Que puis-je faire d'une adresse ?"
    },
    addressChange: {
      text: "Ds que vous effectuez une transaction, une nouvelle adresse est automatiquement ajoute  la liste de sorte qu'il y ait toujours 20 adresses vierges disponibles.",
      title: "Quand les adresses changent-elles ?"
    },
    addressFormats: {
      text: "Par dfaut, le type d'adresse est Native Segwit. Ce type d'adresse est largement adopt par d'autres portefeuilles/exchanges et vous offre les meilleurs niveau de frais pour les transactions quotidiennes. Cependant, vous pouvez galement choisir d'envoyer vers Taproot (Bitcoin uniquement), qui est le type d'adresse le plus rcent, mais qui n'est peut-tre pas encore largement support. Par ailleurs, si vous rencontrez des difficults pour vos envois vers Native Segwit (le type par dfaut), vous pouvez essayer de passer  l'ancien type d'adresse Wrapped Segwit, qui peut se rvler compatible avec davantage de portefeuilles/exchanges.",
      title: `Quand dois-je utiliser la fonction "Modifier le type d'adresse" ?`
    },
    howVerify: {
      text: `Pour le BitBox01, cliquez sur l'icne BitBox dans la barre latrale de gauche et consultez la section appairage. Le guide sera mis  jour et vous pourrez continuer  suivre les instructions  partir de l.
Pour le BitBox02, vous pouvez vrifier les adresses directement sur l'appareil pendant le processus d'envoi/rception.`,
      title: "Comment puis-je vrifier une adresse en toute scurit ?"
    },
    plugout: {
      text: "Non, une fois que vous avez envoy des fonds sur votre adresse BitBox, vous n'avez pas besoin de laisser votre BitBox branche. Vous tes libre de pouvoir dconnecter votre BitBox.",
      title: "Est-ce que je dois laisser mon BitBox branch quand je reois des fond ?"
    },
    why20: {
      text: `Au dmarrage, l'application gnre des adresses drives de votre graine pour vrifier si elles ont reu des fonds. Comme l'application peut gnrer un nombre presque infini d'adresses, elle pourrait prendre des annes  effectuer cette vrification de solde. Pour limiter cette recherche, elle s'arrte aprs avoir gnr 20 adresses vierges. Il s'agit de la "limite d'cart" et 20 est une norme commune bien que arbitraire. Voici les 20 adresses parmi lesquelles vous pouvez choisir.`,
      title: "Pourquoi seulement 20 adresses ?"
    },
    whyMany: {
      text: "Pour prserver la confidentialit et la scurit, ne donnez jamais deux fois la mme adresse. Si vous avez utilis une adresse, cliquez sur la flche  droite pour obtenir une nouvelle adresse. Vous pouvez gnrer jusqu' 20 adresses  la fois. Voyez les adresses comme des numros de facture. Toutes les adresses sont drives de votre graine, elle mme unique.",
      title: "Pourquoi y a-t-il autant d'adresses ?"
    },
    whyVerify: {
      text: "Vous ne devriez pas faire confiance  votre ordinateur pour gnrer et afficher des adresses authentiques. Sa grande surface d'attaque le rend beaucoup plus vulnrable qu'un portefeuille physique. Pour le BitBox01, le bouton permettant de vrifier l'adresse envoie l'adresse de manire scurise  un tlphone mobile jumel,  partir duquel vous pouvez galement scanner et vrifier le code QR. Pour le BitBox02, l'adresse peut tre vrifie directement sur l'cran du BitBox02.",
      title: "Pourquoi devrais-je vrifier l'adresse en toute scurit ?"
    }
  },
  send: {
    change: {
      text: "Le change sera restitue sur une adresse Taproot si vous disposez d'au moins un UTXO Taproot. Si vous utilisez le coin control, le change sera transfr vers une adresse Taproot s'il y a au moins un UTXO Taproot parmi les UTXOs slectionns. Dans tous les autres cas, le change est envoy vers une adresse Native Segwit.",
      title: "Comment le change output (de sortie) est-il dtermin ?"
    },
    fee: {
      text: `Les frais sont bass sur la taille des donnes de la transaction et non sur son montant. L'estimation des frais  payer sont calculs par l'algorithme du logiciel Bitcoin Core en fonction de la priorit de traitement par le rseau choisie. Ils sont affichs s'ils ont une valeur diffrente des cibles ci-dessous.

conomique : 24 blocs (environ 4 heures pour Bitcoin, 1 heure pour Litecoin)
Bas : 12 blocs (environ 2 heures pour Bitcoin, 30 minutes pour Litecoin)
Normal : 6 blocs (environ 1 heure pour Bitcoin, 15 minutes pour Litecoin)
lev : 2 blocs (environ 20 minutes pour Bitcoin, 5 minutes pour Litecoin)
(Un bloc prend en moyenne dix minutes pour Bitcoin (2,5 minutes pour Litecoin)  miner et la charge du rseau peut varier considrablement au cours des priodes ci-dessus.)`,
      title: "Comment les frais sont-ils dtermins ?"
    },
    plugout: {
      text: "Non, une fois que vous avez effectu une transaction, il n'est pas ncessaire de laisser votre BitBox branch. Vous pouvez dconnecter votre BitBox.",
      title: "Dois-je laisser ma BitBox branche pendant l'envoi ?"
    },
    priority: {
      text: "Votre transaction sera gnralement confirme plus rapidement par le rseau si les frais que vous tes prt  payer sont levs.",
      title: "Quelle est la priorit du rseau ?"
    },
    revert: {
      text: `Une fois qu'une transaction est signe et envoye (c'est--dire diffuse sur le rseau), elle ne peut plus tre annule. Vrifiez les transactions (y compris les frais) correctement avant de signer !
Si vous connaissez le destinataire et qu'il est prt  vous renvoyer le mme montant (moins les frais de transaction), vous pouvez lui communiquer une adresse de rception  vous.`,
      title: "Puis-je annuler une transaction ?"
    },
    whyFee: {
      text: `Les transactions sont en comptitions les unes avec les autres pour tre confirmes par un mineur. Les mineurs choisissent quelles transactions sont  inclure dans la blockchain en fonction des frais de rseau.
Les mineurs votent sur l'historique des transactions. Puisqu'il n'y a pas de tiers de confiance qui impose un vote par personne (ce qui est l'intrt des blockchains), les mineurs votent sur les transactions en sacrifiant une ressource coteuse telle que la puissance de calcul. En rcompense de leur travail, ils peuvent prtendre aux jetons fraichement crs ainsi qu'aux frais de toutes les transactions qu'ils ont incluses dans leur bloc.`,
      title: "Pourquoi y a-t-il des frais de rseau ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Si vous avez l'intention de connecter  votre nud exclusivement  un seul rseau (par exemple, le rseau wifi de votre domicile), l'utilisation d'une communication rseau normale est suffisante.
Dans ce cas, il est conseill que votre serveur Electrum fournisse un certificat TLS pour crypter la communication.
Si vous avez l'intention de connecter votre nud depuis n'importe o, l'utilisation de Tor est la meilleure option. Aucun certificat TLS n'est ncessaire dans ce cas.`,
      title: "Dois-je utiliser clearnet TCP, TLS ou Tor ?"
    },
    instructions: {
      link: {
        text: "Guide pour connecter votre nud"
      },
      text: "Pour un tutoriel complet, veuillez consulter notre guide :",
      title: "Comment je fais pour connecter ma BitBoxApp  mon nud personnel?"
    },
    options: {
      text: `Il existe diffrentes solutions pour faire tourner votre propre nud, comme par exemple acheter un appareil prt  l'emploi, ou bien fabriquer le vtre, ou bien encore utiliser Bitcoin Core.
Si vous souhaitez connecter votre BitBoxApp  votre nud, assurez-vous qu'il tourne sur un serveur Electrum. Il s'agit d'un programme ddi qui permet  une application de portefeuille de communiquer avec votre nud.
Les options supportes sont Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).`,
      title: "Quelles sont les options disponibles pour faire tourner un nud?"
    },
    tor: {
      text: `Tor est l'acronyme de "The Onion Router", un logiciel libre et gratuit qui offre de nombreux avantages en matire de confidentialit et qui est particulirement intressant lorsque vous utilisez Bitcoin.
Si vous avez l'intention de vous connecter  votre nud via Tor, assurez-vous que Tor est install sur votre ordinateur, puis activez le proxy Tor dans les paramtres de BitBoxApp.
Sur la plupart des systmes d'exploitation, il existe deux faons d'excuter Tor :
1. Navigateur Tor : tlchargez et ouvrez le navigateur Tor. Cela permettra  BitBoxApp de se connecter au rseau Tor en activant le port 9150 dans les paramtres du proxy Tor.
2. Background service Tor : installez le daemon Tor, qui fonctionne toujours en fond. BitBoxApp peut alors se connecter en configurant le port 9050 dans les paramtres du proxy Tor.`,
      title: "Qu'est-ce que Tor, le proxy Tor et quel port dois-je utiliser ?"
    },
    what: {
      text: "Il est possible de synchroniser votre portefeuille depuis vos propres nuds complets au lieu d'utiliser les serveurs de Shift.",
      title: "Qu'est-ce que cela ?"
    },
    why: {
      text: `Faire tourner votre propre nud n'est pas ncessaire mais amliore la confidentialit et rduit le besoin de faire confiance aux autres.
Premirement, cela signifie que vous utilisez Bitcoin de manire plus prive car le BitBoxApp ne se connectera pas  nos serveurs pour rcuprer l'historique de vos transactions, mais rcuprera ces informations  partir de votre propre nud.
Deuximement, faire tourner votre propre nud signifie que celui-ci vrifie lui-mme toutes les transactions, en s'assurant que les rgles de consensus sont bien respectes.`,
      title: "Pourquoi est-ce que je devrais faire tourner mon propre nud ?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" en abrg) est la plus petite unit de Bitcoin. Un Satoshi correspond  un cent millionime de bitcoin (0,00000001 BTC). Il tire son nom du crateur de Bitcoin, Satoshi Nakamoto.',
      title: "Qu'est-ce qu'un Satoshi?"
    },
    servers: {
      text: `Cette application communique avec les serveurs de Shift Crypto pour rechercher des mises  jour, charger des transactions et envoyer des informations aux applications mobiles appaires.
De plus, elle rcupre les derniers taux de change de CoinGecko.
Les conversions sont calcules localement, aucun de vos montants n'est transmis.
Note : Pour Ethereum et les jetons ERC20, nous utilisons Etherscan.io APIs.`,
      title: "Avec quels serveurs cette application communique-t-elle ?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Fermer le guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Sur ordinateur, dplacez le curseur sur le graphique. Sur mobile, maintenez le doigt sur le graphique et faites-le glisser horizontalement.",
    title: "Comment voir les valeurs historiques sur le graphique?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Vous devez rinitialiser l'appareil et restaurer le portefeuille  partir d'une sauvegarde et du mot de passe de rcupration.",
      title: "Que dois-je faire si j'ai oubli le mot de passe de l'appareil ?"
    },
    reset: {
      text: "Entrez un mauvais mot de passe 15 fois. Les dernires tentatives ncessitent une longue pression du bouton tactile sur l'appareil.",
      title: "Comment rinitialiser l'appareil ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Le dispositif doit clignoter une fois qu'il est insr. Assurez-vous qu'il soit insr dans le bon sens. Si vous rencontrez des difficults, veuillez nous contacter via le lien ci-dessous.

La BitBox01 n'est pas utilisable sur mobile. Veuillez utiliser la BitBoxApp sur votre ordinateur pour connecter votre BitBox01.`,
      title: "Mon BitBox01 n'est pas reconnu"
    },
    getDevice: {
      link: {
        text: "Commander un BitBox"
      },
      text: "Vous pouvez acheter un BitBox dans notre boutique en ligne :",
      title: "Comment puis-je obtenir un appareil BitBox ?"
    },
    internet: {
      text: "Oui, une connexion  Internet est ncessaire pour synchroniser le portefeuille, envoyer des transactions et rcuprer les derniers taux de change.",
      title: "Cette application ncessite-t-elle une connexion  Internet ?"
    },
    lostDevice: {
      link: {
        text: "Centre de sauvegarde"
      },
      text: "Vous pouvez accder  vos comptes via un nouveau BitBox ou depuis notre centre de sauvegarde.",
      title: "J'ai perdu mon appareil. Que faire ?"
    },
    useWithoutDevice: {
      text: "Ce n'est malheureusement pas possible pour le moment.",
      title: "Puis-je utiliser l'application sans appareil Bitbox ?"
    },
    welcome: {
      text: "Merci d'utiliser cette application dveloppe par Shift Crypto en Suisse. Nous apprcions tous les commentaires dont vous pourriez nous faire part. Vous pouvez nous les soumettre en cliquant sur le lien en bas de page.",
      title: "Bienvenue dans l'application BitBox !"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si vous utilisez un nouveau tlphone/ordinateur avec la BitBoxApp, vous devrez vous connecter  nouveau aux DApps. Vous verrez alors vos coins sur la DApps comme prcdemment.",
      title: "Je ne vois pas mes prcdentes connexions."
    },
    supportedNetworks: {
      text: "Actuellement, seul le mainnet dEthereum est support lorsque vous utilisez WalletConnect dans la BitBoxApp. Pour utiliser d'autres chanes compatibles EVM, veuillez utiliser l'extension de navigateur Rabby wallet.",
      title: "Quels sont les rseaux supports ?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect est un protocole de communication pour les applications web3. Il vous permet de vous connecter facilement aux DApps et aux portefeuilles web reposant sur Ethereum sans utiliser d'application tierce; ceci constitue une solution particulirement pratique pour les utilisateurs Android de la BitBoxApp.",
      title: "Qu'est-ce que WalletConnect ?"
    }
  }
}, headerssync$e = {
  blocksSynced: "{{blocks}} blocs synchroniss"
}, hiddenWallet$e = {
  info1HTML: "Pour un besoin de dni plausible, un portefeuille cach peut tre cr  partir d'une combinaison de <strong> diffrents </strong> mot de passe de rcupration et d'appareil.",
  info2HTML: "Dfinissez le mot de passe de l'appareil et de rcupration que vous souhaitez associer  votre portefeuille cach ci-dessous. Le mot de passe de l'appareil et le mot de passe de rcupration doivent tre <strong> diffrents </strong> de ceux que vous avez dfinis pour votre portefeuille principal.",
  passwordLabel: "Mot de passe de rcupration cach",
  passwordPlaceholder: "Veuillez confirmer le mot de passe de rcupration cach",
  pinLabel: "Mot de passe de l'appareil cach",
  pinRepeatLabel: "Rpter le mot de passe de l'appareil cach",
  pinRepeatPlaceholder: "Veuillez confirmer le mot de passe de l'appareil cach",
  success: "Un portefeuille cach a t cr avec succs. Rebranchez votre BitBox pour le dverrouiller."
}, initialize$e = {
  create: "Dfinir le mot de passe de l'appareil",
  creating: "Dfinition du mot de passe de l'appareil en cours",
  error: {
    e102: "Le mot de passe de l'appareil doit comporter au moins 4 caractres."
  },
  info: {
    description1: "Choisissez le mot de passe de votre appareil. Celui-ci sera utilis pour dverrouiller votre BitBox.",
    description2: "Vous pouvez utiliser des chiffres, des lettres et des symboles. Les mots de passe longs offrent une meilleure scurit.",
    description3: "Si vous perdez le mot de passe de votre appareil, vous devrez le rinitialiser et restaurer la sauvegarde de votre portefeuille.",
    subtitle: "Vous allez maintenant dfinir le mot de passe de votre appareil",
    title: "Initialisation de votre appareil"
  },
  input: {
    label: "Mot de passe de l'appareil",
    labelRepeat: "Rpter le mot de passe de l'appareil",
    placeholderRepeat: "Veuillez confirmer le mot de passe de l'appareil"
  }
}, invalidFormat$e = "Format invalide", language$f = {
  title: "Choisir la langue"
}, legacyhiddenwallet$e = {
  disable: "Dsactiver le portefeuille Legacy cach",
  enable: "Activer le portefeuille Legacy cach",
  successDisable: "Portefeuille Legacy cach dsactiv avec succs.",
  successEnable: "Portefeuille Legacy cach activ avec succs. Reconnectez votre BitBox et entrez le mot de passe de l'appareil cach pour accder au portefeuille Legacy cach."
}, loading$e = "chargement en cours", manageAccounts$8 = {
  accountHidden: "Ce compte a t retir de vos comptes watch-only. Pour le voir  nouveau, veuillez brancher votre BitBox02.",
  editAccount: "Modifier",
  editAccountNameTitle: "Modifier le nom du compte",
  noAccounts: "aucun compte trouv",
  settings: {
    hideTokens: "Cacher les jetons",
    showTokens: "Afficher les jetons ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Ajouter et afficher/masquer les comptes",
  title: "Gestion des comptes",
  watchAccount: "Compte de suivi",
  watchAccountDescription: "Ce compte fait partie de vos comptes watch-only. Vous pouvez le faire disparatre de vos comptes watch-only  l'aide du bouton."
}, mobile$9 = {
  usingMobileDataWarning: "Utilisation des donnes mobiles : cette application peut tlcharger jusqu' quelques centaines de mgaoctets de donnes d'en-tte de blockchain aprs avoir dverrouill un compte. Veuillez vous connecter au Wi-Fi afin d'viter d'utiliser les donnes mobiles. Aprs l'avoir quitt, ce message ne s'affichera plus."
}, newSettings$7 = {
  about: {
    appVersion: {
      title: "Version de l'application"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Verrouiller l'accs  l'application via le verrouillage de l'cran/empreinte digitale.",
      title: "Verrouillage de l'cran"
    },
    coinControl: {
      description: "Slectionnez quelles UTXO font partie d'une transaction afin d'amliorer la confidentialit"
    },
    customFees: {
      description: "Vous permet de saisir vos propres frais lors de l'envoi."
    },
    torProxy: {
      description: "Se connecter via Tor pour une meilleure confidentialit."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Ces devises supplmentaires peuvent tre slectionnes sur la page de votre compte.",
      title: "Devises actives"
    },
    darkmode: {
      description: "Voir la BitBoxApp en dark mode (mode sombre)."
    },
    defaultCurrency: {
      description: "Slectionnez votre devise par dfaut",
      title: "Devise par dfaut"
    },
    hideAmounts: {
      description: "Affiche un bouton permettant de masquer votre solde et vos montants afin d'amliorer votre confidentialit lorsque vous utilisez l'application en public.",
      hideAmounts: "Cacher les montants",
      showAmounts: "Afficher les montants",
      title: "Autoriser la dissimulation des montants"
    },
    language: {
      description: "Quelle langue souhaitez vous que BitBoxApp utilise?",
      title: "Langue"
    },
    toggleSats: {
      description: "Activer ou dsactiver l'unit des Satoshis"
    }
  }
}, note$a = {
  input: {
    description: "(facultatif)",
    placeholder: "Ajouter une note..."
  },
  title: "Note"
}, notification$e = {
  newTxs_one: "Nouvelle transaction dans : {{accountName}}",
  newTxs_other: "{{count}} nouvelles transactions dans : {{accountName}}"
}, pairing$e = {
  aborted: {
    text: "L'appairage a t annul depuis l'application mobile.",
    title: "Abandonn"
  },
  button: "Appairer l'application mobile",
  confirm: "tes-vous sr de vouloir appairer votre BitBox ? Notez qu'ensuite le tlphone mobile est ncessaire pour effectuer une transaction.",
  connectOnly: {
    button: "Connecter l'application mobile",
    title: 'Scannez depuis notre application mobile en cliquant sur "Connecter  une nouvelle application de bureau"'
  },
  error: {
    text: "Quelque chose s'est mal pass. Veuillez recommencer.",
    title: "Erreur"
  },
  pullFailed: {
    text: "Impossible de faire passer un message de votre mobile par le serveur relais. Le serveur relais est peut-tre hors ligne, veuillez contacter l'assistance.",
    title: "chec de transfert"
  },
  reconnectOnly: {
    button: "Reconnecter l'application mobile"
  },
  scanningFailed: {
    text: "Le mobile n'a pas pu scanner le message correctement. Veuillez ressayer.",
    title: "chec de la numrisation"
  },
  start: {
    hideAppQRCode: "Masquer le QR Code",
    revealAppQRCode: "Afficher le QR Code",
    step1: "Si vous ne possdez pas encore l'application mobile, vous pouvez scanner le QR code correspondant  l'App Store ou au Play Store en fonction de votre tlphone.",
    step2: `Scannez depuis notre application mobile, que vous pouvez trouver sous le nom "Digital Bitbox 2FA" dans les magasins d'applications pour iOS et Android :`
  },
  started: {
    text: "Veuillez maintenant suivre les instructions sur l'application mobile.",
    title: "Gnial"
  },
  success: {
    text: "Flicitations, vous avez appair votre BitBox  lapplication mobile !",
    title: "Succs"
  },
  timeout: {
    text: "Le temps d'appairage expire aprs deux minutes. Recommencez si vous souhaitez toujours appairer l'application mobile.",
    title: "Expiration de session"
  },
  title: "Appairage mobile"
}, passphrase$8 = {
  considerations: {
    button: "Considrations relatives  la sauvegarde",
    message: `La passphrase ajoute une couche de protection supplmentaire   la sauvegarde de votre portefeuille (carte microSD ou mots de rcupration). Si quelqu'un a accs  votre sauvegarde, il aura galement besoin de la passphrase pour accder  votre portefeuille.

Cependant, cela signifie que vous aurez besoin <strong> la fois de la passphrase ET de la sauvegarde du portefeuille</strong>  pour restaurer votre portefeuille pour lequel la passphrase est active, au cas o votre BitBox02 serait perdu ou cass. Si vous oubliez ou perdez votre passphrase, vous perdrez l'accs  toutes les fonds se trouvant dans ce portefeuille.

Lorsque vous stockez votre passphrase, pensez bien  la conserver dans un endroit diffrent de celui de votre sauvegarde. De cette faon, si venait  trouver votre sauvegarde, il n'aurait pas accs  votre passphrase galement.`,
    title: "Considrations relatives  la sauvegarde"
  },
  disable: "Dsactiver la passphrase",
  disableInfo: {
    button: "Dsactiver",
    message: `Une fois la passphrase dsactive, il ne vous sera plus demand de saisir une passphrase aprs avoir dverrouill votre BitBox02. Par consquent, vous entrerez dans votre portefeuille par dfaut.

Tous les coins (monnaies) se trouvant sur votre portefeuille avec passphrase seront toujours sur ce portefeuille, mais vous ne pourrez plus y accder car aprs avoir dverrouill votre BitBox02, vous ouvrirez votre portefeuille par dfaut.

Pour accder de nouveau  vos portefeuilles avec passphrase, il suffit de ractiver la fonction passphrase et de saisir la passphrase correspondante aprs dverrouillage de la BitBox02.

<strong>Astuce:</strong> Vous pouvez toujours accder  votre portefeuille d'origine en laissant la phrase de passe vide.`
  },
  enable: "Activer la passphrase",
  error: {
    e104: "La modification des paramtres de la passphrase a t interrompue."
  },
  how: {
    button: "A quoi a ressemble",
    message: `Une passphrase ne fonctionne pas comme les mots de passe auxquels vous tes habitu. Si vous vous trompez dans la saisie de votre passphrase, vous ne serez pas averti. En effet, <strong>chaque passphrase cre un portefeuille distinct, mais valide</strong>. Cela signifie que vous pouvez utiliser autant de passphrases que vous le souhaitez afin de crer autant de portefeuilles correspondants. Mais on ne peut accder  chaque portefeuille qu'en saisissant la passphrase associe.

Au moment o vous branchez votre BitBox02, le mot de passe de l'appareil vous sera demand de manire habituelle. Ensuite, il vous sera demand d'entrer une passphrase sur l'appareil.

Aprs avoir saisi la passphrase, vous verrez s'afficher cette mme passphrase que vous avez entre. Cela vous permet de confirmer que vous l'avez saisie correctement.`,
    title: "Comment a marche"
  },
  intro: {
    message: `Une passphrase fournit une couche supplmentaire de scurit en plus pour votre portefeuille.
Voyons comment cela fonctionne.`,
    title: "Configurer la passphrase"
  },
  progressDisable: {
    message: "Confirmez sur votre BitBox que vous souhaitez <strong>dsactiver</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  progressEnable: {
    message: "Confirmez sur votre BitBox que vous voulez <strong>activer</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  successDisabled: {
    message: `Passphrase optionnelle <strong>active avec succs</strong> !
Il vous sera demand de fournir une passphrase  partir de maintenant.`,
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02",
    title: "Passphrase active"
  },
  successEnabled: {
    message: `Passphrase optionnelle <strong>dsactive avec succs</strong> !
Il ne vous sera plus demand de fournir une passphrase  partir de maintenant.`,
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02.",
    tips: "Astuces",
    tipsList: [
      "Nous vous suggrons d'envoyer d'abord un petit montant dans le portefeuille avec passphrase. Ensuite, dbranchez puis rebranchez la BitBox02 avant de saisir votre mot de passe et votre passphrase. Si vous avez entr votre passphrase correctement, vous devriez voir les fonds dans votre portefeuille.",
      "Si vous souhaitez accder  votre portefeuille d'origine sans passphrase, vous pouvez toujours le faire en ne saisissant tout simplement rien lorsque vous tes invit  fournir la passphrase. Vous pouvez galement choisir de dsactiver la fonction passphrase."
    ],
    title: "Passphrase dsactive"
  },
  summary: {
    button: "Activer la passphrase",
    title: "Rsum",
    understand: "Je comprends le fonctionnement de la passphrase et les risques qui lui sont associs.",
    understandList: [
      "La passphrase est une couche de scurit supplmentaire en plus de votre sauvegarde.",
      "La saisie d'une passphrase diffrente gnrera  chaque fois un porte-monnaie diffrent.",
      "Pour restaurer votre portefeuille, vous avez besoin <strong> la fois de la passphrase et de la sauvegarde</strong>.",
      "Si vous oubliez votre passphrase, vous ne pourrez plus accder  vos fonds."
    ]
  },
  what: {
    button: "Dcouvrez comment cela fonctionne",
    message: `Un portefeuille est cr (driv)  partir d'un  nombre alatoire trs grand, galement appel "seed" (graine). Cette seed est cre lors de la premire configuration de votre BitBox02 et est sauvegarde via la carte microSD ou les mots de rcupration. Toute personne ayant accs  la seed dispose d'un contrle total sur les fonds de ce portefeuille.

Une passphrase est un <strong>secret optionnel</strong>, ajout  la seed. Lorsque vous utilisez une passphrase, chaque passphrase cre un nouveau portefeuille bas sur la seed + la passphrase (secret optionnel). Une passphrase peut tre n'importe quoi : des lettres, des mots, des caractres spciaux ou mme tre vide. Le portefeuille par dfaut est en fait driv de la seed + passphrase vide.

La passphrase fait partie de la norme BIP39, ce qui signifie qu'elle est compatible avec tous les portefeuilles qui supportent cette dernire.`,
    title: "Qu'est-ce qu'une passphrase?"
  },
  why: {
    button: "Pourquoi utiliser une passphrase",
    message: `La BitBox02 protge la seed contre l'extraction depuis l'appareil lui-mme, mais la sauvegarde (carte microSD ou mots de rcupration) donne un accs complet au portefeuille. C'est pourquoi elle doit tre stocke dans un endroit sr !

Puisqu'une passphrase cre un nouveau portefeuille en utilisant votre seed existante, le portefeuille avec passphrase ncessite  la fois <strong> votre sauvegarde ET votre passphrase pour tre restaur</strong>. L'avantage de ceci est que si quelqu'un trouve votre sauvegarde, il a toujours besoin de la passphrase pour accder au poretefeuille avec passphrase.

En outre, la fonction passphrase vous permet de crer plusieurs portefeuilles sur le mme appareil, ou "portefeuilles cachs", en plus du portefeuille par dfaut.`,
    title: "Pourquoi utiliser une passphrase"
  }
}, password$e = {
  show: "Montrer {{label}}",
  warning: {
    caps: "ATTENTION : le verrouillage des majuscules () est activ",
    paste: 'Pour coller du texte, activez "Montrer {{label}}"'
  }
}, random$f = {
  button: "Gnrer un numro alatoire",
  description: "Votre BitBox a gnr le numro alatoire  {{bits}}-bit suivant :"
}, receive$g = {
  changeScriptType: "Changer de type d'adresse",
  label: "Votre adresse",
  onlyThisCoin: {
    description: "Pour recevoir d'autres coins, activez-les dans les paramtres. Si vous dposez d'autres coins, il se peut qu'ils ne soient pas accessibles.",
    warning: "Assurez-vous de ne recevoir que {{coinName}} sur cette adresse."
  },
  scriptType: {
    p2tr: "Taproot (nouveau format d'adresse)",
    p2wpkh: "Native Segwit (par dfaut)",
    "p2wpkh-p2sh": "Wrapped Segwit (format compatible)"
  },
  selectAccount: "Slectionner un compte",
  showFull: "Afficher et vrifier l'adresse complte sur l'appareil",
  taprootWarning: `Remarque : Taproot est une nouvelle fonctionnalit sur Bitcoin et n'est pas encore largement adopte. Les fonds reus sur les adresses Taproot peuvent potentiellement ne pas tre visibles depuis les portefeuilles "watch-only" tiers. De nombreux portefeuilles et exchanges ne sont pas encore en mesure d'envoyer des fonds aux adresses Taproot.`,
  title: "Recevoir {{accountName}}",
  verify: "Vrifier l'adresse de faon scurise",
  verifyBitBox01: "Vrifier l'adresse sur l'application mobile",
  verifyBitBox02: "Vrifier l'adresse sur le BitBox02",
  verifyInstruction: "Veuillez vrifier que l'adresse suivante correspond  celle affiche sur votre appareil.",
  warning: {
    secureOutput: "Veuillez appairer votre BitBox avec votre tlphone mobile pour activer la vrification scurise des adresses. Cliquez sur Grer l'appareil dans la barre latrale."
  }
}, reset$e = {
  description: "Toutes les donnes vont tre supprimes de l'appareil. Ceci inclut votre Cl Prive !",
  notReset: "Appareil NON rinitialis.",
  title: "Rinitialiser l'appareil aux paramtres usine",
  understand: "J'ai une sauvegarde et je connais mon mot de passe de rcupration",
  understandBB02: "J'ai une sauvegarde valide"
}, securityInformation$e = {
  create: {
    description1: "Il est recommand de configurer votre appareil dans un environnement scuris; c'est--dire loin d'autres personnes qui seraient susceptibles de voir le mot de passe que vous choisissez.",
    description2: "Il vous sera demand de crer deux mots de passe.",
    description3: "Le premier est le <strong>mot de passe de l'appareil</strong> qui dverrouille votre BitBox et peut tre modifi ultrieurement.",
    description4: "Le second est le <strong>mot de passe de rcupration</strong> qui dverrouille votre portefeuille. Ce mot de passe ne peut PAS tre chang ultrieurement.",
    description5: "Le portefeuille que vous crez sera sauvegard dans un fichier sur la carte microSD fournie. Elle peut tre utilis en cas d'urgence pour rcuprer vos fonds avec l'aide de votre <strong>mot de passe de rcupration</strong>.",
    title: "Information de scurit"
  },
  restore: {
    description1: "Il vous sera demand d'insrer la carte microSD utilise pour votre sauvegarde.",
    description2: "Pour restaurer votre appareil, vous aurez besoin de votre mot de passe de rcupration.",
    description3: "Veuillez faire attention lorsque vous entrez le mot de passe de rcupration. Tout mot de passe que vous entrez crera un portefeuille valide. Si vous entrez un mot de passe diffrent, le solde du portefeuille ne sera pas celui attendu.",
    title: "Information de scurit"
  }
}, seed$e = {
  agreements: {
    "funds-access": "Je ne pourrai PAS accder  mes fonds si j'oublie mon mot de passe de rcupration",
    "password-change": "Je ne peux PAS changer le mot de passe de rcupration ultrieurement",
    "password-required": "Le mot de passe de rcupration est ncessaire pour restaurer un portefeuille  partir d'une sauvegarde."
  },
  create: "Crer un portefeuille",
  creating: "Crer un portefeuille",
  description: "Je comprends que :",
  error: {
    e102: "Le mot de passe doit contenir au minimum 4 caractres.",
    e200: "Vous devez insrer une carte microSD dans votre BitBox afin de crer un portefeuille, une sauvegarde se cre ainsi automatiquement."
  },
  info: {
    button: "Dfinir le mot de passe maintenant",
    description1: "Insrez la carte microSD dans le BitBox",
    description2: 'Choisissez un mot de passe de rcupration pour le portefeuille et slectionnez "Dfinir le mot de passe de rcupration maintenant".',
    description3: "La sauvegarde sur une carte microSD et votre mot de passe de rcupration constituent le seul moyen de rcuprer vos fonds en cas de perte ou de vol de votre BitBox.",
    description4: "Vous ne pouvez pas modifier votre mot de passe de rcupration sans avoir transfr vos fonds au pralable.",
    title: "Crer un nouveau portefeuille"
  },
  password: {
    label: "Mot de passe de rcupration",
    repeatPlaceholder: "Rpter le mot de passe de rcupration"
  },
  walletName: {
    label: "Nom du portefeuille"
  }
}, seedRestore$e = {
  error: {
    e200: "La restauration d'un portefeuille  partir d'une sauvegarde ncessite la carte microSD."
  },
  info: {
    description1: "Insrez la carte microSD dans le BitBox et cliquez sur Continuer",
    description2: 'Choisissez une sauvegarde et cliquez sur "Restaurer"',
    description3: "Entrez le mot de passe de rcupration",
    description4: "Vous devez confirmer avoir compris qu'un mot de passe incorrect crera un portefeuille diffrent.",
    title: "Comment restaurer un portefeuille  partir d'une sauvegarde"
  }
}, send$g = {
  abort: "La transaction a t annule.",
  address: {
    label: "Adresse du destinataire",
    placeholder: "Entrer l'adresse"
  },
  amount: {
    label: "Montant",
    placeholder: "Entrer le montant"
  },
  availableBalance: "Solde disponible",
  button: "Revoir",
  coincontrol: {
    address: "Adresse",
    outpoint: "Point de sortie",
    title: "Envoi  partir de"
  },
  confirm: {
    "selected-coins": "Coins slectionns",
    title: "Confirmer et envoyer la transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Il semblerait que vous n'ayez pas assez d'Ether pour rgler cette transaction ERC20. Veuillez vous assurer que vous avez suffisamment d'Ether dans votre portefeuille.",
    feeTooLow: "Frais pas assez levs",
    feesNotAvailable: "Estimation des frais impossible",
    insufficientFunds: "fonds insuffisants",
    invalidAddress: "adresse invalide",
    invalidAmount: "montant invalide",
    invalidData: "donnes invalides"
  },
  fee: {
    customPlaceholder: "Entrer le montant",
    label: "Frais de rseau",
    placeholder: "Indisponible"
  },
  feeTarget: {
    customLabel: "Taux des frais",
    customLabel_eth: "Prix du Gas",
    description: {
      economy: "4 heures (24 blocs)",
      economy_eth: "30 minutes maximum",
      economy_ltc: "1 heure (24 blocs)",
      high: "20 minutes (2 blocs)",
      high_eth: "30 secondes maximum",
      high_ltc: "5 minutes (2 blocs)",
      low: "2 heures (12 blocs)",
      low_eth: "5 minutes maximum",
      low_ltc: "30 minutes (12 blocs)",
      normal: "1 heure (6 blocs)",
      normal_eth: "2 minutes maximum",
      normal_ltc: "15 minutes (6 blocs)"
    },
    estimate: "Temps d'attente estim avant confirmation:",
    label: {
      custom: "Personnalis",
      economy: "conomique",
      high: "lev",
      low: "Faible",
      normal: "Normal"
    },
    placeholder: "Calcul des frais"
  },
  maximum: "Envoyer tout",
  maximumSelectedCoins: "",
  noFeeTargets: "L'estimation des frais n'est pas disponible actuellement. Veuillez ressayer plus tard ou saisir des frais personnaliss.",
  priority: "Priorit",
  scanQR: "Scanner un QR Code",
  signprogress: {
    description: "Cette transaction contient beaucoup de donnes. Pour la signer entirement, il vous sera demand de confirmer {{steps}} fois.",
    label: "Avancement"
  },
  success: "La transaction a t signe et envoye.",
  title: "Envoyer {{accountName}}",
  toggleCoinControl: "Slecteur de coins",
  transactionDetails: "Dtails de la transaction"
}, settings$f = {
  about: " propos",
  accounts: "Comptes",
  advancedSettings: "Paramtres avancs",
  appearance: "Apparence",
  electrum: {
    add: "Ajouter un serveur",
    "add-server": "Ajouter",
    check: "Vrifier",
    checkFailed: "chou",
    checkSuccess: "Connexion  {{hte}} russie",
    checking: "Vrification",
    "download-cert": "Tlcharger le certificat distant",
    "remove-server": "Retirer",
    removeConfirm: "Supprimer {{serveur}} ?",
    reset: "Rinitialisation aux valeurs par dfaut",
    resetConfirm: 'Voulez-vous retirer tous les serveurs et installer ceux "par dfaut" ?',
    servers: "Serveurs",
    step1: "1",
    "step1-text": "Entrez le endpoint.",
    step2: "2",
    "step2-text": "Entrez un certificat de la chane de certificats du serveur. Vous pouvez galement tlcharger le certificat isol et le comparer visuellement.",
    "step2-text-tcp": "Vous pouvez sauter cette tape si vous ne souhaitez pas utiliser TLS.",
    step3: "3",
    "step3-text": "Vrifiez la connexion et ajoutez le serveur.",
    step4: "4",
    "step4-text": "Redmarrez l'appareil. Si vous ne supprimez pas les serveurs par dfaut votre nud sera ajout comme une redondance.",
    "title-btc": "Serveurs Bitcoin Electrum",
    "title-ltc": "Serveurs Litecoin Electrum",
    "title-tbtc": "Serveurs Bitcoin Testnet Electrum",
    "title-tltc": "Serveurs Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activer le contrle des monnaies",
    electrum: {
      description: "Vous pouvez vous connecter  votre propre nud Electrum.",
      title: "Connectez votre nud complet"
    },
    fee: "Activer la personnalisation des frais",
    setProxyAddress: "Dfinir une adresse proxy",
    title: "Paramtres avancs",
    useProxy: "Activer tor proxy",
    useSats: "Afficher les valeurs des BTC en Satoshis"
  },
  header: {
    home: "Accueil"
  },
  info: {
    "out-of-date": "Nouvelle mise  jour disponible",
    title: "Info",
    "up-to-date": "Votre application est  jour",
    version: "Version de l'application"
  },
  restart: "Veuillez redmarrer la BitBoxApp pour que les changements prennent effet.",
  services: {
    title: "Services"
  },
  success: "Veuillez dbrancher et reconnecter le BitBox pour que les modifications prennent effet.",
  title: "Paramtres"
}, setup$e = "Configuration de l'appareil", sidebar$f = {
  buy: "Acheter de la crypto",
  device: "Grer l'appareil",
  leave: "Quitter",
  settings: "Paramtres"
}, success$l = {
  create: {
    info1: "Votre portefeuille a t correctement sauvegard sur la carte microSD. Retirez-la et gardez-la en scurit.",
    info2: "Vous avez cr un mot de passe scuris pour l'appareil qui permet de dverrouiller votre BitBox.",
    info3: "Vous avez cr un mot de passe de rcupration scuris pour votre portefeuille, qui dverrouille vos fonds et permet la restauration de vos sauvegardes.",
    summary: "Voici un rsum de ce que vous avez fait",
    title: "Succs"
  },
  getstarted: "Commencer",
  restore: {
    summary: "Vous avez restaur avec succs un portefeuille  partir de votre sauvegarde.",
    title: "Succs"
  }
}, transaction$f = {
  confirmation: "Confirmations",
  details: {
    activity: "Activit",
    address: "Adresse",
    amount: "Montant",
    date: "Date",
    fiat: "Devise",
    fiatAmount: "Montant en Fiat",
    fiatAtTime: "Fiat au moment de la transaction",
    status: "Statut",
    type: "Type"
  },
  explorer: "Identification de transaction",
  explorerTitle: "Ouvrir dans un Explorateur de blocs externe",
  fee: "Frais",
  fiatHistorical: "Historique",
  gas: "Gaz",
  note: {
    edit: "Modifier la note",
    save: "Sauvegarder la note"
  },
  pending: "Transaction en attente",
  size: "Taille",
  status: {
    complete: "Termin",
    failed: "chou",
    pending: "En attente"
  },
  tx: {
    received: "Reu de",
    sent: "Envoy "
  },
  vsize: "Taille virtuelle",
  weight: "Poids"
}, transactions$e = {
  errorLoadTransactions: "Une erreur s'est produite lors du chargement des transactions",
  placeholder: "Aucune transaction pour le moment."
}, unknownError$e = "Une erreur inconnue s'est produite : {{errorMessage}}", unlock$e = {
  description: "Entrez le mot de passe de votre appareil pour le dverrouiller.",
  error: {
    e109_normal: "Mauvais mot de passe. {{remainingAttempts}} essais restant avant que l'appareil se rinitialise.",
    e109_touch: "$t(unlock.error.e109_normal) La prochaine connexion ncessite de maintenir le bouton tactile enfonc.",
    e113: "En raison de nombreuses tentatives de connexion, la connexion suivante ncessite de maintenir le bouton tactile enfonc pendant 4 secondes."
  },
  input: {
    label: "Mot de passe de l'appareil",
    placeholder: "Entrez le mot de passe de votre appareil pour le dverrouiller"
  },
  unlocking: "Dverrouillage"
}, upgradeFirmware$f = {
  button: "Mettre  jour le firmware",
  description: "Voulez-vous mettre  jour le firmware de la version {{currentVersion}}  la {{newVersion}} ?",
  label: "Une mise  jour du firmware de votre BitBox est ncessaire.",
  locked: "Pour effectuer la mise  jour de la {{currentVersion}}  la {{newVersion}}, veuillez presser longuement le bouton tactile.",
  title: "Mettre  jour le firmware",
  unlocked: "Le chargeur d'amorage est dverrouill. Pour continuer, veuillez :",
  unlocked1: "Dbrancher et rebrancher votre BitBox",
  unlocked2: "La LED s'allumera lorsque votre BitBox sera rebranch",
  unlocked3: "Appuyez sur le bouton tactile lorsque la LED s'allume"
}, walletConnect$8 = {
  connect: {
    button: "Connecter",
    dappLabel: "Saisir l'adresse URI de la Dapp",
    invalidPairingUri: "Uri d'appariement non valide"
  },
  dashboard: {
    allSessions: "Toutes les sessions",
    disclaimer: "Walletconnect est un protocole permettant de se connecter  des Dapps bases sur Ethereum. Ces Dapps sont gres par des services tiers, ne vous connectez donc uniquement qu' des Dapps en lesquelles vous avez entirement confiance et assurez-vous de toujours savoir ce que vous signez lorsque vous effectuez une transaction.",
    newConnection: "Nouvelle connexion",
    noConnectedSessions: "Aucun compte n'est actuellement connect  une Dapp."
  },
  invalidPairingChain: "Erreur dans l'approbation de l'appariement. Veillez  utiliser l'une des chanes prises en charge : {{chains}}",
  pairingRequest: {
    approve: "Approuver la connexion",
    reject: "Rejeter",
    title: "Nouvelle demande de connexion de"
  },
  pairingSuccess: "Dapp connecte avec succs. Vous pouvez continuer sur le site de la Dapp.",
  signingRequest: {
    account: "Compte",
    chain: "Chane",
    dapp: "Dapp",
    data: "Donnes",
    dataParsingError: "chec de l'analyse des donnes",
    decodeError: "chec de dchiffrage du message",
    method: {
      sendTransaction: "Signer et envoyer la transaction",
      signMessage: "Signer un message",
      signTransaction: "Signer une transaction",
      signTypedData: "Signer les donnes saisies"
    },
    successfullySigned: "Requte signe avec succs",
    walletConnectRequest: "Demande WalletConnect"
  },
  useNewUri: "Cet URI a dj t utilis pour une tentative de connexion. Veuillez utiliser un nouvel URI.",
  walletConnect: "WalletConnect"
}, warning$k = {
  receivePairing: "Veuillez appairer le BitBox pour activer la vrification d'adresse scurise. Cliquez sur Grer l'appareil dans la barre latrale.",
  sdcard: "Conservez la carte micro SD sparment du BitBox,  moins que vous ne  souhaitiez grer les sauvegardes.",
  sendPairing: "Veuillez appairer le BitBox pour vrifier le dtails de la transaction en toute scurit. Cliquez sur Grer l'appareil dans la barre latrale."
}, welcome$e = {
  connect: "Connexion BitBox02",
  getStarted: "Commenons en installant le firmware sur votre BitBox02",
  insertBitBox02: "Pour le BitBox02, appuyez sur l'appareil pour continuer.",
  insertDevice: "Pour commencer, veuillez connecter votre appareil",
  title: "Bienvenue"
}, appTranslationsFR = {
  account: account$e,
  accountInfo: accountInfo$e,
  accountSummary: accountSummary$e,
  addAccount: addAccount$f,
  aopp: aopp$8,
  app: app$e,
  auth: auth$7,
  backup: backup$e,
  bb02Bootloader: bb02Bootloader$e,
  bitbox: bitbox$e,
  bitbox02Interact: bitbox02Interact$e,
  bitbox02Settings: bitbox02Settings$e,
  bitbox02Wizard: bitbox02Wizard$e,
  blink: blink$e,
  bootloader: bootloader$e,
  button: button$i,
  buy: buy$a,
  changePin: changePin$e,
  chart: chart$a,
  checkSDcard: checkSDcard$e,
  clickHere: clickHere$e,
  confirm: confirm$g,
  confirmOnDevice: confirmOnDevice$e,
  connectKeystore: connectKeystore$7,
  darkmode: darkmode$8,
  device: device$e,
  deviceLock: deviceLock$e,
  deviceSettings: deviceSettings$e,
  deviceTampered: deviceTampered$e,
  dialog: dialog$f,
  error: error$a,
  fiat: fiat$g,
  footer: footer$g,
  generic: generic$a,
  genericError: genericError$e,
  goal: goal$e,
  guide: guide$f,
  headerssync: headerssync$e,
  hiddenWallet: hiddenWallet$e,
  initialize: initialize$e,
  invalidFormat: invalidFormat$e,
  language: language$f,
  legacyhiddenwallet: legacyhiddenwallet$e,
  loading: loading$e,
  manageAccounts: manageAccounts$8,
  mobile: mobile$9,
  newSettings: newSettings$7,
  note: note$a,
  notification: notification$e,
  pairing: pairing$e,
  passphrase: passphrase$8,
  password: password$e,
  random: random$f,
  receive: receive$g,
  reset: reset$e,
  securityInformation: securityInformation$e,
  seed: seed$e,
  seedRestore: seedRestore$e,
  send: send$g,
  settings: settings$f,
  setup: setup$e,
  sidebar: sidebar$f,
  success: success$l,
  transaction: transaction$f,
  transactions: transactions$e,
  unknownError: unknownError$e,
  unlock: unlock$e,
  upgradeFirmware: upgradeFirmware$f,
  walletConnect: walletConnect$8,
  warning: warning$k,
  welcome: welcome$e
}, account$d = {
  disconnect: "",
  export: "",
  exportTransactions: "CSV",
  fatalError: "",
  incoming: "",
  initializing: "",
  maybeProxyError: "TorTor",
  reconnecting: "",
  syncedAddressesCount: "{{count}}"
}, accountInfo$d = {
  address: "",
  buyCTA: {
    buy: "{{unit}}",
    buyCrypto: "",
    information: {
      looksEmpty: "",
      start: "BitBoxApp"
    }
  },
  extendedPublicKey: "",
  label: "",
  scriptType: "",
  title: "",
  verify: "",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH",
    p2tr: "Taproot",
    p2wpkh: "Segwit",
    "p2wpkh-p2sh": "Segwit"
  },
  xpubTypeInfo: "{{scriptType}}{{numberOfXPubs}}{{current}}"
}, accountSummary$d = {
  availableBalance: "",
  balance: "",
  exportSummary: "CSV",
  fiatBalance: "",
  name: "",
  noAccount: "",
  subtotalWithCoinName: "{{coinName}}",
  title: "",
  total: "",
  transactionHistory: ""
}, addAccount$e = {
  chooseName: {
    nextButton: "",
    step: "",
    title: ""
  },
  selectCoin: {
    nextButton: "",
    step: "",
    title: ""
  },
  success: {
    addAnotherAccount: "",
    message: "<strong>{{accountName}}</strong>",
    nextButton: "",
    step: "",
    title: ""
  },
  title: ""
}, aopp$7 = {
  addressRequest: "{{host}}",
  addressRequestWithLogo: "",
  banner: "",
  errorTitle: "",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: "",
  signing: "BitBox02",
  success: {
    message: "{{host}}",
    title: ""
  },
  syncing: "",
  title: ""
}, app$d = {
  upgrade: "{{current}}{{version}}"
}, auth$6 = {
  authButton: "",
  title: ""
}, backup$d = {
  check: {
    checking: "",
    confirmTitle: "",
    notOK: "",
    ok: "",
    password: {
      label: "",
      placeholder: "",
      showLabel: ""
    },
    success: "",
    title: ""
  },
  create: {
    alreadyExists: "",
    fail: "",
    info: "",
    name: {
      label: "",
      placeholder: ""
    },
    password: {
      label: "",
      placeholder: ""
    },
    title: "",
    verificationFailed: ""
  },
  description: "<strong></strong>",
  insert: "SD",
  insertButton: "SD",
  list: "microSD",
  noBackups: "microSD",
  restore: {
    confirmTitle: "",
    error: {
      e200: "microSD",
      general: ""
    },
    password: {
      label: "",
      placeholder: "",
      repeatPlaceholder: "",
      showLabel: ""
    },
    restoring: "",
    selectedBackup: "<strong>{{backupName}}</strong>{{createdDateTime}}",
    title: "",
    understand: ""
  },
  showMnemonic: {
    description: `

<strong></strong>

<strong></strong>

<strong></strong>

`,
    title: "",
    warning: "<strong></strong>"
  },
  title: ""
}, bb02Bootloader$d = {
  abort: "  ",
  abort_noUpgrade: "",
  advanced: {
    label: "",
    toggleShowFirmwareHash: ""
  },
  flipscreen: "",
  orientation: "",
  success: "{{rebootSeconds}}",
  success_install: "{{rebootSeconds}} "
}, bitbox$d = {
  error: {
    e10000: "",
    e10001: "",
    e102: "4",
    e112: ""
  }
}, bitbox02Interact$d = {
  confirmDate: "BitBox02",
  confirmDateText: "",
  confirmName: "BitBox02",
  confirmWords: "BitBox02{{amount}}",
  confirmWordsText: "BitBox02",
  followInstructions: "BitBox02",
  followInstructionsMnemonic: "BitBox02",
  followInstructionsMnemonicTitle: ""
}, bitbox02Settings$d = {
  deviceName: {
    current: "",
    error: "",
    error_104: "",
    input: "BitBox02",
    placeholder: "",
    title: "BitBox02"
  },
  gotoStartupSettings: {
    description: "BitBox02",
    title: ""
  }
}, bitbox02Wizard$d = {
  advanced: {
    button: "",
    outOfDate: "",
    seed12WordInfo: "",
    seed12WordLabel: "2412",
    seed12WordText: "BitBox022412",
    skipSDCardLabel: "SD",
    skipSDCardText: "microSD",
    title: ""
  },
  attestationFailed: "support@bitbox.swiss",
  backup: {
    point1: "microSD",
    point2: "",
    restoreText: "",
    text1: "BitBox02microSD",
    text2: "",
    text3: "microSD<strong></strong>microSDBitBox02",
    userConfirmation1: "",
    userConfirmation2: "",
    userConfirmation3: "BitBox02",
    userConfirmation4: "BitBox02",
    userConfirmation5: "SDBitBox02",
    userConfirmation5mnemonic: "BitBox02"
  },
  create: {
    button: "",
    info: "BitBox",
    inputTitle: "",
    point1: "",
    point2: "",
    point3: "",
    text: ""
  },
  createBackupAborted: "",
  createBackupFailed: "",
  initialize: {
    passwordText: "BitBox",
    passwordTitle: "BitBox",
    text: "BitBox02<strong>microSD</strong>",
    tip: "",
    title: "BitBox"
  },
  insertSDCard: "<strong>BitBox02microSD</strong?",
  noPasswordMatch: "",
  pairing: {
    failed: "BitBox02",
    paired: "",
    title: "",
    unpaired: "BitBox02BitBox02"
  },
  restoreFromMnemonic: {
    e104: "",
    failed: ""
  },
  stepBackup: {
    beforeProceed: "",
    createBackup: "microSD",
    createBackupMnemonic: ""
  },
  stepBackupSuccess: {
    fundsSafe: "",
    title: ""
  },
  stepConnected: {
    unlock: "BitBox02"
  },
  stepCreate: {
    description: "",
    nameLabel: "BitBox02",
    namePlaceholder: "BitBox02",
    title: "BitBox02",
    toastMicroSD: "BitBox02microSD"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02microSD",
    storeMnemonic: "",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "BitBox02microSD",
    insertSDcardTitle: "microSD"
  },
  stepPassword: {
    e104: "",
    title: "BitBox02",
    useControls: "BitBox02"
  },
  stepUninitialized: {
    create: "BitBox02",
    restore: "",
    restoreMicroSD: "microSD",
    restoreMnemonic: "",
    title: "BitBox02"
  },
  success: {
    text: `BitBox02

BitBox App`,
    title: ""
  }
}, blink$d = {
  button: ""
}, bootloader$d = {
  button: "",
  button_install: "",
  progress: "{{progress}}\r%",
  progress_install: `{{progress}}
%`,
  success: ""
}, button$h = {
  abort: "",
  back: "",
  buy: "",
  changepin: "",
  check: "",
  continue: "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "",
  next: "",
  ok: "OK",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
}, buy$9 = {
  exchange: {
    bankTransfer: "",
    bestDeal: "",
    creditCard: "",
    fast: "",
    fee: "",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: ": {{fee}}%",
          creditDebitCard: "/: {{fee}}%",
          learnMore: "Moonpay",
          title: ""
        },
        fullCurrenciesList: "",
        payment: {
          asteriskText: "",
          bankTransfer: "",
          bankTransferDetails: {
            pix: "PIX",
            sepa: "SEPASEPASEPA",
            uk: "UKGBP"
          },
          creditDebitCard: "/",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "",
          title: ""
        },
        supportedCurrencies: "USDEURCHF"
      },
      pocket: {
        fees: {
          info: ": {{fee}}%",
          title: ""
        },
        learnMore: "Pocket",
        payment: {
          bankTransfer: "",
          bankTransferDetails: {
            sepa: "SEPASEPASEPA",
            sic: "CH/LICHF",
            uk: "UKGBP"
          },
          bankTransferReccuring: "",
          title: ""
        },
        supportedCurrencies: "EUR, GBP, and CHF.",
        verification: {
          info: "",
          link: "",
          title: ""
        }
      },
      region: {
        title: ""
      }
    },
    noExchanges: "",
    region: "",
    selectRegion: "",
    title: "{{name}}"
  },
  info: {
    continue: "",
    crypto: "",
    disclaimer: {
      intro: [
        "MoonPayBitBoxApp{{name}}",
        "MoonPay160{{name}}"
      ],
      payment: {
        details: "MoonPay{{name}}4 USD/EUR",
        footnote: "MoonPayBitBoxApp",
        table: {
          "1_description": "3",
          "1_method": "(SEPA)",
          "2_description": "",
          "2_method": "",
          description: "",
          fee: "",
          method: ""
        },
        title: ""
      },
      privacyPolicy: "MoonPay",
      protection: {
        description: "BitBoxApp{{name}}MoonPay",
        descriptionGeneric: "BitBoxApp{{name}}",
        title: ""
      },
      security: {
        description: "MoonPay{{name}}BitBox02BitBoxApp",
        descriptionGeneric: "{{name}}BitBox02BitBoxApp",
        link: "",
        title: ""
      },
      title: "{{name}}"
    },
    next: "",
    selectLabel: "",
    selectPlaceholder: "",
    skip: "",
    title: " {{name}} "
  },
  pocket: {
    data: {
      link: "Pocket ",
      p1: "BitBoxAppPocket",
      title: ""
    },
    kyc: {
      link: "Pocket ",
      p1: "PocketKYC19501000KYC/AMLPocket",
      title: "KYC/AML"
    },
    payment: {
      p1: "SEPAPocket1.5%PocketBitBox",
      p2: "PocketBitBoxApp",
      title: ""
    },
    previousTransactions: "Pocket",
    security: {
      link: "BitBox02",
      p1: "PocketBitBox02BitBoxApp",
      title: ""
    },
    usedAddress: "{{address}}",
    verifyBitBox02: "Bitbox",
    welcome: {
      p1: "PocketBitBoxApp",
      p2: "PocketSEPA",
      p3: "PocketDCA",
      title: ""
    }
  },
  title: "{{name}}"
}, changePin$d = {
  newTitle: "",
  oldLabel: ""
}, chart$9 = {
  dataMissing: "...",
  dataOldTimestamp: "{{time}}",
  dataUpdating: "...",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
}, checkSDcard$d = "microSD", clickHere$d = "", confirm$f = {
  abortInfo: "",
  abortInfoRedText: "",
  approveInfo: "4",
  approveInfoGreenText: "",
  info: "BitBox",
  infoWhenPaired: "BitBox"
}, confirmOnDevice$d = "", connectKeystore$6 = {
  promptNoName: "BitBox02",
  promptWithName: '"{{name}}" BitBox02'
}, darkmode$7 = {
  toggle: ""
}, device$d = {
  appUpradeRequired: "BitBox"
}, deviceLock$d = {
  button: "2(2FA)",
  condition1: "",
  condition2: "",
  condition3: "2(2FA)2",
  confirm: "2(2FA)",
  title: "2(2FA)"
}, deviceSettings$d = {
  backups: {
    manageBackups: {
      description: "SD"
    },
    showRecoveryWords: {
      description: ""
    },
    title: ""
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp"
    },
    deviceName: {
      description: ""
    },
    rootFingerprint: {
      description: ""
    },
    securechip: {
      description: ""
    },
    title: ""
  },
  expert: {
    factoryReset: {
      description: "BitBox02",
      title: ""
    },
    goToStartupSettings: {
      description: "BitBox02"
    },
    passphrase: {
      description: "",
      title: ""
    }
  },
  firmware: {
    firmwareVersion: "",
    newVersion: {
      label: ""
    },
    title: "",
    upToDate: "",
    upgradeAvailable: "",
    version: {
      label: ""
    }
  },
  hardware: {
    attestation: {
      false: "",
      label: "",
      true: "BitBox02"
    },
    sdcard: {
      false: "",
      label: "microSD",
      true: ""
    },
    securechip: "",
    title: ""
  },
  loading: "",
  pairing: {
    lock: {
      false: "",
      label: "2(2FA)",
      true: ""
    },
    mobile: {
      false: "",
      label: "",
      true: ""
    },
    status: {
      false: "",
      label: "",
      true: ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "",
    title: ""
  }
}, deviceTampered$d = "BitBoxShift", dialog$e = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
}, error$9 = {
  accountAlreadyExists: "",
  accountLimitReached: "",
  aoppCallback: "{{host}}",
  aoppInvalidRequest: "",
  aoppNoAccounts: "",
  aoppSigningAborted: "",
  aoppUnknown: "",
  aoppUnsupportedAsset: "",
  aoppUnsupportedFormat: "",
  aoppUnsupportedKeystore: "",
  aoppVersion: "",
  wrongKeystore: "",
  wrongKeystore2: ""
}, fiat$f = {
  default: "",
  setDefault: "{{code}}",
  title: ""
}, footer$f = {
  appVersion: ""
}, generic$9 = {
  enabled_false: "",
  enabled_true: ""
}, genericError$d = "", goal$d = {
  buttons: {
    create: "",
    restore: ""
  },
  paragraph: "",
  step: {
    1: {
      title: ""
    },
    2: {
      description: "",
      title: ""
    },
    "3-create": {
      description: "",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$e = {
  accountDescription: {
    text: "",
    title: ""
  },
  accountFiat: {
    text: "",
    title: ""
  },
  accountIncomingBalance: {
    text: "",
    title: ""
  },
  accountInfo: {
    multipleXPubs: {
      text: `xpub"Type""Native Segwit (bech32)""Wrapped Segwit"Taproot{{coinName}}BitBoxAppxpubxpub

Native Segwit"bech32" xpub"Wrapped Segwit"Taproot"Wrapped Segwit"Taproot`,
      title: "xpub"
    },
    privacy: {
      text: `xpubxpub

xpub`,
      title: "xpub"
    },
    verify: {
      text: "xpubxpubxpub",
      title: "xpub"
    },
    xpub: {
      text: `xpub

ElectrumSentinelxpub

Taproot xpub`,
      title: ""
    }
  },
  accountRates: {
    text: "CoinGecko",
    title: ""
  },
  accountReload: {
    text: "",
    title: ""
  },
  accountSendDisabled: {
    text: "0",
    title: "{{unit}}"
  },
  accountSummaryAmount: {
    text: `coingecko.com

: BitBoxAppMyEtherWallet



`,
    title: ""
  },
  accountSummaryDescription: {
    text: "",
    title: ""
  },
  accountTransactionAttributesBTC: {
    text: `Virtual size
Size
WeightSegwitSegregated Witness141400`,
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: `
36
IDblock explorer
`,
    title: ""
  },
  accountTransactionConfirmation: {
    text: "",
    title: ""
  },
  accountTransactionLabel: {
    text: `
`,
    title: ""
  },
  accountTransactionTime: {
    text: `
`,
    title: ""
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin Litecoin5
5`,
      title: ""
    },
    howtoAddTokens: {
      text: "ERC20",
      title: ""
    },
    moveFunds: {
      text: "",
      title: ""
    },
    recoverAccounts: {
      text: "BitBoxApp",
      title: ""
    },
    whatAreAccounts: {
      text: "",
      title: ""
    },
    whyIsThisUseful: {
      text: "",
      title: ""
    }
  },
  appendix: {
    link: "",
    text: ""
  },
  backups: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "",
      title: ""
    },
    howOften: {
      text: `microSDmicroSD
`,
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  backupsBB02: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "microSD",
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  bitbox: {
    "2FA": {
      text: `2(2FA)BitBox
2(2FA)2(2FA)microSDBitBox`,
      title: "2(2FA)"
    },
    disable2FA: {
      text: "2(2FA)BitBoxmicroSD",
      title: "2(2FA)"
    },
    ejectBitbox: {
      text: "BitBox",
      title: "BitBox"
    },
    ejectSD: {
      text: "microSDBitBox",
      title: "microSD"
    },
    hiddenWallet: {
      text: "(plausible deniability)",
      title: ""
    },
    legacyHiddenWallet: {
      text: "BitBox2BitBox",
      title: " legacy"
    },
    pairing: {
      text: "iOSAndroidQR",
      title: ""
    }
  },
  cointracking: {
    text: '""CSVBitBoxCSVCoinTracking',
    title: "CoinTracking"
  },
  device: {
    attestation: {
      link: {
        text: ""
      },
      text: "BitBoxAppBitBox02",
      title: ""
    },
    name: {
      text: "",
      title: "BitBox02"
    },
    "secure-chip": {
      link: {
        text: ""
      },
      text: "ATECC608B",
      title: ""
    }
  },
  receive: {
    address: {
      text: "",
      title: ""
    },
    addressChange: {
      text: "20",
      title: ""
    },
    addressFormats: {
      text: "Native Segwit/TaprootNative Segwit/Wrapped Segwit",
      title: '""'
    },
    howVerify: {
      text: `BitBox01BitBox
BitBox02`,
      title: ""
    },
    plugout: {
      text: "BitBoxBitBoxBitBox",
      title: "BitBox"
    },
    why20: {
      text: "202020",
      title: "20"
    },
    whyMany: {
      text: "2201",
      title: ""
    },
    whyVerify: {
      text: "BitBox01QRBitBox02BitBox02",
      title: ""
    }
  },
  send: {
    change: {
      text: "Taproot UTXO1TaprootUTXO1Taproot UTXOTaprootNative Segwit",
      title: ""
    },
    fee: {
      text: `Bitcoin Core
24(Bitcoin4Litecoin1)
12(Bitcoin2Litecoin30)
6(Bitcoin1Litecoin15)
2(Bitcoin20Litecoin5)
(1Bitcoin10Litecoin2.5)`,
      title: ""
    },
    plugout: {
      text: "BitBoxBitBox",
      title: "BitBox"
    },
    priority: {
      text: "",
      title: ""
    },
    revert: {
      text: `()()
()`,
      title: ""
    },
    whyFee: {
      text: "11()",
      title: ""
    }
  },
  "settings-electrum": {
    connection: {
      text: `wifi
ElectrumTLS
TorTLS`,
      title: "clearnet TCPTLSTor"
    },
    instructions: {
      link: {
        text: ""
      },
      text: "",
      title: "BitBoxApp"
    },
    options: {
      text: `Bitcoin Core
BitBoxAppElectrum
ElectrsElectrum Personal Server (EPS)Bitcoin Wallet Tracker (BTW)`,
      title: ""
    },
    tor: {
      text: `TorThe Onion Router
TorTorBitBoxAppTor Proxy
OSTor2
1. Tor Browser: Tor Browser Tor9150BitBoxAppTor
2. Tor background serviceTorBitBoxAppTor9050`,
      title: `TorTor
`
    },
    what: {
      text: "Shift",
      title: ""
    },
    why: {
      text: `
BitBoxApp
`,
      title: ""
    }
  },
  settings: {
    sats: {
      text: "Satoshisat1 Satoshibitcoin110.00000001BTCbitcoin",
      title: "Satoshi"
    },
    servers: {
      text: "Shift CryptoCoinGecko()",
      title: ""
    }
  },
  title: "",
  toggle: {
    close: "",
    open: ""
  },
  trackingModePortfolioChart: {
    text: "",
    title: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "",
      title: ""
    },
    reset: {
      text: "15",
      title: ""
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `

BitBox01BitBox01BitBoxApp`,
      title: "BitBox01"
    },
    getDevice: {
      link: {
        text: "BitBox"
      },
      text: "BitBox",
      title: ""
    },
    internet: {
      text: "",
      title: ""
    },
    lostDevice: {
      link: {
        text: ""
      },
      text: "BitBox",
      title: ""
    },
    useWithoutDevice: {
      text: "",
      title: ""
    },
    welcome: {
      text: "Shift Crypto",
      title: "BitBoxApp"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "BitBoxAppdappsdapp",
      title: ""
    },
    supportedNetworks: {
      text: "BitBoxAppWalletConnectEthereumEVMRabby",
      title: ""
    },
    whatIsWalletConnect: {
      text: "WalletConnectweb3EthereumDAppsBitBoxAppAndroid",
      title: "WalletConnect"
    }
  }
}, headerssync$d = {
  blocksSynced: "{{blocks}}"
}, hiddenWallet$d = {
  info1HTML: "(plausible deniability)<strong></strong>",
  info2HTML: "2<strong></strong>",
  passwordLabel: "",
  passwordPlaceholder: "",
  pinLabel: "",
  pinRepeatLabel: "",
  pinRepeatPlaceholder: "",
  success: ""
}, initialize$d = {
  create: "",
  creating: "",
  error: {
    e102: "4()"
  },
  info: {
    description1: "BitBox",
    description2: "",
    description3: "",
    subtitle: "",
    title: ""
  },
  input: {
    label: "",
    labelRepeat: "",
    placeholderRepeat: ""
  }
}, invalidFormat$d = "", language$e = {
  title: ""
}, legacyhiddenwallet$d = {
  disable: " legacy",
  enable: " legacy",
  successDisable: " legacy",
  successEnable: " legacyBitBox"
}, loading$d = "", manageAccounts$7 = {
  accountHidden: "BitBox02",
  editAccount: "",
  editAccountNameTitle: "",
  noAccounts: "",
  settings: {
    hideTokens: "",
    showTokens: " ({{activeTokenCount}})"
  },
  settingsButtonDescription: "/",
  title: "",
  watchAccount: "",
  watchAccountDescription: ""
}, mobile$8 = {
  usingMobileDataWarning: "Wi-Fi"
}, newSettings$6 = {
  about: {
    appVersion: {
      title: ""
    }
  },
  advancedSettings: {
    authentication: {
      description: "",
      title: ""
    },
    coinControl: {
      description: "UTXO"
    },
    customFees: {
      description: ""
    },
    torProxy: {
      description: "Tor"
    }
  },
  appearance: {
    activeCurrencies: {
      description: "",
      title: ""
    },
    darkmode: {
      description: "BitBoxApp"
    },
    defaultCurrency: {
      description: "",
      title: ""
    },
    hideAmounts: {
      description: "",
      hideAmounts: "",
      showAmounts: "",
      title: ""
    },
    language: {
      description: "BitBoxApp",
      title: ""
    },
    toggleSats: {
      description: " Satoshi"
    }
  }
}, note$9 = {
  input: {
    description: "()",
    placeholder: "..."
  },
  title: ""
}, notification$d = {
  newTxs_one: "{{accountName}}{{count}}",
  newTxs_other: "{{accountName}}{{count}}"
}, pairing$d = {
  aborted: {
    text: "",
    title: ""
  },
  button: "",
  confirm: "BitBox",
  connectOnly: {
    button: "",
    title: "Connect to new desktop app"
  },
  error: {
    text: "",
    title: ""
  },
  pullFailed: {
    text: "",
    title: ""
  },
  reconnectOnly: {
    button: ""
  },
  scanningFailed: {
    text: "",
    title: ""
  },
  start: {
    hideAppQRCode: "QR",
    revealAppQRCode: "QR",
    step1: "Apple App StoreGoogle Play StoreQR",
    step2: "Digital Bitbox 2FAiOSAndroidQR"
  },
  started: {
    text: "",
    title: ""
  },
  success: {
    text: "BitBox",
    title: ""
  },
  timeout: {
    text: "2",
    title: ""
  },
  title: ""
}, passphrase$7 = {
  considerations: {
    button: "",
    message: `SD

BitBox02<strong> + </strong>

`,
    title: ""
  },
  disable: "",
  disableInfo: {
    button: "",
    message: `BitBox02

BitBox02

BitBox02

<strong>:</strong>`
  },
  enable: "",
  error: {
    e104: ""
  },
  how: {
    button: "",
    message: `<strong></strong>

BitBox02

`,
    title: ""
  },
  intro: {
    message: `


`,
    title: ""
  },
  progressDisable: {
    message: "<strong>disable</strong>BitBox",
    title: ""
  },
  progressEnable: {
    message: "<strong>enable</strong>BitBox",
    title: ""
  },
  successDisabled: {
    message: ` <strong>successfully enabled</strong>
`,
    messageEnd: "BitBox02",
    title: ""
  },
  successEnabled: {
    message: `<strong></strong>

`,
    messageEnd: "BitBox02",
    tips: "",
    tipsList: [
      "BitBox02",
      ""
    ],
    title: ""
  },
  summary: {
    button: "",
    title: "",
    understand: "",
    understandList: [
      "",
      "",
      "<strong></strong>",
      "<strong></strong>"
    ]
  },
  what: {
    button: "",
    message: `BitBox02SD

<strong></strong> +  + 

BIP39`,
    title: ""
  },
  why: {
    button: "",
    message: `BitBox02SD

<strong></strong>

`,
    title: ""
  }
}, password$d = {
  show: "{{label}}",
  warning: {
    caps: "caps lock()",
    paste: "{{label}}"
  }
}, random$e = {
  button: "",
  description: "BitBox{{bits}}bit"
}, receive$f = {
  changeScriptType: "",
  label: "",
  onlyThisCoin: {
    description: "",
    warning: "{{coinName}}"
  },
  scriptType: {
    p2tr: "Taproot ()",
    p2wpkh: "Native Segwit ()",
    "p2wpkh-p2sh": "Wrapped Segwit"
  },
  selectAccount: "",
  showFull: "",
  taprootWarning: "TaprootTaprootwatch-only Taproot",
  title: "{{accountName}}",
  verify: "",
  verifyBitBox01: "",
  verifyBitBox02: "BitBox02",
  verifyInstruction: "",
  warning: {
    secureOutput: `BitBox



`
  }
}, reset$d = {
  description: "",
  notReset: "",
  title: "",
  understand: "",
  understandBB02: ""
}, securityInformation$d = {
  create: {
    description1: "",
    description2: "2",
    description3: "1<strong></strong>BitBox",
    description4: "2<strong></strong>",
    description5: "SD<strong></strong>",
    title: ""
  },
  restore: {
    description1: "microSD",
    description2: "",
    description3: "",
    title: ""
  }
}, seed$d = {
  agreements: {
    "funds-access": "",
    "password-change": "",
    "password-required": ""
  },
  create: "",
  creating: "",
  description: "",
  error: {
    e102: "4()",
    e200: "BitBoxmicroSD"
  },
  info: {
    button: "",
    description1: "BitBoxmicroSD",
    description2: "",
    description3: "SDBitBox",
    description4: "",
    title: ""
  },
  password: {
    label: "",
    repeatPlaceholder: ""
  },
  walletName: {
    label: ""
  }
}, seedRestore$d = {
  error: {
    e200: "SD"
  },
  info: {
    description1: "BitBoxmicroSD",
    description2: "",
    description3: "",
    description4: "",
    title: ""
  }
}, send$f = {
  abort: "",
  address: {
    label: "",
    placeholder: ""
  },
  amount: {
    label: "",
    placeholder: ""
  },
  availableBalance: "",
  button: "",
  coincontrol: {
    address: "",
    outpoint: "",
    title: ""
  },
  confirm: {
    "selected-coins": "",
    title: "",
    total: ""
  },
  error: {
    erc20InsufficientGasFunds: "ERC20",
    feeTooLow: "",
    feesNotAvailable: "",
    insufficientFunds: "",
    invalidAddress: "",
    invalidAmount: "",
    invalidData: ""
  },
  fee: {
    customPlaceholder: "",
    label: "",
    placeholder: ""
  },
  feeTarget: {
    customLabel: "",
    customLabel_eth: "",
    description: {
      economy: "424",
      economy_eth: "30",
      economy_ltc: "124",
      high: "202",
      high_eth: "30",
      high_ltc: "52",
      low: "212",
      low_eth: "5",
      low_ltc: "3012",
      normal: "16",
      normal_eth: "2",
      normal_ltc: "156"
    },
    estimate: "",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "..."
  },
  maximum: "",
  maximumSelectedCoins: "",
  noFeeTargets: "",
  priority: "",
  scanQR: "QR",
  signprogress: {
    description: "{{steps}}",
    label: ""
  },
  success: "",
  title: "{{accountName}}",
  toggleCoinControl: "",
  transactionDetails: ""
}, settings$e = {
  about: "",
  accounts: "",
  advancedSettings: "",
  appearance: "",
  electrum: {
    add: "",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "{{host}}",
    checking: "",
    "download-cert": "",
    "remove-server": "",
    removeConfirm: "{{server}} ",
    reset: "",
    resetConfirm: "",
    servers: "",
    step1: "1",
    "step1-text": "",
    step2: "2",
    "step2-text": "",
    "step2-text-tcp": "TLS",
    step3: "3",
    "step3-text": "",
    step4: "4",
    "step4-text": "",
    "title-btc": "Bitcoin Electrum",
    "title-ltc": "Litecoin Electrum",
    "title-tbtc": "Bitcoin Testnet Electrum",
    "title-tltc": "Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "",
    electrum: {
      description: "Electrum",
      title: ""
    },
    fee: "",
    setProxyAddress: "",
    title: "",
    useProxy: "Tor",
    useSats: `
BTCSatoshi`
  },
  header: {
    home: ""
  },
  info: {
    "out-of-date": "",
    title: "",
    "up-to-date": "",
    version: ""
  },
  restart: "BitBoxApp",
  services: {
    title: ""
  },
  success: "BitBox",
  title: ""
}, setup$d = "", sidebar$e = {
  buy: "",
  device: "",
  leave: "",
  settings: ""
}, success$k = {
  create: {
    info1: "microSD",
    info2: "Bitbox",
    info3: "",
    summary: "",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "",
    title: ""
  }
}, transaction$e = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: "",
    fiatAtTime: "",
    status: "",
    type: ""
  },
  explorer: "ID",
  explorerTitle: "",
  fee: "",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "",
    save: ""
  },
  pending: "",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: ""
  },
  tx: {
    received: "",
    sent: `
`
  },
  vsize: "",
  weight: ""
}, transactions$d = {
  errorLoadTransactions: "",
  placeholder: ""
}, unknownError$d = "{{errorMessage}}", unlock$d = {
  description: "",
  error: {
    e109_normal: "{{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) ",
    e113: "4"
  },
  input: {
    label: "",
    placeholder: ""
  },
  unlocking: ""
}, upgradeFirmware$e = {
  button: "",
  description: "{{currentVersion}}{{newVersion}}",
  label: "BitBox",
  locked: "{{currentVersion}}{{newVersion}}",
  title: "",
  unlocked: "",
  unlocked1: "BitBox",
  unlocked2: "BitBoxLED",
  unlocked3: "LED"
}, walletConnect$7 = {
  connect: {
    button: "",
    dappLabel: "dappURI",
    invalidPairingUri: "URI"
  },
  dashboard: {
    allSessions: "",
    disclaimer: "WalletconnectEthereumDappsdappsdapps",
    newConnection: "",
    noConnectedSessions: "dapps"
  },
  invalidPairingChain: "{{chains}}",
  pairingRequest: {
    approve: "",
    reject: "",
    title: ""
  },
  pairingSuccess: "Dappdapp",
  signingRequest: {
    account: "",
    chain: "",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "",
    decodeError: "",
    method: {
      sendTransaction: "",
      signMessage: "",
      signTransaction: "",
      signTypedData: ""
    },
    successfullySigned: "",
    walletConnectRequest: "WalletConnect"
  },
  useNewUri: "URIURI",
  walletConnect: "WalletConnect"
}, warning$j = {
  receivePairing: "BitBox",
  sdcard: "BitBoxSD",
  sendPairing: "BitBox"
}, welcome$d = {
  connect: "BitBox02",
  getStarted: "BitBox02",
  insertBitBox02: "BitBox02",
  insertDevice: "",
  title: ""
}, appTranslationsJA = {
  account: account$d,
  accountInfo: accountInfo$d,
  accountSummary: accountSummary$d,
  addAccount: addAccount$e,
  aopp: aopp$7,
  app: app$d,
  auth: auth$6,
  backup: backup$d,
  bb02Bootloader: bb02Bootloader$d,
  bitbox: bitbox$d,
  bitbox02Interact: bitbox02Interact$d,
  bitbox02Settings: bitbox02Settings$d,
  bitbox02Wizard: bitbox02Wizard$d,
  blink: blink$d,
  bootloader: bootloader$d,
  button: button$h,
  buy: buy$9,
  changePin: changePin$d,
  chart: chart$9,
  checkSDcard: checkSDcard$d,
  clickHere: clickHere$d,
  confirm: confirm$f,
  confirmOnDevice: confirmOnDevice$d,
  connectKeystore: connectKeystore$6,
  darkmode: darkmode$7,
  device: device$d,
  deviceLock: deviceLock$d,
  deviceSettings: deviceSettings$d,
  deviceTampered: deviceTampered$d,
  dialog: dialog$e,
  error: error$9,
  fiat: fiat$f,
  footer: footer$f,
  generic: generic$9,
  genericError: genericError$d,
  goal: goal$d,
  guide: guide$e,
  headerssync: headerssync$d,
  hiddenWallet: hiddenWallet$d,
  initialize: initialize$d,
  invalidFormat: invalidFormat$d,
  language: language$e,
  legacyhiddenwallet: legacyhiddenwallet$d,
  loading: loading$d,
  manageAccounts: manageAccounts$7,
  mobile: mobile$8,
  newSettings: newSettings$6,
  note: note$9,
  notification: notification$d,
  pairing: pairing$d,
  passphrase: passphrase$7,
  password: password$d,
  random: random$e,
  receive: receive$f,
  reset: reset$d,
  securityInformation: securityInformation$d,
  seed: seed$d,
  seedRestore: seedRestore$d,
  send: send$f,
  settings: settings$e,
  setup: setup$d,
  sidebar: sidebar$e,
  success: success$k,
  transaction: transaction$e,
  transactions: transactions$d,
  unknownError: unknownError$d,
  unlock: unlock$d,
  upgradeFirmware: upgradeFirmware$e,
  walletConnect: walletConnect$7,
  warning: warning$j,
  welcome: welcome$d
}, account$c = {
  disconnect: " .   ... ",
  export: "",
  exportTransactions: "        CSV",
  fatalError: " .",
  incoming: "",
  initializing: "    ...",
  maybeProxyError: "- . ,   - ,    -  .",
  reconnecting: " ,    ...",
  syncedAddressesCount: " {{count}} "
}, accountInfo$c = {
  address: "",
  buyCTA: {
    buy: " {{unit}}",
    buyCrypto: " ",
    information: {
      looksEmpty: ",   ",
      start: "         BitBoxApp."
    }
  },
  extendedPublicKey: " Public Key",
  label: "   ",
  scriptType: " ",
  title: "   ",
  verify: "  ",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH   ",
    p2tr: "  Taproot",
    p2wpkh: "  Native Segwit",
    "p2wpkh-p2sh": " Segwit   "
  },
  xpubTypeInfo: " {{scriptType}}    ({{current}}  {{numberOfXPubs}})"
}, accountSummary$c = {
  availableBalance: " ",
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: " ",
  name: "  ",
  noAccount: "   .",
  subtotalWithCoinName: " ({{coinName}})",
  title: `  
`,
  total: "",
  transactionHistory: " "
}, addAccount$d = {
  chooseName: {
    nextButton: " ",
    step: " ",
    title: "  "
  },
  selectCoin: {
    nextButton: "",
    step: " ",
    title: " "
  },
  success: {
    message: "<strong>{{accountName}}</strong>   ",
    nextButton: "",
    step: "",
    title: " "
  },
  title: "  "
}, aopp$6 = {
  addressRequest: "{{host}}   ",
  addressRequestWithLogo: "  ",
  banner: "  ",
  errorTitle: "   ",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: " ",
  signing: " ,    BitBox02",
  success: {
    message: "  {{host}}",
    title: "  "
  },
  syncing: " , , .",
  title: " "
}, app$c = {
  upgrade: "    !   {{current}}  {{version}}."
}, backup$c = {
  check: {
    checking: "   ...",
    confirmTitle: "  ",
    notOK: "     . ",
    ok: "    .",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "   :",
    title: "  "
  },
  create: {
    alreadyExists: "     .    ?",
    fail: "    !",
    info: "      .",
    name: {
      label: "  ",
      placeholder: "   "
    },
    password: {
      label: " ",
      placeholder: "   "
    },
    title: "  ",
    verificationFailed: "     .    .    ,    ."
  },
  description: " <strong>  </strong>",
  insert: "   microSD    .",
  insertButton: "    microSD",
  list: "      microSD",
  noBackups: "   microSD   .",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "  microSD  ",
      general: "   "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "    ...",
    selectedBackup: "<strong>{{backupName}}</strong>   {{createdDateTime}} ",
    title: "",
    understand: " ,       "
  },
  showMnemonic: {
    description: `   24  ,      .    .

<strong>        .</strong>

<strong>   .</strong>

<strong>     .</strong>

       .`,
    title: "   "
  },
  title: "  "
}, bb02Bootloader$c = {
  abort: "  -  ",
  abort_noUpgrade: " ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "      "
  },
  flipscreen: " ",
  orientation: "    ?",
  success: "  !   {{rebootSeconds}}  ...",
  success_install: "  !   {{rebootSeconds}} ..."
}, bitbox$c = {
  error: {
    e10000: "  .",
    e10001: "    ",
    e102: "     4 .",
    e112: "         ."
  }
}, bitbox02Interact$c = {
  confirmDate: "      BitBox02",
  confirmDateText: "        .",
  confirmName: "     BitBox02",
  followInstructions: ",      BitBox02.",
  followInstructionsMnemonic: ",      BitBox02,       ",
  followInstructionsMnemonicTitle: "    ( )"
}, bitbox02Settings$c = {
  deviceName: {
    current: "  ",
    input: "  BitBox02",
    placeholder: "  ",
    title: "  BitBox02"
  },
  gotoStartupSettings: {
    description: "   BitBox02     ",
    title: "   "
  }
}, bitbox02Wizard$c = {
  attestationFailed: "    .       ,     . ,      . ,   support@bitbox.swiss     ",
  backup: {
    point1: "     microSD",
    point2: "    ",
    restoreText: ",    !",
    text1: ",   BitBox02     .        . ,    microSD   BitBox02,  .",
    text2: ",      ,    .",
    text3: "      microSD     <strong> </strong>.   microSD   .        ,   BitBox02.",
    userConfirmation1: "       .",
    userConfirmation2: "     . ,    ,    .",
    userConfirmation3: "      BitBox02,      -   .",
    userConfirmation4: "         BitBox02,    .",
    userConfirmation5: "       microSD       , ,     ,  BitBox02."
  },
  create: {
    button: "   ",
    info: "  ,        BitBox: ",
    inputTitle: " ",
    point1: "  ",
    point2: "    ",
    point3: "  ",
    text: ",    !"
  },
  createBackupFailed: "    .   .",
  initialize: {
    passwordText: "      .      BitBox     .",
    passwordTitle: "    BitBox",
    text: " BitBox02   !     .             . <strong>,    BitBox02    microSD</strong>",
    tip: "  ,       .",
    title: "  BitBox"
  },
  insertSDCard: "<strong>,   BitBox02   microSD.</strong>",
  noPasswordMatch: "  ,   .",
  pairing: {
    failed: " . ,   BitBox02 .",
    paired: "    ,   .   ,   ,   .",
    title: "  ",
    unpaired: " BitBox02  . ,     ,     .   ,      BitBox02     ,  ."
  },
  restoreFromMnemonic: {
    failed: "   .   ."
  },
  stepBackup: {
    beforeProceed: "  ,      :",
    createBackup: "       microSD."
  },
  stepBackupSuccess: {
    fundsSafe: "    ,  :",
    title: "  !"
  },
  stepConnected: {
    unlock: "  BitBox02  ."
  },
  stepCreate: {
    description: "          ",
    nameLabel: " BitBox02",
    namePlaceholder: " BitBox02",
    title: "  BitBox02",
    toastMicroSD: ",   microSD   BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "  microSD  BitBox02      .",
    success: "    "
  },
  stepInsertSD: {
    insertSDCard: " ,   microSD  BitBox02.",
    insertSDcardTitle: "  microSD"
  },
  stepPassword: {
    title: "  BitBox02",
    useControls: "     BitBox02,   ."
  },
  stepUninitialized: {
    create: "    BitBox02.",
    restore: "       .",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "    ",
    title: "  BitBox02"
  },
  success: {
    text: `!  BitBox02    .

     ,    BitBoxApp, ,    ,        .`,
    title: "   !"
  }
}, blink$c = {
  button: ""
}, bootloader$c = {
  button: " ",
  button_install: " ",
  progress: ": {{progress}}%",
  progress_install: ": {{progress}}%",
  success: " !     .       ."
}, button$g = {
  abort: "",
  back: "",
  buy: "",
  changepin: "  ",
  check: "  ",
  continue: "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
}, buy$8 = {
  info: {
    continue: "  ",
    crypto: "",
    disclaimer: {
      intro: [
        "   MoonPay,      {{name}}   BitBoxApp.    ",
        "MoonPay -  ,       {{name}}    160+ "
      ],
      payment: {
        details: "    {{name}}  MoonPay   .           ,    -    .    ,      .    4 USD/EUR  ",
        footnote: " ,    MoonPay    ,   BitBoxApp,      .",
        table: {
          "1_description": "  ,    3-  ",
          "1_method": "  (SEPA)",
          "2_description": "  ,    ",
          "2_method": "   ",
          description: "",
          fee: "",
          method: ""
        },
        title: "   "
      },
      privacyPolicy: "  MoonPay",
      protection: {
        description: " BitBoxApp       {{name}},      . MoonPay       .     ,    ",
        title: " "
      },
      security: {
        description: " {{name}}  MoonPay,    .         BitBox02     ,      BitBoxApp",
        link: "  ",
        title: " "
      },
      title: "        {{name}}"
    },
    next: "",
    selectLabel: " ",
    selectPlaceholder: " ",
    skip: "  ",
    title: " {{name}}"
  },
  title: " {{name}}"
}, changePin$c = {
  newTitle: "  ",
  oldLabel: "  "
}, chart$8 = {
  dataMissing: "    . , .",
  dataUpdating: " ",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
}, checkSDcard$c = "   microSD", clickHere$c = " .", confirm$e = {
  abortInfo: ", ",
  abortInfoRedText: " ",
  approveInfo: " 4 , ",
  approveInfoGreenText: " ",
  info: "    BitBox. ",
  infoWhenPaired: "    ,    BitBox"
}, confirmOnDevice$c = ",    .", device$c = {
  appUpradeRequired: " BitBox     .     ."
}, deviceLock$c = {
  button: "   (2FA)",
  condition1: "    ?",
  condition2: "    ?",
  condition3: "        .           (2FA)!",
  confirm: " 2FA",
  title: "   (2FA)"
}, deviceSettings$c = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "     ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: " ",
      label: " Micro SD",
      true: ""
    },
    securechip: " ",
    title: " "
  },
  loading: "    ...",
  pairing: {
    lock: {
      false: "",
      label: "  (2FA)",
      true: ""
    },
    mobile: {
      false: "",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: " "
  }
}, deviceTampered$c = "  BitBox    ?   ,         . Shift             .", dialog$d = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
}, error$8 = {
  accountAlreadyExists: "  ",
  accountLimitReached: "  .       ",
  aoppCallback: "      {{host}}",
  aoppInvalidRequest: " ",
  aoppNoAccounts: "  ",
  aoppSigningAborted: "    ",
  aoppUnknown: "  ",
  aoppUnsupportedAsset: "  ",
  aoppUnsupportedFormat: "  ,    .",
  aoppUnsupportedKeystore: "        ",
  aoppVersion: " "
}, fiat$e = {
  default: "",
  setDefault: " {{code}} ",
  title: ""
}, footer$e = {
  appVersion: " :"
}, generic$8 = {
  enabled_false: "",
  enabled_true: ""
}, genericError$c = " .    - ,  .", goal$c = {
  buttons: {
    create: "  ",
    restore: "  "
  },
  paragraph: "    :",
  step: {
    1: {
      title: "  "
    },
    2: {
      description: "  ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$d = {
  accountDescription: {
    text: "    .      .       .  ,        .",
    title: "  ?"
  },
  accountFiat: {
    text: ",      ,   .        .",
    title: "      ?"
  },
  accountIncomingBalance: {
    text: ",    ,    ,     .",
    title: "  ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: ` xpub     "": "Native Segwit (bech32)", "Wrapped Segwit" or Taproot (  Bitcoin).   ,  {{coinName}}.  BitBoxApp  ,       .       xpub ,      xpub .

     ,    (Native Segwit),     xpub  "bech32". ,      "Wrapped Segwit"  Taproot ,        "Wrapped Segwit"  Taproot `,
      title: "   xpub ?"
    },
    privacy: {
      text: `      (xpub)    ,       .  xpub       .

   - xpub ,    ,           .      xpub          .`,
      title: "    xpub   ?"
    },
    verify: {
      text: ",     xpub .  -       xpub ,    ,    .       ,  ,   xpub   .           !",
      title: "    xpub   ?"
    },
    xpub: {
      text: `   (xpub) -   ,        .

         ,    ,   Electrum  Sentinel.        , ,     xpub  ,    ,     .

 ,        Taproot xpubs `,
      title: "    ?"
    }
  },
  accountRates: {
    text: "       CoinGecko.",
    title: "  ?"
  },
  accountReload: {
    text: "     .",
    title: "     ?"
  },
  accountSendDisabled: {
    text: "  ,     .",
    title: "     {{unit}}?"
  },
  accountSummaryAmount: {
    text: `     .       coingecko.com.

.     MyEtherWallet     BitBoxApp    .`,
    title: "   ?"
  },
  accountSummaryDescription: {
    text: "      .          .",
    title: "    ?"
  },
  accountTransactionAttributesBTC: {
    text: ` :      .   ,      .
:            .
:   Segwit,         .    Segwit   ,    -   .   ,        .`,
    title: "  ,   "
  },
  accountTransactionAttributesGeneric: {
    text: `: ,    ,   .    ,       - ,       .   ,   ,       .       3-6 .
 :   ,      .
 :             ,   .   ,   .`,
    title: " ,    ?"
  },
  accountTransactionConfirmation: {
    text: "          .",
    title: "   ?"
  },
  accountTransactionLabel: {
    text: " ,       .",
    title: "     ?"
  },
  accountTransactionTime: {
    text: ",      .",
    title: "  ?"
  },
  accounts: {
    howManyAccounts: {
      text: "      ",
      title: "    ?"
    },
    howtoAddTokens: {
      text: ',   ERC20,    Ethereum.      ,   " ",     Ethereum      .',
      title: "    ?"
    },
    moveFunds: {
      text: ".     ,         .",
      title: "      ?"
    },
    recoverAccounts: {
      text: ". BitBoxApp  ,   ,     -.",
      title: "         ?"
    },
    whatAreAccounts: {
      text: "      .   ,      ",
      title: "  ?"
    },
    whyIsThisUseful: {
      text: '             ,    .     "   (xpub)"   ,       .         . ,          ',
      title: "  ?"
    }
  },
  appendix: {
    link: "  !",
    text: " ?"
  },
  backups: {
    check: {
      text: "    ,       ,    .        .",
      title: "    ?"
    },
    encrypt: {
      text: ",        .",
      title: "     ?"
    },
    howOften: {
      text: `       .           micro SD   ,        SD-    .
        .            ,    .`,
      title: "      ?"
    },
    whatIsABackup: {
      text: "     micro SD.         .",
      title: "   ?"
    }
  },
  backupsBB02: {
    check: {
      text: "    ,       ,    .",
      title: "    ?"
    },
    encrypt: {
      text: ".   microSD   ,          .       ,            .",
      title: "     ?"
    },
    whatIsABackup: {
      text: "     micro SD.",
      title: "   ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `  2FA ,         ,  ,   .       ,      BitBox    .             ,    .

         ,     2FA.  ,  micro SD     .    ,  BitBox,   .`,
      title: "    (2FA)?"
    },
    disable2FA: {
      text: "  2FA,    BitBox,        . ,        microSD          .    .          .   ,     ,      ,      .",
      title: "    (2FA)?"
    },
    ejectBitbox: {
      text: "   BitBox   .",
      title: "    BitBox?"
    },
    ejectSD: {
      text: "    microSD  BitBox   ,           .",
      title: "     microSD?"
    },
    hiddenWallet: {
      text: "      ,        ,      .         ,    ,      .",
      title: "   ?"
    },
    legacyHiddenWallet: {
      text: "    (,  BitBox      ,    2FA ),    Bitbox        .",
      title: "      ?"
    },
    pairing: {
      text: "      iOS  Android   QR-,          .       .",
      title: "    "
    }
  },
  cointracking: {
    text: '  ""    ,       CSV.     ,   CSV- BitBox   ,       ( )     ',
    title: "        ?"
  },
  receive: {
    address: {
      text: "    ,     .  ,      .",
      title: "    ?"
    },
    addressChange: {
      text: "     ,        .     20  .",
      title: "  ?"
    },
    addressFormats: {
      text: "    - Native Segwit.        /         .        Taproot (   (Btc)),      , , ,        .         Native Segwit (  ),          Wrapped Segwit,        / ",
      title: "      ?"
    },
    howVerify: {
      text: `   BitBox01,   BitBox         .  ,      .
   BitBox02,            .`,
      title: "     ?"
    },
    plugout: {
      text: ",  ,        BitBox,      BitBox .     BitBox",
      title: "    BitBox     ?"
    },
    why20: {
      text: "     ,    ,  ,      .        ,      .    ,    20        .     20    -,     .",
      title: "  20 ?"
    },
    whyMany: {
      text: "             .    ,        .     20  .       .       .",
      title: "   ?"
    },
    whyVerify: {
      text: "            .       .    BitBox01,          ,         QR-.    BitBox02,       BitBox02.",
      title: "    ?"
    }
  },
  send: {
    change: {
      text: "      Taproot,        UTXO (  )  Taproot.  ,    ,      Taproot,    UTXOs     Taproot UTXO.          Native Segwit",
      title: "   ?"
    },
    fee: {
      text: `     ,     .       Bitcoin Core    .
: 24  ( 4   , 1   Litecoin)
: 12  ( 2   , 30   Litecoin)
: 6  ( 1   , 15   Litecoin)
: 2  ( 20   , 5   Litecoin)
(        (2,5   Litecoin)           .)`,
      title: "   ?"
    },
    plugout: {
      text: ",  ,    ,      BitBox .     BitBox",
      title: "     BitBox     ?"
    },
    priority: {
      text: "  ,    ,       .",
      title: "   ?"
    },
    revert: {
      text: `       (    ),      .      ( )!
  ,          ,       .`,
      title: "   ?"
    },
    whyFee: {
      text: ` ,    .   ,      blockchain,    .
     .             (     ),    ,   ,    .                 ,   .`,
      title: "   ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `        ,       (,   Wi-Fi),     .
   ,    Electrum   TLS   .
         ,   Tor.     TLS  .`,
      title: "   , TCP, TLS  Tor?"
    },
    instructions: {
      link: {
        text: "    "
      },
      text: "   ",
      title: "  BitBoxApp     ()?"
    },
    options: {
      text: `     ,     ,    Bitcoin Core.
    BitBoxApp   , ,     Electrum.   ,       .
   Electrs,   Electrum (EPS)  Bitcoin Wallet Tracker (BTW).`,
      title: "     ?"
    },
    tor: {
      text: `Tor   .        ,             .
        Tor, ,  Tor    ,    Tor Proxy   BitBoxApp.
        Tor:
1. Tor Browser:    Tor Browser.   BitBoxApp    Tor,   9150   - Tor.
2.   Tor:   Tor,      .  BitBoxApp  ,   9050   - Tor.`,
      title: "  Tor, - Tor      ?"
    },
    what: {
      text: "            Shift.",
      title: " ?"
    },
    why: {
      text: `     ,        .
-,  ,      ,  BitBoxApp           ;          .
-,    ,       ,     .`,
      title: "    ?"
    }
  },
  settings: {
    servers: {
      text: `     Shift Crypto   ,         .
 ,       CoinGecko. (  ,    .)`,
      title: "     ?"
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "         ,   .",
      title: " ,     ?"
    },
    reset: {
      text: "    15 .       .",
      title: "  ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `      . ,    .     , ,      .

BitBox01     . ,   BitBoxApp       BitBox01`,
      title: "  BitBox01  "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox   -:",
      title: "    ?"
    },
    internet: {
      text: ",   ,      ,  -.",
      title: "       ?"
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "        BitBox      .",
      title: "   .  ?"
    },
    useWithoutDevice: {
      text: " ,   .",
      title: "      ?"
    },
    welcome: {
      text: "    ,  Shift Crypto  .  -    -,     ,    . ,  ,   .",
      title: "    BitBoxApp!"
    }
  }
}, headerssync$c = {
  blocksSynced: "{{blocks}}  "
}, hiddenWallet$c = {
  info1HTML: "            <strong>  </strong>     .",
  info2HTML: "     ,        .       <strong>  </strong>  ,       .",
  passwordLabel: "  ",
  passwordPlaceholder: "   ",
  pinLabel: "  ",
  pinRepeatLabel: "   ",
  pinRepeatPlaceholder: "   ",
  success: "   .  BitBox,   ."
}, initialize$c = {
  create: "  ",
  creating: "   ...",
  error: {
    e102: "      4 ."
  },
  info: {
    description1: "  .       BitBox.",
    description2: "     .     .",
    description3: "    ,            .",
    subtitle: "     ",
    title: " "
  },
  input: {
    label: " ",
    labelRepeat: "  ",
    placeholderRepeat: "  "
  }
}, invalidFormat$c = " ", language$d = {
  title: " "
}, legacyhiddenwallet$c = {
  disable: "    ",
  enable: "    ",
  successDisable: "   .",
  successEnable: "   .   BitBox     ,      ."
}, loading$c = " ...", manageAccounts$6 = {
  editAccount: "",
  editAccountNameTitle: "  ",
  noAccounts: "   ",
  settings: {
    hideTokens: " ",
    showTokens: "  ({{activeTokenCount}})"
  },
  settingsButtonDescription: "  / ",
  title: " "
}, mobile$7 = {
  usingMobileDataWarning: "  :               . ,   Wi-Fi,     .    ,     ."
}, note$8 = {
  input: {
    description: "()",
    placeholder: "  ..."
  },
  title: ""
}, notification$c = {
  newTxs_one: "  : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
}, pairing$c = {
  aborted: {
    text: "     .",
    title: ""
  },
  button: "   ",
  confirm: " ,     BitBox?  ,         .",
  connectOnly: {
    button: "  ",
    title: "     ,        ,"
  },
  error: {
    text: " . ,  .",
    title: ""
  },
  pullFailed: {
    text: "         . ,   ,     ",
    title: " "
  },
  reconnectOnly: {
    button: "   "
  },
  scanningFailed: {
    text: "      . ,   ",
    title: " "
  },
  start: {
    hideAppQRCode: " QR ",
    revealAppQRCode: " QR ",
    step1: "     ,    QR-  Apple App Store  Google Play Store    ,    .",
    step2: "     ,       Digital Bitbox 2FA     iOS  Android:"
  },
  started: {
    text: "     .",
    title: ""
  },
  success: {
    text: ",     BitBox   !",
    title: ""
  },
  timeout: {
    text: "     .  ,        .",
    title: "-"
  },
  title: " "
}, passphrase$6 = {
  considerations: {
    button: "   ",
    message: `           ( microSD  seed   24 ).   -      ,          .

  ,    <strong>  ,     </strong>       ,  ,   BitBox02   .        ,          ().

      ,      ,    .  ,  -    ,      !`,
    title: "   "
  },
  disable: "  ",
  disableInfo: {
    button: "",
    message: `              BitBox02.      .

        -     ,        ,      BitBox02    .

         ,              BitBox02.

<strong>:</strong>        ,   `
  },
  enable: "  ",
  error: {
    e104: "     "
  },
  how: {
    button: "  ",
    message: `    ,  ,    .       ,    .   ,  <strong>    ,   </strong>.          ,  .           .

  BitBox02 ,  ,     .         .

          .    ,    ,    `,
    title: "  "
  },
  intro: {
    message: `       .
 ,   `,
    title: "  "
  },
  progressDisable: {
    message: "   BitBox,    <strong></strong>   ",
    title: "  "
  },
  progressEnable: {
    message: "   BitBox,    <strong></strong>   ",
    title: "  "
  },
  successDisabled: {
    message: `   <strong> </strong>!
      `,
    messageEnd: ",  BitBox02 ",
    title: "  "
  },
  successEnabled: {
    message: `   <strong> </strong>!
       `,
    messageEnd: ",   BitBox02 ",
    tips: "",
    tipsList: [
      "          .      BitBox02       .      ,       ",
      "         ,    ,      ,   .       "
    ],
    title: "  "
  },
  summary: {
    button: "  ",
    title: "",
    understand: " ,         ",
    understandList: [
      "  -    ,    ",
      "         ",
      "   ,   <strong>  ,    </strong>",
      "     ,         "
    ]
  },
  what: {
    button: ",   ",
    message: `  ()     ,    seed  ( ).        BitBox02      microSD  24 . ,      seed ,        .

  -  <strong> </strong>,   seed .          seed  +   ( ).      ,  .     : , ,      .             , .. seed  +   .

     BIP39 -  ,      ,      `,
    title: "   ?"
  },
  why: {
    button: "   ",
    message: `BitBox02   seed      ,    ( microSD  24 )     .      !

      ,    seed ,    , <strong>    </strong>.     ,   -     ( seed ),            .

 ,          ,         `,
    title: "   ?"
  }
}, password$c = {
  show: " {{label}}",
  warning: {
    caps: ": Caps Lock () ",
    paste: "    ,   {{label}}"
  }
}, random$d = {
  button: "  ",
  description: " BitBox   {{bits}}-  :"
}, receive$e = {
  changeScriptType: "  ",
  label: " ",
  onlyThisCoin: {
    description: "   ,    .     ,    .",
    warning: ",    {{coinName}}   ."
  },
  scriptType: {
    p2tr: "Taproot ( )",
    p2wpkh: "Native Segwit ( )",
    "p2wpkh-p2sh": "Wrapped Segwit ( )"
  },
  showFull: "      ",
  taprootWarning: ": Taproot -    ,      . ,     Taproot,        ,    .           Taproot",
  title: " {{accountName}}",
  verify: "  ",
  verifyBitBox01: "    ",
  verifyBitBox02: "   BitBox02",
  verifyInstruction: ",           .",
  warning: {
    secureOutput: ',   BitBox   ,     .    " "   '
  }
}, reset$c = {
  description: "     .       !",
  notReset: "   .",
  title: "    ",
  understand: "         ",
  understandBB02: "     "
}, securityInformation$c = {
  create: {
    description1: "       ,         .",
    description2: "     .",
    description3: " <strong>device password</strong>,  ,    BitBox     .",
    description4: "  <strong>recovery password</strong>   .       .",
    description5: "         micro SD.      ,    ,  <strong> </strong>.",
    title: "  "
  },
  restore: {
    description1: "     micro SD,       ",
    description2: "       .",
    description3: "     .       .     ,      ,    .",
    title: "  "
  }
}, seed$c = {
  agreements: {
    "funds-access": "       ,     ",
    "password-change": "      .",
    "password-required": "        "
  },
  create: " ",
  creating: " ",
  description: " :",
  error: {
    e102: "       4 .",
    e200: "    micro SD   BitBox,        "
  },
  info: {
    button: "  ",
    description1: "  micro SD  BitBox",
    description2: "         ",
    description3: "    micro SD      (seed ) -           BitBox.",
    description4: "       ,    .",
    title: "  "
  },
  password: {
    label: " ",
    repeatPlaceholder: "  "
  },
  walletName: {
    label: " "
  }
}, seedRestore$c = {
  error: {
    e200: "        micro SD."
  },
  info: {
    description1: "  micro SD  BitBox   ,",
    description2: "     ,",
    description3: "  ",
    description4: "  ,      .",
    title: "     "
  }
}, send$e = {
  abort: "  .",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: "",
  coincontrol: {
    address: "",
    outpoint: "Outpoint",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    feeTooLow: "  ",
    feesNotAvailable: "   ",
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: ""
  },
  feeTarget: {
    customLabel: " ",
    customLabel_eth: " gas ( eth)",
    description: {
      economy: "4  (24 )",
      economy_eth: "30   ",
      economy_ltc: "1  (24 )",
      high: "20  (2 )",
      high_eth: "30   ",
      high_ltc: "5  (2 )",
      low: "2  (12 )",
      low_eth: "5   ",
      low_ltc: "30  (12 )",
      normal: "1  (6 )",
      normal_eth: "2   ",
      normal_ltc: "15  (6 )"
    },
    estimate: "   :",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "    ..."
  },
  maximum: " ",
  maximumSelectedCoins: "  ",
  priority: "",
  scanQR: " QR ",
  signprogress: {
    description: "    .    ,    {{steps}} a.",
    label: ""
  },
  success: "    .",
  title: " {{accountName}}",
  toggleCoinControl: "  ",
  transactionDetails: " "
}, settings$d = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: "    {{host}}",
    checking: "",
    "download-cert": " ",
    "remove-server": "",
    removeConfirm: " {{server}}?",
    reset: "   ",
    resetConfirm: "       ?",
    servers: "",
    step1: "1",
    "step1-text": " .",
    step2: "2",
    "step2-text": "    . ,      .",
    "step2-text-tcp": "    ,     TLS.",
    step3: "3",
    "step3-text": "    .",
    step4: "4",
    "step4-text": " .      ,       .",
    "title-btc": " Bitcoin Electrum",
    "title-ltc": " Litecoin Electrum",
    "title-tbtc": " Bitcoin Testnet Electrum ",
    "title-tltc": " Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "  ",
    electrum: {
      title: "   "
    },
    fee: "   ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: " - "
  },
  header: {
    home: ""
  },
  restart: " BitBoxApp,     .",
  services: {
    title: ""
  },
  success: ",    BitBox ,     .",
  title: ""
}, setup$c = " ", sidebar$d = {
  buy: " ",
  device: " ",
  leave: "",
  settings: ""
}, success$j = {
  create: {
    info1: "         microSD.       .",
    info2: "    ,     BitBox.",
    info3: "       ,         .",
    summary: "   ,   ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "      .",
    title: ""
  }
}, transaction$d = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: " ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  note: {
    edit: " ",
    save: " "
  },
  pending: " ",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: " "
  },
  tx: {
    received: "",
    sent: ""
  },
  vsize: " ",
  weight: ""
}, transactions$c = {
  placeholder: "   ."
}, unknownError$c = "  : {{errorMessage}}", unlock$c = {
  description: "   ,   .",
  error: {
    e109_normal: "  . {{remainingAttempts}}      .",
    e109_touch: "$t(unlock.error.e109_normal)        .",
    e113: "-     ,            4 ."
  },
  input: {
    label: " ",
    placeholder: "   ."
  },
  unlocking: " ..."
}, upgradeFirmware$d = {
  button: " ",
  description: "     {{currentVersion}}  {{newVersion}}?",
  label: "  BitBox   .",
  locked: "   {{currentVersion}}  {{newVersion}},   .",
  title: " ",
  unlocked: " .  , :",
  unlocked1: "    Bitbox ",
  unlocked2: " ,   BitBox   ",
  unlocked3: "  ,   "
}, warning$i = {
  receivePairing: ",  BitBox,    .       ",
  sdcard: "  micro SD   BitBox,        ",
  sendPairing: " BitBox,   e  .       "
}, welcome$c = {
  getStarted: "       BitBox02",
  insertBitBox02: "  BitBox02, ,  .",
  insertDevice: "     ",
  title: " "
}, appTranslationsRU = {
  account: account$c,
  accountInfo: accountInfo$c,
  accountSummary: accountSummary$c,
  addAccount: addAccount$d,
  aopp: aopp$6,
  app: app$c,
  backup: backup$c,
  bb02Bootloader: bb02Bootloader$c,
  bitbox: bitbox$c,
  bitbox02Interact: bitbox02Interact$c,
  bitbox02Settings: bitbox02Settings$c,
  bitbox02Wizard: bitbox02Wizard$c,
  blink: blink$c,
  bootloader: bootloader$c,
  button: button$g,
  buy: buy$8,
  changePin: changePin$c,
  chart: chart$8,
  checkSDcard: checkSDcard$c,
  clickHere: clickHere$c,
  confirm: confirm$e,
  confirmOnDevice: confirmOnDevice$c,
  device: device$c,
  deviceLock: deviceLock$c,
  deviceSettings: deviceSettings$c,
  deviceTampered: deviceTampered$c,
  dialog: dialog$d,
  error: error$8,
  fiat: fiat$e,
  footer: footer$e,
  generic: generic$8,
  genericError: genericError$c,
  goal: goal$c,
  guide: guide$d,
  headerssync: headerssync$c,
  hiddenWallet: hiddenWallet$c,
  initialize: initialize$c,
  invalidFormat: invalidFormat$c,
  language: language$d,
  legacyhiddenwallet: legacyhiddenwallet$c,
  loading: loading$c,
  manageAccounts: manageAccounts$6,
  mobile: mobile$7,
  note: note$8,
  notification: notification$c,
  pairing: pairing$c,
  passphrase: passphrase$6,
  password: password$c,
  random: random$d,
  receive: receive$e,
  reset: reset$c,
  securityInformation: securityInformation$c,
  seed: seed$c,
  seedRestore: seedRestore$c,
  send: send$e,
  settings: settings$d,
  setup: setup$c,
  sidebar: sidebar$d,
  success: success$j,
  transaction: transaction$d,
  transactions: transactions$c,
  unknownError: unknownError$c,
  unlock: unlock$c,
  upgradeFirmware: upgradeFirmware$d,
  warning: warning$i,
  welcome: welcome$c
}, account$b = {
  disconnect: "Sambungan hilang. Mencuba lagi...",
  export: "Eksport",
  exportTransactions: "Eksport transaksi ke folder muat turun sebagai fail CSV",
  fatalError: "Terdapat kesilapan yang tidak dijangka.",
  incoming: "Masuk",
  initializing: "Mendapatkan maklumat dari blockchain ...",
  maybeProxyError: "Proksi Tor diaktifkan. Pastikan proksi Tor anda berfungsi dengan baik atau matikan tetapan proksi.",
  reconnecting: "Sambungan hilang, mencuba menyambung kembali...",
  syncedAddressesCount: "{{count}} alamat telah diimbas"
}, accountInfo$b = {
  address: "Alamat",
  buyCTA: {
    buy: "Beli {{unit}}",
    buyCrypto: "Beli Kripto",
    information: {
      looksEmpty: "Nampaknya dompet ini kosong.",
      start: "Memulakan dengan mendepositkan beberapa syiling ke dalam dompet atau membeli terus di dalam aplikasi BitBoxApp."
    }
  },
  extendedPublicKey: "Public key lanjutan",
  label: "Maklumat akaun",
  scriptType: "Jenis skrip",
  title: "Maklumat Akaun",
  verify: "Sahkan pada peranti",
  xpubTypeChangeBtn: {
    p2pkh: "Lihat legacy P2PKH extended public key",
    p2tr: "Lihat Taproot",
    p2wpkh: "Lihat Segwit Asli",
    "p2wpkh-p2sh": "Lihat Segwit public key lanjutan yang lebih lama"
  },
  xpubTypeInfo: "Sedang memaparkan {{scriptType}} public key lanjutan ({{current}} daripada {{numberOfXPubs}})"
}, accountSummary$b = {
  availableBalance: "Baki yang ada",
  balance: "Baki",
  exportSummary: "Eksport Ringkasan Akaun ke Folder Muat Turun sebagai Fail CSV",
  fiatBalance: "Baki Fiat",
  name: "Nama Akaun",
  noAccount: "Tiada akaun untuk dipaparkan.",
  subtotalWithCoinName: "Jumlah ({{coinName}})",
  title: "Ringkasan Akaun",
  total: "Jumlah",
  transactionHistory: "Sejarah transaksi"
}, addAccount$c = {
  chooseName: {
    nextButton: "Tambah Akaun",
    step: "Nama akaun",
    title: "Namakan akaun anda"
  },
  selectCoin: {
    nextButton: "Seterusnya",
    step: "Pilih syiling",
    title: "Pilih mata wang kripto"
  },
  success: {
    addAnotherAccount: "Tambah akaun lain",
    message: "<strong>{{accountName}}</strong> telah ditambahkan ke akaun anda",
    nextButton: "Selesai",
    step: "Selesai",
    title: "Akaun ditambahkan"
  },
  title: "Tambah Akaun"
}, aopp$5 = {
  addressRequest: "{{host}} sedang meminta alamat penerimaan.",
  addressRequestWithLogo: "sedang meminta alamat penerima",
  banner: "Permintaan alamat dalam proses.",
  errorTitle: "Ralat semasa permintaan alamat",
  labelAddress: "Alamat",
  labelMessage: "Mesej",
  reverifyInfoText: "Sahkan alamat",
  signing: "Untuk meneruskan, tandatangani mesej pada BitBox02 anda.",
  success: {
    message: "Teruskan {{host}}",
    title: "Alamat berjaya dihantar"
  },
  syncing: "Menyelaraskan akaun, sila tunggu.",
  title: "Permintaan alamat"
}, app$b = {
  upgrade: "Versi baru aplikasi ini telah didapati! Sila kemaskini dari {{current}} ke {{version}}."
}, auth$5 = {
  authButton: "Sahkan",
  title: "Sila sahkan untuk meneruskan"
}, backup$b = {
  check: {
    checking: "Memeriksa backup...",
    confirmTitle: "Semak Backup",
    notOK: "Backup TIDAK sepadan dengan wallet.",
    ok: "Backup sepadan dengan wallet.",
    password: {
      label: "Kata laluan pemulihan",
      placeholder: "Kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    success: "Backup berjaya disahkan",
    title: "Semak Backup"
  },
  create: {
    alreadyExists: "Anda sudah mempunyai backup yang sah. Adakah anda ingin menciptanya kembali?",
    fail: "TIDAK BERJAYA membuat backup!",
    info: "Sila masukkan kata laluan pemulihan dari wallet terkini untuk pengesahan",
    name: {
      label: "Nama backup",
      placeholder: "Sila memberi nama backup"
    },
    password: {
      label: "Kata Laluan Pemulihan",
      placeholder: "Sila masukkan kata laluan pemulihan anda"
    },
    title: "Buat Backup",
    verificationFailed: "Kata laluan pemulihan TIDAK sesuai dompet terkini. Backup telah dibuat. Sila gunakan 'Semak Backup' untuk mengesahkan kembali password pemulihan anda."
  },
  description: "Pilih <strong>fail backup wallet</strong>",
  insert: "Sila masukkan kad micro SD untuk mengurus backup.",
  insertButton: "Saya telah memasukkan kad micro SD",
  list: "Telah jumpa <strong>backup berikut</strong> pada kad SD ini:",
  noBackups: "Tiada backup pada kad microSD ini.",
  restore: {
    confirmTitle: "Memulihkan Backup",
    error: {
      e200: "SD card tidak dijumpai",
      general: "Ralat memulihkan sandaran"
    },
    password: {
      label: "Kata laluan pemulihan atau kata laluan pemulihan tersembunyi",
      placeholder: "Kata laluan pemulihan",
      repeatPlaceholder: "Ulangi kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    restoring: "Memulihkan backup...",
    selectedBackup: "<strong>{{backupName}}</strong> dicipta pada {{createdDateTime}} akan dipulihkan.",
    title: "Memulihkan",
    understand: "Saya faham bahawa kata laluan pemulihan yang salah akan membuat dompet yang berbeza"
  },
  showMnemonic: {
    description: `Anda akan diberikan 24 perkataan pemulihan, yang membentuk sandaran dompet anda. Tulis mereka di atas kertas.

<strong>Jangan menyimpannya secara digital atau mengambil gambar.</strong>

<strong>Jangan mengucapkannya dengan lantang.</strong>

<strong>Sandaran ini tidak dilindungi kata laluan.</strong>

Selepas itu, anda akan diminta mengesahkan setiap perkataan.`,
    title: "Tunjukkan perkataan pemulihan",
    warning: "<strong>Jangan sekali-kali berkongsi kata-kata pemulihan anda dengan sesiapa pun.</strong> Perkataan pemulihan anda memberikan akses penuh kepada dompet anda. Jika seseorang meminta anda untuk kata-kata pemulihan anda, ia adalah penipu, jangan kongsikannya!"
  },
  title: "Urus Backup"
}, bb02Bootloader$b = {
  abort: "Jangan naik taraf - Kembali",
  abort_noUpgrade: "Bawa saya balik",
  advanced: {
    label: "Tetapan lanjutan",
    toggleShowFirmwareHash: "Tunjukkan hash firmware setiap kali pada permulaan"
  },
  flipscreen: "Putar skrin",
  orientation: "Orientasi peranti salah?",
  success: "Naik taraf berjaya! Meneruskan dalam {{rebootSeconds}} detik...",
  success_install: "Pemasangan berjaya! Meneruskan dalam {{rebootSeconds}} detik..."
}, bitbox$b = {
  error: {
    e10000: "Kata laluan peranti terkini salah",
    e10001: "Gagal mengganti kata laluan peranti",
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e112: "Kata laluan peranti tersembunyi tidak boleh sama dengan kata laluan peranti utama."
  }
}, bitbox02Interact$b = {
  confirmDate: "Sahkan tarikh hari ini pada BitBox02 anda.",
  confirmDateText: "Tarikh ini akan digunakan untuk membuat sandaran anda.",
  confirmName: "Sahkan nama pada BitBox02",
  confirmWords: "Tuliskan {{amount}} perkataan pemulihan daripada BitBox02 anda",
  confirmWordsText: "Selepas itu BitBox02 meminta anda mengesahkan setiap perkataan untuk mengesahkan bahawa sandaran adalah betul.",
  followInstructions: "Sila ikuti arahan pada BitBox02 anda.",
  followInstructionsMnemonic: "Ikuti arahan pada BitBox02 anda untuk memasukkan perkataan pemulihan dari sandaran dan pulihkan dompet anda.",
  followInstructionsMnemonicTitle: "Pulihkan dari perkataan pemulihan"
}, bitbox02Settings$b = {
  deviceName: {
    current: "Nama peranti semasa",
    error: "Nama peranti tidak dapat ditetapkan",
    error_104: "Mengesahkan nama peranti telah digugurkan pada peranti.",
    input: "Nama BitBox02",
    placeholder: "Nama peranti baharu",
    title: "Tetapkan Nama BitBox02"
  },
  gotoStartupSettings: {
    description: "Ini akan but semula BitBox02 anda dan masukkan tetapan permulaan.",
    title: "Ini akan me-reboot BitBox02 anda dan masuk ke dalam tetapan permulaan semula."
  }
}, bitbox02Wizard$b = {
  advanced: {
    button: "Pilihan lanjutan",
    outOfDate: "Perisian tegar sudah lapuk untuk ciri ini",
    seed12WordInfo: "Sila ambil perhatian bahawa bilangan perkataan tidak boleh diubah selepas mencipta dompet.",
    seed12WordLabel: "Buat 12 perkataan dan bukannya benih 24 perkataan",
    seed12WordText: "Secara lalai, BitBox02 menggunakan benih 24 perkataan. Kedua-dua panjang benih adalah selamat daripada paksaan kasar dalam amalan. Sesetengah pengguna mungkin lebih suka kemudahan benih 12 perkataan sebaliknya.",
    skipSDCardLabel: "Langkau sandaran kad microSD dan tulis perkataan pemulihan sebaliknya",
    skipSDCardText: "Anda sentiasa mempunyai pilihan untuk membuat sandaran kad microSD atau menulis perkataan pemulihan anda selepas persediaan. Ini boleh dilakukan dari tetapan.",
    title: "Pilihan sandaran lanjutan"
  },
  attestationFailed: "Pengesahan peranti gagal. BitBox anda mungkin palsu atau terkompromi. Syiling di BitBox02 mungkin berisiko hilang. Sila hubungi support@bitbox.swiss dengan segera.",
  backup: {
    point1: "Pilih backup pada kad microSD",
    point2: "Tetapkan kata laluan untuk peranti anda",
    restoreText: "Ok, mari kita pulihkan backup!",
    text1: "Hebat, kata laluan BitBox02 anda sudah ditetapkan dan wallet dibuat. Kini tiba masanya untuk membuat backup pertama anda. Sila pastikan kad microSD anda dimasukkan ke dalam BitBox02 anda dan teruskan.",
    text2: "Sila ikuti arahan pada skrin pada peranti anda untuk membuat backup.",
    text3: "Selepas backup anda dicipta, sila tarik keluar kad microSD dan simpan itu di <strong>lokasi selamat</strong>. Kandungan kad microSD tidak dilindungi kata laluan. Jangan sekali-kali memasukkannya ke peranti lain selain BitBox02 anda.",
    userConfirmation1: "Saya harus menyimpan sandaran saya di lokasi yang selamat.",
    userConfirmation2: "Sandaran saya tidak dilindungi dengan kata laluan. Siapa saja yang mempunyai akses kepadanya dapat mengakses dompet saya.",
    userConfirmation3: "Jika saya kehilangan atau merosakkan BitBox02 saya, satu-satunya cara untuk memulihkan dana saya adalah dengan memulihkan daripada sandaran saya.",
    userConfirmation4: "Jika saya kehilangan atau merusakkan kedua-dua sandaran dan BitBox02 saya, maka dana saya akan hilang.",
    userConfirmation5: "Saya sepatutnya tidak memasukkan sandaran kad microSD saya ke dalam komputer, telefon, pencetak atau sebarang peranti selain daripada BitBox02.",
    userConfirmation5mnemonic: "Saya tidak sepatutnya meletakkan perkataan pemulihan saya dalam komputer, telefon, pencetak atau mana-mana peranti selain daripada BitBox02."
  },
  create: {
    button: "Beri Nama dan Teruskan",
    info: "Inilah langkah-langkah asas yang akan anda ambil untuk menyediakan BitBox anda: ",
    inputTitle: "Nama Wallet",
    point1: "Tetapkan nama untuk peranti anda",
    point2: "Tetapkan kata laluan untuk peranti anda",
    point3: "Buat backup",
    text: "Ok, mari buat dompet baru!"
  },
  createBackupAborted: "Membuat sandaran dihentikan.",
  createBackupFailed: "Gagal membuat sandaran, cuba lagi.",
  initialize: {
    passwordText: "Sekarang mari kita tetapkan kata laluan untuk peranti anda. Gunakan kawalan pada BitBox anda untuk memasukkan dan memilih kata laluan.",
    passwordTitle: "Tetapkan kata laluan untuk BitBox anda",
    text: "Berjaya berpasangan dengan BitBox02 anda! Sekarang mari kita inisialisasi peranti anda. Mulailah dengan memilih untuk membuat wallet baru, atau untuk memulihkan wallet dari backup yang sudah ada. <strong>Sila pastikan anda mempunyai kad microSD yang sudah dimasukkan dalam BitBox02 anda</strong>",
    tip: "Sebelum meneruskan, sangat disyorkan supaya anda meneruskan di persekitaran yang selamat.",
    title: "Inisialisasi BitBox anda"
  },
  insertSDCard: "<strong>Sila pastikan anda mempunyai kad microSD yang dimasukkan ke dalam BitBox02 anda.</strong>",
  noPasswordMatch: "Kata laluan tidak sepadan, sila cuba lagi.",
  pairing: {
    failed: "Pasangan tidak berjaya disahkan. Sila tancap ulang BitBox02 anda.",
    paired: "Anda telah mengesahkan pada peranti anda bahawa kod sepadan. Jika ini betul, anda boleh meneruskan dengan mengklik butang di bawah.",
    title: "Sahkan Kod Pasangan",
    unpaired: "BitBox02 baru telah dikesan. Sila sahkan bahawa kod berikut sepadan dengan apa yang ditunjukkan pada peranti anda. Jika kod itu sepadan, sentuh di bawah tanda semak pada BitBox02 anda dan kemudian klik butang di bawah untuk meneruskan."
  },
  restoreFromMnemonic: {
    e104: "Pemulihan daripada perkataan pemulihan telah dibatalkan.",
    failed: "Pemulihan daripada perkataan pemulihan gagal, sila cuba lagi."
  },
  stepBackup: {
    beforeProceed: "Sebelum meneruskan, sila baca pertimbangan keselamatan berikut:",
    createBackup: "Anda kini akan membuat sandaran pada kad microSD anda.",
    createBackupMnemonic: "Kini, anda akan dapat menulis perkataan pemulihan."
  },
  stepBackupSuccess: {
    fundsSafe: "Untuk memastikan dana anda selamat, sila ingat perkara berikut:",
    title: "Sandaran Dipulihkan!"
  },
  stepConnected: {
    unlock: "Masukkan kata laluan BitBox02 untuk membuka kunci."
  },
  stepCreate: {
    description: "Nama ini digunakan sebagai nama peranti dan untuk sandaran.",
    nameLabel: "Nama BitBox02",
    namePlaceholder: "BitBox02 Saya",
    title: "Pilih nama BitBox02",
    toastMicroSD: "Sila masukkan kad microSD anda ke dalam BitBox02 anda yang akan digunakan untuk menyimpan sandaran dompet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Sila keluarkan kad microSD dari BitBox02 anda dan simpan di tempat yang selamat.",
    storeMnemonic: "Sila simpan perkataan pemulihan anda di lokasi yang selamat",
    success: "Anda telah berjaya membuat sandaran anda."
  },
  stepInsertSD: {
    insertSDCard: "Sila masukkan kad mikroSD ke dalam BitBox02 anda untuk meneruskan.",
    insertSDcardTitle: "Masukkan kad mikroSD"
  },
  stepPassword: {
    e104: "Menetapkan kata laluan telah dibatalkan.",
    title: "Tetapkan kata laluan BitBox02",
    useControls: "Gunakan kawalan pada BitBox02 anda untuk menetapkan kata laluan."
  },
  stepUninitialized: {
    create: "Saya mahu menyiapkan BitBox02 baru",
    restore: "Saya mahu memulihkan dompet saya daripada sandaran.",
    restoreMicroSD: "Pulihkan daripada kad microSD",
    restoreMnemonic: "Pulihkan daripada perkataan pemulihan",
    title: "Sediakan BitBox02 anda"
  },
  success: {
    text: `Hooray! BitBox02 anda kini siap untuk digunakan.

Untuk maklumat lanjut mengenai cara menggunakan aplikasi BitBox, sila gunakan panduan dalam aplikasi dengan mengklik tanda tanya di sudut kanan atas.`,
    title: "Anda sudah bersedia untuk pergi!"
  }
}, blink$b = {
  button: "Berkedip"
}, bootloader$b = {
  button: "Naik taraf Firmware sekarang",
  button_install: "Pasang firmware sekarang",
  progress: "Menaiktaraf: {{progress}}%",
  progress_install: "Memasang: {{progress}}%",
  success: "Naik taraf berjaya! Sila pasang ulang peranti. Kali ini, jangan sentuh butang."
}, button$f = {
  abort: "Tinggalkan",
  back: "Kembali",
  buy: "Beli",
  changepin: "Ubah kata laluan peranti",
  check: "Semak Backup",
  continue: "Teruskan",
  copy: "Menyalin",
  create: "Buat",
  dismiss: "Batalkan",
  done: "Selesai",
  download: "Muat turun",
  hiddenwallet: "Buat wallet tersembunyi",
  next: "Berikut",
  ok: "OK",
  previous: "Sebelumnya",
  receive: "Terima",
  restore: "Memulihkan",
  select: "Pilih",
  send: "Hantar",
  unlock: "Buka",
  update: "Kemas kini",
  upgrade: "Naik taraf"
}, buy$7 = {
  exchange: {
    bankTransfer: "Transfer bank",
    bestDeal: "Tawaran terbaik",
    creditCard: "Kad kredit",
    fast: "Cepat",
    fee: "bayaran",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Pemindahan bank: {{fee}}%",
          creditDebitCard: "Kad kredit/debit: {{fee}}%",
          learnMore: "Ketahui lebih lanjut tentang Moonpay",
          title: "Bayaran"
        },
        fullCurrenciesList: "Lihat senarai penuh mata wang di sini",
        payment: {
          asteriskText: "* Tidak tersedia untuk penduduk AS",
          bankTransfer: "Transfer bank*",
          bankTransferDetails: {
            pix: "PIX (transaksi BR di Brasil sahaja)",
            sepa: "SEPA dan SEPA Instant (transaksi EUR di negara-negara SEPA sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          creditDebitCard: "Kad kredit/debit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa dan Maestro"
          },
          learnMore: "Lihat butiran lanjut tentang kaedah pembayaran",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong semua mata wang fiat utama: USD, EUR, CHF dan lain-lain."
      },
      pocket: {
        fees: {
          info: "Transfer bank: {{fee}}%",
          title: "Bayaran"
        },
        learnMore: "Ketahui lebih lanjut tentang Pocket",
        payment: {
          bankTransfer: "Transfer bank",
          bankTransferDetails: {
            sepa: "SEPA dan SEPA Segera (urus niaga EUR di negara SEPA sahaja)",
            sic: "Swiss Interbank Clearing (transaksi CHF di CH/LI sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          bankTransferReccuring: "Bagaimana cara menyiapkan pembelian berkala dengan standing order?",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong mata wang Eropah: EUR, GBP dan CHF.",
        verification: {
          info: "Hanya memerlukan pengesahan identiti melebihi ambang harian dan tahunan.",
          link: "Cari ambang semasa di sini",
          title: "Pengesahan identiti"
        }
      },
      region: {
        title: "Pilih wilayah akaun bank anda didaftarkan untuk melihat pilihan yang tersedia untuk anda."
      }
    },
    noExchanges: "Maaf, tiada pertukaran tersedia di rantau ini.",
    region: "Wilayah",
    selectRegion: "Tidak dinyatakan",
    title: "Beli {{name}}"
  },
  info: {
    continue: "Setuju dan teruskan",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "Kami bekerjasama dengan MoonPay untuk menawarkan anda cara yang lancar untuk membeli {{name}} terus dalam BitBoxApp. Ia hanya beberapa klik.",
        "MoonPay ialah platform yang memudahkan dan cepat untuk membeli {{name}} di lebih 160+ negara."
      ],
      payment: {
        details: "Anda boleh beli {{name}} serta-merta melalui MoonPay dengan kaedah pembayaran berikut. Pesanan kad kredit atau debit adalah segera dan mudah, tetapi lebih mahal disebabkan peningkatan risiko caj balik. Kami mengesyorkan menggunakan pilihan pindahan bank untuk jumlah yang lebih besar. Yuran minimum ialah 4 USD/EUR atau setara.",
        footnote: "Sila ambil perhatian bahawa kadar pertukaran MoonPay boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
        table: {
          "1_description": "Yuran terendah, boleh mengambil masa sehingga 3 hari bekerja",
          "1_method": "Pindahan bank (SEPA)",
          "2_description": "Yuran yang lebih tinggi tetapi cepat dan segera",
          "2_method": "Kad kredit & debit",
          description: "Penerangan",
          fee: "Yuran",
          method: "Kaedah"
        },
        title: "Kaedah pembayaran dan yuran"
      },
      privacyPolicy: "Dasar privasi MoonPay",
      protection: {
        description: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana masuk dianggap seperti transaksi biasa. MoonPay perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
        descriptionGeneric: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana yang masuk dianggap seperti transaksi biasa. Bagaimanapun pertukaran rakan kongsi perlu mengumpul beberapa maklumat untuk beroperasi. Sila rujuk dasar privasi masing-masing untuk melihat dengan lebih terperinci cara data dikendalikan.",
        title: "Perlindungan Data"
      },
      security: {
        description: "Apabila anda membeli {{name}} melalui MoonPay, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        descriptionGeneric: "Apabila anda membeli {{name}} melalui pertukaran rakan kongsi, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        link: 'Model "security threat"',
        title: "Model security"
      },
      title: ""
    },
    next: "Seterusnya",
    selectLabel: "Pilih akaun anda",
    selectPlaceholder: "Pilih syiling",
    skip: "Jangan tunjukkan lagi",
    title: "Beli {{name}}"
  },
  pocket: {
    data: {
      link: "Dasar privasi poket",
      p1: "BitBoxApp tidak mengumpul sebarang data semasa membeli bitcoin, dana masuk dianggap seperti transaksi biasa. Pocket perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
      title: "Perlindungan Data"
    },
    kyc: {
      link: "Baca Soalan Lazim Poket",
      p1: "Pocket cuba mengekalkan KYC pada tahap minimum. Untuk pembelian di bawah 950 EUR (1000 CHF) sehari, tiada dokumen tambahan diperlukan. Untuk pembelian melebihi jumlah ini, anda perlu menjadualkan panggilan dengan Pocket untuk melengkapkan proses KYC/AML yang diperlukan.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Anda boleh membeli bitcoin serta-merta dengan Pocket melalui pindahan bank SEPA. Yuran adalah 1.5% dan bitcoin didepositkan ke BitBox anda secepat mungkin selepas Pocket menerima pindahan bank (biasanya dalam hari yang sama).",
      p2: "Sila ambil perhatian bahawa kadar pertukaran Pocket boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
      title: "Kaedah pembayaran dan yuran"
    },
    previousTransactions: "Sejarah transaksi akaun ini tidak kosong. Berkongsi akaun ini akan menjadikan semua urus niaga masa lalu dan masa depannya kelihatan untuk Pocket. Teruskan juga?",
    security: {
      link: "Model ancaman keselamatan BitBox02",
      p1: "Apabila anda membeli bitcoin melalui Pocket, anda menggunakan perkhidmatan luaran. Perkhidmatan ini di luar skop model Ancaman Keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran yang dijalankan oleh perisian BitBoxApp. Walau bagaimanapun, kami bekerjasama untuk meningkatkan keselamatan dengan menggunakan mekanisme pengesahan dua faktor untuk mengesahkan alamat anda menerima ke.",
      title: "Model keselamatan"
    },
    usedAddress: "Alamat {{address}} telah digunakan, sila mulakan semula dengan alamat baharu.",
    verifyBitBox02: "Sila sahkan bahawa alamat yang anda terima melalui e-mel sepadan dengan alamat yang dipaparkan pada Bitbox anda. Jika boleh, anda harus membuka e-mel pada peranti kedua untuk keselamatan yang lebih baik.",
    welcome: {
      p1: "Kami bekerjasama dengan Pocket untuk menawarkan anda cara yang lancar untuk membeli bitcoin terus dalam BitBoxApp. Ia hanya beberapa klik.",
      p2: "Pocket ialah platform Switzerland yang menjadikannya cepat dan mudah untuk membeli bitcoin di kebanyakan Eropah (di mana-mana sahaja di mana pemindahan bank SEPA disokong).",
      p3: "Dengan Pocket, anda juga boleh melakukan pembelian biasa melalui pesanan bank tetap, jadi anda boleh DCA (purata kos dolar) dengan mudah.",
      title: "Selamat datang ke kedai sehenti anda untuk membeli bitcoin"
    }
  },
  title: "Beli {{name}}"
}, changePin$b = {
  newTitle: "Kata laluan peranti baru",
  oldLabel: "Kata laluan peranti terkini"
}, chart$7 = {
  dataMissing: "Mengumpul data sejarah... nantikan.",
  dataOldTimestamp: "Pengemaskinian kadar pertukaran sejarah. Carta tidak memaparkan data selepas {{time}}.",
  dataUpdating: "mengemas kini data",
  filter: {
    all: "Semua",
    month: "Bulan",
    week: "Minggu",
    year: "Tahun"
  }
}, checkSDcard$b = "memeriksa kad micro SD", clickHere$b = "Tekan di sini.", confirm$d = {
  abortInfo: "Sentuh untuk ",
  abortInfoRedText: "tinggalkan",
  approveInfo: "Tahan 4 detik untuk ",
  approveInfoGreenText: "sahkan",
  info: "Pada BitBox anda",
  infoWhenPaired: "Mula-mula pada telefon mudah alih yang dipasangkan dan kemudian BitBox anda"
}, confirmOnDevice$b = "Sila sahkan pada peranti anda.", connectKeystore$5 = {
  promptNoName: "Sila sambungkan BitBox02 anda untuk meneruskan",
  promptWithName: 'Sila sambungkan BitBox02 anda bernama "{{name}}" bersambung'
}, darkmode$6 = {
  toggle: "Mod gelap"
}, device$b = {
  appUpradeRequired: "BitBox anda tidak sesuai dengan aplikasi desktop ini. Sila muat turun dan pasang versi terkini."
}, deviceLock$b = {
  button: "Membolehkan Pengesahan Dua Langkah (2FA)",
  condition1: "Adakah anda mempunyai backup?",
  condition2: "Apakah pengesahan aplikasi mudah alih berfungsi?",
  condition3: "2FA MENYAHAKTIFKAN backup dan pemasangan aplikasi. Peranti mesti DITETAPKAN SEMULA untuk keluar dari 2FA!",
  confirm: "Membolehkan Pengesahan Dua Langkah (2FA)",
  title: "Membolehkan Pengesahan Dua Langkah (2FA)"
}, deviceSettings$b = {
  backups: {
    manageBackups: {
      description: "Cipta atau sahkan sandaran kad microSD anda."
    },
    showRecoveryWords: {
      description: "Tunjukkan dan sahkan perkataan pemulihan."
    },
    title: "Sandaran"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp menyemak sama ada peranti anda adalah tulen."
    },
    deviceName: {
      description: "Tukar nama peranti anda."
    },
    rootFingerprint: {
      description: "Root fingerprint ialah pengecam unik untuk dompet yang sedang digunakan. Root fingerpri boleh membantu anda membezakan antara dompet yang berbeza jika anda menggunakan frasa laluan."
    },
    securechip: {
      description: "Model cip selamat."
    },
    title: "Maklumat peranti"
  },
  expert: {
    factoryReset: {
      description: "Tetapkan semula peranti anda kepada tetapan kilang. Ini memadamkan dompet daripada BitBox02 anda!",
      title: "Tetapan semula kilang"
    },
    goToStartupSettings: {
      description: "Masukkan pemuat but BitBox02. Anda boleh mendayakan cincang perisian tegar dari sini."
    },
    passphrase: {
      description: "Dayakan atau lumpuhkan ciri frasa laluan.",
      title: "Ungkapan laluan"
    }
  },
  firmware: {
    firmwareVersion: "Versi Perisian Tegar",
    newVersion: {
      label: "Versi yang tersedia"
    },
    title: "Firmware",
    upToDate: "Peranti anda adalah yang terkini",
    upgradeAvailable: "Peningkatan baharu tersedia",
    version: {
      label: "Versi"
    }
  },
  hardware: {
    attestation: {
      false: "Semakan ketulenan gagal",
      label: "Semakan ketulenan",
      true: "BitBox02 anda adalah sahih"
    },
    sdcard: {
      false: "Belum dimasukkan",
      label: "Kad micro SD",
      true: "Telah dimasukkan"
    },
    securechip: "Cip selamat",
    title: "Hardware"
  },
  loading: "Mengambil maklumat peranti ...",
  pairing: {
    lock: {
      false: "dinyahaktifkan",
      label: "Pengesahan Dua Langkah (2FA)",
      true: "Diaktifkan"
    },
    mobile: {
      false: "Ditutup",
      label: "Aplikasi Mudah Alih",
      true: "Buka"
    },
    status: {
      false: "Belum dipasangkan",
      label: "Status",
      true: "Dipasangkan"
    },
    title: "Memasang"
  },
  secrets: {
    manageBackups: "Urus Backup",
    title: "Rahsia"
  }
}, deviceTampered$b = "Apakah BitBox anda dibekalkan dengan kata laluan pemulihan? Jika ya, hentikan proses persediaan dan hubungi sokongan segera. Shift tidak akan memberikan anda dompet siap pakai atau membuat cadangan kata laluan.", dialog$c = {
  cancel: "Batal",
  confirm: "Sahkan",
  confirmTitle: "Pengesahan"
}, error$7 = {
  accountAlreadyExists: "Akaun sudah wujud.",
  accountLimitReached: "Tidak boleh menambah akaun. Bilangan maksimum akaun untuk syiling ini telah dicapai.",
  aoppCallback: "Terdapat ralat menghantar alamat kepada {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "Tiada akaun tersedia.",
  aoppSigningAborted: "Permintaan pemilikan alamat dibatalkan.",
  aoppUnknown: "Ralat tidak diketahui berlaku.",
  aoppUnsupportedAsset: "Aset tidak disokong.",
  aoppUnsupportedFormat: "Tiada akaun tersedia yang menyokong format alamat yang diminta.",
  aoppUnsupportedKeystore: "Peranti yang disambungkan tidak boleh menandatangani mesej untuk aset ini.",
  aoppVersion: "Versi tidak diketahui.",
  wrongKeystore: "Dompet salah disambungkan. Sila pastikan anda memasukkan peranti yang betul yang sepadan dengan akaun ini.",
  wrongKeystore2: " Jika anda menggunakan frasa laluan pilihan, pastikan anda telah memasukkan frasa laluan yang betul untuk akaun tersebut."
}, fiat$d = {
  default: "tetapan standard",
  setDefault: "Tetapkan {{code}} sebagai tetapan standard",
  title: "Mata wang"
}, footer$d = {
  appVersion: "Versi App:"
}, generic$7 = {
  enabled_false: "Dinyahaktifkan",
  enabled_true: "Diaktifkan"
}, genericError$b = "Kesalahan muncul. Sekiranya anda melihat sebarang masalah, sila mulakan semula aplikasi.", goal$b = {
  buttons: {
    create: "Buat wallet baru",
    restore: "Pulihkan wallet dari backup"
  },
  paragraph: "Sila pilih salah satu pilihan berikut:",
  step: {
    1: {
      title: "Maklumat Keselamatan"
    },
    2: {
      description: "Tetapkan kata laluan peranti",
      title: "Peranti"
    },
    "3-create": {
      description: "Buat wallet baru",
      title: "Wallet"
    },
    "3-restore": {
      description: "dari backup",
      title: "Memulihkan"
    },
    "4-create": {
      title: "Ringkasan"
    },
    "4-restore": {
      title: "Ringkasan"
    }
  }
}, guide$c = {
  accountDescription: {
    text: "Ini adalah gambaran keseluruhan akaun anda. Ia menunjukkan transaksi masuk dan keluar. Baki dipaparkan untuk setiap akaun secara berasingan. Rujuk panduan dalam tetapan untuk mengetahui lebih lanjut mengenai jenis akaun yang berlainan.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountFiat: {
    text: "Ya, anda boleh mengklik ticker mana sahaja untuk berputar melalui beberapa mata wang fiat. Anda juga boleh menukar senarai mata wang dalam tetapan.",
    title: "Bolehkah saya memaparkan kadar penukaran lain?"
  },
  accountIncomingBalance: {
    text: "Jumlah yang akan masuk dan akan dipindahkan kepada anda tetapi belum disahkan oleh rangkaian.",
    title: "Apakah maksud akan masuk?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Setiap xpub terikat dengan "Jenis" yang ditunjukkan: sama ada "Segwit Asli (bech32)", "Segwit Terbungkus" atau "Taproot" (Bitcoin sahaja). Ini adalah jenis skrip yang digunakan oleh {{coinName}}. BitBoxApp menggabungkannya, menyokong berbilang jenis skrip dalam akaun yang sama. Kerana setiap jenis skrip memberikan xpub yang berbeza, terdapat berbilang xpub bagi setiap akaun.

Jika anda menerima secara konsisten pada alamat lalai (Native Segwit), anda hanya memerlukan xpub "bech32". Walau bagaimanapun, jika anda turut menerima dana untuk "Wrapped Segwit" atau "Taproot", anda juga perlu menggunakan kunci awam lanjutan "Wrapped Segwit" dan "Taproot".`,
      title: "Mengapa terdapat banyak xpub?"
    },
    privacy: {
      text: `Untuk akaun khusus ini, kunci awam lanjutan mendedahkan keseluruhan sejarah kewangan, baki akaun anda dan semua urus niaga masa hadapan. Tetapi xpub tidak membenarkan sesiapa membelanjakan syiling anda.

Jika anda memberikan xpub kepada seseorang, anda harus sedar bahawa orang atau syarikat ini boleh melihat semua transaksi lain akaun yang sama. Oleh itu, adalah idea yang baik untuk menggunakan akaun itu hanya untuk tujuan ini dan menyimpan dana lain dalam akaun yang berbeza.`,
      title: "Adakah saya perlu merahsiakan xpub saya?"
    },
    verify: {
      text: "Ya, adalah idea yang baik untuk menyemak semula xpub anda. Jika orang lain akan menjana alamat terima daripada xpub ini untuk menghantar wang kepada anda, ini amat penting. Anda perlu mengesahkannya pada peranti untuk memastikan bahawa xpub ini kepunyaan anda; jika tidak, semua dana boleh pergi ke alamat yang salah.",
      title: "Adakah saya perlu mengesahkan xpub pada peranti?"
    },
    xpub: {
      text: `Public Key Lanjutan adalah kunci akar yang mana semua alamat penerima sebuah akaun diperoleh.
Ia disediakan di sini untuk kegunaan lanjutan dan saling kendalian dengan wallet yang hanya boleh dilihat sahaja, seperti Electrum atau Sentinel.`,
      title: "Apa itu Public Key Lanjutan?"
    }
  },
  accountRates: {
    text: "Kadar pertukaran dikemas kini setiap minit oleh CoinGecko.",
    title: "Kadar mana yang digunakan?"
  },
  accountReload: {
    text: "Semua maklumat transaksi dikemas kini secara automatik.",
    title: "Bagaimanakah saya dapat memuatkan semula sejarah transaksi?"
  },
  accountSendDisabled: {
    text: "Butang 'Hantar' diaktifkan apabila baki anda tidak kosong.",
    title: "Mengapa saya tidak dapat menghantar sebarang {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Jumlah keseluruhan ialah jumlah semua akaun crypto anda. Kadar pertukaran diperoleh daripada coingecko.com.

Nota: Jika anda menggunakan MyEtherWallet untuk token yang tidak disokong dalam BitBoxApp, ia tidak akan dimasukkan dalam jumlah yang dipaparkan.`,
    title: "Bagaimanakah jumlah keseluruhan dikira?"
  },
  accountSummaryDescription: {
    text: "Di sini anda boleh melihat prestasi portfolio anda dari semasa ke semasa. Ringkasan akaun crypto individu anda dipaparkan di bawah carta.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountTransactionAttributesBTC: {
    text: `Saiz maya: Digunakan untuk menentukan yuran rangkaian. Anda telah berjaya menyimpan yuran jika ia lebih kecil daripada saiz transaksi.
Saiz: Saiz transaksi yang sebenarnya dalam bait apabila disirikan mengikuti blockchan yang mendasarinya.
Berat: Diperkenalkan dengan Segwit, itu adalah metrik baru untuk menilai saiz transaksi dan blok. Setiap bait saksi yang dipisahkan dianggap sebagai satu, semua yang lain sebagai empat unit berat. Dibandingkan satu megabyte dalam saiz sebenarnya, had saiz blok kini adalah empat juta unit berat.`,
    title: "Butiran transaksi yang berkaitan dengan Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: `Pengesahan: Apabila transaksi anda disiarkan buat kali pertama, ia tidak akan disahkan terlebih dahulu. Anda perlu menunggu untuk dimasukkan ke dalam blok oleh pelombong, selepas itu ia akan mempunyai 1 pengesahan. Setiap blok yang disiarkan di rangkaian selepas itu akan menambah pengesahan lain ke transaksi anda. Secara umum pedagang dan pelaku rangkaian lain hanya akan menerima transaksi dengan pengesahan 3-6 sebelum mempertimbangkan transaksi sebagai selesai.
ID Transaksi: Nombor pengenalan unik yang boleh digunakan untuk mencari transaksi dalam blok explorer.
Yuran: Pelombong dibayar yuran transaksi sebagai insentif untuk memasukkan transaksi di blok-blok yang mereka laksanakan. Untuk mengetahui lebih lanjut, klik pada butang hantar.`,
    title: "Apa makna daripada maklumat yang ditunjukkan dalam butiran transaksi?"
  },
  accountTransactionConfirmation: {
    text: "Ini adalah transaksi yang telah disiarkan ke rangkaian dan sedang menunggu untuk disahkan.",
    title: "Apa itu transaksi yang tertunda?"
  },
  accountTransactionLabel: {
    text: "Ia adalah alamat di mana anda menerima syiling atau menghantar syiling itu. Satu alamat menyandi bagaimana (dan dengan demikian oleh siapa) syiling dapat dibelanjakan.",
    title: "Alamat mana yang dipaparkan untuk setiap transaksi?"
  },
  accountTransactionTime: {
    text: "Masa daripada transaksi yang telah disahkan di blokchain.",
    title: "Masa mana yang dipaparkan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Setiap syiling boleh mempunyai maksimum lima akaun.",
      title: "Berapa banyak akaun yang boleh saya buat?"
    },
    howtoAddTokens: {
      text: 'Token yang menggunakan standard ERC20 terikat pada akaun Ethereum tertentu. Untuk mendayakan atau melumpuhkan token tertentu, buka skrin "Urus akaun", kembangkan akaun Ethereum anda dan hidupkan atau matikan token yang dikehendaki.',
      title: "Bagaimanakah saya boleh menambah token tambahan?"
    },
    moveFunds: {
      text: "ya. Tetapi kerana akaun adalah bebas, anda perlu menghantar dana anda menggunakan transaksi biasa.",
      title: "Bolehkah saya memindahkan dana antara akaun?"
    },
    recoverAccounts: {
      text: "ya. BitBoxApp mencipta akaun menggunakan piawaian yang mantap yang serasi dengan kebanyakan dompet crypto lain.",
      title: "Bolehkah saya memulihkan akaun saya dengan dompet lain?"
    },
    whatAreAccounts: {
      text: "Dompet anda boleh mengurus berbilang akaun syiling yang sama. Akaun berguna apabila anda ingin mengasingkan dana.",
      title: "Apakah akaun?"
    },
    whyIsThisUseful: {
      text: 'Akaun bagus untuk mengurus dana untuk orang atau tujuan yang berbeza kerana ia dipisahkan. Anda juga boleh berkongsi "kunci awam lanjutan" akaun tanpa mendedahkan apa-apa tentang akaun anda yang lain. Ini membolehkan anda berulang kali menerima dana tanpa menggunakan semula alamat, seperti menerima gaji anda atau kerap membeli kripto.',
      title: "Mengapa ini berguna?"
    }
  },
  appendix: {
    link: "Hubungi kami!",
    text: "Soalan lain?"
  },
  backups: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda. Ia juga boleh digunakan untuk mengesahkan bahawa anda masih mempunyai kata laluan pemulihan yang betul. Anda dapat menyemak kata laluan pemulihan utama atau tersembunyi anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak, tetapi kata laluan pemulihan diperlukan untuk memperoleh wallet dari benih yang disimpan.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    howOften: {
      text: `Cadangan dibuat secara automatik apabila dompet baru dibuat. Anda hanya perlu membuat backup baru jika kad micro SD anda hilang atau rosak, atau jika anda mahu menggunakan lebih daripada satu kad micro SD sebagai backup.
Anda tidak perlu membuat backup baru selepas aktiviti transaksi. Semua data transaksi anda dapat diciptakan oleh backup tunggal anda yang dijana secara automatik untuk anda.`,
      title: "Berapa kerap saya perlu membuat backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad micro SD. Benih bersama-sama dengan kata laluan pemulihan menjana dompet anda.",
      title: "Apa itu backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak. Sila simpan kad SD mikro dengan selamat, kerana ia mengandung benih yang tidak disenarai untuk memulihkan dompet anda.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad microSD.",
      title: "Apakah backup itu?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Apabila 2FA dihidupkan, semua transaksi perlu diluluskan pada telefon mudah alih yang dipasangkan untuk membelanjakan duit syiling. Di bawah tudung, nombor guna tunggal yang disulitkan dihantar ke aplikasi mudah alih, disahsulitkan di sana, dan kembali ke BitBox dengan menekan butang Terima. Komunikasi dengan peranti ini dilakukan melalui saluran antara telefon mudah alih dan aplikasi desktop ini yang ditubuhkan semasa berpasangan.

Pastikan anda telah membackup wallet anda dan pasangkan aplikasi mudah alih sebelum menghidupkan 2FA. Setelah dihidupkan, slot micro SD dan pasangan aplikasi mudah alih akan dimatikan. Mereka boleh diaktifkan semula dengan menetapkan semula BitBox, yang mana akan menghapuskan peranti tersebut.`,
      title: "Bagaimanakah Pengesahan Dua Langkah (2FA) berfungsi?"
    },
    disable2FA: {
      text: "Untuk mematikan 2FA, anda perlu menetapkan semula BitBox anda dan kemudian memulihkan wallet dari backupnya. Pastikan anda masih mempunyai kad micro SD dengan backup dan bahawa anda masih ingat kata laluan pemulihan anda. Kemudian tekan 'Tetapkan semula Peranti'. Lalu tetapkan kata laluan peranti baru dan pilih 'Atau Pulihkan Backup'. Pilih backup yang telah anda buat dari wallet, klik 'Pulihkan' dan masukkan kata laluan pemulihan yang anda gunakan semasa membuat dompet.",
      title: "Bagaimanakah saya dapat mematikan Pengesahan Dua Langkah (2FA)?"
    },
    ejectBitbox: {
      text: "Anda boleh mencabut BitBox bila-bila masa tanpa perlu mengklik ikon 'Selamat Lepaskan Perkakasan' terlebih dahulu.",
      title: "Bagaimana saya dapat menarik keluar BitBox?"
    },
    ejectSD: {
      text: "Anda dapat menyingkirkan micro SD kad dari BitBox kapanpun selama anda tidak menciptakan atau memulihkan sebuah backup",
      title: "Bagaimana saya dapat mengeluarkan kad micro SD?"
    },
    hiddenWallet: {
      text: "Ia adalah wallet kedua pada peranti yang sama yang dilindungi oleh kata laluan peranti dan kata laluan pemulihan yang berlainan, yang boleh anda gunakan untuk tujuan penafian yang munasabah. Dikeranakan penggunaan benih backup yang sama untuk wallet biasa dan tersembunyi anda, tiada tambahan backup diperlukan.",
      title: "Apa itu wallet tersembunyi?"
    },
    legacyHiddenWallet: {
      text: "Mula-mula klik butang di bawah (tersedia jika BitBox dikunci dengan kata laluan peranti utama dan 2FA dinyahdayakan), kemudian pasang kembali Bitbox dan buka dengan kata laluan peranti tersembunyi anda.",
      title: "Bagaimanakah saya dapat mengakses legacy wallet tersembunyi?"
    },
    pairing: {
      text: "Selepas memuat turun aplikasi mudah alih kami untuk iOS atau Android, anda dapat menubuhkan saluran selamat antara aplikasi mudah alih dan aplikasi ini dengan mengimbas kod QR yang dipaparkan. Setelah diimbas, ikut arahan dalam aplikasi mudah alih.",
      title: "Bagaimana memasangkan dengan selamat telefon anda"
    }
  },
  cointracking: {
    text: 'Klik butang "Eksport" dan buka folder muat turun di mana anda akan menemui eksport CSV. Kemudian klik pautan di bawah, muat naik fail CSV BitBox anda dan import data untuk menggunakannya untuk pengurus portfolio CoinTracking anda dan untuk membuat laporan cukai anda.',
    title: "Bagaimana untuk mengimport urus niaga saya ke dalam CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Baca lebih lanjut mengenai semakan ketulenan"
      },
      text: "BitBoxApp menjalankan semakan pengesahan pada BitBox02 untuk mengesahkan sama ada peranti itu tulen. Semakan dilakukan secara tempatan dan tidak bersambung ke mana-mana pelayan.",
      title: "Bagaimanakah semakan ketulenan berfungsi?"
    },
    name: {
      text: "Ini adalah nama dompet dan sandaran anda. Nama itu digunakan untuk sandaran masa hadapan dan boleh digunakan untuk membantu membezakan antara dompet yang berbeza. Ia boleh ditukar pada bila-bila masa tetapi ambil perhatian bahawa sandaran yang dibuat sebelum perubahan masih akan menggunakan nama sebelumnya.",
      title: "Apakah nama BitBox02 digunakan?"
    },
    "secure-chip": {
      link: {
        text: "Baca lebih lanjut mengenai cip selamat"
      },
      text: "Maklumat ini menunjukkan nombor model cip selamat, cip paling terkini ialah ATECC608B dengan ciri keselamatan yang dipertingkatkan berbanding model lama.",
      title: "Mengapa tunjukkan model cip selamat?"
    }
  },
  receive: {
    address: {
      text: `Berikan kepada orang lain untuk menghantarkan anda beberapa syiling.
(Sentiasa sahkan alamat secara mandiri, contohnya dengan panggilan telefon.)`,
      title: "Apa yang boleh saya lakukan dengan alamat?"
    },
    addressChange: {
      text: "Selepas alamat digunakan dalam sebuah transaksi, alamat baru akan ditambah ke senarai untuk menggantikannya. Setiap masa terdapat 20 alamat yang belum digunakan dalam senarai.",
      title: "Bila alamat berubah?"
    },
    addressFormats: {
      text: "Secara lalai, jenis alamat ialah Segwit Asli. Jenis alamat ini digunakan secara meluas oleh dompet/pertukaran lain dan memberikan anda kadar yuran terbaik untuk transaksi harian. Walau bagaimanapun, anda juga boleh memilih untuk menghantar kepada Taproot (Bitcoin sahaja), yang merupakan jenis alamat terbaharu, tetapi mungkin belum disokong secara meluas lagi. Sebagai alternatif, jika anda menghadapi masalah menghantar kepada Native Segwit (jenis lalai), anda boleh cuba bertukar kepada jenis alamat Wrapped Segwit yang lebih lama yang mungkin serasi dengan lebih banyak dompet/pertukaran.",
      title: 'Bilakah saya menggunakan "Tukar jenis alamat"?'
    },
    howVerify: {
      text: "Klik ikon BitBox pada bar sisi di sebelah kiri dan lihat bahagian Pemasangan. Panduan akan dikemas kini dan anda boleh terus mengikuti arahan dari sana.",
      title: "Bagaimana saya dapat mengesahkan alamat dengan selamat?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda menghantar syiling ke alamat BitBox anda, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menerima?"
    },
    why20: {
      text: 'Semasa permulaan apl menjana alamat yang diperoleh daripada benih anda untuk melihat sama ada mereka telah menerima dana. Memandangkan apl boleh menjana bilangan alamat yang hampir tidak terhingga, ia boleh menghabiskan masa bertahun-tahun untuk menentukan baki. Untuk mengehadkan carian ini ia berhenti selepas ia melihat 20 alamat yang tidak pernah menerima dana. Ini ialah "had jurang" dan 20 ialah piawaian de-facto walaupun bilangannya adalah sewenang-wenangnya. Ini ialah 20 alamat yang boleh anda pilih.',
      title: "Mengapa hanya 20 alamat?"
    },
    whyMany: {
      text: "Untuk sebab-sebab privasi dan keselamatan, anda tidak perlu menyerahkan alamat yang sama dua kali. Klik 'Berikut' untuk mendapatkan alamat baru untuk tujuan yang berbeza. Anda boleh menjana hingga 20 alamat dalam satu masa. Semua alamat diperoleh dari biji backup tunggal anda. (Bayangkan alamat seperti nombor invois.)",
      title: "Mengapa terdapat banyak alamat?"
    },
    whyVerify: {
      text: "Salah satu sebab untuk membeli wallet hardware seperti BitBox ialah anda tidak boleh mempercayai komputer anda kerana permukaan serangan yang besar. Oleh itu, anda tidak boleh mempercayai komputer anda untuk menjana dan memaparkan alamat yang sahih. Butang untuk mengesahkan alamat dengan selamat membuat BitBox menghantar alamat ke telefon mudah alih yang dipasangkan, dari mana anda juga boleh mengimbas dan mengesahkan kod QR.",
      title: "Mengapa saya perlu mengesahkan alamat dengan selamat?"
    }
  },
  send: {
    change: {
      text: "Perubahan akan dikembalikan ke alamat Taproot jika anda mempunyai sekurang-kurangnya satu Taproot UTXO. Jika anda menggunakan kawalan syiling, perubahan akan dikembalikan ke alamat Taproot jika terdapat sekurang-kurangnya satu Taproot UTXO antara UTXO yang dipilih. Dalam semua kes lain, perubahan dikembalikan ke alamat Segwit Asli.",
      title: "Bagaimanakah output perubahan ditentukan?"
    },
    fee: {
      text: `Yuran ini didasarkan pada saiz data transaksi dan bukan jumlahnya. Sasaran yuran dikira oleh algoritma pengiraan yuran Bitcoin Core untuk setiap keutamaan rangkaian yang anda pilih. Mereka ditunjukkan jika mereka mempunyai nilai yang berbeza dari sasaran di bawah.
Ekonomi: 24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)
Rendah: 12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)
Normal: 6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)
Tinggi: 2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)
(Blok mengambil purata sepuluh minit untuk Bitcoin (2.5 minit di Litecoin) untuk melombong dan beban rangkaian mungkin berbeza-beza untuk tempoh di atas.)`,
      title: "Bagaimanakah bayaran ditentukan?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda membuat transaksi, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menghantar?"
    },
    priority: {
      text: "Semakin tinggi yuran yang anda bayar, semakin cepat transaksi anda disahkan oleh rangkaian.",
      title: "Apa itu keutamaan rangkaian?"
    },
    revert: {
      text: `Selepas sebuah transaksi ditandatangani dan dihantar (disiarkan ke rangkaian), ia tidak dapat lagi dipulangkan. Periksa ulang transaksi (termasuk yurannya) dengan teliti sebelum menandatangani!
Sekiranya anda tahu sang penerima dan dia akan menghantar jumlah yang sama (dikurang yuran transaksi) kepada anda, anda boleh menghantar kepadanya alamat penerima yang baru.`,
      title: "Dapatkah saya memulangkan transaksi?"
    },
    whyFee: {
      text: `Transaksi bersaing untuk disahkan oleh penambang. Pelombong memilih transaksi untuk dimasukkan ke dalam blok yang berdasarkan yuran mereka.
Miners mengundi untuk sejarah transaksi. Dikeranakan tidak ada pihak ketiga yang dipercayai untuk menguatkuasakan satu undi bagi setiap orang (yang merupakan titik keseluruhan blok), penambang mengundi transaksi dengan mengorbankan sumber yang mahal seperti daya pengkomputeran. Sebagai hadiah untuk kerja mereka, mereka boleh menuntut duit syiling yang baru dibuat dan yuran dari semua transaksi yang mereka sertakan.`,
      title: "Mengapa ada yuran rangkaian?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Jika anda berhasrat untuk menyambung ke nod anda sahaja apabila anda berada di rangkaian yang sama (cth. wifi rumah anda), maka menggunakan komunikasi rangkaian biasa sudah memadai.
Dalam kes ini, adalah dinasihatkan bahawa pelayan Electrum anda menyediakan sijil TLS untuk menyulitkan komunikasi.
Jika anda berhasrat untuk menyambung ke nod anda dari mana-mana sahaja, menggunakan Tor ialah pilihan yang lebih baik. Tiada sijil TLS diperlukan dalam kes itu.`,
      title: "Sekiranya saya menggunakan clearnet TCP, TLS atau Tor?"
    },
    instructions: {
      link: {
        text: "Panduan untuk menyambungkan nod anda"
      },
      text: "Untuk tutorial penuh, sila lawati panduan kami:",
      title: "Bagaimanakah cara saya menyambungkan BitBoxApp saya ke nod penuh saya sendiri?"
    },
    options: {
      text: `Terdapat pelbagai pilihan untuk menjalankan nod anda sendiri seperti membeli peranti siap, membina sendiri atau menjalankan Bitcoin Core.
Jika anda ingin menyambungkan BitBoxApp anda ke nod anda, pastikan ia menjalankan pelayan Electrum. Ini ialah program khusus yang membolehkan apl dompet berkomunikasi dengan nod penuh anda.
Pilihan yang disokong termasuk Electrs, Electrum Personal Server (EPS) atau Bitcoin Wallet Tracker (BTW).`,
      title: "Apakah pilihan yang ada untuk menjalankan nod?"
    },
    tor: {
      text: `Tor adalah singkatan kepada 'The Onion Router', iaitu perisian percuma dan sumber terbuka yang menawarkan banyak faedah privasi dan amat berguna apabila menggunakan Bitcoin.
Jika anda berhasrat untuk menyambung ke nod anda melalui Tor, pastikan Tor dipasang pada komputer anda dan kemudian dayakan Proksi Tor dalam tetapan BitBoxApp.
Pada kebanyakan sistem pengendalian terdapat dua cara untuk menjalankan Tor:
1. Pelayar Tor: muat turun dan buka Pelayar Tor. Ini akan membolehkan BitBoxApp menyambung ke rangkaian Tor dengan menetapkan port 9150 dalam tetapan proksi Tor.
2. Perkhidmatan latar belakang Tor: pasang daemon Tor, yang sentiasa berjalan di latar belakang. BitBoxApp kemudiannya boleh menyambung dengan menetapkan port 9050 dalam tetapan proksi Tor.`,
      title: "Apakah Tor, proksi Tor dan port mana yang harus saya gunakan?"
    },
    what: {
      text: "Adalah mungkin untuk menggerakkan dompet anda dengan nod penuh anda sendiri sebagai ganti menggunakan server Shift.",
      title: "Apakah ini?"
    },
    why: {
      text: `Menjalankan nod anda sendiri tidak perlu tetapi meningkatkan privasi dan mengurangkan keperluan untuk mempercayai orang lain.
Pertama, ini bermakna anda menggunakan Bitcoin secara lebih peribadi kerana BitBoxApp tidak akan menyambung ke pelayan kami untuk mengambil sejarah transaksi anda; sebaliknya ia akan mengambil maklumat tersebut daripada nod anda sendiri.
Kedua, menjalankan nod anda sendiri bermakna nod anda mengesahkan semua transaksi itu sendiri, memastikan peraturan konsensus dikuatkuasakan.`,
      title: "Mengapa saya perlu menjalankan nod saya sendiri?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (pendek kata 'sat') ialah unit terkecil Bitcoin. Satu Satoshi ialah seratus juta bitcoin (0.00000001 BTC). Ia dinamakan sempena pencipta Bitcoin, Satoshi Nakamoto.",
      title: "Apa itu Satoshi?"
    },
    servers: {
      text: `Aplikasi ini berkomunikasi dengan server Shift Crypto untuk memeriksa kemas kini, memuat transaksi, dan menghantar maklumat ke aplikasi mudah alih yang telah dipasangkan.
Di samping itu, ia mengambil kadar pertukaran terkini dari CoinGecko. (Penukaran dikira secara tempatan, tiada wang anda yang dihantar)`,
      title: "Server mana yang digunakan aplikasi ini?"
    }
  },
  title: "Panduan",
  toggle: {
    close: "Tutup panduan",
    open: "Panduan"
  },
  trackingModePortfolioChart: {
    text: "Pada desktop, tuding kursor pada carta. Pada mudah alih, pegang jari anda pada carta dan seret secara mendatar.",
    title: "Bagaimana untuk melihat nilai sejarah pada carta?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Anda perlu menetapkan semula peranti dan memulihkan wallet dari backup dengan menggunakan kata laluan pemulihan.",
      title: "Apa yang perlu saya lakukan jika saya lupa kata laluan peranti?"
    },
    reset: {
      text: "Anda telah memasukkan kata laluan peranti yang salah sebanyak 15 kali. Beberapa percubaan terakhir memerlukan sentuhan panjang pada peranti.",
      title: "Bagaimana menetapkan semula peranti?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Peranti mesti berkelip sekali apabila dimasukkan. Pastikan ia dimasukkan ke arah yang betul. Jika anda menghadapi masalah, sila hubungi kami melalui pautan di bawah.",
      title: "Peranti saya tidak diketahui"
    },
    getDevice: {
      link: {
        text: "Pesan sebuah BitBox"
      },
      text: "Anda boleh membeli BitBox di kedai online kami:",
      title: "Bagaimana saya boleh mendapatkan peranti?"
    },
    internet: {
      text: "Ya, sambungan internet diperlukan untuk menyegerakkan wallet, menghantar transaksi dan mendapatkan kadar pertukaran terkini.",
      title: "Apakah aplikasi ini memerlukan sambungan internet?"
    },
    lostDevice: {
      link: {
        text: "Pusat Backup"
      },
      text: "Anda boleh memulihkan akaun anda pada BitBox baru atau dengan pusat backup kami.",
      title: "Saya kehilangan peranti saya. Bagaimana sekarang?"
    },
    useWithoutDevice: {
      text: "Maaf, ini belum mungkin pada masa ini.",
      title: "Bolehkah saya menggunakan aplikasi tanpa peranti?"
    },
    welcome: {
      text: "Terima kasih kerana menggunakan aplikasi ini yang dibina oleh Shift Crypto dari Switzerland. Ia masih dalam versi beta dan kami menghargai apa-apa input yang anda perlu bagikan. Sila berikan maklum balas menggunakan pautan di bahagian bawah.",
      title: "Selamat datang ke aplikasi BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Jika anda menggunakan telefon/komputer baharu dengan BitBoxApp, maka anda perlu menyambung semula ke DApps. Anda kemudian akan melihat syiling anda pada dapp semula seperti biasa.",
      title: "Saya tidak melihat sambungan saya sebelum ini."
    },
    supportedNetworks: {
      text: "Pada masa ini, hanya mainnet Ethereum disokong menggunakan WalletConnect dalam BitBoxApp. Untuk menggunakan rantaian serasi EVM lain, sila gunakan dompet sambungan penyemak imbas Rabby.",
      title: "Apakah rangkaian yang disokong?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ialah protokol komunikasi untuk aplikasi web3. Ia membolehkan anda menyambung dengan mudah ke DApps berasaskan Ethereum dan dompet web tanpa menggunakan aplikasi pihak ketiga, yang amat berguna untuk pengguna Android BitBoxApp.",
      title: "Apakah itu WalletConnect?"
    }
  }
}, headerssync$b = {
  blocksSynced: "{{blocks}} blok telah disegerakkan"
}, hiddenWallet$b = {
  info1HTML: "Untuk tujuan penafian yang munasabah, wallet tersembunyi boleh dibuat dengan kombinasi kata laluan pemulihan dan kata laluan peranti yang <strong> berbeza </strong>.",
  info2HTML: "Tentukan kata laluan peranti dan kata laluan pemulihan yang anda mahu kaitkan dengan wallet tersembunyi anda di bawah ini. Kata laluan peranti dan kata laluan pemulihan mestilah <strong> berbeza </strong> daripada yang anda tentukan untuk wallet utama anda.",
  passwordLabel: "Kata laluan pemulihan tersembunyi",
  passwordPlaceholder: "Sila ulangi kata laluan pemulihan tersembunyi",
  pinLabel: "Kata laluan peranti tersembunyi",
  pinRepeatLabel: "Ulangi kata laluan peranti tersembunyi",
  pinRepeatPlaceholder: "Sila ulangi kata laluan peranti tersembunyi",
  success: "Dompet tersembunyi berjaya dibuat. Pasang ulang BitBox anda untuk membuka kuncinya."
}, initialize$b = {
  create: "Tetapkan kata laluan peranti",
  creating: "Menetapkan kata laluan peranti...",
  error: {
    e102: "Kata laluan peranti mestilah mengandung sekurang-kurangnya 4 aksara."
  },
  info: {
    description1: "Pilih kata laluan peranti anda. Ini akan digunakan untuk membuka kunci BitBox anda.",
    description2: "Anda boleh menggunakan nombor, huruf dan simbol. Kata laluan yang lebih panjang memberikan keselamatan yang lebih tinggi",
    description3: "Jika anda kehilangan kata laluan peranti, anda perlu menetapkan semula peranti anda dan memulihkan backup wallet anda.",
    subtitle: "Sekarang anda boleh menetapkan kata laluan peranti anda",
    title: "Memulakan peranti anda"
  },
  input: {
    label: "Kata laluan peranti",
    labelRepeat: "Ulangi kata laluan peranti",
    placeholderRepeat: "Sila ulangi kata laluan peranti"
  }
}, invalidFormat$b = "Format tidak sah", language$c = {
  title: "Pilih Bahasa"
}, legacyhiddenwallet$b = {
  disable: "Matikan Legacy Hidden Wallet",
  enable: "Aktifkan Legacy Hidden Wallet",
  successDisable: "Berjaya melumpuhkan legacy hidden wallet",
  successEnable: "Berjaya menyahaktifkan wallet legacy tersembunyi. Pasang semula BitBox anda dan masukkan kata laluan peranti tersembunyi untuk mengakses wallet legacy tersembunyi warisan."
}, loading$b = "memuatkan ...", manageAccounts$5 = {
  accountHidden: "Akaun ini telah disembunyikan daripada akaun watch-only anda sahaja. Untuk melihatnya semula, sila pasangkan BitBox02 anda.",
  editAccount: "Sunting",
  editAccountNameTitle: "Sunting nama akaun",
  noAccounts: "tiada akaun ditemui",
  settings: {
    hideTokens: "Sembunyikan token",
    showTokens: "Tunjukkan token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Tambah dan tunjukkan/sembunyikan akaun",
  title: "Urus akaun",
  watchAccount: "Tonton akaun",
  watchAccountDescription: "Akaun ini adalah sebahagian daripada akaun watch-only anda sahaja. Anda boleh menyembunyikannya daripada akaun jam tangan anda menggunakan togol."
}, mobile$6 = {
  usingMobileDataWarning: "Penggunaan data mudah alih: apl ini boleh memuat turun sehingga beberapa ratus megabait data pengepala blockchain selepas membuka kunci akaun. Sila sambung ke Wi-Fi untuk mengelak daripada menggunakan data mudah alih. Selepas menolaknya, mesej ini tidak akan ditunjukkan lagi."
}, newSettings$5 = {
  about: {
    appVersion: {
      title: "Versi aplikasi"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Kunci akses kepada aplikasi dengan kunci skrin/cap jari.",
      title: "Kunci skrin"
    },
    coinControl: {
      description: "Pilih UTXO yang merupakan sebahagian daripada transaksi untuk membantu meningkatkan privasi."
    },
    customFees: {
      description: "Membolehkan anda memasukkan yuran anda sendiri semasa menghantar."
    },
    torProxy: {
      description: "Sambungkan melalui Tor untuk privasi yang lebih baik."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Mata wang tambahan ini boleh ditogol pada halaman akaun anda.",
      title: "Mata wang aktif"
    },
    darkmode: {
      description: "Lihat BitBoxApp dalam mod gelap."
    },
    defaultCurrency: {
      description: "Pilih mata wang lalai anda",
      title: "Mata wang lalai"
    },
    hideAmounts: {
      description: "Memaparkan togol untuk menyembunyikan baki anda dan amaun untuk meningkatkan privasi anda apabila menggunakan apl di khalayak ramai.",
      hideAmounts: "Sembunyikan jumlah",
      showAmounts: "Tunjukkan jumlah",
      title: "Benarkan menyembunyikan jumlah"
    },
    language: {
      description: "Bahasa yang anda mahu BitBoxApp gunakan.",
      title: "Bahasa"
    },
    toggleSats: {
      description: "Dayakan atau lumpuhkan Satoshis."
    }
  }
}, note$7 = {
  input: {
    description: "(pilihan)",
    placeholder: "Tambah Nota"
  },
  title: "Catatan"
}, notification$b = {
  newTxs_one: "{{count}} transaksi baru di: {{accountName}}",
  newTxs_other: "{{count}} transaksi baharu dalam: {{accountName}}"
}, pairing$b = {
  aborted: {
    text: "Pemasangan telah ditinggalkan oleh aplikasi mudah alih.",
    title: "Ditinggalkan"
  },
  button: "Pasangkan Aplikasi Mudah Alih",
  confirm: "Adakah anda pasti mahu memasangkan BitBox anda? Ambil perhatian bahawa selepas itu, telefon bimbit diperlukan untuk melakukan transaksi.",
  connectOnly: {
    button: "Sambungkan aplikasi mudah alih",
    title: "Imbas dengan aplikasi mudah alih kami dengan memilih item menu 'Sambung ke aplikasi desktop baharu'"
  },
  error: {
    text: "Ada yang salah. Sila mulakan lagi.",
    title: "Ada yang salah"
  },
  pullFailed: {
    text: "Gagal menarik mesej daripada telefon bimbit anda melalui pelayan geganti. Pelayan geganti mungkin berada di luar talian, sila hubungi sokongan.",
    title: "Pull gagal"
  },
  reconnectOnly: {
    button: "Sambung semula aplikasi mudah alih"
  },
  scanningFailed: {
    text: "Mudah alih tidak berjaya mengimbas mesej. Sila cuba lagi.",
    title: "Pengimbasan Gagal"
  },
  start: {
    hideAppQRCode: "Sembunyikan QR Code",
    revealAppQRCode: "Tunjukkan QR Code",
    step1: "Jika anda tidak mempunyai aplikasi mudah alih, anda boleh mengimbas kod QR untuk Apple App Store atau Google Play Store.",
    step2: "Imbas dengan aplikasi mudah alih kami, yang anda dapati di bawah nama 'Digital Bitbox 2FA' di kedai aplikasi untuk iOS dan Android:"
  },
  started: {
    text: "Kini sila ikuti arahan dalam aplikasi mudah alih.",
    title: "Hebat"
  },
  success: {
    text: "Selamat, anda berjaya memasangkan BitBox anda dengan aplikasi mudah alih!",
    title: "Berjaya"
  },
  timeout: {
    text: "Pemasanganan ini berakhir selepas dua minit. Mula semula jika anda masih mahu memasangkan aplikasi mudah alih.",
    title: "Berakhir"
  },
  title: "Memasang telefon bimbit"
}, passphrase$5 = {
  considerations: {
    button: "Pertimbangan sandaran",
    message: `Frasa laluan menambah lapisan perlindungan pada sandaran dompet anda (kad mikroSD atau perkataan pemulihan). Jika seseorang mempunyai akses kepada sandaran anda, mereka juga memerlukan frasa laluan untuk mengakses dompet anda.

Walau bagaimanapun, ini bermakna anda perlu <strong>kedua-dua frasa laluan + sandaran dompet</strong> untuk memulihkan dompet didayakan frasa laluan anda, sekiranya BitBox02 anda hilang atau rosak. Jika anda terlupa atau kehilangan frasa laluan anda, anda akan kehilangan akses kepada semua syiling pada dompet itu.

Apabila menyimpan frasa laluan anda, pertimbangkan untuk meletakkannya di lokasi yang berasingan daripada sandaran anda. Dengan cara itu jika seseorang menjumpai sandaran anda, mereka juga tidak menemui frasa laluan anda.`,
    title: "Pertimbangan sandaran"
  },
  disable: "Lumpuhkan frasa laluan",
  disableInfo: {
    button: "Lumpuhkan",
    message: `Selepas melumpuhkan frasa laluan, anda tidak lagi akan diminta untuk memasukkan frasa laluan selepas membuka kunci BitBox02 anda. Oleh itu, anda akan memasukkan dompet lalai anda.

Mana-mana syiling pada dompet frasa laluan anda masih ada pada dompet itu, namun anda tidak akan dapat mengaksesnya kerana selepas membuka kunci BitBox02 anda, anda akan membuka dompet lalai anda.

Untuk mengakses dompet frasa laluan anda sekali lagi, cukup dayakan semula ciri frasa laluan dan masukkan frasa laluan yang berkaitan selepas membuka kunci BitBox02.

<strong>Petua:</strong> Anda masih boleh memasukkan dompet asal anda dengan membiarkan frasa laluan kosong.`
  },
  enable: "Dayakan frasa laluan",
  error: {
    e104: "Menukar tetapan frasa laluan telah digugurkan."
  },
  how: {
    button: "Macam mana rupanya",
    message: `Frasa laluan tidak berfungsi seperti kata laluan yang anda gunakan. Jika anda tersalah taip frasa laluan anda, anda tidak akan dimaklumkan. Ini adalah kerana <strong>setiap frasa laluan mencipta dompet yang berbeza, namun sah</strong>. Ini bermakna anda boleh menggunakan berbilang frasa laluan untuk seberapa banyak dompet yang anda mahukan. Tetapi setiap dompet hanya boleh diakses apabila menaip frasa laluan yang sepadan.

Apabila memasang BitBox02 anda, anda akan digesa untuk kata laluan peranti seperti biasa. Selepas itu, anda akan diminta untuk memasukkan frasa laluan pada peranti.

Selepas memasukkan frasa laluan, anda akan ditunjukkan frasa laluan yang anda masukkan. Ini supaya anda boleh mengesahkan anda memasukkannya dengan betul.`,
    title: "Bagaimanakah ia berfungsi"
  },
  intro: {
    message: `Frasa laluan menyediakan lapisan keselamatan tambahan di atas dompet anda.
Mari belajar bagaimana ia berfungsi.`,
    title: "Sediakan frasa laluan"
  },
  progressDisable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>melumpuhkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  progressEnable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>membolehkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  successDisabled: {
    message: `Ungkapan laluan pilihan <strong>berjaya didayakan</strong>!
Anda akan diminta untuk memberikan frasa laluan mulai sekarang.`,
    messageEnd: "Sila pasang semula BitBox02 sekarang.",
    title: "Ungkapan laluan didayakan"
  },
  successEnabled: {
    message: `Ungkapan laluan pilihan <strong>berjaya dilumpuhkan</strong>!

Anda tidak akan diminta untuk memberikan frasa laluan lagi.`,
    messageEnd: "Sila pasang semula BitBox02 anda sekarang.",
    tips: "Petua",
    tipsList: [
      "Kami cadangkan menghantar sejumlah kecil ke dompet frasa laluan terlebih dahulu. Kemudian cabut dan pasang semula BitBox02 dan masukkan kata laluan dan frasa laluan anda. Jika anda memasukkan frasa laluan dengan betul, anda sepatutnya melihat syiling dalam dompet anda.",
      "Jika anda ingin memasukkan dompet asal anda tanpa frasa laluan, anda masih boleh melakukan ini dengan memasukkan apa-apa apabila digesa untuk memasukkan frasa laluan. Atau anda boleh melumpuhkan ciri frasa laluan."
    ],
    title: "Ungkapan laluan dilumpuhkan"
  },
  summary: {
    button: "Dayakan frasa laluan",
    title: "Ringkasan",
    understand: "Saya faham cara frasa laluan berfungsi dan risiko yang berkaitan dengannya.",
    understandList: [
      "Frasa laluan ialah lapisan keselamatan tambahan di atas sandaran anda.",
      "Memasukkan frasa laluan yang berbeza akan sentiasa menghasilkan dompet yang berbeza.",
      "Untuk memulihkan dompet anda yang anda perlukan <strong>kedua-dua frasa laluan dan sandaran</strong>.",
      "Jika anda terlupa frasa laluan anda, anda tidak lagi boleh mengakses syiling anda."
    ]
  },
  what: {
    button: "Ketahui cara ini berfungsi",
    message: `Dompet dicipta (berasal) daripada nombor rawak yang sangat besar, juga dikenali sebagai benih. Benih ini dicipta apabila anda mula-mula menyediakan BitBox02 anda dan disandarkan dengan kad microSD atau perkataan pemulihan. Sesiapa sahaja yang mempunyai akses kepada benih mempunyai kawalan penuh ke atas dana pada dompet itu.

Frasa laluan ialah <strong>rahsia pilihan</strong>, ditambah kepada benih. Apabila menggunakan frasa laluan, setiap frasa laluan mencipta dompet baharu berdasarkan benih + frasa laluan (rahsia pilihan). Frasa laluan boleh jadi apa-apa sahaja: huruf, perkataan, aksara khas atau malah boleh kosong. Dompet lalai sebenarnya berasal daripada benih + frasa laluan kosong.

Frasa laluan adalah sebahagian daripada standard BIP39, yang bermaksud ia serasi dengan semua dompet yang menyokong standard yang sama.`,
    title: "Apakah frasa laluan?"
  },
  why: {
    button: "Mengapa menggunakan frasa laluan",
    message: `BitBox02 melindungi benih daripada pengekstrakan daripada peranti itu sendiri, tetapi sandaran (kad mikroSD atau perkataan pemulihan) memberikan akses penuh kepada dompet. Itulah sebabnya ia harus disimpan di lokasi yang selamat!

Memandangkan frasa laluan mencipta dompet baharu menggunakan benih sedia ada anda, frasa laluan-dompet memerlukan kedua-dua anda <strong>sandaran DAN frasa laluan untuk memulihkan</strong>. Faedah ini ialah jika seseorang menemui sandaran anda, mereka masih memerlukan frasa laluan untuk mengakses dompet frasa laluan.

Selain itu, ciri frasa laluan membolehkan anda membuat berbilang dompet pada peranti yang sama, atau "dompet tersembunyi" sebagai tambahan kepada dompet lalai.`,
    title: "Mengapa menggunakan frasa laluan?"
  }
}, password$b = {
  show: "Tunjukkan {{label}}",
  warning: {
    caps: "AMARAN: kunci caps () diaktifkan",
    paste: 'untuk menampal teks, aktifkan "SHOW {{label}}"'
  }
}, random$c = {
  button: "Menjana Nombor Rawak",
  description: "BitBox anda telah menjana nombor rawak {{bits}}-bit berikut:"
}, receive$d = {
  changeScriptType: "Tukar jenis alamat",
  label: "Alamat anda",
  onlyThisCoin: {
    description: "Untuk menerima token lain, dayakannya dalam tetapan. Jika anda mendepositkan token lain, ia mungkin tidak boleh diakses.",
    warning: "Pastikan hanya menerima {{coinName}} pada alamat ini."
  },
  scriptType: {
    p2tr: "Akar Tunjang (format terbaharu)",
    p2wpkh: "Segwit asli (lalai)",
    "p2wpkh-p2sh": "Wrapped Segwit (format yang serasi)"
  },
  selectAccount: "Pilih akaun",
  showFull: "Tunjukkan dan sahkan alamat lengkap",
  taprootWarning: "Nota: Taproot ialah ciri Bitcoin baharu dan belum diterima pakai secara meluas. Dana yang diterima pada alamat Taproot mungkin tidak kelihatan dalam dompet jam tangan pihak ketiga sahaja. Banyak dompet dan pertukaran belum dapat dihantar ke alamat Taproot.",
  title: "Dapatkan syiling",
  verify: "Sahkan alamat dengan selamat",
  verifyBitBox01: "Sahkan alamat pada apl mudah alih",
  verifyBitBox02: "Sahkan alamat pada BitBox02",
  verifyInstruction: "Sila sahkan bahawa alamat berikut sepadan dengan yang dipaparkan pada peranti anda.",
  warning: {
    secureOutput: "Sila pasangkan BitBox anda dengan peranti mobile anda untuk menghidupkan pengesahan alamat selamat. Pergi ke 'Urus Peranti' pada bar sisi."
  }
}, reset$b = {
  description: "Semua data pada peranti akan dihapus. Itu termasuk Private Key anda!",
  notReset: "Peranti BELUM ditetapkan semula.",
  title: "Tetapkan semula peranti",
  understand: "Saya mempunyai backup dan mengetahui kata laluan pemulihan saya",
  understandBB02: "Saya mempunyai sandaran yang sah"
}, securityInformation$b = {
  create: {
    description1: "Sebelum menetapkan peranti anda, disarankan agar anda dalam persekitaran yang selamat.",
    description2: "Anda akan diminta untuk membuat dua kata laluan.",
    description3: "Yang pertama adalah <strong> kata laluan peranti </strong> yang digunakan untuk membuka peranti BitBox anda dan boleh diubah kemudian.",
    description4: "Yang kedua ialah <strong>kata laluan pemulihan</strong> yang digunakan untuk membuka wallet anda. Kata laluan ini tidak boleh diubah kemudian.",
    description5: "Wallet yang anda buat akan dibackupkan kepada fail pada kad micro SD yang disediakan. Ini boleh digunakan dalam kecemasan untuk memulihkan wang anda menggunakan <strong> kata laluan pemulihan </strong> anda.",
    title: "Maklumat Keselamatan"
  },
  restore: {
    description1: "Anda akan diminta untuk memasukkan kad micro SD yang digunakan untuk menyimpan backup.",
    description2: "Untuk memulihkan peranti, anda memerlukan kata laluan pemulihan anda.",
    description3: "Sila berhati-hati semasa memasukkan kata laluan pemulihan. Sebarang kata laluan yang anda masukkan akan membuat wallet yang sah. Jika anda memasukkan kata laluan yang salah, anda mungkin akan mendapatkan baki wallet yang tidak anda harapkan.",
    title: "Maklumat Keselamatan"
  }
}, seed$b = {
  agreements: {
    "funds-access": "Saya TIDAK akan dapat mengakses dana saya jika saya lupa kata laluan pemulihan saya",
    "password-change": "Saya TIDAK dapat menukar kata laluan pemulihan di kemudian hari",
    "password-required": "Kata laluan pemulihan diperlukan untuk memulihkan dompet dari backup"
  },
  create: "Buat Wallet",
  creating: "Membuat dompet",
  description: "Saya faham bahawa:",
  error: {
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e200: "Anda perlu memasukkan kad micro SD ke dalam BitBox anda untuk membuat wallet, agar backup boleh dibuat secara automatik."
  },
  info: {
    button: "Tetapkan kata laluan pemulihan sekarang",
    description1: "Masukkan kad micro SD ke dalam BitBox",
    description2: 'Pilih kata laluan pemulihan untuk wallet dan pilih "Tetapkan kata laluan pemulihan sekarang"',
    description3: "Backup ke kad micro SD dan kata laluan pemulihan anda adalah satu-satunya cara untuk mendapatkan semula wang anda, sekiranya peranti BitBox hilang atau dicuri.",
    description4: "Anda tidak dapat mengganti kata laluan pemulihan anda di kemudian hari tanpa memindahkan wang anda.",
    title: "Buat wallet baru"
  },
  password: {
    label: "Kata laluan pemulihan",
    repeatPlaceholder: "Ulangi kata laluan pemulihan"
  },
  walletName: {
    label: "Nama Wallet"
  }
}, seedRestore$b = {
  error: {
    e200: "Untuk memulihkan wallet dari backup memerlukan kad micro SD."
  },
  info: {
    description1: 'Masukkan kad micro SD ke BitBox dan klik "Teruskan"',
    description2: 'Pilih backup pada dan klik "Simpan semula"',
    description3: "Masukkan kata laluan pemulihan",
    description4: "Anda perlu mengesahkan untuk memahami bahawa kata laluan salah akan membuat dompet yang berbeza.",
    title: "Bagaimana cara memulihkan wallet dari backup"
  }
}, send$d = {
  abort: "Transaksi telah ditinggalkan.",
  address: {
    label: "Alamat Penerima",
    placeholder: "Masukkan alamat"
  },
  amount: {
    label: "Jumlah",
    placeholder: "Masukkan jumlah"
  },
  availableBalance: "Baki yang ada",
  button: "Tandatangan dan Hantar",
  coincontrol: {
    address: "Alamat",
    outpoint: "Outpoint",
    title: "Hantar dari Output"
  },
  confirm: {
    "selected-coins": "Syiling yang dipilih",
    title: "Sahkan Transaksi",
    total: "Jumlah"
  },
  error: {
    erc20InsufficientGasFunds: "Nampaknya anda tidak mempunyai Eter yang mencukupi untuk membayar transaksi ERC20 ini. Sila pastikan anda memegang cukup Eter dalam dompet anda",
    feeTooLow: "bayaran terlalu rendah",
    feesNotAvailable: "Tidak dapat menganggarkan bayaran",
    insufficientFunds: "Dana tidak mencukupi",
    invalidAddress: "alamat tidak sah",
    invalidAmount: "jumlah tidak sah",
    invalidData: "data tidak sah"
  },
  fee: {
    customPlaceholder: "Masukkan jumlah",
    label: "Yuran Rangkaian",
    placeholder: "Tidak tersedia"
  },
  feeTarget: {
    customLabel: "Kadar bayaran",
    customLabel_eth: "Harga gas",
    description: {
      economy: "24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)",
      economy_eth: "30 minit atau kurang",
      economy_ltc: "1 jam (24 blok)",
      high: "2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)",
      high_eth: "30 saat atau kurang",
      high_ltc: "5 minit (2 blok)",
      low: "12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)",
      low_eth: "5 minit atau kurang",
      low_ltc: "30 minit (12 blok)",
      normal: "6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)",
      normal_eth: "2 minit atau kurang",
      normal_ltc: "15 minit (6 blok)"
    },
    estimate: "Anggaran masa pengesahan:",
    label: {
      custom: "Adat",
      economy: "ekonomi",
      high: "tinggi",
      low: "rendah",
      normal: "normal"
    },
    placeholder: "Mengira bayaran anggaran ..."
  },
  maximum: "Hantar semua",
  maximumSelectedCoins: "Hantar syiling terpilih",
  noFeeTargets: "Anggaran kadar yuran tidak tersedia pada masa ini. Sila cuba sebentar lagi atau masukkan yuran tersuai.",
  priority: "Keutamaan",
  scanQR: "Imbas Kod QR",
  signprogress: {
    description: "Ini adalah transaksi yang mengandung banyak data. Untuk menandatangani transaksi dengan sepenuhnya, anda akan diminta untuk mengesahkan sebanyak {{steps}} kali.",
    label: "Kemajuan"
  },
  success: "Transaksi telah ditandatangani dan dihantar.",
  title: "Hantar syiling",
  toggleCoinControl: "Toggle Kawalan Syiling",
  transactionDetails: "Butiran transaksi"
}, settings$c = {
  about: "Tentang aplikasi",
  accounts: "Akaun",
  advancedSettings: "Tetapan lanjutan",
  appearance: "Penampilan",
  electrum: {
    add: "Tambah server",
    "add-server": "Tambah",
    check: "Periksa",
    checkFailed: "Gagal",
    checkSuccess: "Berhasil menubuhkan sambungan ke {{host}}",
    checking: "Memeriksa",
    "download-cert": "Muat turun sijil jauh",
    "remove-server": "Hapus",
    removeConfirm: "Hapus {{server}}?",
    reset: "Tetapkan semula kepada tetapan standard",
    resetConfirm: "Apakah anda mahu menyingkirkan semua server dan memasang server standard?",
    servers: "Server",
    step1: "1",
    "step1-text": "Masukkan titik akhir.",
    step2: "2",
    "step2-text": "Masukkan sijil dari rantai sijil server. Secara alternatif, muat turun sijil jauh dan bandingkan secara visual.",
    "step2-text-tcp": "Anda boleh melangkau langkah ini jika anda tidak mahu menggunakan TLS.",
    step3: "3",
    "step3-text": "Semak sambungan dan tambahkan server.",
    step4: "4",
    "step4-text": "Mulakan semula wallet anda. Jika anda tidak menyingkirkan server standard, nod anda akan ditambah sebagai redundansi.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Hidupkan kawalan syiling",
    electrum: {
      description: "Anda boleh menyambung ke nod penuh Electrum anda sendiri.",
      title: "Sambung nod penuh anda sendiri"
    },
    fee: "Dayakan yuran tersuai",
    setProxyAddress: "Tetapkan alamat proksi",
    title: "Tetapan Pakar",
    useProxy: "Dayakan proksi tor",
    useSats: "Paparkan nilai BTC dalam Satoshis"
  },
  header: {
    home: "Rumah"
  },
  info: {
    "out-of-date": "Kemas kini baharu tersedia",
    title: "info",
    "up-to-date": "Apl anda adalah terkini",
    version: "Versi Apl"
  },
  restart: "Sila mulakan semula BitBoxApp untuk perubahan berkuat kuasa.",
  services: {
    title: "Perkhidmatan"
  },
  success: "Sila cabut dan pasang kembali BitBox agar perubahan dapat berlaku.",
  title: "Tetapan"
}, setup$b = "Menetapkan peranti", sidebar$c = {
  buy: "Beli kripto",
  device: "Urus Peranti",
  leave: "Tinggalkan",
  settings: "Tetapan"
}, success$i = {
  create: {
    info1: "Dompet anda telah dibackupkan dengan selamat ke kad micro SD. Tarik keluar kad micro SD dan simpan dengan selamat.",
    info2: "Anda telah membuat kata laluan peranti yang selamat yang dapat membuka BitBox.",
    info3: "Anda telah membuat kata laluan pemulihan yang selamat untuk wallet anda yang dapat membuka wang anda dan mengembalikan backup anda.",
    summary: "Berikut adalah ringkasan dari apa yang telah anda lakukan",
    title: "Berjaya"
  },
  getstarted: "Bermula",
  restore: {
    summary: "Anda telah berjaya memulihkan wallet dari backup anda.",
    title: "Berjaya"
  }
}, transaction$c = {
  confirmation: "Pengesahan",
  details: {
    activity: "Aktiviti",
    address: "Alamat",
    amount: "Jumlah",
    date: "Tarikh",
    fiat: "Fiat",
    fiatAmount: "Jumlah Fiat",
    fiatAtTime: "Fiat pada masa transaksi",
    status: "Status",
    type: "taip"
  },
  explorer: "ID Transaksi",
  explorerTitle: "Buka dalam blok Explorer luaran",
  fee: "Yuran",
  fiatHistorical: "Sejarah",
  gas: "Gas",
  note: {
    edit: "Edit nota",
    save: "Simpan nota"
  },
  pending: "Transaksi Menunggu",
  size: "Saiz",
  status: {
    complete: "lengkap",
    failed: "Gagal",
    pending: "Yang belum selesai"
  },
  tx: {
    received: "Diterima kepada",
    sent: "Dihantar kepada"
  },
  vsize: "Saiz maya",
  weight: "Berat"
}, transactions$b = {
  errorLoadTransactions: "Terdapat ralat semasa memuatkan urus niaga",
  placeholder: "Belum ada transaksi."
}, unknownError$b = "Kesalahan yang tidak diketahui muncul: {{errorMessage}}", unlock$b = {
  description: "Masukkan kata laluan peranti anda untuk membuka peranti.",
  error: {
    e109_normal: "Kata laluan peranti salah. Masih ada {{remainingAttempts}} percubaan sebelum peranti diset semula.",
    e109_touch: "$t(unlock.error.e109_normal) Menahan butang sentuhan diperlukan pada log masuk berikutnya",
    e113: "Oleh kerana banyaknya percubaan masuk, menahan butang sentuhan selama 4 saat diperlukan pada log masuk berikutnya ."
  },
  input: {
    label: "Kata laluan peranti",
    placeholder: "Masukkan kata laluan peranti anda"
  },
  unlocking: "Membuka ..."
}, upgradeFirmware$c = {
  button: "Tingkatkan firmware",
  description: "Apakah anda mahu menaik taraf Firmware dari versi {{currentVersion}} ke {{newVersion}}?",
  label: "Peningkatan firmware diperlukan untuk BitBox anda.",
  locked: "Untuk menaik taraf dari {{currentVersion}} ke {{newVersion}}, sila buat sentuhan panjang.",
  title: "Tingkatkan Firmware",
  unlocked: "Bootloader terbuka. Untuk meneruskan, sila:",
  unlocked1: "Tarik keluar dan pasang ulang BitBox anda",
  unlocked2: "LED akan menyala apabila BitBox anda terpasang kembali",
  unlocked3: "Tekan butang sentuh apabila LED menyala"
}, walletConnect$6 = {
  connect: {
    button: "Sambung",
    dappLabel: "Masukkan alamat URI dapp",
    invalidPairingUri: "Uri gandingan tidak sah"
  },
  dashboard: {
    allSessions: "Semua sesi",
    disclaimer: "Walletconnect ialah protokol untuk menyambung ke Dapps berasaskan Ethereum. Dapps ini dijalankan oleh perkhidmatan pihak ketiga, jadi hanya sambungkan kepada dapps yang anda percayai dan pastikan anda sentiasa mengetahui perkara yang anda tandatangani semasa membuat transaksi.",
    newConnection: "Sambungan baharu",
    noConnectedSessions: "Tiada akaun disambungkan ke mana-mana dapp pada masa ini."
  },
  invalidPairingChain: "Ralat dalam meluluskan gandingan. Sila pastikan anda menggunakan salah satu rangkaian yang disokong: {{chains}}",
  pairingRequest: {
    approve: "Luluskan Sambungan",
    reject: "Tolak",
    title: "Permintaan sambungan baharu daripada"
  },
  pairingSuccess: "Dapp berjaya disambungkan. Anda boleh teruskan di laman web dapp.",
  signingRequest: {
    account: "Akaun",
    chain: "Rantai",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Gagal menghuraikan data",
    decodeError: "Gagal menyahkod mesej",
    method: {
      sendTransaction: "Tandatangan dan hantar transaksi",
      signMessage: "Tandatangan mesej",
      signTransaction: "Tandatangani transaksi",
      signTypedData: "Tandatangani data yang ditaip"
    },
    successfullySigned: "Permintaan berjaya ditandatangani",
    walletConnectRequest: "Permintaan WalletConnect"
  },
  useNewUri: "URI ini telah digunakan untuk mencuba sambungan. Sila gunakan URI baharu.",
  walletConnect: "WalletConnect"
}, warning$h = {
  receivePairing: "Sila pasangkan BitBox untuk membolehkan pengesahan alamat dengan selamat. Pergi ke 'Uruskan Peranti' pada bar sisi.",
  sdcard: "Pastikan kad micro SD disimpan berasingan dari BitBox, kecuali jika anda mahu mengurus backup.",
  sendPairing: "Sila pasang BitBox untuk mengesahkan butiran transaksi dengan selamat. Pergi ke 'Urus Peranti' di bar sisi."
}, welcome$b = {
  connect: "Sambungkan BitBox02",
  getStarted: "Mari mulakan dengan memasang perisian tegar pada BitBox02 anda.",
  insertBitBox02: "Untuk BitBox02, sila ketik peranti untuk meneruskan.",
  insertDevice: "Sila sambungkan peranti anda untuk memulakan",
  title: "Selamat datang"
}, appTranslationsMS = {
  account: account$b,
  accountInfo: accountInfo$b,
  accountSummary: accountSummary$b,
  addAccount: addAccount$c,
  aopp: aopp$5,
  app: app$b,
  auth: auth$5,
  backup: backup$b,
  bb02Bootloader: bb02Bootloader$b,
  bitbox: bitbox$b,
  bitbox02Interact: bitbox02Interact$b,
  bitbox02Settings: bitbox02Settings$b,
  bitbox02Wizard: bitbox02Wizard$b,
  blink: blink$b,
  bootloader: bootloader$b,
  button: button$f,
  buy: buy$7,
  changePin: changePin$b,
  chart: chart$7,
  checkSDcard: checkSDcard$b,
  clickHere: clickHere$b,
  confirm: confirm$d,
  confirmOnDevice: confirmOnDevice$b,
  connectKeystore: connectKeystore$5,
  darkmode: darkmode$6,
  device: device$b,
  deviceLock: deviceLock$b,
  deviceSettings: deviceSettings$b,
  deviceTampered: deviceTampered$b,
  dialog: dialog$c,
  error: error$7,
  fiat: fiat$d,
  footer: footer$d,
  generic: generic$7,
  genericError: genericError$b,
  goal: goal$b,
  guide: guide$c,
  headerssync: headerssync$b,
  hiddenWallet: hiddenWallet$b,
  initialize: initialize$b,
  invalidFormat: invalidFormat$b,
  language: language$c,
  legacyhiddenwallet: legacyhiddenwallet$b,
  loading: loading$b,
  manageAccounts: manageAccounts$5,
  mobile: mobile$6,
  newSettings: newSettings$5,
  note: note$7,
  notification: notification$b,
  pairing: pairing$b,
  passphrase: passphrase$5,
  password: password$b,
  random: random$c,
  receive: receive$d,
  reset: reset$b,
  securityInformation: securityInformation$b,
  seed: seed$b,
  seedRestore: seedRestore$b,
  send: send$d,
  settings: settings$c,
  setup: setup$b,
  sidebar: sidebar$c,
  success: success$i,
  transaction: transaction$c,
  transactions: transactions$b,
  unknownError: unknownError$b,
  unlock: unlock$b,
  upgradeFirmware: upgradeFirmware$c,
  walletConnect: walletConnect$6,
  warning: warning$h,
  welcome: welcome$b
}, account$a = {
  disconnect: "Verbinding verbroken. Opnieuw aan het verbinden...",
  export: "Exporteren",
  exportTransactions: "Transacties als CSV bestand naar de downloads map exporteren",
  fatalError: "Er is een onverwachte fout opgetreden",
  incoming: "Inkomende",
  initializing: "Blockchain wordt gesynchroniseerd",
  maybeProxyError: "De Tor Proxy staat ingeschakeld. Zorg ervoor dat deze correct werkt, of schakel de proxy-instelling uit.",
  reconnecting: "Verbinding verbroken, opnieuw aan het verbinden...",
  syncedAddressesCount: "{{count}} adressen gescand"
}, accountInfo$a = {
  address: "Adres",
  buyCTA: {
    buy: "Koop {{unit}}",
    buyCrypto: "Koop Crypto",
    information: {
      looksEmpty: "Het lijkt erop dat deze wallet leeg is.",
      start: "Begin door coins naar deze wallet te sturen, of direct vanuit de BitBoxApp te kopen."
    }
  },
  extendedPublicKey: "Uitgebreide publieke sleutel",
  label: "Accountinformatie",
  scriptType: "Script-type",
  title: "Accountinformatie",
  verify: "Verifieer op je adres",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy P2PKH uitgebreide publieke sleutel weergeven",
    p2tr: "Taproot weergeven",
    p2wpkh: "Native SegWit weergeven",
    "p2wpkh-p2sh": "Oude SegWit uitgebreide publieke sleutel weergeven"
  },
  xpubTypeInfo: "Op dit moment wordt nummer {{current}} van de {{numberOfXPubs}} {{scriptType}} uitgebreide publieke sleutels weergegeven"
}, accountSummary$a = {
  availableBalance: "Beschikbare balans",
  balance: "Balans",
  exportSummary: "Accounts als CSV bestand naar de downloads map exporteren",
  fiatBalance: "Fiat balans",
  name: "Accountnaam",
  noAccount: "Er zijn geen accounts om weer te geven",
  subtotalWithCoinName: "Totaal ({{coinName}})",
  title: "Mijn portfolio",
  total: "Totaal",
  transactionHistory: "Transactiegeschiedenis"
}, addAccount$b = {
  chooseName: {
    nextButton: "Account toevoegen",
    step: "Account benoemen",
    title: "Geef je account een naam"
  },
  selectCoin: {
    nextButton: "Volgende",
    step: "Coin selecteren",
    title: "Cryptovaluta selecteren"
  },
  success: {
    addAnotherAccount: "Voeg een account toe",
    message: "<strong>{{accountName}}</strong> is aan je accounts toegevoegd",
    nextButton: "Klaar",
    step: "Afgerond",
    title: "Account toegevoegd"
  },
  title: "Account toevoegen"
}, aopp$4 = {
  addressRequest: "Er wordt een ontvangstadres aangevraagd door {{host}}",
  addressRequestWithLogo: "vraagt een ontvangstadres aan",
  banner: "Adresaanvraag in behandeling",
  errorTitle: "Foutmelding tijdens adresaanvraag",
  labelAddress: "Adres",
  labelMessage: "Bericht",
  reverifyInfoText: "Adres verifiren",
  signing: "Onderteken het bericht op je BitBox02 om door te gaan",
  success: {
    message: "Ga door op {{host}}",
    title: "Adres verzonden"
  },
  syncing: "Account aan het synchroniseren, even geduld",
  title: "Adresaanvraag"
}, app$a = {
  upgrade: "Er is een nieuwe versie van de app beschikbaar! Upgrade nu van versie {{current}} naar {{version}}>"
}, backup$a = {
  check: {
    checking: "Backup aan het controleren...",
    confirmTitle: "Controleer backup",
    notOK: "De backup komt NIET overeen met de wallet",
    ok: "Backup komt overeen met de wallet",
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      showLabel: "herstelwachtwoord"
    },
    success: "Backup geverifieerd:",
    title: "Controleer backup"
  },
  create: {
    alreadyExists: "Je hebt al een valide backup. Wil je deze opnieuw maken?",
    fail: "Backup is NIET gemaakt!",
    info: "Voer het herstelwachtwoord van de huidige wallet in.",
    name: {
      label: "Backup naam",
      placeholder: "Geef de backup een naam"
    },
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Voer alsjeblieft je herstelwachtwoord in"
    },
    title: "Creer backup",
    verificationFailed: "Het herstelwachtworod komt NIET overeen met de huidige wallet. De backup is aangemaakt. Gebruik 'Check backup' om je herstelwachtwoord nogmaals te verifiren."
  },
  description: "Selecteer <strong>wallet backup bestand</strong>",
  insert: "Voer de microSD kaart in om je backups te beheren",
  insertButton: "Ik heb de microSD kaart ingevoerd",
  list: "Jouw microSD kaart backups",
  noBackups: "Er zijn geen backups op deze microSD kaart aanwezig.",
  restore: {
    confirmTitle: "Backup herstellen",
    error: {
      e200: "microSD kaart niet gevonden",
      general: "Fout tijdens het herstellen van de backup"
    },
    password: {
      label: "Herstelwachtwoord of verborgen herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      repeatPlaceholder: "Herstelwachtwoord herhalen",
      showLabel: "Herstelwachtwoord"
    },
    restoring: "Backup aan het herstellen",
    selectedBackup: "De backup <strong>{{backupName}}</strong>, aangemaakt op {{createdDateTime}}, wordt hersteld",
    title: "Herstellen",
    understand: ""
  },
  showMnemonic: {
    description: `Je ziet zometeen de 24 herstelwoorden die de backup van je wallet vormen. Schrijf ze op papier op.
<strong>Sla ze niet digitaal op en neem er geen foto's van</strong>
<strong>Zeg de woorden niet hardop</strong>
<strong>Deze backup is niet beschermd met een wachtwoord</strong>
Achteraf word je gevraagd ieder woord te bevestigen`,
    title: "Herstelwoorden tonen"
  },
  title: "Backups beheren"
}, bb02Bootloader$a = {
  abort: "Terug - doe de update niet",
  abort_noUpgrade: "Breng me terug",
  advanced: {
    label: "Geavanceerde instellingen",
    toggleShowFirmwareHash: "Toon de firmware hash iedere keer tijdens het opstarten"
  },
  flipscreen: "Scherm omkeren",
  orientation: "Tekst op je BitBox ondersteboven?",
  success: "Upgrade voltooid! Verder in {{rebootSeconds}} seconden...",
  success_install: "Installatie voltooid! Verder in {{rebootSeconds}} seconden..."
}, bitbox$a = {
  error: {
    e10000: "Huidig apparaatwachtwoord incorrect",
    e10001: "Het veranderen van het wachtwoord is niet gelukt",
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e112: "Het verborgen apparaatwachtwoord kan niet hetzelfde zijn als het hoofdwachtwoord."
  }
}, bitbox02Interact$a = {
  confirmDate: "Bevestig de huidige datum op je BitBox02",
  confirmDateText: "Deze datum wordt gebruikt om je backup te maken.",
  confirmName: "Bevestig naam op je BitBox02",
  confirmWords: "Schrijf de {{amount}}",
  confirmWordsText: "Hierna vraagt de BitBox je om ieder woord te bevestigen zodat je zeker weet dat de backup correct is.",
  followInstructions: "Volg de instructies op je BitBox02",
  followInstructionsMnemonic: "Volg de instructies op je BitBox02 om te herstellen met je herstelwoorden.",
  followInstructionsMnemonicTitle: "Met herstelwoorden herstellen"
}, bitbox02Settings$a = {
  deviceName: {
    current: "Huidige naam",
    error: "Het is niet gelukt de naam in te stellen.",
    error_104: "Het instellen van de naam is afgebroken door de BitBox.",
    input: "BitBox02 naam",
    placeholder: "Nieuwe naam",
    title: "BitBox02 naam instellen"
  },
  gotoStartupSettings: {
    description: "",
    title: "Ga naar opstartinstellingen"
  }
}, bitbox02Wizard$a = {
  advanced: {
    button: "Geavanceerde opties",
    outOfDate: "Deze optie is niet beschikbaar voor deze firmware-versie",
    seed12WordInfo: "De hoeveelheid woorden kan niet veranderd worden nadat je de wallet hebt aangemaakt.",
    seed12WordLabel: "Seed met 12 ipv 24 herstelwoorden aanmaken",
    seed12WordText: 'De BitBox maakt standaard een backup met 24 herstelwoorden aan. Backups met zowel 12 als 24 woorden zijn in de praktijk veilig tegen "brute force" aanvallen. ',
    skipSDCardLabel: "MicroSD backup overslaan en herstelwoorden opschrijven",
    skipSDCardText: "Je hebt altijd de mogelijkheid om via de instellingen alsnog een microSD- of herstelwoord-backup te maken.",
    title: "Geavanceerde backup-opties"
  },
  attestationFailed: "Validiteitscheck niet gehaald. Dit kan gebeuren als de app opnieuw wordt opgestart terwijl de BitBox wachtte op input. Probeer de BitBox opnieuw te verbinden. Neem contact op met support@bitbox.swiss als dit probleem blijft voortbestaan.",
  backup: {
    point1: "Selecteer een backup op de microSD kaart",
    point2: "Stel een wachtwoord in voor je apparaat",
    restoreText: "Ok, laten we een backup herstellen!",
    text1: "Je BitBox02 wachtwoord is ingesteld en je wallet is aangemaakt. Nu gaan we je eerste backup instellen. Zorg dat je microSD kaart is ingevoerd in de BitBox02 en ga verder.",
    text2: "Volg de instructies op je BitBox om een backup te maken.",
    text3: "Verwijder de microSD kaart en sla hem op in een <strong>veilige locatie</strong> nadat je backup is aangemaakt. De inhoud van de microSD kaart is niet beveiligd met een wachtwoord. Voer je microSD kaart nooit in een ander apparaat dan je BitBox02 in.",
    userConfirmation1: "Ik zal mijn backup in een veilige locatie opslaan.",
    userConfirmation2: "Mijn backup is niet beveiligd met een wachtwoord. Iedereen die er toegang tot heeft, heeft toegang tot mijn wallet.",
    userConfirmation3: "Als ik mijn BitBox02 verlies of beschadig, is de backup mijn enige manier om weer toegang tot mijn wallet te krijgen.",
    userConfirmation4: "Als ik mijn BitBox02 n mijn backup verlies of beschadig, is mijn wallet permanent verloren.",
    userConfirmation5: "Ik moet mijn microSD kaart niet in een computer, telefoon, printer of ieder ander apparaat dan een BitBox02 invoeren.",
    userConfirmation5mnemonic: "Ik snap dat ik mijn herstelwoorden NOOIT in een computer, telefoon, printer of ieder ander apparaat dat geen BitBox is moet invoeren"
  },
  create: {
    button: "",
    info: "Dit zijn de stappen die je gaat nemen om je BitBox in te stellen:",
    inputTitle: "Walletnaam",
    point1: "Geef je BitBox een naam",
    point2: "Stel een wachtwoord voor je BitBox in",
    point3: "Maak een backup",
    text: "Ok, we gaan nu een nieuwe wallet aanmaken!"
  },
  createBackupAborted: "Backup afgebroken",
  createBackupFailed: "Het maken van een backup is niet gelukt, probeer het opnieuw.",
  initialize: {
    passwordText: "Gebruik de touch-sensors op je BitBox om een wachtwoord in te stellen.",
    passwordTitle: "Stel een wachtwoord in voor je BitBox.",
    text: "Je BitBox02 is gekoppeld. Stel hem in door te kiezen voor het maken van een nieuwe wallet, of het herstellen van een backup. <strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
    tip: "We raden je aan in een veilige omgeving door te gaan.",
    title: "Initializeer je BitBox"
  },
  insertSDCard: "<strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
  noPasswordMatch: "De wachtwoorden kwamen niet overeen, probeer het op nieuw.",
  pairing: {
    failed: "Koppeling niet bevestigd. Plug je BitBox opnieuw in.",
    paired: "Je hebt de volgende code op je BitBox bevestigd. Klik om door te gaan.",
    title: "Verifieer koppelcode",
    unpaired: "Er is een nieuwe BitBox02 gedetecteerd. Controleer dat onderstaande code overeenkomt met wat er op je BitBox staat"
  },
  restoreFromMnemonic: {
    e104: "Het herstellen is afgebroken",
    failed: "Herstel is niet gelukt, probeer het nog eens."
  },
  stepBackup: {
    beforeProceed: "Lees deze belangrijke veiligheidsoverwegingen voordat je verder gaat:",
    createBackup: "Je gaat nu een backup op je microSD kaart maken.",
    createBackupMnemonic: "Je gaat nu de herstelwoorden opschrijven"
  },
  stepBackupSuccess: {
    fundsSafe: "Houd rekening met het volgende om je crypto veilig te houden:",
    title: "Backup hersteld!"
  },
  stepConnected: {
    unlock: "Voer je BitBox02 wachtwoord in om te ontgrendelen."
  },
  stepCreate: {
    description: "Deze naam wordt gebruikt als apparaatnaam en voor de backup",
    nameLabel: "BitBox02 naam",
    namePlaceholder: "Mijn BitBox02",
    title: "Kies een naam voor je BitBox02",
    toastMicroSD: "Zorg dat je microSD kaart is ingevoerd in je BitBox02; deze wordt gebruikt om een backup van je wallet op te slaan."
  },
  stepCreateSuccess: {
    removeMicroSD: "Haal de microSD kaart uit je BitBox02 en bewaar deze in een veilige locatie.",
    storeMnemonic: "Bewaar je herstelwoorden op een veilige locatie",
    success: "Je backup is aangemaakt."
  },
  stepInsertSD: {
    insertSDCard: "Stop een microSD kaart in je BitBox02 om door te gaan.",
    insertSDcardTitle: "Voer microSD kaart in"
  },
  stepPassword: {
    e104: "Het instellen van een wachtwoord is afgebroken",
    title: "BitBox02 wachtwoord instellen",
    useControls: "Gebruik de touch-sensors op je BitBox02 om een wachtwoord in te voeren."
  },
  stepUninitialized: {
    create: "Ik wil een nieuwe BitBox02 instellen.",
    restore: "Ik wil de backup van een bestaande wallet herstellen.",
    restoreMicroSD: "Herstel met microSD kaart",
    restoreMnemonic: "Herstel met herstelwoorden",
    title: "Stel je BitBox02 in"
  },
  success: {
    text: `Gefeliciteerd! Je BitBox02 is nu klaar om te gebruiken.
Voor meer informatie over het gebruik van de BitBoxApp check je de applicatiehulp door op het icoon rechtsbovenin te klikken.`,
    title: "Je bent helemaal klaar!"
  }
}, blink$a = {
  button: "Knipperen"
}, bootloader$a = {
  button: "Firmwareupgrade uitvoeren",
  button_install: "Firmware installeren",
  progress: "Firmwareupgrade wordt uitgevoerd: {{progress}}%",
  progress_install: "Firmware wordt genstalleerd: {{progress}}%",
  success: "Upgrade voltooid! Plug je BitBox opnieuw in. Druk deze keer niet op de knop."
}, button$e = {
  abort: "Annuleren",
  back: "Terug",
  buy: "Koop",
  changepin: "BitBox-wachtwoord veranderen",
  check: "Backup controleren",
  continue: "Verder",
  copy: "Kopiren",
  create: "Aanmaken",
  dismiss: "Sluiten",
  done: "Klaar",
  download: "Download",
  hiddenwallet: "Verborgen wallet aanmaken",
  next: "Volgende",
  ok: "OK",
  previous: "Vorige",
  receive: "Ontvangen",
  restore: "Herstellen",
  select: "Selecteren",
  send: "Verzenden",
  unlock: "Ontgrendelen",
  update: "Updaten",
  upgrade: "Upgraden"
}, buy$6 = {
  exchange: {
    bankTransfer: "Bankoverschrijving",
    bestDeal: "Beste deal",
    creditCard: "Creditcard",
    fast: "Snel",
    fee: "transactiekosten",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankoverschrijving: {{fee}}%",
          creditDebitCard: "Creditcard:  {{fee}}%",
          learnMore: "Lees meer over Moonpay",
          title: "Transactiekosten"
        },
        fullCurrenciesList: "Bekijk hier de hele Valutalijst",
        payment: {
          asteriskText: "* Niet beschikbaar voor inwoners van de VS",
          bankTransfer: "Bankoverschrijving*",
          bankTransferDetails: {
            pix: "PIX (Alleen in Brazili)",
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          creditDebitCard: "Credit/debitkaart",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa en Maestro"
          },
          learnMore: "Zie meer details over betaalmethodes",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "Ondersteunt alle grote fiat-valuta: USD, EUR, CHF en meer"
      },
      pocket: {
        fees: {
          info: "Bankoverschrijving: {{fee}}%",
          title: "Transactiekosten"
        },
        learnMore: "Lees meer over Pocket",
        payment: {
          bankTransfer: "Bankoverschrijving",
          bankTransferDetails: {
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            sic: "Swiss Interbank Clearing (CHF-transacties alleen in CH/LI)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          bankTransferReccuring: "Hoe stel ik regelmatige aankopen in?",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "EUR, GBP en CHF worden ondersteund",
        verification: {
          info: "Vereist alleen identiteitsverificatie boven een dagelijks/jaarlijks limiet",
          link: "Vind de huidige limieten hier",
          title: "Identiteitsverificatie"
        }
      },
      region: {
        title: "Selecteer het land waarin je bankrekening is geregistreerd om de beschikbare opties te zien"
      }
    },
    noExchanges: "Sorry, er zijn geen exchanges beschikbaar in jouw regio",
    region: "Regio",
    selectRegion: "Niet aangegeven",
    title: "Koop {{name}}"
  },
  info: {
    continue: "Akkoord, verder",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Samen met MoonPay bieden we je een naadloze manier om {{name}} direct in de BitBoxApp te kopen. Het is met een paar kliks gedaan.",
        "MoonPay is een platform dat het snel en makkelijk maakt om {{name}} in meer dan 160 landen te kopen."
      ],
      payment: {
        details: "Je kunt via MoonPay direct {{name}} kopen met de volgende betaalmethodes. Credit- of debitcard aankopen zijn makkelijk en snel, maar zijn duurder omdat de transactie teruggedraaid kan worden. We raden aan om een bankoverschrijving te doen voor grotere hoeveelheden. De minimale kosten zijn 4 euro.",
        footnote: "Houd er rekening mee dat de wisselkoers die MoonPay aanhoudt anders kan zijn dan die in de BitBoxApp, waardoor de hoeveelheden kunnen verschillen.",
        table: {
          "1_description": "Laagste kosten, kan tot 3 werkdagen duren.",
          "1_method": "Bankoverschrijving (SEPA)",
          "2_description": "Hogere kosten, onmiddelijke aankoop",
          "2_method": "Credit- en debitcards",
          description: "Omschrijving",
          fee: "Kosten",
          method: "Methode"
        },
        title: "Betaalmethode en kosten"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "De BitBoxApp verzamelt geen data als je {{name}} koopt, de inkomende transactie wordt als gewone transactie behandeld. MoonPay moet wat persoonlijke data verzamelen om je hun diensten aan te bieden. Hun privacy policy legt in detail uit hoe die data behandeld wordt.",
        descriptionGeneric: "De BitBoxApp verzamelt geen informatie van je als je {{name}} koopt. De inkomende transactie wordt als een normale transactie behandeld. Onze partner-exchanges moeten echter wat informatie verzamelen om hun diensten te kunnen verlenen. Zie hun respectievelijke privacybeleid voor meer informatie over hoe ze met je data omgaan.",
        title: "Databescherming."
      },
      security: {
        description: "Als je {{name}} koopt via MoonPay, gebruik je een externe dienst. Deze dienst valt buiten het BitBox02 Beveiligings- en bedreigingsmodel en vertrouwt op de beveiliging van de omgeving waarin je de BitBoxApp draait.",
        descriptionGeneric: "Als je {{name}} koopt via een van onze partner-exchanges, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait.",
        link: "Beveiliging- en bedreigingsmodel",
        title: "Bedreigingsmodel"
      },
      title: "Welkom bij jouw one-stop-shop om {{name}} te kopen"
    },
    next: "Volgende",
    selectLabel: "Kies je account",
    selectPlaceholder: "Selecteer een coin",
    skip: "Niet nog eens weergeven",
    title: "Koop {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket's privacybeleid",
      p1: "De BitBoxApp verzamelt geen informatie van je als je bitcoin koopt. De inkomende transactie wordt als een normale transactie behandeld. Moet echter wat informatie verzamelen om hun diensten te kunnen verlenen. Pocket's privacybeleid legt in detail uit hoe ze met je data omgaan.",
      title: "Databescherming"
    },
    kyc: {
      link: "Lees de Pocket-FAQs",
      p1: "Pocket probeert KYC tot een minimum te beperken. Voor aankopen van minder dan 950EUR (1000 CHF) per dag, is het uploaden van identificatie-documenten niet nodig. Als je meer dan dit wilt kopen, zul je een gesprek met Pocket in moeten plannen om de benodigde KYC/AML-procedure te doorlopen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Je kunt bij Pocket direct bitcoin kopen met een simpele SEPA bankoverschrijving. De transactiekosten hiervoor zijn 1.5%, en de bitcoin wordt direct naar je BitBox gestuurd (zodra Pocket de bankoverschrijving heeft ontvangen - meestal dezelfde dag nog).",
      p2: "Let er op dat de wisselkoers die Pocket hanteert verschillend kan zijn dan die in de BitBoxApp wordt aangegeven, wat een klein verschil in de hoeveelheden kan opleveren.",
      title: "Betaalmethodes en transactiekosten"
    },
    previousTransactions: "Je deelt een bestaande en gebruikte account met Pocket. Als je dit doet kunnen ze je volledige transactiegeschiedenis en alle toekomstige transacties inzien. Wil je toch doorgaan?",
    security: {
      link: "BitBox02 beveiligings- en bedreigingsmodel",
      p1: "Als je bitcoin koopt via Pocket, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait. We werken echter samen met Pocket om de beveiliging te verbeteren door het adres waar je op ontvangt te controleren met een tweefactor-authenticatiemechanisme.",
      title: "Beveiligingsmodel"
    },
    usedAddress: "Het adres {{address}} is al gebruikt, probeer het opnieuw met een nieuw adres.",
    verifyBitBox02: "Verifieer alsjeblieft of het adres wat je via de mail is toegestuurd hetzelfde is als het adres dat op je BitBox wordt weergegeven. Als het kan, is het het beste om de email op een tweede apparaat te openen.",
    welcome: {
      p1: "Met Pocket kun je binnen een paar kliks direct in de BitBoxApp bitcoin kopen.",
      p2: "Pocket is een Zwitsers platform wat het makkelijk en snel maakt om bitcoin te kopen in bijna heel Europa (overal waar SEPA bankoverschrijvingen beschikbaar zijn).",
      p3: "Met Pocket kun je ook regelmatige aankopen doen door een herhaalopdracht in te stellen bij je bank, zodat je makkelijk een DCA (dollar-cost-averaging) spaarplan in kunt stellen.",
      title: "Welkom bij je one-stop-shop voor bitcoin-aankopen"
    }
  },
  title: "Koop {{name}}"
}, changePin$a = {
  newTitle: "Nieuw BitBox02 wachtwoord",
  oldLabel: "Huidig BitBox02 wachtwoord"
}, chart$6 = {
  dataMissing: "Datahistorie aan het verzamelen... even geduld.",
  dataUpdating: "Data aan het updaten...",
  filter: {
    all: "Alle",
    month: "Maand",
    week: "Week",
    year: "Jaar"
  }
}, checkSDcard$a = "microSD kaart aan het controleren", clickHere$a = "Klik hier", confirm$c = {
  abortInfo: "Klik om",
  abortInfoRedText: "annuleren",
  approveInfo: "Houd 4 seconden ingedrukt om te",
  approveInfoGreenText: "bevestigen",
  info: "Ga verder op je BitBox",
  infoWhenPaired: "Eerst op de gekoppelde telefoon en dan op je BitBox"
}, confirmOnDevice$a = "Bevestig op je BitBox", darkmode$5 = {
  toggle: "Donkere kleurstelling"
}, device$a = {
  appUpradeRequired: "Je BitBox wordt niet ondersteund door deze desktop applicatie. Download en installeer de laatste versie."
}, deviceLock$a = {
  button: "Stel tweefactor authenticatie (2FA) in",
  condition1: "Heb je een backup?",
  condition2: "Werkt de mobiele app verificatie?",
  condition3: "2FA stelt backups en app-koppelingen buiten werking. De BitBox moet worden gereset om 2FA uit te zetten!",
  confirm: "Stel tweefactor authenticatie (2FA) in",
  title: "Stel tweefactor authenticatie (2FA) in"
}, deviceSettings$a = {
  backups: {
    manageBackups: {
      description: "MicroSD kaart backup aanmaken of controleren."
    },
    showRecoveryWords: {
      description: "Herstelwoorden tonen en verifiren."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "De BitBoxApp controleert of je apparaat echt is."
    },
    deviceName: {
      description: "Verander de naam van je apparaat."
    },
    securechip: {
      description: "Secure-chip modelnummer"
    },
    title: "Apparaatinformatie"
  },
  expert: {
    factoryReset: {
      description: "Zet je BitBox terug naar de fabrieksinstellingen - dit verwijdert de wallet uit je BitBox02!",
      title: "Terugzetten naar fabrieksinstellingen"
    },
    goToStartupSettings: {
      description: 'Ga naar de bootloader van de BitBox02. Je kunt hier het laten zien van de "firmware hash" inschakelen.'
    },
    passphrase: {
      description: "Zet de optionele passphrase aan of uit",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware-versie",
    newVersion: {
      label: "Beschikbare versie"
    },
    title: "Firmware",
    upToDate: "Je BitBox is up-to-date",
    upgradeAvailable: "Een nieuwe upgrade is beschikbaar",
    version: {
      label: "Versie"
    }
  },
  hardware: {
    attestation: {
      false: "Autentiteitscontrole mislukt",
      label: "Autentiteitscontrole",
      true: "Je hebt een autentieke BitBox02"
    },
    sdcard: {
      false: "Niet ingevoerd",
      label: "microSD kaart",
      true: "Ingevoerd"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Apparaatinformatie aan het verzamelen...",
  pairing: {
    lock: {
      false: "Uitgeschakeld",
      label: "Tweefactor authenticatie (2FA)",
      true: "Ingeschakeld"
    },
    mobile: {
      false: "Gesloten",
      label: "Mobiele app",
      true: "Open"
    },
    status: {
      false: "Niet gekoppeld",
      label: "Status",
      true: "Gekoppeld"
    },
    title: "Aan het koppelen"
  },
  secrets: {
    manageBackups: "Backups beheren",
    title: "Geheimen"
  }
}, deviceTampered$a = "Heb je een herstelwachtwoord gekregen bij de aankoop van je BitBox? Zo ja, moet je onmiddelijk stoppen en ons onmiddelijk contacteren. Shift zal je nooit een kant-en-klare wallet aanbieden of aanbevelingen doen voor je wachtwoorden.", dialog$b = {
  cancel: "Annuleren",
  confirm: "Bevestigen",
  confirmTitle: "Bevestiging"
}, error$6 = {
  accountAlreadyExists: "Deze account bestaat al",
  accountLimitReached: "Kan account niet toevoegen. Je hebt de maximale hoeveelheid accounts voor deze coin.",
  aoppCallback: "Er is een fout opgetreden tijdens het versturen van het adres naar {{host}}",
  aoppInvalidRequest: "Ongeldig verzoek.",
  aoppNoAccounts: "Er zijn geen accounts beschikbaar.",
  aoppSigningAborted: "Verzoek om adreseigenaarschap geannuleerd.",
  aoppUnknown: "Er is een onbekende fout opgetreden.",
  aoppUnsupportedAsset: "Dit token wordt niet ondersteund.",
  aoppUnsupportedFormat: "Er zijn geen accounts beschikbaar die de het verzochte adresformaat ondersteunen.",
  aoppUnsupportedKeystore: "Het verbonden apparaat kan voor deze crypto geen berichten ondertekenen.",
  aoppVersion: "Onbekende versie."
}, fiat$c = {
  default: "Standaard",
  setDefault: "Stel {{code}} in als standaard",
  title: "Valuta's"
}, footer$c = {
  appVersion: "App versie:"
}, generic$6 = {
  enabled_false: "Uitgeschakeld",
  enabled_true: "Ingeschakeld"
}, genericError$a = "Er is een fout opgetreden. Start de applicatie opnieuw op als je problemen tegenkomt.", goal$a = {
  buttons: {
    create: "Maak een nieuwe wallet aan.",
    restore: "Herstel een wallet met een backup"
  },
  paragraph: "Selecteer n van de volgende opties:",
  step: {
    1: {
      title: "Beveiligingsinformatie"
    },
    2: {
      description: "Stel een apparaatwachtwoord in",
      title: "Apparaat"
    },
    "3-create": {
      description: "Maak een nieuwe wallet aan",
      title: "Wallet"
    },
    "3-restore": {
      description: "met een backup",
      title: "Herstel"
    },
    "4-create": {
      title: "Samenvatting"
    },
    "4-restore": {
      title: "Samenvatting"
    }
  }
}, guide$b = {
  accountDescription: {
    text: "Je accountpagina laat je beschikbare balansen, en binnenkomende en uitgaande transacties zien. In de instellingen kun je meer informatie vinden over iedere accountsoort.",
    title: "Wat staat er op deze pagina?"
  },
  accountFiat: {
    text: "Ja. Je kunt op iedere 'ticker' klikken om door fiatvaluta te roteren. Je kunt de lijst van valuta's in de instellingen veranderen.",
    title: "Kan ik ook andere wisselkoersen weergeven?"
  },
  accountIncomingBalance: {
    text: "Binnenkomende transacties zijn een som van de hoeveelheden die naar je toe gestuurd zijn, maar nog geen bevestiging hebben van het netwerk.",
    title: "Wat zijn binnenkomende transacties?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Iedere xpub is gekoppeld aan het getoonde 'type': dit is "Native segwit (bech32)", "Wrapped segwit" of "Taproot" (alleen bij Bitcoin). Dit zijn scrypttypes die gebruikt worden door {{coinName}}. De BitBoxApp combineert ze door meerdere scripttypes in dezelfde account te ondersteunen. Omdat ieder scripttype een andere xpub heeft, heb je meerdere xpubs per account.

Als je altijd op het standaardadres ontvangt, heb je alleen de 'bech32' xpub nodig. Als je echter ook (handmatig) ontvangt op je compatibiliteitsadres, staan deze onder de "oudere Segwit" of "Taproot" uitgebreide publieke sleutel (xpub).`,
      title: "Waarom heb ik meerdere xpubs?"
    },
    privacy: {
      text: `Met de uitgebreide publieke sleutel vallen de volledige financile geschiedenis, de balans van je account en alle eventuele toekomstige transacties te achterhalen. Met alleen de xpub heb je echter geen verzendcontrole over de coins.

Als je een xpub aan iemand geeft, moet je je ervan bewust zijn dat deze persoon of dit bedrijf alle transacties van dit account kan zien. Daarom is het handig om accounts waarvan je de xpub weggeeft maar voor n doel te gebruiken, en je andere financin op een ander account te beheren. `,
      title: "Moet ik mijn xpub geheim houden?"
    },
    verify: {
      text: "Ja, het is altijd een goed idee om je xpub te dubbel-checken. Zeker als iemand anders met deze xpub adressen gaat genereren om je geld te sturen is het extra belangrijk. Je verifieert de xpub op je BitBox om er zeker van te zijn dat de xpub van jou is. Anders zullen alle transacties naar een verkeerd adres gaan. ",
      title: "Moet ik de xpub verifiren op mijn BitBox?"
    },
    xpub: {
      text: `Een uitgebreide publieke sleutel (xpub) is de bron waaruit alle ontvangstadressen van een account gemaakt worden. 

Het wordt hier weergegeven voor geavanceerde gebruikers en voor ondersteuning van watch-only wallets zoals Electrum of Sentinel. Als je verschillende adrestypes gebruikt, noteer dan alle verschillende xpub-formaten in de watch-only wallet om al je coins te kunnen zien.

Let op dat nog niet alle externe wallets Taproot ondersteunen. `,
      title: "Wat is een uitgebreide publieke sleutel?"
    }
  },
  accountRates: {
    text: "We vernieuwen de wisselkoers iedere minuut gebaseerd op de wisselkoersen van CoinGecko.",
    title: "Welke wisselkoersen gelden er?"
  },
  accountReload: {
    text: "Dat is niet nodig. Je transactiegeschiedenis wordt automatisch gepdatet.",
    title: "Kan ik de transactiegeschiedenis herladen?"
  },
  accountSendDisabled: {
    text: "De verzendknop wordt geactiveerd als de balans van dat account meer dan nul is.",
    title: "Waarom kan ik geen {{unit}} verzenden?"
  },
  accountSummaryAmount: {
    text: `De totale balans is de som van al je crypto-accounts, berekend met de wisselkoers van coingecko.com.
Let op: Gebruik je MyEtherWallet voor toekens die niet ondersteund worden door de BitBoxApp? Dan worden deze niet meegerekend in dit totaal.`,
    title: "Hoe wordt de totale balans berekend?"
  },
  accountSummaryDescription: {
    text: "Hier kun je de prestaties van je gehele portfolio gedurende verschillende tijdsbestekken bekijken. Een overzicht van je individuele crypto-accounts wordt onder de grafiek weergegeven.",
    title: "Wat zie ik op deze pagina?"
  },
  accountTransactionAttributesBTC: {
    text: `Grootte: De daadwerkelijke grootte van de transactie in bytes zoals berekend volgens de onderliggende blockchain.
Virtuele grootte: Dit bepaalt de netwerkkosten. Je bespaart op kosten als de virtuele grootte kleiner is dan de transactiegrootte.
Gewicht: Een nieuwe meeteenheid die gentroduceerd is met Segwit om de grootte van transacties en blokken te evalueren. Iedere 'segregated witness' byte telt als n gewichtseenheid (weight unit), alle andere data telt als vier. In plaats van n megabyte is de grootte van een block nu vier miljoen weight units.`,
    title: "Hoe zit het met de Bitcoin-specifieke transactiedetails?"
  },
  accountTransactionAttributesGeneric: {
    text: `Bevestigingen: Je transactie is onbevestigd totdat een miner het toevoegt aan een block. Op dat moment heeft het n bevestiging. Ieder block wat daarna komt geeft jouw transactie een extra bevestiging. Over het algemeen vereisen winkels en andere mensen op het netwerk drie tot zes bevestigingen.
Transactie-ID: Een uniek identificatienummer waarmee je je transactie in een block explorer kunt opzoeken.
Transactiekosten: Miners worden betaald met transactiekosten, die ervoor moet zorgen dat ze jouw transactie in een block opnemen. Klik op 'verzenden' om hier meer over te leren.`,
    title: "Welke informatie vind ik in de transactiedetails?"
  },
  accountTransactionConfirmation: {
    text: "Een transactie die is uitgezondern naar het netwerk, maar nog geen bevestigingen heeft. ",
    title: "Wat is een transactie in afwachting?"
  },
  accountTransactionLabel: {
    text: "Dit is het adres waarop je coins hebt ontvangen of naartoe hebt verzonden. ",
    title: "Wat is het adres wat bij iedere transactie wordt weergegeven?"
  },
  accountTransactionTime: {
    text: "De transactiebevestigingstijd op de blockchain",
    title: "Wat is de tijd die wordt weergegeven?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin en Litecoin kunnen zoveel accounts hebben als je wilt. Na vijf accounts kun je pas een nieuwe toevoegen als de vorige account daadwerkelijk gebruikt is voor een transactie. Andere coins hebben een maximum van vijf accounts.",
      title: "Hoeveel accounts kan ik aanmaken?"
    },
    howtoAddTokens: {
      text: 'Tokens die gebruik maken van de ERC20 standaard worden aan een specifieke Ethereum-account gekoppeld. Om een token aan- of uit te zetten, open je het "Accounts beheren" scherm, klik je op je Ethereum account en schakel je de gewenste token in of uit.',
      title: "Hoe kan ik meer tokens toevoegen?"
    },
    moveFunds: {
      text: "Ja, maar omdat accounts onafhankelijk van elkaar zijn, moet je een reguliere transactie maken.",
      title: "Kan ik mijn coins tussen accounts verplaatsen?"
    },
    recoverAccounts: {
      text: "Ja, de BitBoxApp maakt accounts die voldoen aan breed gebruikte standaarden, zodat je accounts compatibel zijn met de meeste andere crypto-wallets.",
      title: "Kan ik mijn accounts in een andere wallet herstellen?"
    },
    whatAreAccounts: {
      text: "Je wallet kan meerdere accounts van dezelfde coin aanmaken. Accounts zijn handig als je verschillende 'rekeningen' wilt hebben om je financin gescheiden te houden..",
      title: "Wat zijn accounts?"
    },
    whyIsThisUseful: {
      text: "Accounts zijn een goede manier om bijvoorbeeld de financin van verschillende mensen of voor verschillende doeleinden te beheren omdat deze gescheiden gehouden worden in verschillende accounts. Je kunt ook de uitgebreide publieke sleutel (xpub) van n account met iemand anders delen zonder ook maar iets over je andere accounts aan diegene bloot te stellen. Dit zorgt ervoor dat je herhaaldelijk kunt ontvangen zonder een adres te hergebruiken, bijvoorbeeld om een salaris te ontvangen of regelmatig crypto te kopen.",
      title: "Waar is dit goed voor?"
    }
  },
  appendix: {
    link: "Neem contact met ons op!",
    text: "Nog een vraag?"
  },
  backups: {
    check: {
      text: "Het checken van je backup zorgt ervoor dat je kunt controleren of je een geldige backup hebt voor je huidige wallet. Het kan ook gebruikt worden om te controleren of je herstelwachtwoord nog klopt. Je kunt je hoofdherstelwachtwoord checken, of je verborgen herstelwachtwoord.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, maar je herstelwachtwoord is nodig om de wallet vanuit de seed phrase te herstellen.",
      title: "Kan ik de backup versleutelen?"
    },
    howOften: {
      text: "De backup wordt automatisch gegenereerd wanneer je een nieuwe wallet aanmaakt. Je hoeft alleen een nieuwe backup te maken als je microSD kaart kapot of kwijt is, of als je meerdere microSD kaarten als backup wilt gebruiken. Je hoeft geen nieuwe backup te maken nadat je een transactie hebt gedaan; alle transactiedata kan worden hersteld met de backup die aan het begin gemaakt is.",
      title: "Hoe vaak moet ik een nieuwe backup maken?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwoorden ('seed phrase') op een microSD kaart. De herstelwoorden samen met je herstelwachtwoord genereren je wallet.",
      title: "Wat is een backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "Met 'check backup' kun je verifiren dat je een werkende backup hebt die overeenkomt met je huidige wallet.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, dit is niet mogelijk. Bewaar de microSD kaart op een veilige plek, omdat de onversleutelde herstelwoorden die je wallet kunnen herstellen hierop staan. Als je een wachtwoordbeveiliging wilt gebruiken, kun je de optionele wachtwoordfunctie inschakelen onder de geavanceerde instellingen. ",
      title: "Kan ik de backup versleutelen?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwachtwoorden op een microSD kaart.",
      title: "Wat is een backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Wanneer 2FA is ingeschakeld moeten alle (verzend-) transacties goedgekeurd worden met de gekoppelde mobiele telefoon. Dit is wat er onder de motorkap gebeurt: Een versleuteld bericht wordt naar de mobiele app gestuurd en ontgrendeld, waarna het teruggestuurd wordt naar de BitBoxApp als je op 'accepteren' klikt. Deze communicatie wordt gedaan via het kanaal dat opgezet wordt tussen de mobiele telefoon en de BitBoxApp tijdens het koppelen. 

Zorg dat je wallet gebackupt is en gekoppeld met de mobiele app voordat je 2FA inschakeld. Zodra dit gebeurd is worden de microSD poort en het koppelen met de mobiele app uitgeschakeld. Ze kunnen opnieuw ingeschakeld worden door de BitBox te resetten, wat ook je wallets verwijdert. `,
      title: "Hoe werkt tweefactor authenticatie (2FA)?"
    },
    disable2FA: {
      text: "Om 2FA uit te zetten moet je de BitBox resetten en herstellen middels je backup. Zorg ervoor dat je de microSD kaart met de backup nog hebt en dat je het herstelwachtwoord nog weet. Kies dan voor 'Reset BitBox' in de instellingen. Kies een nieuw apparaatwachtwoord en kies 'herstel een backup'. Selecteer de backup die je voor je wallet hebt gemaakt, klik op herstellen en voer het herstelwachtwoord in wat je hebt gekozen toen je de wallet aanmaakte.",
      title: "Hoe kan ik tweefactor authenticatie (2FA) uitschakelen?"
    },
    ejectBitbox: {
      text: "Je kunt de BitBox op ieder moment uit je apparaat halen, zonder dat je het eerst hoeft uit te werpen.",
      title: "Hoe kan ik de BitBox uitwerpen?"
    },
    ejectSD: {
      text: "Je kunt de microSD kaart op ieder moment handmatig uit je BitBox halen, zo lang je niet op dat moment een backup aan het maken of herstellen bent.",
      title: "Hoe kan ik de microSD kaart uitwerpen?"
    },
    hiddenWallet: {
      text: "Het is een tweede wallet op dezelfde BitBox, die beschermd wordt door aparte apparaat- en herstelwachtwoorden, die je kunt gebruiken om een gedeelte van je balans te verbergen. Dezelfde herstelwoorden / SD kaart backup wordt gebruikt voor je normale en verborgen wallet, dus je hebt geen extra backup nodig.",
      title: "Wat is een verborgen wallet?"
    },
    legacyHiddenWallet: {
      text: "Klik eerst op onderstaande button (die beschikbaar is als de BitBox ontgrendeld is en 2FA niet ingeschakeld staat), plug daarna je BitBox opnieuw in en ontgrendel hem met je verborgen apparaatwachtwoord.",
      title: "Hoe krijg ik toegang tot mijn verborgen legacy wallet?"
    },
    pairing: {
      text: "Nadat je de mobiele BitBoxApp hebt gedownload voor iOS of Android, kun je de weergegeven QR-code scannen. Dit zet een beveiligd kanaal op tussen de mobiele telefoon en deze applicatie. Zodra je de QR-code gescand hebt, kun je de instructies op je telefoon volgen.",
      title: "Hoe koppel ik mijn mobiele telefoon?"
    }
  },
  cointracking: {
    text: "Klik op de 'exporteren' knop en open de downloads map. Hier vind je een .csv export bestand. Klik op onderstaande link, upload je BitBox .csv bestand en importeer de data om het in je CoinTracking porfoliomanager te gebruiken en je belastingaangifte te genereren.",
    title: "Hoe importeer ik mijn transacties in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lees meer over de authenticiteits-check"
      },
      text: "De BitBoxApp doet een authenticiteitscheck om er zeker van te zijn dat je BitBox echt is. Deze check wordt lokaal uitgevoerd en benodigt geen verbinding naar externe servers.",
      title: "Hoe werkt de authenticiteitscheck?"
    },
    name: {
      text: "Dit is de naam van je wallet en van je backup. De naam wordt gebruikt voor toekomstige backups en kan ook gebruikt worden om verschillende wallets te onderscheiden. Deze kun je op ieder moment veranderen, maar backups die je hiervoor gemaakt hebt zullen nog steeds de oude naam gebruiken.",
      title: "Waar wordt de BitBox02-naam voor gebruikt?"
    },
    "secure-chip": {
      link: {
        text: "Lees meer over de secure chip"
      },
      text: "Deze informatie toont het modelnummer van de secure chip. De het nieuwste model is de ATECC608B, die verbeterde beveiligings-eigenschappen heeft vergleken met oudere modellen.",
      title: "Waarom wordt het secure chip modelnummer getoond?"
    }
  },
  receive: {
    address: {
      text: "Je kunt dit adres aan anderen geven, zodat ze transacties naar je kunnen doen. Controleer altijd met de verzender of zij wel het juiste adres hebben ingevuld!",
      title: "Wat moet ik met een adres?"
    },
    addressChange: {
      text: "Zodra je een transactie doet, wordt er automatisch een nieuw adres gegenereerd en toegevoegd aan de lijst. Zo heb je altijd 20 adressen beschikbaar die nog nooit coins hebben ontvangen.",
      title: "Wanneer veranderen mijn adressen?"
    },
    addressFormats: {
      text: "Het standaardadrestype is Native Segwit. Dit adrestype is het meest gebruikt door andere wallets en exchanges en zorgt ervoor dat je de laagste transactiekosten betaalt. Je kunt er echter voor kiezen om bitcointransacties naar Taproot-adressen te doen, wat het nieuwste adresformaat is, maar nog niet overal ondersteund wordt. Als je problemen ondervind met het versturen naar een Native Segwit adres, kun je ervoor kiezen om een Wrapped Segwit adres te gebruiken, wat met vrijwel alle andere wallets en exchanges compatibel is. ",
      title: 'Wanneer moet ik "Adrestype wijzigen" gebruiken?'
    },
    howVerify: {
      text: `Voor de BitBox01 klik je op het BitBox icoon in het zijmenu aan de linkerkant en ga je naar de 'koppelen'-sectie. Als je daar bent, updatet de hulp en kun je de instructies daar verder volgen.
Op de BitBox02 kun je adressen direct op het apparaat verifiren tijdens het proces van verzenden of ontvangen.`,
      title: "Hoe kan ik veilig mijn adressen verifiren?"
    },
    plugout: {
      text: "Nee, zodra je je coins naar het adres hebt verstuurd, kun je je BitBox gewoon weer opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het ontvangen?"
    },
    why20: {
      text: "Tijdens het opstarten genereert de app verschillende adressen op basis van je seed om te kijken of ze iets hebben ontvangen. Omdat de app een praktisch oneindige hoeveelheid adressen kan genereren, kan de app ook oneindig doorgaan met adressen controleren tijdens het opstarten. Om dit te voorkomen, stopt de app met controleren als het 20 adressen achter elkaar heeft gezien die niets ontvangen hebben. Dit is het tussenruimte-limiet en 20 is hiervoor de arbitraire standaard. Dit zijn de 20 adressen waar je uit kunt kiezen.",
      title: "Waarom slechts 20 adressen?"
    },
    whyMany: {
      text: "Om je privacy en veiligheid te bewaken, moet je nooit twee keer hetzelfde adres gebruiken; bekijk een adres als een factuurnummer. Als je een adres hebt gebruikt, kun je op de rechterpijl klikken voor een nieuw adres. Je kunt tot 20 adressen tegelijkertijd aanmaken. Alle adressen zijn gegenereerd op basis van je backup herstelwoorden.",
      title: "Waarom zo veel adressen?"
    },
    whyVerify: {
      text: `Je zou je computer niet moeten vertrouwen om adressen te genereren en weer te geven. Je computer heeft een veel hoger aanvalsrisico dan een hardware wallet, waardoor de kans op virussen en malware vele malen hoger is. 
Voor de BitBox01 klik je op de knop om een veilig adres naar de gekoppelde telefoon te sturen, die je ook kun gebruiken om de QR-code te scannen en verifiren. Voor de BitBox02 kun je het adres direct op het display verifiren. `,
      title: "Waarom moet ik mijn adressen verifiren. "
    }
  },
  send: {
    change: {
      text: "Het wisselgeld wordt naar een Taproot-adres gestort als je ten minste n andere Taproot-UTXO hebt. Als je coin control gebruikt, wordt het wisselgeld naar een Taproot adres gestort als er zich ten minste n Taproot-UTXO tussen de geselecteerde UTXOs bevindt. In alle andere gevallen wordt het wisselgeld naar een Native Segwit adres gestort. ",
      title: "Hoe wordt het wisselgeldadres bepaald?"
    },
    fee: {
      text: `De netwerkkosten worden geschat op basis van de grootte van de transactie en niet de hoeveelheid. De netwerkkosten worden berekend door het algoritme van Bitcoin Core op basis van de prioriteit die je zelf kiest. Deze worden weergegeven als ze een andere waarde hebben dan de waardes hieronder:
Budget: 24 blokken (ongeveer 4 uur voor Bitcoin, 1 uur voor Litecoin)
Laag: 12 blokken (ongeveer 2 uur voor Bitcoin, 30 minuten voor Litecoin)
Normaal: 6 blokken (ongeveer 1 uur voor Bitcoin, 15 minuten voor Litecoin)
Hoog: 2 blokken (ongeveer 20 uur voor Bitcoin, 5 minuten voor Litecoin)
(Een Bitcoin-blok kost gemiddeld 10 minuten en een Litecoin-blok 2,5 minuut om te minen. De belasting op het netwerk en dus je bevestigingstijd kan drastisch variren.)`,
      title: "Hoe worden de netwerkkosten bepaald?"
    },
    plugout: {
      text: "Nee, zodra je een transactie hebt gemaakt, hoef je je BitBox niet ingeplugd te laten. Je kunt je BitBox direct na verzenden veilig opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het verzenden?"
    },
    priority: {
      text: "Hoe hoger de netwerkkosten die je bereid bent te betalen, hoe sneller je transactie bevestigd zal worden door het netwerk.",
      title: "Wat is de netwerkprioriteit?"
    },
    revert: {
      text: "Zodra een transactie is ondertekend en verzonden (uitgezonden naar het netwerk), kan het niet teruggedraaid worden. Verifieer daarom altijd alle onderdelen van de transactie (inclusief de netwerkkosten) voordat je hem ondertekent! Als je de ontvanger kent, kun je ze middels een ontvangstadres vragen om de transactie handmatig terug te sturen.",
      title: "Kan ik een transactie terugdraaien?"
    },
    whyFee: {
      text: "Transacties concurreren met elkaar om bevestigd te worden door een miner. Miners kiezen de transacties die ze in hun blokken stoppen op basis van welke transacties het meeste betalen. Miners bepalen welke transacties er opgenomen worden in de blockchain. Omdat er geen vertrouwde derde partijen zijn om te bepalen welke transacties valide zijn, doen miners dit door middel van computerkracht op te offeren. Als beloning voor hun werk, kunnen ze nieuwe Bitcoin en de netwerkkosten van alle transacties die ze hebben uitgekozen opeisen.",
      title: "Waarom zijn er netwerkkosten?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Als je je eigen node wilt verbinden die zich op hetzelfde netwerk bevindt (bv. je wifinetwerk thuis), kun je zonder problemen normale netwerkcommunicatie gebruiken. Het is aan te raden dat je Electrum-server een TLS-certificaat heeft om de communicatie te versleutelen.
Als je op andere locaties dan alleen thuis met je node wilt verbinden, is Tor de betere optie. In dit geval is een TLS-certificaat niet nodig.`,
      title: "Moet ik clearnet TCP, TLS of Tor gebruiken?"
    },
    instructions: {
      link: {
        text: "Instructies om je eigen node te koppelen."
      },
      text: "Voor een volledige tutorial kun je onze instructies op deze webpagina volgen:",
      title: "Hoe verbind ik mijn BitBoxApp met mijn eigen full node?"
    },
    options: {
      text: `Er zijn meerdere opties om je eigen node te draaien, zoals een kant-en-klaar apparaat te kopen, er zelf een te bouwen of Bitcoin Core te draaien op je PC. Als je de BitBoxApp wilt verbinden met je eigen node, moet je ervoor zorgen dat het beschikt over een Electrum server. Dit is een programma dat toegeweid is aan het verbinden van wallets met je full node.
Ondersteunde opties zijn Electrs, Electrum Personal Server of Bitcoin Wallet Tracker.`,
      title: "Welke opties heb ik om zelf een full node te draaien?"
    },
    tor: {
      text: `Tor staat voor 'The Onion Router'. Het is een gratis, open source programma dat je extra privacy biedt en heel nuttig is in combinatie met Bitcoin. 
Als je met je node wilt verbinden via Tor, moet je ervoor zorgen dat Tor is genstalleerd op je computer en dat de Tor Proxy is ingeschakeld in de instellingen van de BitBoxApp.
Op de meeste besturingssystemen zijn er twee manieren om Tor te gebruiken:
1. Tor Browser: download en open de Tor Browser. Dit zorgt ervoor dat de BitBoxApp kan verbinden met het Tor netwerk als je poort 9150 hebt ingesteld in de Tor Proxy instellingen.
2. Tor achtergronddienst: installeer de Tor daemon, die altijd in de achtergrond draait. De BitBoxApp kan dan verbinden door poort 9050 in te stellen in de Tor Proxy instellingen.`,
      title: "Wat zijn Tor en de Tor Proxy, en welke poort moet ik gebruiken?"
    },
    what: {
      text: "Het is mogelijk om je wallet te verbinden met je eigen full node, in plaats van het gebruiken van de Shift servers.",
      title: "Wat is dit?"
    },
    why: {
      text: `Het draaien van je eigen node is niet noodzakelijk, maar het verhoogt wel je privacy en verlaagt de noodzaak om anderen te vertrouwen.
Het betekent dat je Bitcointransacties meer priv zijn, omdat de BitBoxApp niet meer verbindt met onze servers om je transactiegeschiedenis op te halen. In plaats daarvan wordt die informatie van je eigen node gehaald.
Ten tweede zorgt het draaien van je eigen node ervoor dat je alle transacties zelf verifieerd en controleert of de consensusregels gevolgd worden `,
      title: "Waarom zou ik mijn eigen node moeten draaien?"
    }
  },
  settings: {
    sats: {
      text: 'Een Satoshi (of "sat" in het kort) is de kleinst mogelijke eenheid op het bitcoinnetwerk. Een satoshi is n honderdmiljoenste bitcoin (0.00 000 001 BTC). Het is vernoemd naar de maker van Bitcoin, Satoshi Nakamoto.',
      title: "Wat is een Satoshi?"
    },
    servers: {
      text: `De app communiceert met de Shift Crypto servers om op updates te controleren, je transacties te laden en informatie te versturen naar je gekoppelde mobiele apps. 
De app haalt ook de huidige wisselkoersen van CoinGecko. Alle conversies worden lokaal gedaan, zodat je balansen nooit naar derde partijen verstuurd worden.
Voor Ethereum en ERC20 tokens worden de Etherscan.io APIs gebruikt.`,
      title: "Met welke servers verbindt deze app?"
    }
  },
  title: "Gids",
  toggle: {
    close: "Gids sluiten",
    open: "Gids"
  },
  trackingModePortfolioChart: {
    text: "Op de desktop kun je je muiscursor over de grafiek heen bewegen. Op je telefoon gebruik je je vinger om horizontaal over de grafiek te slepen.",
    title: "Hoe kan ik de historische waardes op de grafiek inzien?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Je moet het apparaat resetten en de wallet herstellen middels een backup en het herstelwachtwoord.",
      title: "Wat moet ik doen als ik het wachtwoord van mijn BitBox vergeten ben?"
    },
    reset: {
      text: "Door 15 keer een verkeerd apparaatwachtwoord in te voeren. Tijdens de laatste paar keer moet je de knoppen langer ingedrukt houden.",
      title: "Hoe reset ik mijn BitBox?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Het apparaat zou n keer moeten knipperen als het ingevoerd wordt. Zorg dat het met de juiste kant boven ingevoerd is. Als je het probleem niet opgelost krijgt, kun je contact met ons opnemen via onderstaande link.
De BitBox01 is niet te koppelen met mobiele telefoons. Gebruik alsjeblieft de BitBoxApp op een PC om je BitBox01 te verbinden.`,
      title: "Mijn BitBox01 wordt niet herkend."
    },
    getDevice: {
      link: {
        text: "Bestel een BitBox"
      },
      text: "Je kunt een BitBox op onze webwinkel bestellen:",
      title: "Hoe kan ik aan een BitBox komen?"
    },
    internet: {
      text: "Ja, een internetverbinding is nodig om de wallet te synchroniseren, transacties te versturen en de laatste wisselkoersen op te halen.",
      title: "Heeft deze app een internetverbinding nodig?"
    },
    lostDevice: {
      link: {
        text: "Backup-center"
      },
      text: "Je kunt je accounts herstellen met een nieuwe BitBox of via ons backup-center",
      title: "Ik ben mijn BitBox kwijt, wat nu?"
    },
    useWithoutDevice: {
      text: "Dat is op dit moment niet mogelijk.",
      title: "Kan ik de app ook zonder BitBox gebruiken?"
    },
    welcome: {
      text: "Bedankt voor het gebruiken van deze app, gemaakt door Shift Crypto in Zwitserland. We waarderen alle feedback die je voor ons hebt! Die kun je delen door op de link onderaan het scherm te klikken.",
      title: "Welkom in de BitBoxApp!"
    }
  }
}, headerssync$a = {
  blocksSynced: "{{blocks}} blokken gesynchroniseerd"
}, hiddenWallet$a = {
  info1HTML: "Je kunt een verborgen wallet aanmaken met een <strong>andere</strong> combinatie van apparaatwachtwoord & herstelwachwoord, om plausibele ontkenning mogelijk te maken.",
  info2HTML: "Voer het apparaatwachwoord en het herstelwachtwoord dat je met je verborgen wallet wilt associren hieronder in. Het apparaatwachtworod en het herstelwachtwoord <strong>moeten</strong> van je hoofdwallet verschillen.",
  passwordLabel: "Verborgen herstelwachtwoord",
  passwordPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  pinLabel: "Verborgen apparaatwachtwoord",
  pinRepeatLabel: "Herhaal je verborgen herstelwachtwoord",
  pinRepeatPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  success: "Verborgen wallet aangemaakt. Voer je BitBox opnieuw in om het te ontgrendelen."
}, initialize$a = {
  create: "Stel apparaatwachtwoord in",
  creating: "Apparaatwachtwoord instellen...",
  error: {
    e102: "Het apparaatwachtwoord moet ten minste vier karakters bevatten."
  },
  info: {
    description1: "Kies je apparaatwachtwoord. Dit wordt gebruikt om je BitBox te ontgrendelen.",
    description2: "Je kunt nummers, letters en symbolen gebruiken. Langere wachtwoorden bieden je meer veiligheid.",
    description3: "Als je je apparaatwachtwoord kwijtraakt moet je je BitBox resetten met je backup.",
    subtitle: "Nu ga je je apparaatwachtwoord instellen.",
    title: "Apparaat initialiseren..."
  },
  input: {
    label: "Apparaatwachtwoord",
    labelRepeat: "Herhaal apparaatwachtwoord",
    placeholderRepeat: "Bevestig apparaatwachtwoord"
  }
}, invalidFormat$a = "Ongeldig format", language$b = {
  title: "Selecteer je taal"
}, legacyhiddenwallet$a = {
  disable: "Verborgen legacy wallet uitschakelen",
  enable: "Verborgen legacy wallet inschakelen",
  successDisable: "Verborgen legacy wallet uitgeschakeld",
  successEnable: "Verborgen legacy wallet ingeschakeld. Plug je BitBox opnieuw in en voer het verborgen apparaatwachtwoord in om toegang te krijgen tot je verborgen legacy wallet."
}, loading$a = "laden...", manageAccounts$4 = {
  editAccount: "Bewerken",
  editAccountNameTitle: "Accountnaam bewerken",
  noAccounts: "Geen accounts gevonden",
  settings: {
    hideTokens: "Tokens verbergen",
    showTokens: "Tokens tonen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Accounts toevoegen en tonen/verbergen",
  title: "Accounts beheren"
}, mobile$5 = {
  usingMobileDataWarning: `Mobiel datagebruik: deze app kan een paar honderd megabyte aan blockchaindata downloaden als je een account opent. Verbind met een wifinetwerk om je mobiele datagebruik te beperken.

Dit bericht wordt niet nogmaals getoond.`
}, newSettings$4 = {
  about: {
    appVersion: {
      title: "App versie"
    }
  },
  advancedSettings: {
    coinControl: {
      description: "Selecteer welke UTXOs onderdeel van een transactie zijn om privacy te verbeteren."
    },
    customFees: {
      description: "Dit laat je de transactiekosten van een overboeking precies bepalen."
    },
    torProxy: {
      description: "Verbind via Tor voor betere privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Je kunt door alle valuta heen wisselen op de acccountpagina.",
      title: "Actieve valuta"
    },
    darkmode: {
      description: "Verander het uiterlijk van de BitBoxApp naar een donkere kleurstelling."
    },
    defaultCurrency: {
      description: "Selecteer je standaardvaluta",
      title: "Standaardvaluta"
    },
    language: {
      description: "De taal waarin je de BitBoxApp wilt gebruiken.",
      title: "Taal"
    },
    toggleSats: {
      description: "Satoshis in- of uitschakelen."
    }
  }
}, note$6 = {
  input: {
    description: "(optioneel)",
    placeholder: "Notitie toevoegen"
  },
  title: "Notitie"
}, notification$a = {
  newTxs_one: "Nieuwe transactie in: {{accountName}}",
  newTxs_other: "{{count}} nieuwe transacties in: {{accountName}}"
}, pairing$a = {
  aborted: {
    text: "Het koppelen van de mobiele app is afgebroken.",
    title: "Afgebroken"
  },
  button: "Mobiele app koppelen",
  confirm: "Weet je zeker dat je je BitBox wilt koppelen? Hierna heb je je mobiele telefoon nodig om een transactie uit te voeren.",
  connectOnly: {
    button: "Mobiele app verbinden",
    title: "Scan met de mobiele app door in het menu 'Nieuwe desktop-app verbinden' te kiezen."
  },
  error: {
    text: "Er is iets misgegaan. Probeer het opnieuw.",
    title: "Fout"
  },
  pullFailed: {
    text: "We konden het bericht niet van je telefoon ophalen door de relay server. De server kan offline zijn, neem contact op met de klantenservice.",
    title: "Pull niet gelukt"
  },
  reconnectOnly: {
    button: "Mobiele app opnieuw verbinden"
  },
  scanningFailed: {
    text: "Telefoon kon het bericht niet scannen. Probeer het opnieuw.",
    title: "Scan niet gelukt"
  },
  start: {
    hideAppQRCode: "QR-code verbergen",
    revealAppQRCode: "QR-code tonen",
    step1: "Als je de mobiele app niet hebt, kun je de QR-code voor de App Store of Play store scannen, afhankelijk van welke telefoon je hebt. ",
    step2: "Scan met onze mobiele app, die je kunt vinden als 'Digital BitBox 2FA' in de iOS en Android app stores."
  },
  started: {
    text: "Volg de instructies op de mobiele app",
    title: "Fantastisch"
  },
  success: {
    text: "Gefeliciteerd, je hebt je BitBox met de mobiele app gekoppeld!",
    title: "Gelukt"
  },
  timeout: {
    text: "Het koppelen is na twee minuten automatisch gestopt. Begin opnieuw als je de mobiele app nog steeds wilt koppelen. ",
    title: "Time-out"
  },
  title: "Mobiele koppeling"
}, passphrase$4 = {
  considerations: {
    button: "Backup overwegingen",
    message: `De passphrase biedt je extra bescherming voor je (microSD of herstelwoord-) backup. Als iemand toegang heeft gekregen tot je backup, hebben ze nu ook de passphrase nodig om toegang te krijgen tot je wallet.

Dit betekent echter dat je <strong>zowel de passphrase als de backup</strong> nodig hebt om je wallet te herstellen wanneer je BitBox02 kapot gaat of verloren raakt. Als je je passphrase verliest of vergeet, raak je de toegang tot alle coins op die wallet kwijt.

Als je je passphrase ergens opslaat, zou je dit op een andere plek dan je backup moeten doen. Op die manier heeft iemand die je backup vindt niet ook toegang tot je passphrase.`,
    title: "Backup overwegingen"
  },
  disable: "Passphrase uitzetten",
  disableInfo: {
    button: "Uitzetten",
    message: `Nadat je de passphrase hebt uitgezet, word je niet langer gevraagd om een passphrase in te voeren nadat je je BitBox02 hebt ontgrendeld. Je voert dus je standaard wallet in.

Eventuele coins die nog op je passphrase wallet staan, zullen daarop blijven staan, en je kunt hier niet meer bij; je BitBox vraagt immers niet meer om de passphrase en opent direct je standaard wallet. Om weer toegang te krijgen, kun je simpelweg de passphrase opnieuw inschakelen en de passphrase weer invoeren bij het opstarten.

<strong>Tip:</strong> Je kunt ook met een passphrase toegang tot je standaardwallet krijgen door niks in te voeren als er om je passphrase gevraagd wordt.`
  },
  enable: "Passphrase inschakelen",
  error: {
    e104: "Het veranderen van de passphrase-instelling is geannuleerd."
  },
  how: {
    button: "Hoe het er uit ziet",
    message: `Een passphrase werkt niet zoals andere wachtwoorden waar je aan gewend bent. Als je je passphrase verkeerd invoerd, krijg je hier geen melding van. Dit komt omdat <strong>iedere passphrase een nieuwe, valide wallet maakt</strong>. Dit betekent dat je zo veel verschillende wallets kunt aanmaken als je wilt door een andere passphrase in te voeren. Je kunt weer toegang krijgen tot iedere wallet door de bijbehorende passphrase in te voeren.

Als je je BitBox02 invoert, zul je zoals je gewend bent om het gewone wachtwoord gevraagd worden. Daarna kun je een passphrase invoeren.

Nadat je de passphrase hebt ingevoerd, kun je nog een keer checken wat je precies hebt ingevoerd, zodat je zeker weet dat het was wat je verwachtte.`,
    title: "Hoe werkt het"
  },
  intro: {
    message: `Een passphrase zorgt voor extra beveiliging voor je wallet.
Dit is hoe het werkt.`,
    title: "Passphrase instellen"
  },
  progressDisable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>uitschakelen</strong>",
    title: "Bevestig op je BitBox"
  },
  progressEnable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>aanzetten</strong>.",
    title: "Bevestig op je BitBox"
  },
  successDisabled: {
    message: `De passphrase <strong>staat nu aan</strong>!
Vanaf nu zul je tijdens het opstarten om een passphrase worden gevraagd.`,
    messageEnd: "Plug alsjeblieft de BitBox opnieuw in.",
    title: "Passphrase aangezet"
  },
  successEnabled: {
    message: `De passphrase <strong>staat nu uit</strong>!
Vanaf nu zul je niet langer tijdens het opstarten om een passphrase worden gevraagd.`,
    messageEnd: "Plug je BitBox02 opnieuw in.",
    tips: "Tips",
    tipsList: [
      "We raden je aan om een kleine hoeveelheid coins naar de passphrase wallet te sturen. Plug daarna je BitBox opnieuw in en voer je wachtwoord en passphrase in. Als je passphrase correct is, zou je de coins in je wallet moeten zien.",
      "Als je toegang wilt krijgen tot de originele wallet, kun je dit nog steeds doen door niets in te voeren als je om een passphrase wordt gevraagd. Of je kunt de passphrase helemaal uitzetten."
    ],
    title: "Passphrase uitgeschakeld"
  },
  summary: {
    button: "Passphrase aanzetten",
    title: "Samenvatting",
    understand: "Ik snap hoe de passphrase werkt, en begrijp de risico's die het met zich meebrengt.",
    understandList: [
      "De passphrase is een extra beveiliging bovenop je backup",
      "Het invoeren van een andere passphrase genereert een andere wallet.",
      "Om je wallet te herstellen heb je <strong>zowel de passphrase als de backup</strong> nodig.",
      "Als je je passphrase vergeet, kun je geen toegang meer krijgen tot je coins."
    ]
  },
  what: {
    button: "Leer hoe dit werkt",
    message: `Een wallet komt voort uit een heel groot willekeurig getal, ook wel bekend als je 'seed'. Deze seed is gemaakt toen je je BitBox02 voor het eerst instelde en is gebackupt met de microSD kaart of je lijst van herstelwoorden. Iedereen die toegang heeft tot de seed, heeft volledige controle over de coins in die wallet. 

Een passphrase is een <strong>optioneel geheim</strong> dat toegevoegd wordt aan de seed. Wanneer je de passphrase aanzet, maakt iedere verschillende passphrase een nieuwe wallet op basis van de seed <strong>en</strong> de passphrase. Een passphrase kan alles zijn; letters, woorden, speciale karakters, of helemaal niets. In feite is je standaardwallet een seed met een lege passphrase.

Deze passphrase is onderdeel van de BIP39 standaard, wat betekent dat hij compatibel is met alle wallets die diezelfde standaard ondersteunen. `,
    title: "Wat is een passphrase?"
  },
  why: {
    button: "Waarom zou ik een passphrase gebruiken?",
    message: `De BitBox02 beschermt je seed op het apparaat zelf, maar de backup (op de microSD kaart of je herstelwoorden) geeft nog steeds volledige controle over de wallet. Dat is waarom deze backup veilig opgeslagen moet worden!

Omdat een passphrase een nieuwe wallet genereert met de bestaande seed, heeft een passphrase wallet <strong>zowel de backup als de passphrase</strong> nodig om hem te herstellen. Het voordeel hiervan is dat als iemand je backup vindt, ze nog steeds je passphrase nodig hebben om toegang te krijgen tot je wallet.

Daarnaast kun je met de passphrase meerdere wallets op hetzelfde device aanmaken, ook bekend als 'verborgen wallets', naast de bestaande wallet.`,
    title: "Waarom zou je een passphrase gebruiken?"
  }
}, password$a = {
  show: "Toon {{label}}",
  warning: {
    caps: "WAARSCHUWING: Caps lock () is ingeschakeld",
    paste: 'om tekst te plakken, schakel je "SHOW {{label}}" in'
  }
}, random$b = {
  button: "Genereer willekeurig getal",
  description: "Je BitBox heeft het volgende willekeurige getal van {{bits}} bits gegenereerd:"
}, receive$c = {
  changeScriptType: "Adrestype wijzigen",
  label: "Jouw adres",
  onlyThisCoin: {
    description: "Om andere tokens te ontvangen, moet je deze inschakelen in de instellingen. Als je hier andere tokens stort, zijn ze mogelijk niet toegankelijk.",
    warning: "Zorg dat je alleen {{coinName}} op dit adres ontvangt."
  },
  scriptType: {
    p2tr: "Taproot (nieuwste adresformaat)",
    p2wpkh: "Native Segwit (standaard)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatibiliteitsformaat)"
  },
  selectAccount: "Selecteer een account",
  showFull: "Toon het volledige adres op je BitBox om te verifiren",
  taprootWarning: "Let op: Taproot is een nieuwe adressoort in Bitcoin en wordt nog niet op grote schaal gebruikt. Het kan bijvoorbeeld zijn dat bitcoin die op een Taproot-adres ontvangen wordt, niet weergegeven wordt in andere watch-only wallets. Veel andere wallets en exchanges kunnen ook nog niet naar Taproot-adressen zenden.",
  title: "{{accountName}} ontvangen",
  verify: "Verifieer veilig je adres ",
  verifyBitBox01: "Verifieer het adres op de mobiele app",
  verifyBitBox02: "Verifieer het adres op je BitBox02",
  verifyInstruction: "Verifieer of het volgende adres hetzelfde is als het adres wat op je BitBox wordt getoond.",
  warning: {
    secureOutput: "Koppel je BitBox met je mobiele telefoon om beveiligde adresverificatie in te schakelen. Ga hiervoor naar 'Apparaten beheren' in de zijbalk."
  }
}, reset$a = {
  description: "Alle data zal van dit apparaat worden verwijderd, inclusief je privsleutel!",
  notReset: "Apparaat NIET gereset",
  title: "Fabrieksinstellingen terugzetten",
  understand: "Ik heb een backup en weet mijn herstelwachtwoord",
  understandBB02: "Ik heb een geldige backup"
}, securityInformation$a = {
  create: {
    description1: "We raden je aan om je apparaat in te stellen in een veilige omgeving. Het belangrijkste is dat andere mensen niet kunnen zien welk wachtwoord je keist.",
    description2: "Je wordt gevraagd om twee wachtwoorden aan te maken.",
    description3: "Het eerste is het <strong>apparaatwachtwoord</strong>, wat je BitBox ontgrendeld. Dit kan later veranderd worden.",
    description4: "Het tweede is je <strong>herstelwachtwoord</strong>, wat je wallet ontgrendeld. Dit wachtwoord kan niet gewijzigd worden.",
    description5: "De wallet die je aanmaakt wordt gebackupt als bestand op de meegeleverde microSD kaart. Dit kan <strong>samen met je herstelwachtwoord</strong> gebruikt worden om je wallets te herstellen.",
    title: "Beveiligingsinformatie"
  },
  restore: {
    description1: "Je wordt gevraagd om de microSD kaart die je gebruikt hebt om je backup te maken in te voeren.",
    description2: "Om je apparaat te herstellen, heb je je herstelwachtwoord nodig.",
    description3: "Zorg ervoor dat je het juiste herstelwachtwoord invoert. Ongeacht wat je hier invoert, maak je een valide wallet aan. Als je een verkeerd wachtwoord invoert, krijg je waarschijnlijk een nieuwe, lege wallet te zien.",
    title: "Beveiligingsinformatie"
  }
}, seed$a = {
  agreements: {
    "funds-access": "Ik kan NIET bij mijn wallets als ik mijn herstelwachtwoord vergeet",
    "password-change": "Ik kan het herstelwachtwoord NIET meer veranderen",
    "password-required": "Het hetstelwachtwoord is nodig om een wallet van een backup te herstellen"
  },
  create: "Wallet aanmaken",
  creating: "Wallet aanmaken...",
  description: "Ik heb het volgende gelezen en begrepen:",
  error: {
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e200: "Je moet een microSD kaart in je BitBox invoeren om een wallet aan te maken, zodat er automatisch een backup gegenereerd kan worden."
  },
  info: {
    button: "Stel nu je herstelwachtwoord in",
    description1: "Voer de microSD kaart in de BitBox in",
    description2: 'Kies een herstelwachtwoord voor de wallet en selecteer "Herstelwachtwoord nu instellen"',
    description3: "De backup op je microSD kaart en je herstelwachtwoord zijn de enige manier om weer toegang te krijgen tot je wallet als je BitBox verloren raakt, gestolen wordt, of kapot gaat.",
    description4: "Je kunt je herstelwachtwoord niet veranderen zonder je balans over te zetten op een nieuwe wallet.",
    title: "Nieuwe wallet aanmaken"
  },
  password: {
    label: "Herstelwachtwoord",
    repeatPlaceholder: "Herstelwachtwoord herhalen"
  },
  walletName: {
    label: "Walletnaam"
  }
}, seedRestore$a = {
  error: {
    e200: "Voor het herstellen van een backup is de microSD kaart nodig"
  },
  info: {
    description1: 'Voer de microSD kaart in de BitBox in en klik op "verder"',
    description2: 'Kies een backup en klik op "herstellen"',
    description3: "Voer het herstelwachtwoord in",
    description4: "Je moet bevestigen dat je begrijpt dat een verkeerd wachtwoord een nieuwe, andere wallet aanmaakt.",
    title: "Hoe herstel je een wallet vanuit een backup"
  }
}, send$c = {
  abort: "De transactie is afgebroken",
  address: {
    label: "Adres van de ontvanger",
    placeholder: "Adres invoeren"
  },
  amount: {
    label: "Hoeveelheid",
    placeholder: "Hoeveelheid invoeren"
  },
  availableBalance: "Beschikbare balans",
  button: "Controle",
  coincontrol: {
    address: "Adres",
    outpoint: "Output",
    title: "Verstuur uit output"
  },
  confirm: {
    "selected-coins": "Geselecteerde coins",
    title: "Bevestigen & transactie versturen",
    total: "Totaal"
  },
  error: {
    erc20InsufficientGasFunds: "Je hebt niet genoeg Ether in je wallet voor deze transactie. Stort meer Ether in je wallet om de transactie uit te voeren.",
    feeTooLow: "netwerkkosten te laag",
    feesNotAvailable: "Schatting van netwerkkosten niet beschikbaar",
    insufficientFunds: "ontoereikende balans",
    invalidAddress: "ongeldig adres",
    invalidAmount: "ongeldige hoeveelheid",
    invalidData: "ongeldige data"
  },
  fee: {
    customPlaceholder: "Hoeveelheid invoeren",
    label: "Netwerkkosten",
    placeholder: "Niet beschikbaar"
  },
  feeTarget: {
    customLabel: "Netwerktarief",
    customLabel_eth: "Gas-prijs",
    description: {
      economy: "4 uur (24 blokken)",
      economy_eth: "30 minuten of minder",
      economy_ltc: "1 uur (24 blokken)",
      high: "20 minuten (2 blokken)",
      high_eth: "30 seconden of minder",
      high_ltc: "5 minuten (2 blokken)",
      low: "2 uur (12 blokken)",
      low_eth: "5 minuten of minder",
      low_ltc: "30 minuten (12 blokken)",
      normal: "1 uur (6 blokken)",
      normal_eth: "2 minuten of minder",
      normal_ltc: "15 minuten (6 blokken)"
    },
    estimate: "Geschatte bevestigingstijd:",
    label: {
      custom: "Eigen selectie",
      economy: "Budget",
      high: "Hoog",
      low: "Laag",
      normal: "Normaal"
    },
    placeholder: "Netwerkkosten berekenen..."
  },
  maximum: "Alles verzenden",
  maximumSelectedCoins: "Geselecteerde coins verzenden",
  noFeeTargets: "Schattingen van de transactiekosten zijn op dit moment niet beschikbaar. Probeer het later opnieuw of stel zelf de hoogte in.",
  priority: "Prioriteit",
  scanQR: "QR-code scannen",
  signprogress: {
    description: "Dit is een transactie die veel data in zich heeft. Om de transactie te verzenden, word je gevraagd om {{steps}} keer te ondertekenen.",
    label: "Voortgang"
  },
  success: "De transactie is ondertekend en verzonden.",
  title: "Verstuur {{accountName}}",
  toggleCoinControl: "Coin control aan/uitzetten",
  transactionDetails: "Transactiedetails"
}, settings$b = {
  about: "Over",
  accounts: "Accounts",
  advancedSettings: "Geavanceerde instellingen",
  appearance: "Uiterlijk",
  electrum: {
    add: "Server toevoegen",
    "add-server": "Toevoegen",
    check: "Controleer",
    checkFailed: "Niet geslaagd",
    checkSuccess: "Verbinding met {{host}} tot stand gebracht",
    checking: "Aan het controleren",
    "download-cert": "Remote certificate downloaden",
    "remove-server": "Verwijderen",
    removeConfirm: "Wil je {{server}} verwijderen?",
    reset: "Terugzetten naar standaardinstelling",
    resetConfirm: "Wil je alle servers verwijderen en de standaard-servers instellen?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Voer het eindpunt in.",
    step2: "2",
    "step2-text": "Voer een certificaat van de server in. Je kunt ook het remote certificate downloaden en het op het oog inspecteren.",
    "step2-text-tcp": "Je kunt deze stap overslaan als je geen TLS wilt gebruiken.",
    step3: "3",
    "step3-text": "Controleer de verbinding en voeg de server toe.",
    step4: "4",
    "step4-text": "Start de wallet opnieuw op. Als je de standaard servers niet verwijderd, wordt je eigen node als backup-server toegevoegd.",
    "title-btc": "",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Coin control aanzetten",
    electrum: {
      description: "Je kunt hier met je eigen Electrum-fullnode verbinden.",
      title: "Verbind met je eigen full node"
    },
    fee: "Custom fees aanzetten",
    setProxyAddress: "Proxy adres instellen",
    title: "Geavanceerde instellingen",
    useProxy: "Tor proxy aanzetten",
    useSats: "BTC-waarde in Satoshis weergeven"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nieuwe update beschikbaar ",
    title: "Info",
    "up-to-date": "Je app is bijgewerkt",
    version: "App versie"
  },
  restart: "Start de BitBoxApp opnieuw op om de veranderde instellingen in te schakelen.",
  services: {
    title: "Diensten"
  },
  success: "Voer de BitBox opnieuw in om de veranderde instellingen in te schakelen.",
  title: "Instellingen"
}, setup$a = "Apparaat instellen", sidebar$b = {
  buy: "Crypto kopen",
  device: "Apparaat beheren",
  leave: "Verlaten",
  settings: "Instellingen"
}, success$h = {
  create: {
    info1: "Je wallet is veilig gebackupt op de microSD kaart. Verwijder deze en bewaar hem op een veilige plek.",
    info2: "Je hebt een veilig apparaatwachtwoord aangemaakt dat de BitBox ontgrendelt.",
    info3: "Je hebt een veilig herstelwachtwoord voor je wallet aangemaakt die je wallet ontgrendeld en nodig is om je backups te herstellen.",
    summary: "Hier is een samenvatting van wat je gedaan hebt",
    title: "Gelukt"
  },
  getstarted: "Get started",
  restore: {
    summary: "Je hebt je wallet vanuit je backup hersteld",
    title: "Gelukt"
  }
}, transaction$b = {
  confirmation: "Bevestigingen",
  details: {
    activity: "Activiteit",
    address: "Adres",
    amount: "Hoeveelheid",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Hoeveelheid in fiat",
    fiatAtTime: "Fiat-waarde ten tijde van de transactie",
    status: "Status",
    type: "Type"
  },
  explorer: "Transactie-ID",
  explorerTitle: "In externe block explorer openen",
  fee: "Netwerkkosten",
  fiatHistorical: "Historie",
  gas: "Gas",
  note: {
    edit: "Notitie aanpassen",
    save: "Notitie opslaan"
  },
  pending: "Transactie in afwachting",
  size: "Grootte",
  status: {
    complete: "Afgerond",
    failed: "Niet gelukt",
    pending: "In afwachting"
  },
  tx: {
    received: "Ontvangen naar",
    sent: "Verzonden naar"
  },
  vsize: "Virtuele grootte",
  weight: "Gewicht"
}, transactions$a = {
  errorLoadTransactions: "Er is een fout opgetreden bij het laden van de transacties",
  placeholder: "Nog geen transacties"
}, unknownError$a = "Er is een onbekende fout opgetreden: {{errorMessage}}", unlock$a = {
  description: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen",
  error: {
    e109_normal: "Apparaatwachtwoord onjuist. Je hebt nog {{remainingAttempts}} over voordat je BitBox wordt gereset.",
    e109_touch: "$t(unlock.error.e109_normal) Met de volgende login moet je de touchknop ingedrukt houden.",
    e113: "Omdat je tevaak geprobeerd hebt in te loggen, moet je de touchknop 4 seconden ingedrukt houden bij de volgende login."
  },
  input: {
    label: "Apparaatwachtwoord",
    placeholder: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen"
  },
  unlocking: "Ontgrendelen..."
}, upgradeFirmware$b = {
  button: "Firmware updaten",
  description: "Wil je de firmware updaten van versie {{currentVersion}} naar versie {{newVersion}}?",
  label: "Je BitBox heeft een firmwareupdate nodig.",
  locked: "Hou de touchknop lang ingedrukt om van {{currentVersion}} naar {{newVersion}} te updaten.",
  title: "Firmware updaten",
  unlocked: "De bootloader is ontgrendeld. Om door te gaan:",
  unlocked1: "Voer je BitBox opnieuw in",
  unlocked2: "Het LED lichtje gaat branden als je BitBox opnieuw is ingevoerd",
  unlocked3: "Klik op de touchknop wanneer het LED lichtje gaat branden"
}, warning$g = {
  receivePairing: "Koppel de BitBox om beveiligde adresverificatie in te schakelen. Ga naar 'Apparaat beheren' in de sidebar.",
  sdcard: "Bewaar de microSD kaart apart van de BitBox, tenzij je je backups aan het beheren bent.",
  sendPairing: "Koppel de BitBox om je transactiedetails beveiligd te kunnen verifiren. Ga naar 'Manage device' in de sidebar."
}, welcome$a = {
  getStarted: "Laten we beginnen door de firmware op je BitBox02 te installeren.",
  insertBitBox02: "Tap de touch-sensoren op je BitBox02 om door te gaan.",
  insertDevice: "Verbind je BitBox om te starten",
  title: "Welkom"
}, appTranslationsNL = {
  account: account$a,
  accountInfo: accountInfo$a,
  accountSummary: accountSummary$a,
  addAccount: addAccount$b,
  aopp: aopp$4,
  app: app$a,
  backup: backup$a,
  bb02Bootloader: bb02Bootloader$a,
  bitbox: bitbox$a,
  bitbox02Interact: bitbox02Interact$a,
  bitbox02Settings: bitbox02Settings$a,
  bitbox02Wizard: bitbox02Wizard$a,
  blink: blink$a,
  bootloader: bootloader$a,
  button: button$e,
  buy: buy$6,
  changePin: changePin$a,
  chart: chart$6,
  checkSDcard: checkSDcard$a,
  clickHere: clickHere$a,
  confirm: confirm$c,
  confirmOnDevice: confirmOnDevice$a,
  darkmode: darkmode$5,
  device: device$a,
  deviceLock: deviceLock$a,
  deviceSettings: deviceSettings$a,
  deviceTampered: deviceTampered$a,
  dialog: dialog$b,
  error: error$6,
  fiat: fiat$c,
  footer: footer$c,
  generic: generic$6,
  genericError: genericError$a,
  goal: goal$a,
  guide: guide$b,
  headerssync: headerssync$a,
  hiddenWallet: hiddenWallet$a,
  initialize: initialize$a,
  invalidFormat: invalidFormat$a,
  language: language$b,
  legacyhiddenwallet: legacyhiddenwallet$a,
  loading: loading$a,
  manageAccounts: manageAccounts$4,
  mobile: mobile$5,
  newSettings: newSettings$4,
  note: note$6,
  notification: notification$a,
  pairing: pairing$a,
  passphrase: passphrase$4,
  password: password$a,
  random: random$b,
  receive: receive$c,
  reset: reset$a,
  securityInformation: securityInformation$a,
  seed: seed$a,
  seedRestore: seedRestore$a,
  send: send$c,
  settings: settings$b,
  setup: setup$a,
  sidebar: sidebar$b,
  success: success$h,
  transaction: transaction$b,
  transactions: transactions$a,
  unknownError: unknownError$a,
  unlock: unlock$a,
  upgradeFirmware: upgradeFirmware$b,
  warning: warning$g,
  welcome: welcome$a
}, account$9 = {
  disconnect: "Conexo perdida. Tentando novamente...",
  export: "Exportar",
  exportTransactions: "Exportar transaes para a pasta Downloads como um arquivo CSV.",
  fatalError: "Ocorreu um erro inesperado.",
  incoming: "Lanamentos",
  initializing: "Obtendo informaes da blockchain...",
  maybeProxyError: "Tor proxy ativado. Certifique-se que seu Tor esteja rodando corretamente ou desative as opes de proxy.",
  reconnecting: "Conexo perdida, tentando reconectar...",
  syncedAddressesCount: "Encontrado {{count}} endereos"
}, accountInfo$9 = {
  address: "Endereo",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Cripto",
    information: {
      looksEmpty: "Parece que esta carteira est vazia.",
      start: "Comece depositando algumas moedas na carteira ou comprando diretamente no BitBoxApp."
    }
  },
  extendedPublicKey: "Chave pblica estendida",
  label: "Informaes da conta",
  scriptType: "Tipo de script",
  title: "Informaes da conta",
  verify: "Verificar no dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizar chave P2PKH pblica estendida j existente.",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Segwit Nativo",
    "p2wpkh-p2sh": "Veja a chave pblica estendida do Segwit mais antiga"
  },
  xpubTypeInfo: "Atualmente mostrando {{scriptType}} chave pblica estendida ({{current}} de {{numberOfXPubs}})"
}, accountSummary$9 = {
  availableBalance: "Saldo disponvel",
  balance: "Saldo",
  exportSummary: "Exportar resumo de contas para a pasta de Downloads como um arquivo CSV",
  fiatBalance: "Saldo em moeda corrente",
  name: "Nome da conta",
  noAccount: "No h contas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Meu portflio",
  total: "Total",
  transactionHistory: "Histrico de transaes"
}, addAccount$a = {
  chooseName: {
    nextButton: "Adicionar conta",
    step: "Nome conta",
    title: "Um nome para sua conta"
  },
  selectCoin: {
    nextButton: "Prximo",
    step: "Selecione a moeda",
    title: "Selecione a crypto."
  },
  success: {
    addAnotherAccount: "Adicionar outra conta",
    message: "<strong>{{accountName}}</strong> foi addicionado agora as suas contas.",
    nextButton: "Pronto",
    step: "Terminado",
    title: "Conta adicionada"
  },
  title: "Adicionar conta"
}, aopp$3 = {
  addressRequest: "{{host}} est solicitando um endereo de recebimento.",
  addressRequestWithLogo: "est solicitando um endereo de recebimento",
  banner: "Solicitao de endereo em andamento.",
  errorTitle: "Erro durante a solicitao de endereo",
  labelAddress: "Endereo",
  labelMessage: "Mensagem",
  reverifyInfoText: "Verificar endereo",
  signing: "Para prosseguir, assine a mensagem na sua BitBox02",
  success: {
    message: "Prossiga em {{host}}",
    title: "Endereo enviado com sucesso"
  },
  syncing: "Sincronizando a conta, aguarde.",
  title: "Solicitao de endereo"
}, app$9 = {
  upgrade: "Uma nova verso desse app est disponvel! Por favor, atualize de {{current}} para {{version}}."
}, auth$4 = {
  authButton: "Autenticar",
  title: "Autentique-se para continuar"
}, backup$9 = {
  check: {
    checking: "Checando backup...",
    confirmTitle: "Checar backup",
    notOK: "O Backup NO corresponde  carteira.",
    ok: "Backup corresponde  carteira.",
    password: {
      label: "Senha de recuperao",
      placeholder: "Senha de recuperao",
      showLabel: "senha de recuperao"
    },
    success: "Backup verificado com sucesso:",
    title: "Checar backup"
  },
  create: {
    alreadyExists: "Voc j tem um backup vlido. Voc deseja recri-lo?",
    fail: "A criao do backup FALHOU!",
    info: "Por favor, digite a senha de recuperao da carteira atual para verificao.",
    name: {
      label: "Nome do backup",
      placeholder: "Por favor, nomeie o backup"
    },
    password: {
      label: "Senha de recuperao",
      placeholder: "Por favor, digite sua senha de recuperao"
    },
    title: "Criar backup",
    verificationFailed: "A senha de recuperao NO CORRESPONDE  carteira atual. O backup foi criado. Por favor, use 'Checar backup' para verificar sua senha de recuperao novamente."
  },
  description: "Selecione um <strong>arquivo de backup da carteira</strong>",
  insert: "Por favor, insira o carto microSD para gerenciar backups.",
  insertButton: "Eu inseri o carto microSD",
  list: "Os backups do seu carto microSD",
  noBackups: "No h backups neste carto microSD.",
  restore: {
    confirmTitle: "Restaurar backup",
    error: {
      e200: "Carto microSD no encontrado",
      general: "Erro ao restaurar o backup"
    },
    password: {
      label: "Senha de recuperao ou senha de recuperao oculta",
      placeholder: "Senha de recuperao",
      repeatPlaceholder: "Repita a senha de recuperao",
      showLabel: "Senha de recuperao"
    },
    restoring: "Restaurando o backup...",
    selectedBackup: "<strong>{{backupName}}</strong> criado em {{createdDateTime}} ser restaurado.",
    title: "Restaurar",
    understand: "Eu entendo que uma senha de recuperao incorreta criar uma carteira diferente"
  },
  showMnemonic: {
    description: `Sero mostradas suas palavras de recuperao, que formam um backup de sua carteira. Anote-as em um papel.

<strong>No as armazene digitalmente nem tire fotos delas.</strong>

<strong>No diga as palavras em voz alta.</strong>

<strong>Este backup no  protegido por senha.</strong>

Depois disso, voc ser solicitado a confirmar cada palavra.`,
    title: "Mostrar frase de recuperao",
    warning: "<strong>Nunca compartilhe suas palavras de recuperao com ningum.</strong> Suas palavras de recuperao do acesso total  sua carteira. Se algum est pedindo suas palavras de recuperao,  um golpista, no as compartilhe!"
  },
  title: "Gerenciar backups"
}, bb02Bootloader$9 = {
  abort: "No atualizar - Leve-me de volta",
  abort_noUpgrade: "Me leve de volta",
  advanced: {
    label: "Configuraes avanadas",
    toggleShowFirmwareHash: "Mostrar o hash de firmware toda vez na inicializao"
  },
  flipscreen: "Girar tela",
  orientation: "Dispositivo orientado de maneira errada?",
  success: "Atualizao bem sucedida! Continuando em {{rebootSeconds}} segundos...",
  success_install: "Instalao com sucesso! Continuando em {{rebootSeconds}} segundos..."
}, bitbox$9 = {
  error: {
    e10000: "Senha atual do dispositivo incorreta.",
    e10001: "Falha ao substituir a senha do dispositivo",
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e112: "A senha do dispositivo oculto no pode ser igual  senha do dispositivo principal."
  }
}, bitbox02Interact$9 = {
  confirmDate: "Confirme a data de hoje em sua BitBox02",
  confirmDateText: "Esta data ser usada para criar seu backup.",
  confirmName: "Confirme o nome na BitBox02",
  confirmWords: "Escreva as {{amount}} palavras de recuperao da sua BitBox02",
  confirmWordsText: "Depois disso a BitBox02 pede para voc confirmar cada palavra para verificar se o backup est correto.",
  followInstructions: "Por favor, siga as instrues na sua BitBox02.",
  followInstructionsMnemonic: "Siga as instrues em sua BitBox02 para inserir as palavras de recuperao de seu backup e restaurar sua carteira.",
  followInstructionsMnemonicTitle: "Restaurar a partir da frase de recuperao"
}, bitbox02Settings$9 = {
  deviceName: {
    current: "Nome atual do dispositivo",
    error: "No foi possvel definir o nome do dispositivo",
    error_104: "A confirmao do nome do dispositivo foi interrompida no dispositivo.",
    input: "Nome da BitBox02",
    placeholder: "Novo nome de dispositivo",
    title: "Definir nome da BitBox02"
  },
  gotoStartupSettings: {
    description: "Isso reiniciar sua BitBox02 e entrar nas configuraes de inicializao.",
    title: "V para as configuraes de inicializao"
  }
}, bitbox02Wizard$9 = {
  advanced: {
    button: "Opes avanadas",
    outOfDate: "Firmware desatualizado para este recurso",
    seed12WordInfo: "Observe que o nmero de palavras no pode ser alterado aps a criao da carteira.",
    seed12WordLabel: "Criar uma semente de 12 palavras em vez de 24 palavras",
    seed12WordText: "Por padro, a BitBox02 usa uma semente de 24 palavras. Ambos os tamanhos de sementes so seguros contra fora bruta na prtica. Alguns usurios podem preferir a convenincia da semente de 12 palavras.",
    skipSDCardLabel: "Pule o backup do carto microSD e anote as palavras de recuperao",
    skipSDCardText: "Voc sempre tem a opo de criar um backup em um carto microSD ou escrever suas palavras de recuperao aps a configurao. Isso pode ser feito nas configuraes.",
    title: "Opes avanadas de backup"
  },
  attestationFailed: "Falha na verificao do dispositivo, o que pode ter ocorrido ao reniciar o app enquanto o dispositivo estava esperando uma entrada do usurio. Por favor, reconecte e tente novamente. Entre em contato com support@bitbox.swiss se a falha persistir.",
  backup: {
    point1: "Selecione um backup no carto microSD",
    point2: "Defina uma senha para o seu dispositivo",
    restoreText: "Ok, vamos restaurar um backup!",
    text1: "timo, sua senha da BitBox02 foi definida e a carteira foi criada. Agora  hora de criar seu primeiro backup. Por favor, verifique se o seu carto microSD est inserido na sua BitBox02 e continue.",
    text2: "Por favor, siga as instrues na tela do seu dispositivo para criar um backup.",
    text3: "Aps o backup ser criado, remova o carto microSD e armazene-o em um <strong>local seguro</strong>. O contedo do carto microSD no  protegido por senha. Nunca insira em qualquer outro dispositivo alm de sua BitBox02.",
    userConfirmation1: "Eu devo armazenar meu backup em um local seguro.",
    userConfirmation2: "Meu backup no  protegido por senha. Qualquer pessoa com acesso a ele pode acessar minha carteira.",
    userConfirmation3: "Se eu perder ou danificar minha BitBox02, a nica maneira de recuperar meus fundos  restaurando do meu backup.",
    userConfirmation4: "Se eu perder ou danificar meu backup e minha BitBox02, meus fundos sero perdidos.",
    userConfirmation5: "Eu no devo colocar meu carto de backup microSD em um computador, telefone, impressora ou qualquer dispositivo a no ser o BitBox02. ",
    userConfirmation5mnemonic: "No devo colocar minhas palavras de recuperao em um computador, telefone, impressora ou qualquer outro dispositivo que no seja uma BitBox02."
  },
  create: {
    button: "Nomear dispositivo e continuar",
    info: "Aqui esto os passos bsicos que voc vai seguir para configurar a sua BitBox: ",
    inputTitle: "Nome da carteira",
    point1: "Nomear seu dispositivo",
    point2: "Definir uma senha para o seu dispositivo",
    point3: "Criar um backup",
    text: "Ok, vamos criar uma nova carteira!"
  },
  createBackupAborted: "Criao de backup abortada.",
  createBackupFailed: "Falha na criao do backup, tente novamente.",
  initialize: {
    passwordText: "Agora vamos definir uma senha para o seu dispositivo. Use os controles da sua BitBox para entrar e escolher uma senha.",
    passwordTitle: "Definir uma senha para a sua BitBox",
    text: "Sucesso ao emparelhar sua BitBox02! Agora vamos inicializar seu dispositivo. Comece escolhendo criar uma nova carteira ou restaurar uma carteira a partir de um backup existente. <strong>Por favor, verifique se voc tem um carto microSD inserido na sua BitBox02</strong>",
    tip: "Recomendamos que voc proceda em um ambiente seguro.",
    title: "Inicialize sua BitBox"
  },
  insertSDCard: "<strong>Por favor, verifique se voc tem um carto microSD inserido em sua BitBox02.</strong>",
  noPasswordMatch: "Senhas no conferem, tente novamente.",
  pairing: {
    failed: "Pareamento no confirmado. Por favor, reconecte sua BitBox02.",
    paired: "Voc confirmou o seguinte cdigo em seu dispositivo. Por favor continue.",
    title: "Verificar o cdigo de pareamento",
    unpaired: "Uma BitBox02 no pareada foi detectada. Verifique se o cdigo de pareamento corresponde ao que  mostrado em sua BitBox02."
  },
  restoreFromMnemonic: {
    e104: "A restaurao a partir das palavras de recuperao foi cancelada.",
    failed: "A restaurao a partir da frase de recuperao falhou, por favor, tente novamente."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, leia estas importantes consideraes de segurana:",
    createBackup: "Agora voc criar um backup no seu carto microSD.",
    createBackupMnemonic: "Agora voc anotar as palavras de recuperao."
  },
  stepBackupSuccess: {
    fundsSafe: "Para manter seus fundos seguros, lembre-se do seguinte:",
    title: "Backup restaurado!"
  },
  stepConnected: {
    unlock: "Digite a senha da BitBox02 para desbloquear."
  },
  stepCreate: {
    description: "Este nome  usado como o nome do dispositivo e para o backup.",
    nameLabel: "Nome da BitBox02",
    namePlaceholder: "Minha BitBox02",
    title: "Escolha o nome da BitBox02",
    toastMicroSD: "Por favor, insira seu carto microSD em sua BitBox02, que ser usado para armazenar um backup da carteira."
  },
  stepCreateSuccess: {
    removeMicroSD: "Remova o carto microSD de sua BitBox02 e guarde-o em um local seguro.",
    storeMnemonic: "Guarde suas palavras de recuperao em um local seguro",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "Por favor insira um carto microSD na sua BitBox02 para continuar.",
    insertSDcardTitle: "Insira carto microSD."
  },
  stepPassword: {
    e104: "A definio da senha foi cancelada.",
    title: "Definir senha da BitBox02",
    useControls: "Use os controles em sua BitBox02 para definir uma senha."
  },
  stepUninitialized: {
    create: "Quero configurar uma nova BitBox02.",
    restore: "Quero restaurar minha carteira a partir de um backup.",
    restoreMicroSD: "Restaurar a partir do carto microSD",
    restoreMnemonic: "Restaurar a partir da frase de recuperao",
    title: "Configure sua BitBox02"
  },
  success: {
    text: `Oba! Sua BitBox02 agora est pronta para uso.

Para obter mais informaes sobre como usar o BitBoxApp, use o guia no aplicativo clicando no ponto de interrogao no canto superior direito.`,
    title: "Voc est pronto para comear!"
  }
}, blink$9 = {
  button: "Piscar"
}, bootloader$9 = {
  button: "Atualizar firmware agora",
  button_install: "Instale o firmware agora",
  progress: "Atualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Atualizao bem sucedida! Por favor, insira novamente o dispositivo. Desta vez, no toque no boto."
}, button$d = {
  abort: "Abortar",
  back: "Voltar",
  buy: "Comprar",
  changepin: "Mudar senha do dispositivo",
  check: "Checar backup",
  continue: "Continuar",
  copy: "Copiar",
  create: "Criar",
  dismiss: "Dispensar",
  done: "Pronto",
  download: "Baixar",
  hiddenwallet: "Criar carteira oculta",
  next: "Prximo",
  ok: "OK",
  previous: "Anterior",
  receive: "Receber",
  restore: "Restaurar",
  select: "Selecionar",
  send: "Enviar",
  unlock: "Desbloquear",
  update: "Atualizar",
  upgrade: "Atualizar"
}, buy$5 = {
  exchange: {
    bankTransfer: "Transferncia bancria",
    bestDeal: "Melhor oferta",
    creditCard: "Carto de crdito",
    fast: "Rpido",
    fee: "taxa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferncia bancria: {{fee}}%",
          creditDebitCard: "Carto de crdito/dbito: {{fee}}%",
          learnMore: "Saiba mais sobre a Moonpay",
          title: "Taxas"
        },
        fullCurrenciesList: "Veja a lista completa de moedas aqui",
        payment: {
          asteriskText: "* No disponvel para residentes nos EUA",
          bankTransfer: "Transferncia bancria*",
          bankTransferDetails: {
            pix: "PIX (transaes BR somente no Brasil)",
            sepa: "SEPA e SEPA Instant (transaes em EUR somente em pases SEPA)",
            uk: "UK Faster Payments (transaes em GBP somente no Reino Unido)"
          },
          creditDebitCard: "Carto de crdito/dbito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Veja mais detalhes sobre os mtodos de pagamento",
          title: "Mtodos de Pagamento"
        },
        supportedCurrencies: "Suporta todas as principais moedas fiducirias: USD, EUR, CHF e outras."
      },
      pocket: {
        fees: {
          info: "Transferncia bancria: {{fee}}%",
          title: "Taxas"
        },
        learnMore: "Saiba mais sobre a Pocket",
        payment: {
          bankTransfer: "Transferncia bancria",
          bankTransferDetails: {
            sepa: "SEPA e SEPA Instant (transaes em EUR somente em pases SEPA)",
            sic: "Swiss Interbank Clearing (transaes em CHF apenas em CH/LI)",
            uk: "UK Faster Payments (transaes em GBP somente no Reino Unido)"
          },
          bankTransferReccuring: "Como configurar compras recorrentes com uma ordem permanente?",
          title: "Mtodos de Pagamento"
        },
        supportedCurrencies: "Suporta moedas europeias: EUR, GBP e CHF.",
        verification: {
          info: "Requer apenas verificao de identidade acima dos limites dirios e anuais.",
          link: "Encontre os limites atuais aqui",
          title: "Verificao de Identidade"
        }
      },
      region: {
        title: "Selecione a regio em que sua conta bancria est registrada para ver quais opes esto disponveis para voc."
      }
    },
    noExchanges: "Desculpe, no h exchanges disponveis nesta regio.",
    region: "Regio",
    selectRegion: "No especificada",
    title: "Comprar {{name}}"
  },
  info: {
    continue: "Concordo e continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Somos parceiros da MoonPay para oferecer a voc um modo perfeito de comprar {{name}} diretamente para o BitBoxApp. Em apenas alguns cliques.",
        "MoonPay  uma plataforma simples e rpida para comprar {{name}} em mais de 160 pases."
      ],
      payment: {
        details: "Voc pode comprar {{name}} instantneamente atravs da MoonPay com os seguintes mtodos de pagamento. Compras com carto de crdito ou dbito so convenientes e instantneas, mas so mais caras devido ao risco de estorno. Ns recomendamos que use a opo de transferncia bancria para quantidades maiores. A taxa mnima  de 4 USD/EUR ou equivalente.",
        footnote: "Por favor perceba que as taxas da corretora MoonPay pode ser diferente das utilizadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
        table: {
          "1_description": "Taxas baixas podem levar at 3 dias teis.",
          "1_method": "Transferncia bancria (SEPA)",
          "2_description": "Taxas altas mas rpidas e instantneas",
          "2_method": "Cartes de crdito & dbito",
          description: "Descrio",
          fee: "Taxa",
          method: "Mtodo"
        },
        title: "Mtodos de pagamento e taxas"
      },
      privacyPolicy: "Poltica de privacidade da MoonPay",
      protection: {
        description: "O BitBoxApp no coleta nenhum dado quando voc compra {{name}}, o saldo recebido  tratado como uma transao regular. A MoonPay precisa coletar alguns dados pessoais para a operao. A Poltica de Privacidade da MoonPay explica detalhadamente como esses dados so tratados.",
        descriptionGeneric: "O BitBoxApp no coleta nenhum dado quando voc compra {{name}}, os fundos recebidos so tratados como uma transao normal. No entanto, as exchanges parceiras precisam coletar algumas informaes para operar. Consulte suas respectivas polticas de privacidade para ver com mais detalhes como os dados so tratados.",
        title: "Proteo dos dados"
      },
      security: {
        description: "Quando voc compra {{name}} atravs da MoonPay, voc est usando um servio externo. Esse servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e fora do ambiente de segurana onde o aplicativo BitBoxApp est rodando.",
        descriptionGeneric: "Quando voc compra {{name}} atravs de uma exchange parceira, voc est usando um servio externo. Este servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e depende da proteo e segurana do ambiente em que o software BitBoxApp est sendo executado.",
        link: "Modelo de ameaas de segurana",
        title: "Modelo de segurana"
      },
      title: "Bem-vindo a sua loja virtual pessoal para comprar {{name}}"
    },
    next: "Prximo",
    selectLabel: "Seleciona sua conta",
    selectPlaceholder: "Selecione uma moeda",
    skip: "No mostre novamente",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Poltica de privacidade da Pocket",
      p1: "O BitBoxApp no coleta nenhum dado ao comprar bitcoin, os fundos recebidos so tratados como uma transao regular. A Pocket precisa coletar alguns dados pessoais para operar. Sua Poltica de Privacidade explica em detalhes como esses dados so tratados.",
      title: "Proteo de dados"
    },
    kyc: {
      link: "Leia as perguntas frequentes da Pocket",
      p1: "A Pocket tenta manter o KYC no mnimo. Para compras abaixo de 950 EUR (1000 CHF) por dia, no so necessrios documentos adicionais. Para compras acima desse valor, ser necessrio agendar uma ligao com a Pocket para concluir o processo KYC/AML necessrio.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Voc pode comprar bitcoin instantaneamente com a Pocket via transferncia bancria SEPA. A taxa  de 1,5% e o bitcoin  depositado em sua BitBox o mais rpido possvel aps a Pocket receber a transferncia bancria (geralmente no mesmo dia).",
      p2: "Observe que as taxas de cmbio da Pocket podem diferir daquelas usadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
      title: "Mtodos de pagamento e taxas"
    },
    previousTransactions: "O histrico de transaes desta conta no est vazio. Compartilhar esta conta tornar todas as transaes passadas e futuras visveis para a Pocket. Continuar mesmo assim?",
    security: {
      link: "Modelo de ameaas de segurana da BitBox02",
      p1: "Ao comprar bitcoin via Pocket, voc est usando um servio externo. Este servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e depende da proteo e segurana do ambiente em que o software BitBoxApp est sendo executado. No entanto, trabalhamos juntos para melhorar a segurana usando um mecanismo de autenticao de dois fatores para verificar o endereo em que voc est recebendo.",
      title: "Modelo de segurana"
    },
    usedAddress: "O endereo {{address}} j foi usado, comece novamente com um novo endereo.",
    verifyBitBox02: "Verifique se o endereo que voc recebeu por e-mail corresponde ao exibido em sua Bitbox. Se possvel, voc deve abrir o e-mail em um segundo dispositivo para maior segurana.",
    welcome: {
      p1: "Fizemos parceria com a Pocket para oferecer a voc uma maneira perfeita de comprar bitcoin diretamente no BitBoxApp. So apenas alguns cliques.",
      p2: "Pocket  uma plataforma sua que facilita e agiliza a compra de bitcoin na maior parte da Europa (em qualquer lugar onde as transferncias bancrias SEPA sejam suportadas).",
      p3: "Com a Pocket, voc tambm pode fazer compras regulares por meio de ordens bancrias recorrentes, para poder fazer DCA (dollar-cost averaging) com facilidade.",
      title: "Bem-vindo ao seu balco nico para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
}, changePin$9 = {
  newTitle: "Nova senha do dispositivo",
  oldLabel: "Senha atual do dispositivo"
}, chart$5 = {
  dataMissing: "Buscando dados histricos... fique ligado.",
  dataOldTimestamp: "Atualizao das taxas de cmbio histricas. O grfico no est exibindo dados aps {{time}}.",
  dataUpdating: "atualizando dados...",
  filter: {
    all: "Todos",
    month: "Ms",
    week: "Semana",
    year: "Ano"
  }
}, checkSDcard$9 = "checando carto microSD", clickHere$9 = "Clique aqui.", confirm$b = {
  abortInfo: "Toque para ",
  abortInfoRedText: "abortar",
  approveInfo: "Segure 4 segundos ou mais para ",
  approveInfoGreenText: "confirmar",
  info: "Prossiga na sua BitBox.",
  infoWhenPaired: "Primeiro no celular emparelhado e depois na sua BitBox"
}, confirmOnDevice$9 = "Por favor, confirme no seu dispositivo.", connectKeystore$4 = {
  promptNoName: "Por favor conecte sua BitBox02 para continuar",
  promptWithName: 'Por favor conecte sua BitBox02 chamada "{{name}}" para continuar'
}, darkmode$4 = {
  toggle: "Modo escuro"
}, device$9 = {
  appUpradeRequired: "Sua BitBox no  compatvel com este aplicativo. Por favor, baixe e instale a verso mais recente."
}, deviceLock$9 = {
  button: "Ativar autorizao de dois fatores (2FA)",
  condition1: "Voc tem um backup?",
  condition2: "A verificao pelo aplicativo de celular est funcionando?",
  condition3: "2FA DESATIVA backups e emparelhamento de aplicativos mveis. O dispositivo precisa ser RESETADO para sair do 2FA!",
  confirm: "Ativar autorizao de dois fatores (2FA)",
  title: "Ativar autorizao de dois fatores (2FA)"
}, deviceSettings$9 = {
  backups: {
    manageBackups: {
      description: "Criar ou verificar o backup do carto microSD."
    },
    showRecoveryWords: {
      description: "Mostrar e verificar palavras de recuperao."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "O BitBoxApp verifica se o seu dispositivo  autntico."
    },
    deviceName: {
      description: "Altere o nome do seu dispositivo."
    },
    rootFingerprint: {
      description: "A impresso digital raiz  um identificador exclusivo da carteira atualmente em uso. Pode ajud-lo a distinguir entre diferentes carteiras se voc usar frases secretas."
    },
    securechip: {
      description: "O modelo do chip seguro."
    },
    title: "Informaes do dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Redefina seu dispositivo para as configuraes de fbrica - isso apagar a sua carteira BitBox02!",
      title: "Restaurao de fbrica"
    },
    goToStartupSettings: {
      description: "Acesse o bootloader da BitBox02. Voc pode habilitar o hash do firmware aqui."
    },
    passphrase: {
      description: "Ative ou desative o recurso de frase secreta.",
      title: "Frase secreta"
    }
  },
  firmware: {
    firmwareVersion: "Verso do firmware",
    newVersion: {
      label: "Verso disponvel"
    },
    title: "Firmware",
    upToDate: "Seu dispositivo est atualizado",
    upgradeAvailable: "Nova atualizao disponvel",
    version: {
      label: "Verso"
    }
  },
  hardware: {
    attestation: {
      false: "Falha na verificao de autenticidade",
      label: "Verificao de autenticidade",
      true: "Sua BitBox02  autntica"
    },
    sdcard: {
      false: "No inserido",
      label: "Carto microSD",
      true: "Inserido"
    },
    securechip: "Chip seguro",
    title: "Hardware"
  },
  loading: "Recuperando informaes do dispositivo...",
  pairing: {
    lock: {
      false: "Desativado",
      label: "Autorizao de dois fatores (2FA)",
      true: "Ativado"
    },
    mobile: {
      false: "Fechado",
      label: "Aplicativo mvel",
      true: "Abrir"
    },
    status: {
      false: "No emparelhado",
      label: "Status",
      true: "Emparelhado"
    },
    title: "Emparelhamento"
  },
  secrets: {
    manageBackups: "Gerenciar backups",
    title: "Privacidade"
  }
}, deviceTampered$9 = "Sua BitBox foi fornecida com uma senha de recuperao? Se sim, pare o processo de configurao e contate o suporte imediatamente. A Shift nunca lhe dar uma carteira pronta ou far recomendaes de senha.", dialog$a = {
  cancel: "Cancelar",
  confirm: "Confirmar",
  confirmTitle: "Confirmao"
}, error$5 = {
  accountAlreadyExists: "A conta j existe.",
  accountLimitReached: "No foi possvel adicionar a conta. O nmero mximo de contas para essa moeda foi atingido.",
  aoppCallback: "Ocorreu um erro ao entregar o endereo para {{host}}.",
  aoppInvalidRequest: "Pedido invlido.",
  aoppNoAccounts: "No h contas disponveis.",
  aoppSigningAborted: "Solicitao de propriedade de endereo cancelada.",
  aoppUnknown: "Ocorreu um erro desconhecido.",
  aoppUnsupportedAsset: "O ativo no  compatvel.",
  aoppUnsupportedFormat: "No h contas disponveis que suportem o formato de endereo solicitado.",
  aoppUnsupportedKeystore: "O dispositivo conectado no pode assinar mensagens para este ativo.",
  aoppVersion: "Verso desconhecida.",
  wrongKeystore: "Carteira errada conectada. Certifique-se de inserir o dispositivo correto que corresponde a esta conta.",
  wrongKeystore2: " Se voc estiver usando a frase secreta opcional, certifique-se de ter digitado a frase secreta correta para a conta."
}, fiat$b = {
  default: "padro",
  setDefault: "Definir {{code}} como padro",
  title: "Moedas"
}, footer$b = {
  appVersion: "Verso do aplicativo:"
}, generic$5 = {
  enabled_false: "Desabilitado",
  enabled_true: "Habilitado"
}, genericError$9 = "Um erro ocorreu. Se voc notar algum problema, por favor, reinicie o aplicativo.", goal$9 = {
  buttons: {
    create: "Criar uma nova carteira",
    restore: "Restaurar uma carteira de um backup"
  },
  paragraph: "Por favor, selecione uma das seguintes opes:",
  step: {
    1: {
      title: "Informao de segurana"
    },
    2: {
      description: "Definir uma senha do dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Criar uma nova carteira",
      title: "Carteira"
    },
    "3-restore": {
      description: "de um backup",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumo"
    },
    "4-restore": {
      title: "Resumo"
    }
  }
}, guide$a = {
  accountDescription: {
    text: 'A viso geral da sua conta mostra seu saldo disponvel, alm de transaes de entrada e sada. Nosso guia em "Configuraes" contm mais informaes sobre cada tipo de conta. ',
    title: "O que esta pgina me mostra?"
  },
  accountFiat: {
    text: "Sim. Clique em qualquer cdigo para alternar entre moedas fiducirias. Voc pode alterar a lista de moedas nas configuraes.",
    title: "Posso exibir outras taxas de converso?"
  },
  accountIncomingBalance: {
    text: "Lanamentos soma os valores transferidos para voc ainda no confirmados pela rede.",
    title: "O que significa lanamentos?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Cada xpub  atrelado ao "Tipo" mostrado: tanto o "Segwit Nativo (bech32)" como ao "Wrapped Segwit" ou "Taproot" (somente Bitcoin). Esses so tipos de scripts usados pela {{coinName}}. O BitBoxApp combina eles, suportando mltiplos tipos de scripts na mesma conta. Por isso cada tipo de script te fornece um xpub diferente, existem vrios xpubs por conta.

Se voc recebe constantemente em um tipo de endereo padro (Segwit Nativo), voc s precisa do xpub "bech32". Entretando, se voc tambm recebe valores nos tipos "Wrapped Segwit" ou "Taproot", voc precisa usar as chaves pblicas estendidas do "Wrapped Segwit" e "Taproot" respectivamente.`,
      title: "Por que tem vrios xpubs?"
    },
    privacy: {
      text: `Para esse tipo especfio de conta, a chave pblica estendida revela seu histrico financeiro completo, seu saldo em conta e todas suas transaes futuras. Mas a xpub no permite que ningum gaste suas moedas.

Se voc fornecer sua xpub  algum, voc dever ter em mente que essa pessoa ou empresa poder ver todas as transaes antigas da sua conta. Assim achamos uma boa idia que voc use essa conta somente para esse propsito e mantenha seus fundos salvos em contas diferentes dessa.`,
      title: "Por que preciso manter minha xpub secreta?"
    },
    verify: {
      text: "Sim,  sempre uma boa idia revisar sua xpub. Se alguma outra pessoa gerar um endereo de recebimento atravs da sua xpub para mandar seu dinheiro, isso  muito importante. Voc precisa verificar no dispositivo para garantir que essa xpub pertence a voc para que seus fundos no acabem indo para endereos errados e sejam perdidos.",
      title: "Preciso verificar minha xpub nesse dispositivo?"
    },
    xpub: {
      text: `Uma chave pblica estendida (xpub)  uma chave-raiz da qual todos os endereos de recebimento de uma conta so derivados.

Ela  fornecida aqui para uso avanado e interoperabilidade com carteiras watch-only, como Electrum ou Sentinel. Se voc recebeu de diferentes tipos de endereo, importe todos os formatos diferentes de xpub em sua carteira watch-only para ver todas as suas moedas.

Por favor, note que que carteiras de terceiros podem no suportar xpubs do tipo Taproot ainda.`,
      title: "O que  uma chave pblica estendida?"
    }
  },
  accountRates: {
    text: "Ns atualizamos as taxas de cmbio a cada minuto no CoinGecko.",
    title: "Quais taxas de cmbio so aplicadas?"
  },
  accountReload: {
    text: "No h necessidade. Suas informaes de transao so atualizadas automaticamente.",
    title: "Posso recarregar o histrico de transaes?"
  },
  accountSendDisabled: {
    text: 'O boto "Enviar"  ativado quando seu saldo for maior que zero.',
    title: "Por que no consigo enviar {{unit}}?"
  },
  accountSummaryAmount: {
    text: `O montante total  a soma de de saldo de todas sua contas crypto. Taxas de troca so obtidas atravs da coingecko.com.

Obs: Se voc usa a MyEtherWallet para tokens ela no  suportada no BitBoxApp, por isso no ser incluso no montante total mostrado.`,
    title: "Como o valor total  calculado?"
  },
  accountSummaryDescription: {
    text: "Aqui voc pode ver o desempenho do seu portflio ao longo do tempo. Um resumo de suas contas crypto individuais  exibido abaixo do grfico.",
    title: "O que essa pgina me mostra?"
  },
  accountTransactionAttributesBTC: {
    text: `Tamanho virtual: determina a taxa de rede. Voc economizou com sucesso em taxas se for menor que o tamanho da transao.
Tamanho: tamanho real da transao em bytes quando serializado de acordo com a blockchain subjacente.
Peso: uma nova mtrica introduzida no Segwit para avaliar os tamanhos de transao e bloco. Cada segregated witness (segwit) byte conta como um, todo o resto como quatro unidades de peso. Em vez de um megabyte em tamanho real, o limite de tamanho do bloco agora  de quatro milhes de unidades de peso.`,
    title: "E os detalhes da transao especfica do Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmaes: sua primeira transmisso de transao no  confirmada at que um minerador a inclua em um bloco, isso s acontece aps uma confirmao. Cada bloco transmitido na rede adiciona outra confirmao  sua transao. Geralmente, os comerciantes e outros agentes da rede somente liquidam transaes com trs a seis confirmaes.
ID da transao: um nmero de identificao exclusivo que permite procurar uma transao em um explorador de blocos.
Taxa: Os mineradores recebem uma taxa de minerao como incentivo para incluir transaes nos blocos que mineram. Para saber mais, clique no boto enviar.`,
    title: "Quais so as informaes nos detalhes da transao?"
  },
  accountTransactionConfirmation: {
    text: "Uma transao transmitida para a rede, mas ainda no confirmada.",
    title: "O que  uma transao pendente?"
  },
  accountTransactionLabel: {
    text: " o endereo para o qual voc recebeu ou enviou moedas.",
    title: "Qual endereo  exibido para cada transao?"
  },
  accountTransactionTime: {
    text: "O horrio de confirmao da transao blockchain.",
    title: "Qual horrio  exibido?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin e Litecoin podem ter uma quantidade arbitrria de contas. Aps cinco contas, voc s pode adicionar outra conta se a conta anterior tiver sido usada. Outras moedas podem ter um mximo de cinco contas.",
      title: "Quantas contas posso criar?"
    },
    howtoAddTokens: {
      text: 'Tokens usando o padro ERC20 so atrelados a uma conta Ethereum especfica. Para habilitar ou desabilitar um token em particular, abra a tela "Gerenciar contas", e expanda at a sua conta Ethereum e mude o token desejado para ligado ou desligado.',
      title: "Como posso adicionar mais tokens?"
    },
    moveFunds: {
      text: "Sim. Porque as contas so independentes, voc deve mandar saldo usando uma transao regular.",
      title: "Posso mover saldo entre contas?"
    },
    recoverAccounts: {
      text: "Sim, O BitBoxApp cria suas contas usando o melhor padro estabelecido compatvel com a maioria das outras carteiras de crypto.",
      title: "Posso recuperar minhas contas com outras carteiras?"
    },
    whatAreAccounts: {
      text: "Sua carteira pode gerenciar contas mltiplas da mesma moeda. Vrias contas so de extrema ajuda para manter seus fundos separadamente.",
      title: "O que so contas?"
    },
    whyIsThisUseful: {
      text: 'Contas so timas para gerenciar seus fundos para pessoas ou propsitos diferentes porque so separadas. Voc pode tambm compartilhar sua "chave pblica estendida" de uma conta sem revelar nada sobre suas outras contas.Isso permite voc repetidamente receber saldo sem reutilizar os seus endereos, bem como receber seu salrio ou seu saldo de crypto que for comprado.',
      title: "Por que isso  til?"
    }
  },
  appendix: {
    link: "Contate-nos!",
    text: "Outra pergunta?"
  },
  backups: {
    check: {
      text: "'Checar backup' permite verificar se voc tem um backup funcionando correspondente  sua carteira atual. Tambm pode ser usado para verificar se voc ainda tem a senha de recuperao correta. Voc pode verificar sua senha de recuperao principal ou sua senha de recuperao oculta.",
      title: "O que  'Checar backup'?"
    },
    encrypt: {
      text: "No, mas sua senha de recuperao  necessria para derivar a carteira a partir da semente armazenada.",
      title: "Posso criptografar o backup?"
    },
    howOften: {
      text: `O backup  gerado automaticamente quando uma nova carteira  criada. Voc s precisa fazer um novo backup se o seu carto microSD for perdido ou danificado ou se desejar usar vrios cartes microSD como backups.
Voc no precisa criar novos backups depois das atividades de transao. Todos os seus dados de transao podem ser recriados pelo backup nico que foi gerado automaticamente para voc.`,
      title: "Com que frequncia tenho que fazer um backup?"
    },
    whatIsABackup: {
      text: " uma cpia da semente em um carto microSD. A semente junto com sua senha de recuperao gera sua carteira.",
      title: "O que  um backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Checar backup' permite verificar se voc tem um backup funcionando correspondente  sua carteira atual.",
      title: "O que  'Checar backup'?"
    },
    encrypt: {
      text: 'No. Por favor, mantenha o carto microSD seguro, pois ele contm a semente no criptografada para recuperar sua carteira. Se voc deseja proteger sua semente com senha,  possvel ativar uma frase secreta opcional nas configuraes de especialistas em "Gerenciar dispositivo".',
      title: "Posso criptografar o backup?"
    },
    whatIsABackup: {
      text: " uma cpia da semente em um carto microSD.",
      title: "O que  um backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando o 2FA  ativado, todas as transaes de moedas precisam ser aprovadas no celular emparelhado. Internamente, um nmero de uso nico criptografado  enviado para o aplicativo mvel,  descriptografado e retornado  BitBox ao pressionar o boto Aceitar. Esta comunicao com o dispositivo  feita atravs do canal entre o telefone celular e este aplicativo de desktop estabelecido durante o emparelhamento.

Certifique-se de fazer um backup de sua carteira e emparelhar o aplicativo mvel antes de ativar o 2FA. Uma vez ativado, o slot de carto microSD e o emparelhamento via aplicativo mvel so desativados. Eles podem ser reativados resetando a BitBox, o que formata o dispositivo.`,
      title: "Como funciona a autenticao de dois fatores (2FA)?"
    },
    disable2FA: {
      text: `Para desabilitar o 2FA, voc precisa resetar a sua BitBox e restaurar a carteira atravs do seu backup. Certifique-se de que voc ainda tem o carto microSD com o backup e que voc ainda se lembra da senha de recuperao. Em seguida, pressione 'Resetar dispositivo'. Defina uma nova senha para o dispositivo e escolha "Ou restaurar a partir de um backup". Selecione o backup que voc fez da carteira, clique em 'Restaurar' e insira a senha de recuperao que voc usou ao criar a carteira.`,
      title: "Como posso desativar a autorizao de dois fatores (2FA)?"
    },
    ejectBitbox: {
      text: "Voc pode desconectar a BitBox a qualquer momento sem precisar ejet-la primeiro.",
      title: "Como posso ejetar a BitBox?"
    },
    ejectSD: {
      text: "Voc pode remover o carto microSD da BitBox a qualquer momento, desde que no esteja criando ou restaurando um backup.",
      title: "Como posso ejetar o carto microSD?"
    },
    hiddenWallet: {
      text: " uma segunda carteira no mesmo dispositivo protegida por uma senha de dispositivo e senha de recuperao diferentes, que voc pode usar para negao plausvel (plausible deniability). A mesma semente do backup  usada para sua carteira normal e oculta, portanto, nenhum backup adicional  necessrio.",
      title: "O que  uma carteira oculta?"
    },
    legacyHiddenWallet: {
      text: "Primeiro, clique no boto abaixo (disponvel se a BitBox estiver desbloqueada com a senha principal do dispositivo e o 2FA estiver desabilitado), em seguida, reconecte sua BitBox e desbloqueie-a com a senha oculta do dispositivo.",
      title: "Como fao para acessar a carteira legacy oculta?"
    },
    pairing: {
      text: "Depois de fazer o download do nosso aplicativo para dispositivos mveis para iOS ou Android, escaneie o QR code exibido, que cria um canal seguro entre o aplicativo mvel e este aplicativo. Depois de escanear, siga as instrues no aplicativo para dispositivos mveis.",
      title: "Como emparelhar de forma segura com o seu telefone"
    }
  },
  cointracking: {
    text: 'Clique no boto "Exportar" e abra a pasta de downloads onde voc ira encontrar seu arquivo CSV exportado. Depois clique no link abaixo, faa upload do arquivo CSV BitBox e importe ele a fim de usar os dados no seu Gerenciador de rastreamento de moeda e poder criar seus relatrios de taxa.',
    title: "Como importar minhas transaes para a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leia mais sobre a verificao de autenticidade"
      },
      text: "O BitBoxApp executa uma verificao de atestado na BitBox02 para verificar se o dispositivo  genuno. A verificao  feita localmente e no se conecta a nenhum servidor.",
      title: "Como funciona a verificao de autenticidade?"
    },
    name: {
      text: "Este  o nome da sua carteira e backup. O nome  usado para backups futuros e pode ser usado para ajudar a distinguir entre diferentes carteiras. Ele pode ser alterado a qualquer momento, mas observe que os backups feitos antes da alterao ainda usaro o nome anterior.",
      title: "Para que serve o nome da BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leia mais sobre o chip seguro"
      },
      text: "Esta informao mostra o nmero do modelo do chip seguro, o chip mais atualizado  o ATECC608B com recursos de segurana aprimorados em comparao com modelos mais antigos.",
      title: "Por que mostrar o modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Voc pode dar o endereo para que outras pessoas lhe enviem algumas moedas. Apenas certifique-se de que esto enviando para o endereo correto.",
      title: "O que eu fao com um endereo?"
    },
    addressChange: {
      text: "Assim que voc realiza a transao, um novo endereo  automaticamente adicionado  lista, para que haja sempre 20 endereos disponveis que nunca receberam moedas.",
      title: "Quando os endereos mudam?"
    },
    addressFormats: {
      text: "Por padro, o tipo de endereo  Segwit Nativo. Esse tipo de endereo  amplamente adotado por outras carteiras/corretoras e oferece as melhores taxas para transaes habituais. No entanto, voc tambm pode optar por enviar para Taproot (somente Bitcoin), que  o tipo de endereo mais recente, mas pode no ser amplamente suportado ainda. Alternativamente, se voc estiver tendo problemas para enviar para o Segwit Nativo (o tipo padro), tente alternar para o tipo de endereo mais antigo Wrapped Segwit que pode ser compatvel com mais carteiras/corretoras.",
      title: 'Quando usar "Alterar tipo de endereo"?'
    },
    howVerify: {
      text: `Para a BitBox01, clique no cone BitBox na barra lateral  esquerda e veja a seo Emparelhamento. O guia ser atualizado e voc poder continuar seguindo as instrues.
Para a BitBox02, voc pode verificar os endereos diretamente no dispositivo durante o processo de envio/recebimento.`,
      title: "Como posso verificar um endereo com segurana?"
    },
    plugout: {
      text: "No, uma vez que voc enviou moedas para o seu endereo BitBox, voc no precisa deixar sua BitBox conectada. Voc pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o recebimento?"
    },
    why20: {
      text: 'Durante a inicializao, o aplicativo gera endereos derivados de sua semente para ver se eles receberam fundos. Como o aplicativo pode gerar um nmero quase infinito de endereos, poderia levar anos determinando o saldo. Para limitar essa pesquisa, ele para depois de ver 20 endereos que nunca receberam fundos. Esse  o "gap limit" e 20  um padro de fato, embora o nmero seja arbitrrio. Estes so os 20 endereos que voc pode escolher.',
      title: "Por que apenas 20 endereos?"
    },
    whyMany: {
      text: "Para manter a privacidade e a segurana, nunca distribua o mesmo endereo duas vezes. Se voc usou um endereo, clique na seta para a direita para obter um novo endereo. Voc pode gerar at 20 endereos por vez. Pense em endereos como nmeros de fatura. Todos os endereos so derivados de sua nica semente de backup.",
      title: "Por que tantos endereos?"
    },
    whyVerify: {
      text: "Voc no deve confiar no seu computador para gerar e exibir endereos autnticos. As diferentes formas que um computador convencional pode ser atacado o torna significativamente mais vulnervel do que uma carteira de hardware. Para a BitBox01, o boto para verificar o endereo envia o endereo com segurana para um telefone celular emparelhado, a partir do qual voc tambm pode digitalizar e verificar o QR code. Para a BitBox02, o endereo pode ser verificado diretamente no visor da BitBox02.",
      title: "Por que devo verificar o endereo com segurana?"
    }
  },
  send: {
    change: {
      text: "O troco ser devolvido a um endereo Taproot se voc tiver pelo menos um Taproot UTXO. Se voc usar o controle de moedas, o troco ser devolvido a um endereo Taproot se houver pelo menos um Taproot UTXO entre os UTXOs selecionados. Em todos os outros casos, o troco  devolvido a um endereo Segwit Nativo.",
      title: "Como o output do troco  determinado?"
    },
    fee: {
      text: `A taxa  baseada no tamanho dos dados da transao e no no valor. As metas de taxas so calculadas pelo algoritmo de estimativa de taxas do Bitcoin Core para cada prioridade de rede que voc escolher. Elas so mostradas se tiverem um valor diferente do objetivo abaixo.
Econmica: 24 blocos (cerca de 4 horas para Bitcoin, 1 hora para Litecoin)
Baixa: 12 blocos (cerca de 2 horas para o Bitcoin, 30 minutos para o Litecoin)
Normal: 6 blocos (cerca de 1 hora para o Bitcoin, 15 minutos para o Litecoin)
Alta: 2 blocos (cerca de 20 minutos para Bitcoin, 5 minutos para Litecoin)
(Um bloco demora, em mdia, dez minutos para Bitcoin (2,5 minutos para Litecoin) para ser minerado e o carregamento da rede pode variar consideravelmente nos perodos acima.)`,
      title: "Como a taxa  determinada?"
    },
    plugout: {
      text: "No, uma vez que voc tenha feito uma transao, voc no precisa deixar sua BitBox conectada. Voc pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o envio?"
    },
    priority: {
      text: "Tipicamente, quanto maior a taxa que voc est disposto a pagar, mais rapidamente sua transao  confirmada pela rede.",
      title: "Qual  a prioridade da rede?"
    },
    revert: {
      text: `Depois que uma transao  assinada e enviada (ou seja, transmitida para a rede), ela no pode mais ser revertida. Verifique as transaes (incluindo a taxa) corretamente antes de assinar!
Se voc conhece o destinatrio e ele ou ela est disposto a enviar o mesmo valor (menos as taxas de transao) de volta para voc, voc pode enviar um novo endereo de recebimento.`,
      title: "Posso reverter uma transao?"
    },
    whyFee: {
      text: `As transaes esto competindo para serem confirmadas por um minerador. Mineradores escolhem transaes para serem includas na blockchain com base em sua taxa.
Os mineradores votam no histrico das transaes. Como no h nenhum terceiro confivel para fazer valer um voto por pessoa (que  a ideia das blockchains), os mineradores votam em transaes sacrificando um recurso caro como o poder de computao. Como recompensa por seu trabalho, eles podem reivindicar moedas recm-criadas e a taxa de todas as transaes includas.`,
      title: "Por que h uma taxa de rede?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Se voc pretente apenas conectar seu n quando voc tiver em uma rede especfica (ex: seu wifi de casa), ento uma comunicao padro apenas  suficiente.
Nesse caso  aconselhado que seu servidor Electrum fornea um certificado TLS para encriptar a comunicao.
Se voc prente conectar seu n de qualquer lugar usando o protocolo Tor a melhor opo e necessria  no usar um certificado TLS para esse caso.`,
      title: "Devo usar clearnet TCP, TLS ou Tor?"
    },
    instructions: {
      link: {
        text: "Guia para conectar seu n"
      },
      text: "Para um tutorial completo, por favor visite nosso guia:",
      title: "Como conecto meu BitBoxApp no meu prrprio n?"
    },
    options: {
      text: `Existem vrias opes para voc rodar seu prprio n, como comprar um dispositivo prprio, construir um ou usar a rede Bitcoin Core.
Se voc deseja conectar seu BitBoxApp no seu n, certifique-se de quele roda um servidor Electrum compatvel. Trata-se de um programa dedicado que permite que seu aplicativo de carteira se comunique com seu prprio n.
Operaes suportadas incluem Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).`,
      title: "Quais opes tenho para rodar um n?"
    },
    tor: {
      text: `Tor significa 'The Onion Router', que  um software de cdigo aberto e gratuito que oferece muitos benefcios de privacidade e  especialmente til ao usar Bitcoin.
Se voc pretende se conectar ao seu node atravs do Tor, certifique-se de que o Tor est instalado no seu computador e ative o Proxy Tor nas configuraes do BitBoxApp.
Na maioria dos sistemas operacionais, existem duas maneiras de executar o Tor:
1. Navegador Tor: baixe e abra o navegador Tor. Isso permitir que o BitBoxApp se conecte  rede Tor configurando a porta 9150 nas configuraes de proxy do Tor.
2. Servio Tor em segundo plano: instale o daemon Tor, que sempre  executado em segundo plano. O BitBoxApp pode ento se conectar definindo a porta 9050 nas configuraes de proxy do Tor.`,
      title: "O que  Tor, proxy Tor e qual porta devo usar?"
    },
    what: {
      text: " possvel alimentar sua carteira com seus prprios full nodes em vez de usar os servidores Shift.",
      title: "O que  isso?"
    },
    why: {
      text: `Executar seu prprio node no  necessrio, mas melhora a privacidade e reduz a necessidade de confiar nos outros.
Em primeiro lugar, significa que voc est usando o Bitcoin de forma mais privada, pois o BitBoxApp no se conecta aos nossos servidores para buscar seu histrico de transaes; em vez disso, ele buscar essas informaes em seu prprio node.
Em segundo lugar, executar seu prprio node significa que ele verifica todas as transaes por si mesmo, garantindo que as regras de consenso sejam aplicadas.`,
      title: "Por que devo executar meu prprio node?"
    }
  },
  settings: {
    sats: {
      text: "Um Satoshi ('sat' para abreviar)  a menor unidade de Bitcoin. Um Satoshi  um centsimo milionsimo de um bitcoin (0,00000001 BTC).  o nome do criador do Bitcoin, Satoshi Nakamoto.",
      title: "O que  um Satoshi?"
    },
    servers: {
      text: `Este aplicativo se comunica com os servidores Shift Crypto para verificar atualizaes, carregar transaes e enviar informaes para aplicativos mveis emparelhados.
O aplicativo tambm busca as taxas de cmbio mais recentes do CoinGecko. Todas as converses so calculadas localmente, o que significa que nenhum dado sobre o valor da sua transao  transmitido.
Nota: Para Ethereum e ERC20 Tokens, ns usamos APIs do Etherscan.io.`,
      title: "Com quais servidores este aplicativo se comunica?"
    }
  },
  title: "Guia",
  toggle: {
    close: "Fechar guia",
    open: "Guia"
  },
  trackingModePortfolioChart: {
    text: "No desktop passe o cursor sobre o grfico. No celular, segure o dedo no grfico e arraste horizontalmente.",
    title: "Como ver os valores histricos no grfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Voc precisa resetar o dispositivo e restaurar a carteira a partir de um backup, usando a senha de recuperao.",
      title: "O que fao se eu esquecer a senha do dispositivo?"
    },
    reset: {
      text: "Digite uma senha do dispositivo errada 15 vezes. As ltimas tentativas exigem um toque longo no dispositivo.",
      title: "Como fao para resetar o dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `O dispositivo deve piscar uma vez quando inserido. Certifique-se de que est inserido de maneira correta. Se voc est tendo problemas, por favor, entre em contato conosco atravs do link abaixo.

A BitBox01 no  suportada em dispositivos mveis. Por favor, use o BitBoxApp no Desktop para conectar sua BitBox01.`,
      title: "Minha BitBox01 no  reconhecida"
    },
    getDevice: {
      link: {
        text: "Encomendar uma BitBox"
      },
      text: "Voc pode comprar uma BitBox em nossa loja online:",
      title: "Como posso obter um dispositivo?"
    },
    internet: {
      text: "Sim, uma conexo com a internet  necessria para sincronizar a carteira, enviar transaes e buscar as taxas de cmbio mais recentes.",
      title: "Este aplicativo requer uma conexo com a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de backup"
      },
      text: "Voc pode recuperar suas contas em uma nova BitBox ou com o nosso centro de backup.",
      title: "Eu perdi meu dispositivo. E agora?"
    },
    useWithoutDevice: {
      text: "Infelizmente, isso ainda no  possvel no momento.",
      title: "Posso usar o aplicativo sem um dispositivo?"
    },
    welcome: {
      text: "Obrigado por usar este aplicativo criado pela Shift Crypto na Sua. Agradecemos qualquer contribuio que voc tenha para compartilhar. Por favor, d feedback usando o link na parte inferior.",
      title: "Bem-vindo ao BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se voc estiver usando um novo telefone/computador com o BitBoxApp, precisar se conectar aos DApps novamente. Voc ver suas moedas no dapp novamente, como de costume.",
      title: "No vejo minhas conexes anteriores."
    },
    supportedNetworks: {
      text: "Atualmente, apenas a rede principal Ethereum  suportada usando WalletConnect no BitBoxApp. Para usar outras cadeias compatveis com a EVM, use a carteira de extenso do navegador Rabby.",
      title: "Quais redes so suportadas?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect  um protocolo de comunicao para aplicativos web3. Ele permite que voc se conecte convenientemente a DApps baseados em Ethereum e carteiras web sem usar um aplicativo de terceiros, o que  particularmente til para usurios Android do BitBoxApp.",
      title: "O que  WalletConnect?"
    }
  }
}, headerssync$9 = {
  blocksSynced: "{{blocks}} blocos sincronizados"
}, hiddenWallet$9 = {
  info1HTML: "Para fins de negao plausvel (plausible deniability), uma carteira oculta pode ser criada com base em uma combinao de senha de recuperao e uma senha de dispositivo <strong>diferente</strong>.",
  info2HTML: "Defina a senha do dispositivo e a senha de recuperao que voc deseja associar  sua carteira oculta abaixo. A senha do dispositivo e a senha de recuperao devem ser <strong>diferentes</strong> das que voc definiu para sua carteira principal.",
  passwordLabel: "Senha de recuperao oculta",
  passwordPlaceholder: "Por favor, confirme a senha de recuperao oculta",
  pinLabel: "Senha oculta do dispositivo",
  pinRepeatLabel: "Repita a senha oculta do dispositivo",
  pinRepeatPlaceholder: "Por favor, confirme a senha oculta do dispositivo",
  success: "Carteira oculta criada com sucesso. Reconecte a sua BitBox para desbloque-la."
}, initialize$9 = {
  create: "Definir senha do dispositivo",
  creating: "Configurando senha do dispositivo...",
  error: {
    e102: "A senha do dispositivo precisa conter pelo menos 4 caracteres."
  },
  info: {
    description1: "Escolha a senha do seu dispositivo. Ela ser usada para desbloquear a sua BitBox.",
    description2: "Voc pode usar nmeros, letras & smbolos. Senhas maiores oferecem mais segurana.",
    description3: "Se voc perder a senha do dispositivo, precisar reset-lo e restaurar o backup da carteira.",
    subtitle: "Agora voc vai definir a senha do seu dispositivo",
    title: "Inicializando seu dispositivo"
  },
  input: {
    label: "Senha do dispositivo",
    labelRepeat: "Repita a senha do dispositivo",
    placeholderRepeat: "Por favor, confirme a senha do dispositivo"
  }
}, invalidFormat$9 = "Formato Invlido", language$a = {
  title: "Selecione o idioma"
}, legacyhiddenwallet$9 = {
  disable: "Desativar carteira legacy oculta",
  enable: "Ativar carteira legacy oculta",
  successDisable: "Carteira legacy oculta desativada com sucesso.",
  successEnable: "Carteira legacy oculta ativada com sucesso. Reconecte sua BitBox e digite a senha oculta do dispositivo para acessar a carteira legacy oculta."
}, loading$9 = "carregando", manageAccounts$3 = {
  accountHidden: "Esta conta foi ocultada das suas contas watch-only. Para v-la novamente, conecte sua BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nome da conta",
  noAccounts: "nenhuma conta encontrada",
  settings: {
    hideTokens: "Esconder tokens",
    showTokens: "Exibir tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Adicionar e exibir/mostrar contas",
  title: "Gerenciar contas",
  watchAccount: "Observar conta",
  watchAccountDescription: "Esta conta faz parte das suas contas watch-only. Voc pode ocult-la de suas contas watch-only usando o boto de alternncia."
}, mobile$4 = {
  usingMobileDataWarning: "Uso de dados mveis: esse aplicativo baixa centenas de megabytes de dados de cabealho de blockhain depois de desbloquear sua conta. Por favor conecte no Wi-Fi para evitar de usar dados mveis desnecessrios. Depois de descartar isso, essa mensagem no aparecer novamente."
}, newSettings$3 = {
  about: {
    appVersion: {
      title: "Verso do aplicativo"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloqueie o acesso ao aplicativo com bloqueio de tela/impresso digital.",
      title: "Bloqueio de tela"
    },
    coinControl: {
      description: "Selecione quais UTXOs fazem parte de uma transao para ajudar a melhorar a privacidade."
    },
    customFees: {
      description: "Permite inserir sua prpria taxa ao enviar."
    },
    torProxy: {
      description: "Conecte-se via Tor para melhor privacidade."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Essas moedas adicionais podem ser alternadas na pgina da sua conta.",
      title: "Moedas ativas"
    },
    darkmode: {
      description: "Veja o BitBoxApp no modo escuro."
    },
    defaultCurrency: {
      description: "Selecione sua moeda padro",
      title: "Moeda padro"
    },
    hideAmounts: {
      description: "Exibe um boto para ocultar seu saldo e valores para melhorar sua privacidade ao usar o aplicativo em pblico.",
      hideAmounts: "Ocultar valores",
      showAmounts: "Mostrar valores",
      title: "Permitir ocultar valores"
    },
    language: {
      description: "Qual idioma voc deseja que o BitBoxApp use.",
      title: "Idioma"
    },
    toggleSats: {
      description: "Ativar ou desativar Satoshis."
    }
  }
}, note$5 = {
  input: {
    description: "(opcional)",
    placeholder: "Adicionar nota..."
  },
  title: "Nota"
}, notification$9 = {
  newTxs_one: "Nova transao em: {{accountName}}",
  newTxs_other: "{{count}} novas transaes em: {{accountName}}"
}, pairing$9 = {
  aborted: {
    text: "O emparelhamento foi cancelado no aplicativo para dispositivos mveis.",
    title: "Abortado"
  },
  button: "Emparelhar aplicativo mvel",
  confirm: "Tem certeza de que deseja emparelhar sua BitBox? Observe que, depois disso, o celular ser necessrio para realizar uma transao.",
  connectOnly: {
    button: "Conectar aplicativo mvel",
    title: "Escaneie com nosso aplicativo mvel selecionando o item 'Conectar ao novo aplicativo de desktop' do menu"
  },
  error: {
    text: "Algo deu errado. Por favor comece de novo.",
    title: "Erro"
  },
  pullFailed: {
    text: "Falha ao obter mensagem de seu dispositivo mvel atravs do servidor. O servidor pode estar offline, por favor entre em contato com o suporte.",
    title: "Falha ao obter"
  },
  reconnectOnly: {
    button: "Reconectar aplicativo mvel"
  },
  scanningFailed: {
    text: "Telefone no foi capaz de scanear a mensagem com sucesso. Por favor tente novamente.",
    title: "Falha ao scanear."
  },
  start: {
    hideAppQRCode: "Ocultar QR code",
    revealAppQRCode: "Mostrar QR code",
    step1: "Se voc no tiver o aplicativo para dispositivos mveis, voc pode escanear o QR code da Apple App Store ou da Google Play Store, dependendo de qual celular voc possui.",
    step2: 'Escaneie com nosso aplicativo para celular, que voc pode encontrar sob o nome "Digital Bitbox 2FA" nas lojas de aplicativos para iOS e Android:'
  },
  started: {
    text: "Agora, por favor, siga as instrues no aplicativo mvel.",
    title: "timo"
  },
  success: {
    text: "Parabns, voc pareou com sucesso sua BitBox com o aplicativo mvel!",
    title: "Sucesso"
  },
  timeout: {
    text: "O emparelhamento expirou aps dois minutos. Comece novamente se voc ainda deseja emparelhar o aplicativo para dispositivos mveis.",
    title: "Tempo esgotado"
  },
  title: "Emparelhamento por celular"
}, passphrase$3 = {
  considerations: {
    button: "Consideraes sobre backup",
    message: `A frase secreta adiciona uma camada de proteo ao backup da sua carteira (carto microSD ou palavras de recuperao). Se algum tiver acesso ao seu backup, tambm precisar da frase secreta para acessar sua carteira.

No entanto, isso significa que voc precisar <strong>tanto da frase secreta + backup da carteira</strong> para restaurar sua carteira habilitada para frase secreta, caso sua BitBox02 seja perdida ou danificada. Se voc esquecer ou perder sua frase secreta, perder o acesso a todas as moedas dessa carteira.

Ao armazenar sua frase secreta, considere coloc-la em um local separado do backup. Dessa forma, se algum encontrar seu backup, eles tambm no encontraro sua frase secreta.`,
    title: "Consideraes sobre backup"
  },
  disable: "Desabilitar frase secreta",
  disableInfo: {
    button: "Desabilitar",
    message: `Depois de desabilitar a frase secreta, voc no ser mais solicitado a inserir uma frase secreta aps desbloquear sua BitBox02. Portanto, voc entrar em sua carteira padro.

Quaisquer moedas em sua carteira gerada com a frase secreta ainda estaro nessa carteira, mas voc no poder acess-las porque depois de desbloquear sua BitBox02, voc abrir sua carteira padro.

Para acessar suas carteiras geradas com frases secretas novamente, basta reativar o recurso de frase secreta e inserir a frase secreta relevante aps desbloquear a BitBox02.

<strong>Dica:</strong> voc ainda pode acessar sua carteira original deixando a frase secreta vazia.`
  },
  enable: "Habilitar frase secreta",
  error: {
    e104: "A alterao da configurao da frase secreta foi abortada."
  },
  how: {
    button: "Como funciona",
    message: `Uma frase secreta no funciona como uma senha com a qual voc est acostumado. Se voc digitar incorretamente sua frase secreta, voc no ser notificado. Isso ocorre porque <strong>cada frase secreta cria uma carteira diferente, porm vlida</strong>. Isso significa que voc pode usar vrias frases secretas para quantas carteiras quiser. Mas cada carteira s pode ser acessada ao digitar a frase secreta correspondente.

Ao conectar sua BitBox02, voc ser solicitado a inserir a senha do dispositivo como de costume. Depois disso, voc ser solicitado a inserir uma frase secreta no dispositivo.

Depois de inserir a frase secreta, voc ver a frase secreta digitada. Isso  para que voc possa confirmar que digitou corretamente.`,
    title: "Como funciona"
  },
  intro: {
    message: `Uma frase secreta fornece uma camada adicional de segurana em sua carteira.
Vamos aprender como funciona.`,
    title: "Configurar frase secreta"
  },
  progressDisable: {
    message: "Confirme em sua BitBox que voc deseja <strong>desabilitar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  progressEnable: {
    message: "Confirme em sua BitBox que voc deseja <strong>ativar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  successDisabled: {
    message: `Frase secreta opcional <strong>ativada com sucesso</strong>!
Voc ser solicitado a fornecer uma frase secreta a partir de agora.`,
    messageEnd: "Por favor, reconecte a BitBox02 agora.",
    title: "Frase secreta ativada"
  },
  successEnabled: {
    message: `Frase secreta opcional <strong>desativada com sucesso</strong>!

Voc no ser mais solicitado a fornecer uma frase secreta.`,
    messageEnd: "Por favor, reconecte sua BitBox02 agora.",
    tips: "Dicas",
    tipsList: [
      "Sugerimos enviar primeiro uma pequena quantia para a carteira gerada pela frase secreta. Em seguida, desconecte e reconecte a BitBox02 e digite sua senha e frase secreta. Se voc digitou a frase secreta corretamente, dever ver as moedas em sua carteira.",
      "Se voc deseja acessar sua carteira original sem uma frase secreta, voc ainda pode fazer isso no digitando nada quando solicitado a inserir a frase secreta. Ou voc pode desativar o recurso de frase secreta."
    ],
    title: "Frase secreta desativada"
  },
  summary: {
    button: "Ativar frase secreta",
    title: "Resumo",
    understand: "Eu entendo como a frase secreta funciona e os riscos associados a ela.",
    understandList: [
      "A frase secreta  uma camada adicional de segurana em seu backup.",
      "A insero de uma frase secreta diferente sempre gerar uma carteira diferente.",
      "Para restaurar sua carteira, voc precisa <strong>da frase secreta e do backup</strong>.",
      "Se voc esquecer sua frase secreta, voc <strong>no poder mais acessar suas moedas</strong>."
    ]
  },
  what: {
    button: "Saiba como isso funciona",
    message: `Uma carteira  criada (derivada) a partir de um nmero aleatrio muito grande, tambm conhecido como semente. Essa semente  criada quando voc configura sua BitBox02 pela primeira vez e  feito backup com o carto microSD ou palavras de recuperao. Qualquer pessoa que tenha acesso  semente tem controle total sobre os fundos dessa carteira.

Uma frase secreta  um <strong>segredo opcional</strong>, adicionado  semente. Ao usar uma frase secreta, cada frase secreta cria uma nova carteira com base na semente + frase secreta (segredo opcional). Uma frase secreta pode ser qualquer coisa: letras, palavras, caracteres especiais ou pode at ser vazia. A carteira padro  de fato derivada da semente + frase secreta vazia.

A frase secreta  parte do padro BIP39, o que significa que  compatvel com todas as carteiras que suportam o mesmo padro.`,
    title: "O que  uma frase secreta?"
  },
  why: {
    button: "Por que usar uma frase secreta",
    message: `A BitBox02 protege a semente contra extrao do prprio dispositivo, mas o backup (carto microSD ou palavras de recuperao) d acesso total  carteira.  por isso que deve ser armazenado em um local seguro!

Como uma frase secreta cria uma nova carteira usando sua semente existente, a carteira da frase secreta requer tanto seu <strong>backup quanto sua frase secreta para restaurar</strong>. O benefcio disso  que, se algum encontrar seu backup, ainda precisar da frase secreta para acessar a carteira.

Alm disso, o recurso de frase secreta permite que voc crie vrias carteiras no mesmo dispositivo ou carteiras ocultas alm da padro.`,
    title: "Por que usar uma frase secreta?"
  }
}, password$9 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "ATENO: o caps lock () est ativado",
    paste: 'para colar o texto, ative "MOSTRAR {{label}}"'
  }
}, random$a = {
  button: "Gerar nmero aleatrio",
  description: "Sua BitBox gerou o seguinte nmero aleatrio de {{bits}} bits:"
}, receive$b = {
  changeScriptType: "Alterar tipo de endereo",
  label: "Seu endereo",
  onlyThisCoin: {
    description: "Para receber outros tokens, ative-os nas configuraes. Se voc depositar outros tokens, eles podem no ser acessveis.",
    warning: "Certifique-se de receber apenas {{coinName}} neste endereo."
  },
  scriptType: {
    p2tr: "Taproot (formato mais recente)",
    p2wpkh: "Segwit Nativo (padro)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatvel)"
  },
  selectAccount: "Selecione a conta",
  showFull: "Mostrar e verificar endereo completo no dispositivo",
  taprootWarning: "Nota: Taproot  um novo recurso do Bitcoin e ainda no  amplamente adotado. Os valores recebidos em endereos Taproot podem no ser visveis em carteiras watch-only de terceiros. Muitas carteiras e corretoras ainda no podem enviar para endereos Taproot.",
  title: "Receber {{accountName}}",
  verify: "Verificar endereo com segurana",
  verifyBitBox01: "Verifique o endereo no aplicativo mvel",
  verifyBitBox02: "Verifique o endereo na BitBox02",
  verifyInstruction: "Por favor, verifique se o endereo a seguir corresponde ao exibido no seu dispositivo.",
  warning: {
    secureOutput: "Por favor, emparelhe sua BitBox com seu dispositivo mvel para ativar a verificao segura de endereo. V para 'Gerenciar dispositivo' na barra lateral."
  }
}, reset$9 = {
  description: "Todos os dados sero excludos deste dispositivo. Isso inclui sua chave privada!",
  notReset: "Dispositivo NO redefinido.",
  title: "Restaurar configuraes de fbrica",
  understand: "Eu tenho um backup e sei minha senha de recuperao",
  understandBB02: "Eu tenho um backup vlido"
}, securityInformation$9 = {
  create: {
    description1: "Recomendamos que voc configure seu dispositivo em um ambiente seguro, ou seja, voc estar longe de outras pessoas que possam ver a senha que voc escolher.",
    description2: "Voc ser solicitado a criar duas senhas.",
    description3: "A primeira  a <strong>senha do dispositivo</strong> que desbloqueia o seu dispositivo BitBox e pode ser alterada mais tarde.",
    description4: "A segunda  a <strong>senha de recuperao</strong> que desbloqueia sua carteira. Esta senha no pode ser alterada mais tarde.",
    description5: "A carteira que voc criar ser copiada para um arquivo no carto microSD fornecido. Ele pode ser usado em caso de emergncia para recuperar seus fundos usando a sua <strong>senha de recuperao</strong>.",
    title: "Informao de segurana"
  },
  restore: {
    description1: "Voc ser solicitado a inserir o carto microSD usado para armazenar seu backup.",
    description2: "Para restaurar o seu dispositivo, voc precisar da sua senha de recuperao.",
    description3: "Por favor, tenha cuidado ao digitar a senha de recuperao. Qualquer senha que voc inserir criar uma carteira vlida. Se voc digitar a senha errada, poder ser mostrado um saldo da carteira que voc no espera.",
    title: "Informao de segurana"
  }
}, seed$9 = {
  agreements: {
    "funds-access": "Eu NO poderei acessar meus fundos se esquecer minha senha de recuperao",
    "password-change": "Eu NO posso mudar a senha de recuperao mais tarde",
    "password-required": "A senha de recuperao  necessria para restaurar uma carteira de um backup"
  },
  create: "Criar carteira",
  creating: "Criando carteira",
  description: "Eu entendo que:",
  error: {
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e200: "Voc precisa inserir um carto microSD na sua BitBox para criar uma carteira, para que um backup possa ser criado automaticamente."
  },
  info: {
    button: "Definir senha de recuperao agora",
    description1: "Insira o carto microSD na BitBox",
    description2: 'Escolha uma senha de recuperao para a carteira e selecione "Definir senha de recuperao agora"',
    description3: "O backup para o carto microSD e sua senha de recuperao  o nico mtodo para recuperar seus fundos em caso de perda ou roubo de um dispositivo BitBox.",
    description4: "Voc no pode alterar sua senha de recuperao posteriormente sem transferir seus fundos.",
    title: "Criar uma nova carteira"
  },
  password: {
    label: "Senha de recuperao",
    repeatPlaceholder: "Repita a senha de recuperao"
  },
  walletName: {
    label: "Nome da carteira"
  }
}, seedRestore$9 = {
  error: {
    e200: "Restaurar uma carteira a partir de um backup requer o carto microSD."
  },
  info: {
    description1: 'Insira o carto microSD na BitBox e clique em "Continuar"',
    description2: 'Escolha um backup e clique em "Restaurar"',
    description3: "Digite a senha de recuperao",
    description4: "Voc precisa confirmar que entende que uma senha incorreta criar uma carteira diferente.",
    title: "Como restaurar uma carteira a partir de um backup"
  }
}, send$b = {
  abort: "A transao foi abortada.",
  address: {
    label: "Endereo do destinatrio",
    placeholder: "Insira o endereo"
  },
  amount: {
    label: "Montante",
    placeholder: "Insira o valor"
  },
  availableBalance: "Saldo disponvel",
  button: "Revisar",
  coincontrol: {
    address: "Endereo",
    outpoint: "Outpoint",
    title: "Enviar da sada"
  },
  confirm: {
    "selected-coins": "Moedas selecionadas",
    title: "Confirmar e enviar transao",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que voc no tem Ether suficiente para pagar por esta transao ERC20. Certifique-se de ter Ether suficiente em sua carteira",
    feeTooLow: "taxa muito baixa",
    feesNotAvailable: "No foi possvel estimar as taxas",
    insufficientFunds: "saldo insuficiente",
    invalidAddress: "endereo invlido",
    invalidAmount: "montante invlido",
    invalidData: "dados invlidos"
  },
  fee: {
    customPlaceholder: "Insira o valor",
    label: "Taxa de rede",
    placeholder: "No disponvel"
  },
  feeTarget: {
    customLabel: "Taxa",
    customLabel_eth: "Preo do gs",
    description: {
      economy: "4 horas (24 blocos)",
      economy_eth: "30 minutos ou menos",
      economy_ltc: "1 hora (24 blocos)",
      high: "20 minutos (2 blocos)",
      high_eth: "30 segundos ou menos",
      high_ltc: "5 minutos (2 blocos)",
      low: "2 horas (12 blocos)",
      low_eth: "5 minutos ou menos",
      low_ltc: "30 minutos (12 blocos)",
      normal: "1 hora (6 blocos)",
      normal_eth: "2 minutos ou menos",
      normal_ltc: "15 minutos (6 blocos)"
    },
    estimate: "Tempo estimado de confirmao:",
    label: {
      custom: "Customizar",
      economy: "Econmica",
      high: "Alta",
      low: "Baixa",
      normal: "Normal"
    },
    placeholder: "Calculando a taxa ..."
  },
  maximum: "Enviar tudo",
  maximumSelectedCoins: "Enviar moedas selecionadas",
  noFeeTargets: "As estimativas de taxa de transao esto indisponveis no momento. Por favor, tente novamente mais tarde ou insira uma taxa personalizada.",
  priority: "Prioridade",
  scanQR: "Escanear QR code",
  signprogress: {
    description: "Esta  uma transao que contm muitos dados. Para assinar completamente a transao, voc ser solicitado a confirmar {{steps}} vezes.",
    label: "Progresso"
  },
  success: "A transao foi assinada e enviada.",
  title: "Enviar {{accountName}}",
  toggleCoinControl: "Alternar controle de moedas",
  transactionDetails: "Detalhes da transao"
}, settings$a = {
  about: "Sobre",
  accounts: "Contas",
  advancedSettings: "Configuraes avanadas",
  appearance: "Aparncia",
  electrum: {
    add: "Adicionar um servidor",
    "add-server": "Adicionar",
    check: "Checar",
    checkFailed: "Falhou",
    checkSuccess: "Conexo com {{host}} estabelecida com sucesso.",
    checking: "Checando",
    "download-cert": "Baixar certificado remoto",
    "remove-server": "Remover",
    removeConfirm: "Remover {{server}}?",
    reset: "Redefinir para o padro",
    resetConfirm: "Voc deseja remover todos os servidores e instalar os servidores padro?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Digite o endpoint.",
    step2: "2",
    "step2-text": "Digite um certificado da cadeia de certificados do servidor. Alternativamente, baixe o certificado remoto e compare-o visualmente.",
    "step2-text-tcp": "Voc pode pular essa estapa se no quiser usar TLS.",
    step3: "3",
    "step3-text": "Checar a conexo e adicionar o servidor.",
    step4: "4",
    "step4-text": "Reinicie a carteira. Se voc no remover os servidores padro, seu prprio node ser adicionado como uma redundncia.",
    "title-btc": "Servidores Bitcoin Electrum",
    "title-ltc": "Servidores Litecoin Electrum",
    "title-tbtc": "Servidores Bitcoin Testnet Electrum",
    "title-tltc": "Servidores Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Ativar controle de moedas",
    electrum: {
      description: "Voc pode se conectar ao seu prprio n completo Electrum.",
      title: "Conectar seu prprio full node"
    },
    fee: "Habilitar taxas personalizadas",
    setProxyAddress: "Configurar endereo de proxy",
    title: "Configuraes para especialistas",
    useProxy: "Ativar proxy Tor",
    useSats: "Exibir valores BTC em Satoshis"
  },
  header: {
    home: "Incio"
  },
  info: {
    "out-of-date": "Nova atualizao disponvel",
    title: "Informaes",
    "up-to-date": "Seu aplicativo est atualizado",
    version: "Verso do aplicativo"
  },
  restart: "Por favor, reinicie o BitBoxApp para que as alteraes faam efeito.",
  services: {
    title: "Servios"
  },
  success: "Por favor, retire e reconecte a BitBox para que as mudanas faam efeito.",
  title: "Configuraes"
}, setup$9 = "Configurar dispositivo", sidebar$a = {
  buy: "Comprar crypto",
  device: "Gerenciar dispositivo",
  leave: "Sair",
  settings: "Configuraes"
}, success$g = {
  create: {
    info1: "Sua carteira foi armazenada com segurana no carto microSD. Remova-o e mantenha-o seguro.",
    info2: "Voc criou uma senha de dispositivo segura que desbloqueia a BitBox.",
    info3: "Voc criou uma senha de recuperao segura para sua carteira que desbloqueia seu saldo e restaura seus backups.",
    summary: "Aqui est um resumo do que voc fez",
    title: "Sucesso"
  },
  getstarted: "Comear",
  restore: {
    summary: "Voc restaurou uma carteira a partir do seu backup com sucesso.",
    title: "Sucesso"
  }
}, transaction$a = {
  confirmation: "Confirmaes",
  details: {
    activity: "Movimentao",
    address: "Endereo",
    amount: "Valor",
    date: "Data",
    fiat: "Fiduciria",
    fiatAmount: "Valor fiducirio",
    fiatAtTime: "Fiat no momento da transao",
    status: "Status",
    type: "Tipo"
  },
  explorer: "ID da transao",
  explorerTitle: "Abrir no explorador de blocos externo",
  fee: "Taxa",
  fiatHistorical: "Histrico",
  gas: "Gas",
  note: {
    edit: "Editar n",
    save: "Salvar n"
  },
  pending: "Transao pendente",
  size: "Tamanho",
  status: {
    complete: "Completa",
    failed: "Falhou",
    pending: "Pendente"
  },
  tx: {
    received: "Recebido para",
    sent: "Enviado para"
  },
  vsize: "Tamanho virtual",
  weight: "Peso"
}, transactions$9 = {
  errorLoadTransactions: "Ocorreu um erro ao carregar as transaes",
  placeholder: "Nenhuma transao ainda."
}, unknownError$9 = "Ocorreu um erro desconhecido: {{errorMessage}}", unlock$9 = {
  description: "Digite a senha do dispositivo para desbloque-lo.",
  error: {
    e109_normal: "Senha do dispositivo errada. {{remainingAttempts}} tentativas restantes antes que o dispositivo seja resetado.",
    e109_touch: "$t(unlock.error.e109_normal) O prximo login requer que segure o boto touch.",
    e113: "Devido a muitas tentativas de login, o prximo login requer que o boto touch seja pressionado por 4 segundos."
  },
  input: {
    label: "Senha do dispositivo",
    placeholder: "Digite a senha do dispositivo para desbloque-lo"
  },
  unlocking: "Desbloqueando..."
}, upgradeFirmware$a = {
  button: "Atualizar firmware",
  description: "Deseja atualizar o firmware da verso {{currentVersion}} para {{newVersion}}?",
  label: "Sua BitBox requer uma atualizao de firmware.",
  locked: "Para atualizar da verso {{currentVersion}} para a {{newVersion}}, por favor, realize um longo toque.",
  title: "Atualizar firmware",
  unlocked: "O bootloader est desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecte e reconecte sua Bitbox",
  unlocked2: "O LED acender quando a sua BitBox for conectada novamente",
  unlocked3: "Toque no boto touch quando o LED acender"
}, walletConnect$5 = {
  connect: {
    button: "Conectar",
    dappLabel: "Insira o endereo URI do dapp",
    invalidPairingUri: "Uri de emparelhamento invlido"
  },
  dashboard: {
    allSessions: "Todas as sesses",
    disclaimer: "Walletconnect  um protocolo para conectar-se a Dapps baseados em Ethereum. Esses dapps so executados por servios de terceiros, portanto, conecte-se apenas a dapps em que voc confia e sempre saiba o que est assinando ao fazer uma transao.",
    newConnection: "Nova conexo",
    noConnectedSessions: "Nenhuma conta est atualmente conectada a nenhum dapps."
  },
  invalidPairingChain: "Erro ao aprovar o emparelhamento. Certifique-se de usar uma das cadeias suportadas: {{chains}}",
  pairingRequest: {
    approve: "Aprovar conexo",
    reject: "Rejeitar",
    title: "Nova solicitao de conexo de"
  },
  pairingSuccess: "Dapp conectado com sucesso. Voc pode continuar no site dapp.",
  signingRequest: {
    account: "Conta",
    chain: "Cadeia",
    dapp: "Dapp",
    data: "Dados",
    dataParsingError: "Falha ao analisar os dados",
    decodeError: "Falha ao decodificar a mensagem",
    method: {
      sendTransaction: "Assinar e enviar transao",
      signMessage: "Assinar mensagem",
      signTransaction: "Assinar transao",
      signTypedData: "Assinar dados digitados"
    },
    successfullySigned: "Solicitao assinada com sucesso",
    walletConnectRequest: "Solicitao WalletConnect"
  },
  useNewUri: "Este URI j foi usado para tentar uma conexo. Use um novo URI.",
  walletConnect: "WalletConnect"
}, warning$f = {
  receivePairing: "Por favor, emparelhe a BitBox para ativar a verificao segura de endereo. V para 'Gerenciar dispositivo' na barra lateral.",
  sdcard: "Mantenha o carto microSD guardado separado da BitBox, a menos que voc queira gerenciar os backups.",
  sendPairing: 'Por favor, emparelhe a BitBox para verificar com segurana os detalhes da transao. V para "Gerenciar dispositivo" na barra lateral.'
}, welcome$9 = {
  connect: "Conecte a BitBox02",
  getStarted: "Vamos comear instalando o firmware na sua BitBox02.",
  insertBitBox02: "Para a BitBox02, por favor, toque no dispositivo para continuar.",
  insertDevice: "Por favor, conecte seu dispositivo para iniciar",
  title: "Bem-vindo"
}, appTranslationsPT = {
  account: account$9,
  accountInfo: accountInfo$9,
  accountSummary: accountSummary$9,
  addAccount: addAccount$a,
  aopp: aopp$3,
  app: app$9,
  auth: auth$4,
  backup: backup$9,
  bb02Bootloader: bb02Bootloader$9,
  bitbox: bitbox$9,
  bitbox02Interact: bitbox02Interact$9,
  bitbox02Settings: bitbox02Settings$9,
  bitbox02Wizard: bitbox02Wizard$9,
  blink: blink$9,
  bootloader: bootloader$9,
  button: button$d,
  buy: buy$5,
  changePin: changePin$9,
  chart: chart$5,
  checkSDcard: checkSDcard$9,
  clickHere: clickHere$9,
  confirm: confirm$b,
  confirmOnDevice: confirmOnDevice$9,
  connectKeystore: connectKeystore$4,
  darkmode: darkmode$4,
  device: device$9,
  deviceLock: deviceLock$9,
  deviceSettings: deviceSettings$9,
  deviceTampered: deviceTampered$9,
  dialog: dialog$a,
  error: error$5,
  fiat: fiat$b,
  footer: footer$b,
  generic: generic$5,
  genericError: genericError$9,
  goal: goal$9,
  guide: guide$a,
  headerssync: headerssync$9,
  hiddenWallet: hiddenWallet$9,
  initialize: initialize$9,
  invalidFormat: invalidFormat$9,
  language: language$a,
  legacyhiddenwallet: legacyhiddenwallet$9,
  loading: loading$9,
  manageAccounts: manageAccounts$3,
  mobile: mobile$4,
  newSettings: newSettings$3,
  note: note$5,
  notification: notification$9,
  pairing: pairing$9,
  passphrase: passphrase$3,
  password: password$9,
  random: random$a,
  receive: receive$b,
  reset: reset$9,
  securityInformation: securityInformation$9,
  seed: seed$9,
  seedRestore: seedRestore$9,
  send: send$b,
  settings: settings$a,
  setup: setup$9,
  sidebar: sidebar$a,
  success: success$g,
  transaction: transaction$a,
  transactions: transactions$9,
  unknownError: unknownError$9,
  unlock: unlock$9,
  upgradeFirmware: upgradeFirmware$a,
  walletConnect: walletConnect$5,
  warning: warning$f,
  welcome: welcome$9
}, account$8 = {
  disconnect: "       ...",
  exportTransactions: "     CSV      ",
  fatalError: "   ",
  incoming: "  ",
  initializing: "       ...",
  reconnecting: "  ,          ..."
}, accountInfo$8 = {
  address: "",
  extendedPublicKey: "  ",
  label: " ",
  title: "  ",
  verify: "   "
}, accountSummary$8 = {
  balance: "",
  exportSummary: "      CSV      ",
  fiatBalance: " ",
  name: "  ",
  noAccount: "      ",
  title: " ",
  total: ""
}, addAccount$9 = {
  title: " "
}, app$8 = {
  upgrade: "       !  {{current}}  {{version}}   "
}, backup$8 = {
  check: {
    checking: "    ...",
    confirmTitle: "   ",
    notOK: "      ",
    ok: "     ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "  :",
    title: "   "
  },
  create: {
    alreadyExists: "                ?",
    fail: "   ",
    info: "          ",
    name: {
      label: "  ",
      placeholder: "    "
    },
    password: {
      label: " ",
      placeholder: "     "
    },
    title: " ",
    verificationFailed: "                       ' '   "
  },
  description: "<strong>  </strong>  ",
  insert: "         ",
  insertButton: "     ",
  list: "   ",
  noBackups: "        ",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "     ...",
    title: " ",
    understand: "           "
  },
  showMnemonic: {
    description: ` 24   ,            

<strong>           </strong>

<strong>     </strong>

<strong>      </strong>

 ,          `,
    title: "  "
  },
  title: "  "
}, bb02Bootloader$8 = {
  abort: "   -    ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "     hash "
  },
  flipscreen: " ",
  orientation: "     ?",
  success: "  !  {{rebootSeconds}}     ..."
}, bitbox$8 = {
  error: {
    e10000: "    ",
    e10001: "    ",
    e102: "     4   ",
    e112: "           "
  }
}, bitbox02Interact$8 = {
  followInstructions: "  BitBox02       "
}, bitbox02Settings$8 = {
  deviceName: {
    current: "   ",
    input: "BitBox02  ",
    title: "BitBox02    "
  }
}, bitbox02Wizard$8 = {
  attestationFailed: "    ,                     :      ",
  backup: {
    point1: "      ",
    point2: "       ",
    restoreText: " ,    !",
    text1: ",   BitBox02                          BitBox02       ",
    text2: "        -    ",
    text3: "     ,       <strong> </strong>                BitBox02        ",
    userConfirmation1: "        ",
    userConfirmation2: "               ",
    userConfirmation3: "   BitBox02       ,               ",
    userConfirmation4: "      BitBox02                "
  },
  create: {
    button: "      ",
    info: " BitBox             ",
    inputTitle: "  ",
    point1: "    ",
    point2: "       ",
    point3: "  ",
    text: " ,     !"
  },
  initialize: {
    passwordText: "                  BitBox     ",
    passwordTitle: " BitBox      ",
    text: "  BitBox02  !            ,               <strong>     BitBox02       </strong>",
    tip: "         ",
    title: " BitBox   "
  },
  insertSDCard: "<strong>       BitBox02       </strong>",
  pairing: {
    failed: "    BitBox02   ",
    paired: "               ,             ",
    title: "pairing   ",
    unpaired: "  BitBox02                    ,   BitBox02                    "
  },
  restoreFromMnemonic: {
    failed: "      ,    "
  },
  stepBackup: {
    beforeProceed: "   ,       :",
    createBackup: "        "
  },
  stepBackupSuccess: {
    fundsSafe: "      ,     :",
    title: "   !"
  },
  stepConnected: {
    unlock: "    BitBox02  "
  },
  stepCreate: {
    nameLabel: "BitBox02 ",
    namePlaceholder: " BitBox02",
    title: "BitBox02   ",
    toastMicroSD: "        BitBox02    "
  },
  stepCreateSuccess: {
    removeMicroSD: "  BitBox02           ",
    success: "      "
  },
  stepPassword: {
    title: "BitBox02    ",
    useControls: "      BitBox02     "
  },
  stepUninitialized: {
    create: "   BitBox02    ",
    restore: "          ",
    restoreMicroSD: "    ",
    restoreMnemonic: "mnemonic   ",
    title: " BitBox02  "
  },
  success: {
    text: `!  BitBox02       

BitBoxApp           ,          -    `,
    title: "      !"
  }
}, blink$8 = {
  button: ""
}, bootloader$8 = {
  button: "   ",
  progress: "   : {{progress}}%",
  success: "  !        ,     "
}, button$c = {
  abort: "      ",
  back: " ",
  changepin: "  ",
  check: "   ",
  continue: "Continue",
  copy: " ",
  create: " ",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: " ",
  restore: " ",
  select: "Select",
  send: "",
  unlock: "",
  update: "Update",
  upgrade: ""
}, changePin$8 = {
  newTitle: "  ",
  oldLabel: "  "
}, checkSDcard$8 = "       ", clickHere$8 = "  ", confirm$a = {
  abortInfo: "  ",
  abortInfoRedText: "    ",
  approveInfo: "4+     ",
  approveInfoGreenText: "    ",
  info: " BitBox ",
  infoWhenPaired: "         BitBox"
}, confirmOnDevice$8 = "     ", device$8 = {
  appUpradeRequired: " BitBox              "
}, deviceLock$8 = {
  button: "Two Factor Authorization (2FA)  ",
  condition1: "    ?",
  condition2: "       ?",
  condition3: "2FA            2FA      RESET  !",
  confirm: "Two Factor Authorization (2FA)  ",
  title: "Two Factor Authorization (2FA)  "
}, deviceSettings$8 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "     ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: "  ",
      label: "  ",
      true: " "
    },
    title: ""
  },
  loading: "     ",
  pairing: {
    lock: {
      false: " ",
      label: "Two Factor Authorization (2FA)",
      true: " "
    },
    mobile: {
      false: " ",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: " "
    },
    title: " "
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
}, deviceTampered$8 = "  BitBox        ?  ,        support    Shift             ", dialog$9 = {
  cancel: " ",
  confirm: " "
}, fiat$a = {
  default: "",
  setDefault: "set {{code}} as default",
  title: ""
}, footer$a = {
  appVersion: " :"
}, genericError$8 = "          ,       ", goal$8 = {
  buttons: {
    create: "   ",
    restore: "     "
  },
  paragraph: "        :",
  step: {
    1: {
      title: " "
    },
    2: {
      description: "   ",
      title: ""
    },
    "3-create": {
      description: "   ",
      title: ""
    },
    "3-restore": {
      description: " ",
      title: " "
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$9 = {
  accountDescription: {
    text: "       -           '              ",
    title: "     ?"
  },
  accountFiat: {
    text: "                        ",
    title: "        ?"
  },
  accountIncomingBalance: {
    text: "                     ",
    title: "incoming    ?"
  },
  accountInfo: {
    xpub: {
      text: `                  
  -                 `,
      title: "     ?"
    }
  },
  accountRates: {
    text: ` CoinGecko         
`,
    title: "      ?"
  },
  accountReload: {
    text: "     -        ",
    title: "        ?"
  },
  accountSendDisabled: {
    text: "        'Send'     ",
    title: "  {{unit}}     ?"
  },
  accountTransactionAttributesBTC: {
    text: ` :                         
:            
: Segwit     ,                segregated witness         ,               ,          `,
    title: "-       ?"
  },
  accountTransactionAttributesGeneric: {
    text: `(Confirmations):   -        miner        ,                                   
 (Transaction ID):               
(Fee):                          ,     `,
    title: "        ?"
  },
  accountTransactionConfirmation: {
    text: "                  ",
    title: "   ?"
  },
  accountTransactionLabel: {
    text: "              ",
    title: "         ?"
  },
  accountTransactionTime: {
    text: "   ",
    title: "     ?"
  },
  appendix: {
    link: "  !",
    text: "  ?"
  },
  backups: {
    check: {
      text: "' '                                                         ",
      title: "'   ?"
    },
    encrypt: {
      text: ",                           ",
      title: "      ?"
    },
    howOften: {
      text: `                       ,              ,        
-                                  `,
      title: "     ?"
    },
    whatIsABackup: {
      text: "                    ",
      title: "  ?"
    }
  },
  backupsBB02: {
    check: {
      text: "' '                     ",
      title: "'   ?"
    },
    encrypt: {
      text: ',      ,                        ,   " "            ',
      title: "      ?"
    },
    whatIsABackup: {
      text: "         ",
      title: "  ?"
    }
  },
  bitbox: {
    "2FA": {
      text: ` 2FA   ,                      ,   -       ,     ,      BitBox                            
2FA                     ,             BitBox         ,      `,
      title: "Two Factor Authorization (2FA)    ?"
    },
    disable2FA: {
      text: "2FA     ,   BitBox                                     ' '         '  '         , ''                 ",
      title: " Two Factor Authorization (2FA)      ?"
    },
    ejectBitbox: {
      text: " BitBox       BitBox     ",
      title: " BitBox    ?"
    },
    ejectSD: {
      text: "            ,             ",
      title: "       ?"
    },
    hiddenWallet: {
      text: "                 ,      (plausible deniability)                      ,       ",
      title: "   ?"
    },
    legacyHiddenWallet: {
      text: "        (  BitBox           2FA  ),   BitBox               ",
      title: "       ?"
    },
    pairing: {
      text: "iOS  Android          ,   QR     ,                    ,         ",
      title: "        "
    }
  },
  receive: {
    address: {
      text: "                     ",
      title: "     ?"
    },
    addressChange: {
      text: "   -  ,             20          ",
      title: "   ?"
    },
    howVerify: {
      text: `BitBox01  ,     BitBox                       
BitBox02  ,   /              `,
      title: "           ?"
    },
    why20: {
      text: '-                                 ,                      20                " "   20    ,       20       ',
      title: " 20   ?"
    },
    whyMany: {
      text: "      ,                 ,                20               ",
      title: "   ?"
    },
    whyVerify: {
      text: `
                                BitBox01  ,                  ,   QR          BitBox02  ,    BitBox02       `,
      title: "        ?"
    }
  },
  send: {
    fee: {
      text: `       ,                   Bitcoin Core                 ,     
: 24  (Bitcoin    4 , Litecoin   1 )
: 12  (Bitcoin    2 , Litecoin   30 )
: 6  (Bitcoin    1 , Litecoin   15 )
: 2  (Bitcoin    20 , Litecoin   5 )
(Bitcoin      (  2.5 )                  )`,
      title: "     ?"
    },
    priority: {
      text: "         ,              ",
      title: "   ?"
    },
    revert: {
      text: `      (   )  ,             ( )     !
             (  )    ,            `,
      title: "      ?"
    },
    whyFee: {
      text: `                           
             (      )           ,                       ,                  `,
      title: "   ?"
    }
  },
  "settings-electrum": {
    what: {
      text: "                   ",
      title: "  ?"
    }
  },
  settings: {
    servers: {
      text: `  ,  -          ,        
                           -            
:    20   ,       `,
      title: "       ?"
    }
  },
  title: "",
  toggle: {
    close: "  ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "                  ",
      title: "          ?"
    },
    reset: {
      text: "15                    ",
      title: "     ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "                        ,            ",
      title: " BitBox01    "
    },
    getDevice: {
      link: {
        text: "BitBox  "
      },
      text: "     BitBox   :",
      title: " BitBox      ?"
    },
    internet: {
      text: ",    ,                  ",
      title: "         ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "   BitBox              ",
      title: "      ?"
    },
    useWithoutDevice: {
      text: " ,     ",
      title: "          ?"
    },
    welcome: {
      text: "  Shift Crypto                                 ",
      title: "BitBox     !"
    }
  }
}, headerssync$8 = {
  blocksSynced: "{{blocks}}    "
}, hiddenWallet$8 = {
  info1HTML: "  (plausible deniability)  , <strong></strong>   +              ",
  info2HTML: "                                   <strong></strong>     ",
  passwordLabel: "  ",
  passwordPlaceholder: "      ",
  pinLabel: "  ",
  pinRepeatLabel: "    ",
  pinRepeatPlaceholder: "      ",
  success: "           BitBox    "
}, initialize$8 = {
  create: "   ",
  creating: "      ...",
  error: {
    e102: "      4   "
  },
  info: {
    description1: "       BitBox       ",
    description2: " ,             ",
    description3: "      ,               ",
    subtitle: "      ",
    title: "    "
  },
  input: {
    label: " ",
    labelRepeat: "  ",
    placeholderRepeat: "     "
  }
}, invalidFormat$8 = " ", language$9 = {
  title: " "
}, legacyhiddenwallet$8 = {
  disable: "     ",
  enable: "    ",
  successDisable: "       ",
  successEnable: "        BitBox                  "
}, loading$8 = "   ", notification$8 = {
  newTxs_one: "{{accountName}}    ",
  newTxs_other: "{{accountName}}  {{count}}  "
}, pairing$8 = {
  aborted: {
    text: "         ",
    title: "  "
  },
  button: "  ",
  confirm: "    BitBox    ?             ",
  connectOnly: {
    button: "   ",
    title: "  '     '         "
  },
  error: {
    text: "        ",
    title: ""
  },
  reconnectOnly: {
    button: "      "
  },
  start: {
    hideAppQRCode: "QR  ",
    revealAppQRCode: "QR  ",
    step1: "      ,           Apple App Store  Google Play Store   QR      ",
    step2: "     ,   iOS  Android      'Digital BitBox 2FA'     :"
  },
  started: {
    text: "          ",
    title: "Great"
  },
  success: {
    text: " ,   BitBox        !",
    title: ""
  },
  timeout: {
    text: "                        ",
    title: " "
  },
  title: "Mobile Pairing"
}, password$8 = {
  show: "{{label}} ",
  warning: {
    caps: ":   ()  ",
    paste: 'text   , "{{label}} "    '
  }
}, random$9 = {
  button: "   ",
  description: " BitBox   {{bits}}-bit     :"
}, receive$a = {
  label: " ",
  onlyThisCoin: {
    description: "     ,            ,          ",
    warning: "    {{coinName}}    "
  },
  showFull: "     ",
  title: "{{accountName}} ",
  verify: "      ",
  verifyBitBox01: "     ",
  verifyBitBox02: "BitBox02    ",
  verifyInstruction: "              ",
  warning: {
    secureOutput: "               BitBox     ' '  "
  }
}, reset$8 = {
  description: "            !",
  notReset: "   ",
  title: "  ",
  understand: "          ",
  understandBB02: "     "
}, securityInformation$8 = {
  create: {
    description1: "                  ",
    description2: "       ",
    description3: "  <strong> </strong>   BitBox              ",
    description4: "  <strong> </strong>                 ",
    description5: "    ,  SD            <strong> </strong>               ",
    title: " "
  },
  restore: {
    description1: "                   ",
    description2: "              ",
    description3: "                                        ",
    title: " "
  }
}, seed$8 = {
  agreements: {
    "funds-access": "               ",
    "password-change": "       ",
    "password-required": "            "
  },
  create: " ",
  creating: "   ",
  description: "   :",
  error: {
    e102: "     4   ",
    e200: "      BitBox          ,          "
  },
  info: {
    button: "    ",
    description1: "BitBox     ",
    description2: '        "    " ',
    description3: "BitBox                            ",
    description4: "              ",
    title: "   "
  },
  password: {
    label: " ",
    repeatPlaceholder: "  "
  },
  walletName: {
    label: "  "
  }
}, seedRestore$8 = {
  error: {
    e200: "              "
  },
  info: {
    description1: 'BitBox       " "   ',
    description2: '    " "   ',
    description3: "  ",
    description4: "                   ",
    title: "      "
  }
}, send$a = {
  abort: "     ",
  address: {
    label: "  ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  button: "   ",
  coincontrol: {
    address: "",
    outpoint: "outpoint",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "24  (Bitcoin    4 , Litecoin   1 )",
      high: "2  (Bitcoin    20 , Litecoin   5 )",
      low: "12  (Bitcoin    2 , Litecoin   30 )",
      normal: "6  (Bitcoin    1 , Litecoin   15 )"
    },
    estimate: "  :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "       ..."
  },
  maximum: " ",
  scanQR: "QR   ",
  signprogress: {
    description: "                    {{steps}}       ",
    label: ""
  },
  success: "         ",
  title: "{{accountName}} ",
  toggleCoinControl: "Coin Control  "
}, settings$9 = {
  electrum: {
    add: "  ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: " {{host}}      ",
    checking: "   ",
    "download-cert": "   ",
    "remove-server": "",
    removeConfirm: "{{server}} ?",
    reset: "   ",
    resetConfirm: "               ?",
    servers: "",
    step1: "1",
    "step1-text": "endpoint  ",
    step2: "2",
    "step2-text": "          ,          ",
    step3: "3",
    "step3-text": "      ",
    step4: "4",
    "step4-text": "           ,          ",
    "title-btc": "Bitcoin Electrum ",
    "title-ltc": "Litecoin Electrum ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "   ",
    electrum: {
      title: "    "
    },
    setProxyAddress: "   ",
    title: " ",
    useProxy: "   "
  },
  header: {
    home: "Home"
  },
  restart: "       BitBoxApp     ",
  success: "          BitBox    ",
  title: ""
}, setup$8 = " ", sidebar$9 = {
  device: "  ",
  leave: "",
  settings: ""
}, success$f = {
  create: {
    info1: "                   ",
    info2: "        BitBox    ",
    info3: "                        ",
    summary: "         ",
    title: ""
  },
  getstarted: " ",
  restore: {
    summary: "          ",
    title: ""
  }
}, transaction$9 = {
  confirmation: "Confirmations",
  explorer: " ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: "",
  gas: "Gas",
  pending: " ",
  size: "",
  vsize: " ",
  weight: ""
}, transactions$8 = {
  placeholder: "     "
}, unknownError$8 = "   : {{errorMessage}}", unlock$8 = {
  description: "          ",
  error: {
    e109_normal: "          {{remainingAttempts}}   ",
    e109_touch: "$t(unlock.error.e109_normal)          ",
    e113: "    ,     4         "
  },
  input: {
    label: " ",
    placeholder: "         "
  },
  unlocking: "    ..."
}, upgradeFirmware$9 = {
  button: "  ",
  description: "    {{currentVersion}}  {{newVersion}}       ?",
  label: " BitBox      ",
  locked: "{{currentVersion}}  {{newVersion}}    ,     ",
  title: "  ",
  unlocked: "        , :",
  unlocked1: " Bitbox         ",
  unlocked2: "  BitBox          ",
  unlocked3: "          "
}, warning$e = {
  receivePairing: "        BitBox     ' '  ",
  sdcard: "       ,          ",
  sendPairing: "            BitBox     ' '  "
}, welcome$8 = {
  insertBitBox02: "BitBox02  ,         ",
  insertDevice: "        ",
  title: "  "
}, appTranslationsHI = {
  account: account$8,
  accountInfo: accountInfo$8,
  accountSummary: accountSummary$8,
  addAccount: addAccount$9,
  app: app$8,
  backup: backup$8,
  bb02Bootloader: bb02Bootloader$8,
  bitbox: bitbox$8,
  bitbox02Interact: bitbox02Interact$8,
  bitbox02Settings: bitbox02Settings$8,
  bitbox02Wizard: bitbox02Wizard$8,
  blink: blink$8,
  bootloader: bootloader$8,
  button: button$c,
  changePin: changePin$8,
  checkSDcard: checkSDcard$8,
  clickHere: clickHere$8,
  confirm: confirm$a,
  confirmOnDevice: confirmOnDevice$8,
  device: device$8,
  deviceLock: deviceLock$8,
  deviceSettings: deviceSettings$8,
  deviceTampered: deviceTampered$8,
  dialog: dialog$9,
  fiat: fiat$a,
  footer: footer$a,
  genericError: genericError$8,
  goal: goal$8,
  guide: guide$9,
  headerssync: headerssync$8,
  hiddenWallet: hiddenWallet$8,
  initialize: initialize$8,
  invalidFormat: invalidFormat$8,
  language: language$9,
  legacyhiddenwallet: legacyhiddenwallet$8,
  loading: loading$8,
  notification: notification$8,
  pairing: pairing$8,
  password: password$8,
  random: random$9,
  receive: receive$a,
  reset: reset$8,
  securityInformation: securityInformation$8,
  seed: seed$8,
  seedRestore: seedRestore$8,
  send: send$a,
  settings: settings$9,
  setup: setup$8,
  sidebar: sidebar$9,
  success: success$f,
  transaction: transaction$9,
  transactions: transactions$8,
  unknownError: unknownError$8,
  unlock: unlock$8,
  upgradeFirmware: upgradeFirmware$9,
  warning: warning$e,
  welcome: welcome$8
}, account$7 = {
  disconnect: "  .   ...",
  exportTransactions: "     Downloads  CSV ",
  fatalError: "  .",
  incoming: "",
  initializing: "    ...",
  reconnecting: "  ,     ..."
}, accountInfo$7 = {
  address: "",
  extendedPublicKey: "  ",
  label: "  ",
  title: "  ",
  verify: "  "
}, accountSummary$7 = {
  balance: "",
  exportSummary: "       CSV    Downloads",
  fiatBalance: "   ",
  name: "  ",
  noAccount: "  ",
  title: "   ",
  total: ""
}, addAccount$8 = {
  title: "  "
}, app$7 = {
  upgrade: "  -    !    {{current}}  {{version}}."
}, backup$7 = {
  check: {
    checking: " ...",
    confirmTitle: "  ",
    notOK: "     .",
    ok: "    .",
    password: {
      label: "  ",
      placeholder: "  ",
      showLabel: "  "
    },
    success: "  :",
    title: "  "
  },
  create: {
    alreadyExists: "    .      ?",
    fail: "    !",
    info: "         .",
    name: {
      label: "  ",
      placeholder: "    "
    },
    password: {
      label: "  ",
      placeholder: "    "
    },
    title: "  ",
    verificationFailed: '         .   .    "  ",      .'
  },
  description: "  <strong>   </strong>",
  insert: "  microSD ,    .",
  insertButton: "microSD   ",
  list: "   micro SD :",
  noBackups: "  microSD   .",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   microSD "
    },
    password: {
      label: "       ",
      placeholder: "  ",
      repeatPlaceholder: "     ",
      showLabel: "  "
    },
    restoring: "  ...",
    title: "",
    understand: ",           "
  },
  showMnemonic: {
    description: `       24 ,       .    .

<strong>         .</strong>

<strong>    .</strong>

<strong>     .</strong>

        .`,
    title: "   "
  },
  title: "  "
}, bb02Bootloader$7 = {
  abort: "     ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "          "
  },
  flipscreen: "  ",
  orientation: "     ?",
  success: "  !   {{rebootSeconds}} ..."
}, bitbox$7 = {
  error: {
    e10000: "      .",
    e10001: "      ",
    e102: "     4 ",
    e112: "             ."
  }
}, bitbox02Interact$7 = {
  followInstructions: "  ,    BitBox02."
}, bitbox02Settings$7 = {
  deviceName: {
    current: "   ",
    input: "  BitBox02",
    title: "   BitBox02"
  }
}, bitbox02Wizard$7 = {
  attestationFailed: "    .     ,   ,        .      .",
  backup: {
    point1: "   microSD ",
    point2: "    ",
    restoreText: ",    !",
    text1: ",    BitBox02      .        .  ,  microSD     BitBox02  .",
    text2: "     ,    .",
    text3: "    ,  micro SD     <strong>  </strong>.   micro SD      .          ,   BitBox02.",
    userConfirmation1: "      .",
    userConfirmation2: "     . ,     ,      .",
    userConfirmation3: "     BitBox02,               .",
    userConfirmation4: "     ,  BitBox02 ,     ."
  },
  create: {
    button: "      ",
    info: "   ,    ,     BitBox:",
    inputTitle: "  ",
    point1: "    ",
    point2: "    ",
    point3: " ",
    text: ",    !"
  },
  initialize: {
    passwordText: "     .      BitBox,       .",
    passwordTitle: "    BitBox",
    text: "   BitBox02  !    . -         ,       . <strong> ,    BitBox02   microSD </strong>",
    tip: "  ,      .",
    title: "   BitBox"
  },
  insertSDCard: "<strong> ,    BitBox02   microSD </strong>",
  pairing: {
    failed: "   .     BitBox02.",
    paired: "   ,   .    ,   ,    .",
    title: "    .",
    unpaired: "   BitBox02.  ,           .   ,            BitBox02    ,   ."
  },
  restoreFromMnemonic: {
    failed: "    ,  ."
  },
  stepBackup: {
    beforeProceed: "  ,       :",
    createBackup: "       microSD ."
  },
  stepBackupSuccess: {
    fundsSafe: "       ,   :",
    title: "  !"
  },
  stepConnected: {
    unlock: "   BitBox02,    ."
  },
  stepCreate: {
    nameLabel: "  BitBox02",
    namePlaceholder: " BitBox02 ",
    title: "    BitBox02",
    toastMicroSD: " ,  microSD      BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: " microSD    BitBox02      .",
    success: "   ."
  },
  stepPassword: {
    title: "    BitBox02",
    useControls: "    BitBox02,    ."
  },
  stepUninitialized: {
    create: "    BitBox02 .",
    restore: "      .",
    restoreMicroSD: "  microSD ",
    restoreMnemonic: "   ",
    title: "   BitBox02 "
  },
  success: {
    text: `!  BitBox02    .

       BitBox,     ,          .`,
    title: "  !"
  }
}, blink$7 = {
  button: ""
}, bootloader$7 = {
  button: "  firmware",
  progress: ": {{progress}}%",
  success: "  !       ,    ."
}, button$b = {
  abort: "",
  back: "",
  changepin: "    ",
  check: "  ",
  continue: "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "   ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
}, changePin$7 = {
  newTitle: "   ",
  oldLabel: "   "
}, checkSDcard$7 = "  microSD ", clickHere$7 = " ", confirm$9 = {
  abortInfo: ",  ",
  abortInfoRedText: "",
  approveInfo: "  4 ,  ",
  approveInfoGreenText: "",
  info: "  BitBox",
  infoWhenPaired: "          BitBox"
}, confirmOnDevice$7 = "    .", device$7 = {
  appUpradeRequired: " BitBox       .      - ."
}, deviceLock$7 = {
  button: "    (2FA)",
  condition1: "   ?",
  condition2: "     ?",
  condition3: "2FA           .     ,     2FA!",
  confirm: "    (2FA)",
  title: "    (2FA)"
}, deviceSettings$7 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "Firmware",
    upToDate: "   - ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: "  ",
      label: "microSD ",
      true: ""
    },
    title: ""
  },
  loading: "    ...",
  pairing: {
    lock: {
      false: "",
      label: "  (2FA)",
      true: ""
    },
    mobile: {
      false: "",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: " "
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
}, deviceTampered$7 = "         BitBox,            . Shift            !", dialog$8 = {
  cancel: "",
  confirm: ""
}, fiat$9 = {
  default: " ",
  setDefault: " {{code}}  ",
  title: ""
}, footer$9 = {
  appVersion: "  :"
}, genericError$7 = " .   ,  .", goal$7 = {
  buttons: {
    create: "   ",
    restore: "    "
  },
  paragraph: "    :",
  step: {
    1: {
      title: "  "
    },
    2: {
      description: "    ",
      title: ""
    },
    "3-create": {
      description: "   ",
      title: ""
    },
    "3-restore": {
      description: " ",
      title: ""
    },
    "4-create": {
      title: " "
    },
    "4-restore": {
      title: " "
    }
  }
}, guide$8 = {
  accountDescription: {
    text: '         ,    .     ""       .',
    title: "     ?"
  },
  accountFiat: {
    text: ".   ,     .           .",
    title: "      ?"
  },
  accountIncomingBalance: {
    text: ' ""     ,        .',
    title: '  ""?'
  },
  accountInfo: {
    xpub: {
      text: "   (Extended Public Key)   ,         .                Electrum  Sentinel.",
      title: "    ?"
    }
  },
  accountRates: {
    text: "        CoinGecko.",
    title: "   ?"
  },
  accountReload: {
    text: "  .       .",
    title: "      ?"
  },
  accountSendDisabled: {
    text: ' ""  ,    -  .',
    title: "     {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    text: ` :   .   -     ,   .
 :      ,      .
:  ,    SegWit         .  SegWit       ,          .     ,           .`,
    title: "   Bitcoin   ?"
  },
  accountTransactionAttributesGeneric: {
    text: `:     "",       ,       "1 ".  ,     ,       .                 3  6 .
ID  :  ,         block explorer.
:           ,  .    ,   "".`,
    title: "     ? "
  },
  accountTransactionConfirmation: {
    text: ",     ,     .",
    title: "   (pending) ?"
  },
  accountTransactionLabel: {
    text: "  ,         .",
    title: "      ?"
  },
  accountTransactionTime: {
    text: "      .",
    title: "   ?"
  },
  appendix: {
    link: "   !",
    text: "  ?"
  },
  backups: {
    check: {
      text: '"  "    ,     ,       .          ,       .     ,     .',
      title: '  "  "?'
    },
    encrypt: {
      text: ",     ,          (seed).",
      title: "    ?"
    },
    howOften: {
      text: `        .             microSD          microSD .
             .           ,    .`,
      title: "     ?"
    },
    whatIsABackup: {
      text: "      (seed),   microSD .         .",
      title: "  ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"  "     ,     ,   ,    .',
      title: '  "  "?'
    },
    encrypt: {
      text: '.  microSD    ,          (seed),     .        ,                "  ".',
      title: "    ?"
    },
    whatIsABackup: {
      text: "      (seed),   microSD .",
      title: "  ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `     (2FA),           . - ,          ;            "" (Accept)     BitBox.        ,     .

 ,          ,     .     , microSD          .     ,    BitBox  ,    .`,
      title: "    (2FA)?"
    },
    disable2FA: {
      text: '    ,     BitBox         . -  ,    microSD           .     "  ".        "   ".     ,   ""     ,       .',
      title: "      (2FA)?"
    },
    ejectBitbox: {
      text: '   BitBox   ;     " " (Eject Media).',
      title: "   BitBox  ?"
    },
    ejectSD: {
      text: "   microSD   BitBox   ,              .",
      title: "    microSD ?"
    },
    hiddenWallet: {
      text: "      ,           .           (.. 'plausible deniability').  ,         ,          .",
      title: '  " "?'
    },
    legacyHiddenWallet: {
      text: "-     (     BitBox            ),      BitBox          .",
      title: "      (legacy)   ?"
    },
    pairing: {
      text: "      iOS  Android,     QR .             .    ,     .",
      title: "       "
    }
  },
  receive: {
    address: {
      text: "      ,       .          .",
      title: "     ?"
    },
    addressChange: {
      text: "   ,      ,      20 ,     .",
      title: "   ?"
    },
    howVerify: {
      text: ` BitBox01:     BitBox       "".          - .
 BitBox02:           /  .`,
      title: "       ?"
    },
    why20: {
      text: "   ,   ,      (seed)        .          ,       .       ,      20  ,     .   ..  (gap limit),       ,       .   20- ,     .",
      title: "  20 ?"
    },
    whyMany: {
      text: "      ,         .      ,   ,     .     20  .                   (seed).",
      title: "   ?"
    },
    whyVerify: {
      text: "             .    -     .  BitBox01          ,           QR .  BitBox02           .",
      title: "    ?"
    }
  },
  send: {
    fee: {
      text: `       ,    .       Bitcoin Core       ,       -  .
: 24  (. 4   Bitcoin, 1   Litecoin)
: 12  (. 2   Bitcoin, 30   Litecoin)
: 6  (. 1   Bitcoin, 15   Litecoin)
: 2  (. 20   Bitcoin, 5   Litecoin)

:       10   Bitcoin (2.5   Litecoin)        .`,
      title: "    ?"
    },
    priority: {
      text: " -  ,  -       .",
      title: "   ?"
    },
    revert: {
      text: `         (..   ),      .      (   ) ,   !
            (     ),       .`,
      title: "      ?"
    },
    whyFee: {
      text: '        .            .  ""    .       ,    ,    ,      .              ,    .',
      title: "    ?"
    }
  },
  "settings-electrum": {
    what: {
      text: "        ,      Shift.",
      title: "  ?"
    }
  },
  settings: {
    servers: {
      text: `     Shift Crypto,      ,           .  ,       CoinGecko.                .
:  Ethereum  ERC20   API-  Etherscan.io`,
      title: "    ?"
    }
  },
  title: "",
  toggle: {
    close: "  ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "               .",
      title: "   ,      ?"
    },
    reset: {
      text: "       15  .          .",
      title: "   ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "      .  ,    .   ,       .",
      title: " BitBox 01    "
    },
    getDevice: {
      link: {
        text: " BitBox "
      },
      text: "   BitBox    :",
      title: "   ?"
    },
    internet: {
      text: "     ,             .",
      title: "     ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "       BitBox        ",
      title: " .  ?"
    },
    useWithoutDevice: {
      text: "         .",
      title: "      ?"
    },
    welcome: {
      text: " ,    ,   Shift Crypto  .    ,    .     ,    .",
      title: "   BitBoxApp!"
    }
  }
}, headerssync$7 = {
  blocksSynced: " {{blocks}} "
}, hiddenWallet$7 = {
  info1HTML: "       ,   <strong></strong>        .      .",
  info2HTML: "            ,       .    ,        <strong></strong>     .",
  passwordLabel: "   ",
  passwordPlaceholder: "     ",
  pinLabel: "    ",
  pinRepeatLabel: "     ()",
  pinRepeatPlaceholder: "      ",
  success: "    .    BitBox,    ."
}, initialize$7 = {
  create: "     ",
  creating: "   ...",
  error: {
    e102: "      4 ."
  },
  info: {
    description1: "    .        BitBox.",
    description2: "   ,   . -   - .",
    description3: "     ,            .",
    subtitle: "       ",
    title: "  "
  },
  input: {
    label: "   ",
    labelRepeat: "    ()",
    placeholderRepeat: "     "
  }
}, invalidFormat$7 = " ", language$8 = {
  title: "  "
}, legacyhiddenwallet$7 = {
  disable: "     Legacy",
  enable: "     Legacy",
  successDisable: " Legacy    .",
  successEnable: "      Legacy.    BitBox      ,        ."
}, loading$7 = "...", notification$7 = {
  newTxs_one: "   {{accountName}}",
  newTxs_other: "{{count}}    {{accountName}}"
}, pairing$7 = {
  aborted: {
    text: "     .",
    title: ""
  },
  button: "   ",
  confirm: "  ,      BitBox   ?   ,       ,    .",
  connectOnly: {
    button: "   ",
    title: '   ,    "    "  .'
  },
  error: {
    text: "   .    .",
    title: ""
  },
  reconnectOnly: {
    button: "    "
  },
  start: {
    hideAppQRCode: "  QR ",
    revealAppQRCode: "  QR ",
    step1: "     ,    QR   Apple App Store  Google Play Store       .",
    step2: "   ,         iOS  Android   'Digital Bitbox 2FA':"
  },
  started: {
    text: "      .",
    title: ""
  },
  success: {
    text: ",    BitBox     !",
    title: ""
  },
  timeout: {
    text: "      2 .  ,        .",
    title: ""
  },
  title: " "
}, password$7 = {
  show: "  {{label}}",
  warning: {
    caps: ": Caps lock ()  ",
    paste: '   ,  "  {{label}}"'
  }
}, random$8 = {
  button: "   ",
  description: " BitBox   {{bits}}-  :"
}, receive$9 = {
  label: " ",
  onlyThisCoin: {
    description: "    ,    .     ,           .",
    warning: " ,     {{coinName}}   ."
  },
  showFull: "       ",
  title: "  {{accountName}}",
  verify: "   ",
  verifyBitBox01: "     ",
  verifyBitBox02: "    BitBox02",
  verifyInstruction: " ,          .",
  warning: {
    secureOutput: '  BitBox   ,         .   "  "   .'
  }
}, reset$7 = {
  description: "      .    !",
  notReset: "   .",
  title: "  ",
  understand: "       ",
  understandBB02: "   "
}, securityInformation$7 = {
  create: {
    description1: "    ,   ,      .",
    description2: "       .",
    description3: "  <strong> </strong>,    BitBox      .",
    description4: "  <strong>    </strong>,    .         - .",
    description5: "       microSD .                    <strong>  </strong>.",
    title: "  "
  },
  restore: {
    description1: "      microSD ,    .",
    description2: "     ,      .",
    description3: "  ,     .      .    ,     .",
    title: "  "
  }
}, seed$7 = {
  agreements: {
    "funds-access": "        ,     .",
    "password-change": "         - .",
    "password-required": "           "
  },
  create: "  ",
  creating: "  ...",
  description: ", :",
  error: {
    e102: "     4 .",
    e200: "       microSD    BitBox ,        ."
  },
  info: {
    button: "    ",
    description1: " microSD   BitBox",
    description2: '        "    "',
    description3: "  microSD                      ,  BitBox     .",
    description4: "        - ,       .",
    title: "   "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "   ()"
  },
  walletName: {
    label: "  "
  }
}, seedRestore$7 = {
  error: {
    e200: "         microSD ."
  },
  info: {
    description1: ' microSD   BitBox    ""',
    description2: '    ""',
    description3: "   ",
    description4: "  ,  ,        .",
    title: "     "
  }
}, send$9 = {
  abort: "  .",
  address: {
    label: "  ",
    placeholder: "  "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  button: "  ",
  coincontrol: {
    address: "",
    outpoint: "  output",
    title: "  output  "
  },
  confirm: {
    "selected-coins": " ",
    title: "  ",
    total: ""
  },
  error: {
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "24  ( 4   Bitcoin, 1   Litecoin)",
      high: "2  ( 20   Bitcoin, 5   Litecoin)",
      low: "12  ( 2   Bitcoin, 30   Litecoin)",
      normal: "6  ( 1   Bitcoin, 15   Litecoin)"
    },
    estimate: "   :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "  ..."
  },
  maximum: "  ",
  scanQR: "  QR ",
  signprogress: {
    description: "    .        {{steps}} .",
    label: ""
  },
  success: "    .",
  title: "  {{accountName}}",
  toggleCoinControl: "   (Coin Control)"
}, settings$8 = {
  electrum: {
    add: "  ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "    {{host}}",
    checking: "...",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: "   {{server}}?",
    reset: "    ",
    resetConfirm: "            ?",
    servers: "",
    step1: "1",
    "step1-text": "  .",
    step2: "2",
    "step2-text": "      ,         .",
    step3: "3",
    "step3-text": "    ",
    step4: "4",
    "step4-text": " .      ,        .",
    "title-btc": "Bitcoin Electrum ",
    "title-ltc": "Litecoin Electrum ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "     (Coin Control)",
    electrum: {
      title: "    "
    },
    setProxyAddress: "   ",
    title: " ",
    useProxy: "  Tor "
  },
  header: {
    home: ""
  },
  restart: " BitBoxApp,        .",
  success: " BitBox     ,        .",
  title: ""
}, setup$7 = "  ", sidebar$8 = {
  device: "  ",
  leave: "",
  settings: ""
}, success$e = {
  create: {
    info1: "      microSD .          .",
    info2: "   ,      BitBox.",
    info3: "      ,           .",
    summary: "   ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "     .",
    title: ""
  }
}, transaction$8 = {
  confirmation: "",
  explorer: "ID  ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: " ",
  gas: "Gas",
  pending: ",  ",
  size: "",
  vsize: " ",
  weight: ""
}, transactions$7 = {
  placeholder: "  ."
}, unknownError$7 = "  : {{errorMessage}}", unlock$7 = {
  description: "  ,     .",
  error: {
    e109_normal: "  .  {{remainingAttempts}},     .",
    e109_touch: "$t(unlock.error.e109_normal)           .",
    e113: "      ,            4 ."
  },
  input: {
    label: " ",
    placeholder: "  ,    "
  },
  unlocking: "..."
}, upgradeFirmware$8 = {
  button: "  firmware",
  description: "     firmware   {{currentVersion}}  {{newVersion}}?",
  label: " BitBox    firmware.",
  locked: "    {{currentVersion}}  {{newVersion}},     .",
  title: "  firmware",
  unlocked: "Bootloader-  .   , :",
  unlocked1: "     BitBox",
  unlocked2: " BitBox    ,    ",
  unlocked3: "   ,   "
}, warning$d = {
  receivePairing: '  BitBox,         .   "  "   .',
  sdcard: " microSD    BitBox ,     .",
  sendPairing: ' BitBox ,           .   "  "   .'
}, welcome$7 = {
  insertBitBox02: " BitBox02,     ,   .",
  insertDevice: " ,    ",
  title: " !"
}, appTranslationsBG = {
  account: account$7,
  accountInfo: accountInfo$7,
  accountSummary: accountSummary$7,
  addAccount: addAccount$8,
  app: app$7,
  backup: backup$7,
  bb02Bootloader: bb02Bootloader$7,
  bitbox: bitbox$7,
  bitbox02Interact: bitbox02Interact$7,
  bitbox02Settings: bitbox02Settings$7,
  bitbox02Wizard: bitbox02Wizard$7,
  blink: blink$7,
  bootloader: bootloader$7,
  button: button$b,
  changePin: changePin$7,
  checkSDcard: checkSDcard$7,
  clickHere: clickHere$7,
  confirm: confirm$9,
  confirmOnDevice: confirmOnDevice$7,
  device: device$7,
  deviceLock: deviceLock$7,
  deviceSettings: deviceSettings$7,
  deviceTampered: deviceTampered$7,
  dialog: dialog$8,
  fiat: fiat$9,
  footer: footer$9,
  genericError: genericError$7,
  goal: goal$7,
  guide: guide$8,
  headerssync: headerssync$7,
  hiddenWallet: hiddenWallet$7,
  initialize: initialize$7,
  invalidFormat: invalidFormat$7,
  language: language$8,
  legacyhiddenwallet: legacyhiddenwallet$7,
  loading: loading$7,
  notification: notification$7,
  pairing: pairing$7,
  password: password$7,
  random: random$8,
  receive: receive$9,
  reset: reset$7,
  securityInformation: securityInformation$7,
  seed: seed$7,
  seedRestore: seedRestore$7,
  send: send$9,
  settings: settings$8,
  setup: setup$7,
  sidebar: sidebar$8,
  success: success$e,
  transaction: transaction$8,
  transactions: transactions$7,
  unknownError: unknownError$7,
  unlock: unlock$7,
  upgradeFirmware: upgradeFirmware$8,
  warning: warning$d,
  welcome: welcome$7
}, account$6 = {
  disconnect: "Balant koptu. Tekrar deneniyor...",
  exportTransactions: "lemleri ndirilenler Klasrne CSV Dosyas Olarak Da Aktar",
  fatalError: "Beklenmeyen bir hata olutu.",
  incoming: "Gelen",
  initializing: "Blockchain'den bilgi alnyor",
  reconnecting: "Balant koptu, yeniden balant kuruluyor..."
}, accountInfo$6 = {
  address: "Adres",
  extendedPublicKey: "Geniletilmi Genel Anahtar",
  label: "Hesap bilgileri",
  title: "Hesap Bilgileri",
  verify: "Bu cihazda dorula"
}, accountSummary$6 = {
  balance: "Bakiye",
  exportSummary: "Hesap zetini ndirilenler Klasrne CSV Dosyas Olarak Da Aktar",
  fiatBalance: "Fiat Bakiyesi",
  name: "Hesap ad",
  noAccount: "Gsterilecek hesap yok.",
  title: "Hesap zeti",
  total: "Toplam"
}, addAccount$7 = {
  title: "Hesap Ekle"
}, app$6 = {
  upgrade: "Bu uygulamann yeni bir srm mevcut! Ltfen  {{current}} 'dan  {{version}}'a ykseltin."
}, backup$6 = {
  check: {
    checking: "Yedekleme kontrol ediliyor...",
    confirmTitle: "Yedeklemeyi Kontrol Et",
    notOK: "Yedekleme czdanla elemiyor.",
    ok: "Yedekleme czdanla eleti.",
    password: {
      label: "ifre yenileme",
      placeholder: "Kurtarma ifresi",
      showLabel: "kurtarma ifresi"
    },
    success: "Baaryla dorulanm yedeklemeler:",
    title: "Yedeklemeyi Kontrol Et"
  },
  create: {
    alreadyExists: "Zaten geerli bir yedeiniz var. Yeniden yedeklemek ister misiniz?",
    fail: "Yedekleme oluturma BAARISIZ!",
    info: "Ltfen dorulama iin mevcut czdannzn kurtarma ifresini girin.",
    name: {
      label: "Yedek Ad",
      placeholder: "Ltfen yedei adlandrn"
    },
    password: {
      label: "Kurtarma ifresi",
      placeholder: "Ltfen kurtarma ifrenizi girin"
    },
    title: "Yedek Olutur",
    verificationFailed: "Kurtarma ifresi mevcut czdanla elemiyor. Yedekleme oluturuldu. Ltfen kurtarma ifrenizi tekrar dorulamak iin 'Yedeklemeyi Kontrol Et'i kullann."
  },
  description: "<strong>czdan yedekleme dosyasn</strong> sein",
  insert: "Yedeklemeleri ynetmek iin ltfen micro SD kart takn.",
  insertButton: "Mikro SD kartm taktm",
  list: "MicroSD kart yedekleriniz",
  noBackups: "Bu microSD kartta yedekleme yok.",
  restore: {
    confirmTitle: "Yedeklemeyi Geri Ykle",
    error: {
      e200: "SD kart bulunamad"
    },
    password: {
      label: "Kurtarma ifresi veya gizli kurtarma ifresi",
      placeholder: "Kurtarma ifresi",
      repeatPlaceholder: "Kurtarma ifresini tekrar girin",
      showLabel: "Kurtarma ifresi"
    },
    restoring: "Yedekleme geri ykleniyor...",
    title: "Geri Ykle",
    understand: "Yanl kurtarma ifresinin farkl bir czdan yaratacan onaylyorum"
  },
  showMnemonic: {
    description: `Czdannzn yedeini oluturan 24 kelimeyi size sunacaz. Onlar kada yazn.

<strong>Bunlar dijital olarak saklamayn veya fotoraflarn ekmeyin.</strong>

<strong>Kelimeleri yksek sesle syleme.</strong>

<strong>Bu yedekleme ifre korumal deildir.</strong>

Sonrasnda, her bir kelimeyi tek tek onaylamanz istenecektir.`,
    title: "BIP39 Anmsatcsn Gster"
  },
  title: "Yedeklemeleri Ynet"
}, bb02Bootloader$6 = {
  abort: "Ykseltmeyi durdur  Beni geri gtr",
  advanced: {
    label: "Gelimi Ayarlar",
    toggleShowFirmwareHash: "Her alta bellenim hash'ini gster"
  },
  flipscreen: "Ekran evir",
  orientation: "Cihaz yanl yne mi yneldi?",
  success: "Ykseltme baarl!  {{rebootSeconds}} saniye ierisinde devam edecek..."
}, bitbox$6 = {
  error: {
    e10000: "Geerli cihaz ifresi yanl.",
    e10001: "Cihazn ifresini deitirme baarsz",
    e102: "ifre en az 4 karakterden olumaldr.",
    e112: "Gizli cihaz ifresi, ana cihaz ifresi ile ayn olamaz."
  }
}, bitbox02Interact$6 = {
  followInstructions: "Ltfen BitBox02 zerindeki talimatlar takip edin."
}, bitbox02Settings$6 = {
  deviceName: {
    current: "Geerli cihaz ad",
    input: "BitBox02 Ad",
    title: "BitBox02 cihaznz isimlendirin"
  }
}, bitbox02Wizard$6 = {
  attestationFailed: "Cihaz onay baarsz oldu. BitBox'nz sahte veya tehlikede olabilir. BitBox02 zerindeki paralar kaybolma riski altnda olabilir. Ltfen acilen support@bitbox.swiss ile iletiime gein.",
  backup: {
    point1: "MicroSD karttan bir yedek sein",
    point2: "Cihaznz iin bir ifre belirleyin",
    restoreText: "Tamam, hadi bir yedei geri ykleyelim!",
    text1: "Harika, BitBox02 ifreniz ayarland ve czdan oluturuldu. imdi ilk yedeinizi oluturma zaman. Ltfen microSD kartnzn BitBox02 cihaznza takl olduundan emin olun ve devam edin.",
    text2: "Bir yedekleme oluturmak iin ltfen cihaznzdaki ekrandaki talimatlar izleyin.",
    text3: "Yedeklemeniz oluturulduktan sonra, ltfen microSD kart karn ve <strong>gvenli bir yerde</strong> saklayn. MicroSD kartn ierii ifre korumal deildir. Bu nedenle asla baka bir cihaza yerletirmeyin.",
    userConfirmation1: "Yedeklememi gvenli bir yerde saklamalym.",
    userConfirmation2: "Yedeklerim ifre korumal deil. Buna eriimi olan herkes czdanma eriebilir.",
    userConfirmation3: "BitBox02 yazlmm kaybedersem veya zarar verirsem, param kurtarmann tek yolu yedeklememden geri yklemektir.",
    userConfirmation4: "Hem yedeimi hem de BitBox02mi kaybedersem veya zarar verirsem fonlarm kaybolacak."
  },
  create: {
    button: "Cihaz adlandr ve devam et",
    info: "te BitBox'nz ayarlamak iin atmanz gereken temel admlar: ",
    inputTitle: "Czdan ad",
    point1: "Cihaznz adlandrn",
    point2: "Cihaznz iin bir ifre belirleyin",
    point3: "Yedekleme olutur",
    text: "Tamam, hadi yeni bir czdan yaratalm!"
  },
  initialize: {
    passwordText: "imdi cihaznz iin bir ifre ayarlayalm. Bir ifre girmek ve bir ifre semek iin BitBox'nzdaki kontrolleri kullann.",
    passwordTitle: "BitBox'nz iin bir ifre belirleyin",
    text: "BitBox02 cihaznz baaryla eletirildi! imdi cihaznz balatalm. Yeni bir czdan oluturmay veya czdan mevcut bir yedekten geri yklemeyi seerek balayn. <strong>Ltfen BitBox02 cihaznza takl bir microSD kartn olduundan emin olun.</strong>",
    tip: "Balamadan nce, ilemlere gvenli bir ortamda devam etmeniz iddetle tavsiye edilir.",
    title: "BitBox'nz balatn"
  },
  insertSDCard: "<strong>Ltfen BitBox02 cihaznza takl bir microSD kartn olduundan emin olun.</strong>",
  pairing: {
    failed: "Onaylanmam eletirme. Ltfen BitBox02'nizi deitirin.",
    paired: "Cihaznzda kodun eletiini onayladnz. Bu doruysa, aadaki dmeye tklayarak devam edebilirsiniz.",
    title: "Eletirme Kodunu Dorulayn",
    unpaired: "Yeni bir BitBox02 tespit edildi. Ltfen aadaki kodun cihaznzda gsterilenlerle eletiini dorulayn. Kod eleirse, BitBox02 zerindeki onay iaretinin altndaki simgeye dokunun ve devam etmek iin aadaki dmeye tklayn."
  },
  restoreFromMnemonic: {
    failed: "BIP39 anmsatcsndan geri ykleme baarsz oldu, ltfen tekrar deneyin."
  },
  stepBackup: {
    beforeProceed: "Devam etmeden nce, ltfen u nemli gvenlik hususlarn okuyun:",
    createBackup: "imdi microSD kartnzda bir yedekleme oluturacaksnz."
  },
  stepBackupSuccess: {
    fundsSafe: "Fonlarnz gvende tutmak iin ltfen aadakileri unutmayn:",
    title: "Yedekleme Geri Yklendi!"
  },
  stepConnected: {
    unlock: "Kilidi amak iin BitBox02 ifresini girin."
  },
  stepCreate: {
    nameLabel: "BitBox02 ad",
    namePlaceholder: "Benim BitBox02 czdanm",
    title: "BitBox02 adn sein",
    toastMicroSD: "Ltfen microSD kartnzn BitBox02 cihaznza takl olduundan emin olun."
  },
  stepCreateSuccess: {
    removeMicroSD: "Ltfen microSD kart BitBox02 cihaznzdan karn ve gvenli bir yerde saklayn.",
    success: "Yedeklemenizi baaryla oluturdunuz."
  },
  stepPassword: {
    title: "BitBox02 ifresini ayarla",
    useControls: "Bir ifre belirlemek iin BitBox02 zerindeki kontrolleri kullann."
  },
  stepUninitialized: {
    create: "BitBox02 cihazm yeniden kurmak istiyorum.",
    restore: "Czdanm bir yedekten geri yklemek istiyorum.",
    restoreMicroSD: "MicroSD karttan geri ykle",
    restoreMnemonic: "Anmsatcdan geri ykle",
    title: "BitBox02 cihaznz kurun"
  },
  success: {
    text: `Yaasn! BitBox02'niz artk kullanma hazr.

BitBox Uygulamas'nn nasl kullanlaca hakknda daha fazla bilgi iin, ltfen sa st kedeki soru iaretini tklayarak uygulama ii klavuzunu kullann.`,
    title: "Balamaya hazrsn!"
  }
}, blink$6 = {
  button: "Gz ard et"
}, bootloader$6 = {
  button: "Donanm yazlmn imdi ykselt",
  progress: "Ykseltme: {{progress}}%",
  success: "Ykseltme baarl! Ltfen cihaz tekrar takn. Bu kez, dmeye dokunmayn."
}, button$a = {
  abort: "ptal Et",
  back: "Geri",
  changepin: "Cihaz ifresini Deitir",
  check: "Yedeklemeyi Kontrol Et",
  continue: "Devam et",
  copy: "Kopyala",
  create: "Olutur",
  download: "ndir",
  hiddenwallet: "Gizli Czdan Olutur",
  next: "Sonraki",
  ok: "Tamam",
  previous: "nceki",
  receive: "Alnan",
  restore: "Geri Ykle",
  select: "Se",
  send: "Gnder",
  unlock: "Kilidini a",
  update: "Gncelletirme",
  upgrade: "Ykselt"
}, changePin$6 = {
  newTitle: "Yeni cihazn ifresi",
  oldLabel: "Mevcut cihazn ifresi"
}, checkSDcard$6 = "Mikro SD kart kontrol ediliyor", clickHere$6 = "Buraya tklayn.", confirm$8 = {
  abortInfo: "Dokunun",
  abortInfoRedText: "ptal et",
  approveInfo: "u tua 4 saniye basl tut ",
  approveInfoGreenText: "dorula",
  info: "BitBox'nzda",
  infoWhenPaired: "nce telefonla sonrasnda Bitbox'la eletirin"
}, confirmOnDevice$6 = "Ltfen cihaznzda onaylayn.", device$6 = {
  appUpradeRequired: "BitBox'nz bu masast uygulamas ile uyumlu deil. Ltfen en son srm indirin ve ykleyin."
}, deviceLock$6 = {
  button: "Two Factor Authorization (2FA) Etkinletirme",
  condition1: "Bir yedein var m?",
  condition2: "Mobil uygulama dorulama alyor mu?",
  condition3: "2FA yedekleri ve mobil uygulama eletirmesini DEVRE DII brakr. 2FA'dan kmak iin cihazn SIFIRLANMASI olmas gerekir!",
  confirm: "Two Factor Authorization (2FA) Etkinletirme",
  title: "Two Factor Authorization (2FA) Etkinletirme"
}, deviceSettings$6 = {
  firmware: {
    newVersion: {
      label: "Mevcut srm"
    },
    title: "Donanm yazlm",
    upToDate: "Cihaznz gncel",
    version: {
      label: "Versiyon"
    }
  },
  hardware: {
    sdcard: {
      false: "Takl deil",
      label: "Mikro SD kart",
      true: "Takl"
    },
    title: "Donanm"
  },
  loading: "Cihaz bilgisi alnyor",
  pairing: {
    lock: {
      false: "Devre d",
      label: "Two Factor Authorization (2FA)",
      true: "Etkinletir"
    },
    mobile: {
      false: "Kapal",
      label: "Mobil Uygulama",
      true: "A"
    },
    status: {
      false: "Eletirilmemi",
      label: "Durum",
      true: "Eletirilmi"
    },
    title: "Eletirme"
  },
  secrets: {
    manageBackups: "Yedekleri Ynet",
    title: "Secrets"
  }
}, deviceTampered$6 = "BitBox'nza kurtarma ifresi mi saland? yleyse, kurulum ilemini durdurun ve hemen destee bavurun. Ekibimiz asla size hazr bir czdan vermez veya ifre nerileri yapmaz.", dialog$7 = {
  cancel: "ptal Et",
  confirm: "Dorula"
}, fiat$8 = {
  default: "Varsaylan",
  setDefault: "{{code}} varsaylan olarak ayarla",
  title: "Para birimleri"
}, footer$8 = {
  appVersion: "Uygulama Srm:"
}, genericError$6 = "Bir hata olutu. Herhangi bir sorunla karlarsanz, ltfen uygulamay yeniden balatn.", goal$6 = {
  buttons: {
    create: "Yeni bir czdan olutur",
    restore: "Czdan yedekten geri ykle"
  },
  paragraph: "Ltfen aadaki seeneklerden birini sein:",
  step: {
    1: {
      title: "Gvenlik bilgileri"
    },
    2: {
      description: "Bir cihaz ifresi belirleyin",
      title: "cihaz"
    },
    "3-create": {
      description: "Yeni bir czdan olutur",
      title: "Czdan"
    },
    "3-restore": {
      description: "bir yedekten",
      title: "Geri Ykle"
    },
    "4-create": {
      title: "zet"
    },
    "4-restore": {
      title: "zet"
    }
  }
}, guide$7 = {
  accountDescription: {
    text: 'Hesabnza genel bak, mevcut bakiyenizi, gelen ve giden ilemlerinizi gsterir. " Ayarlar" sekmesindeki klavuzumuz her hesap tr hakknda daha fazla bilgi ierir. ',
    title: "Bu sayfa bana ne gsteriyor?"
  },
  accountFiat: {
    text: "Evet. Fiat para birimlerine dntrmek iin herhangi bir ticker'a tklayn. Ayarlardan Fiat para birimlerini deitirebilirsiniz.",
    title: "Dier dnm oranlarn grntleyebilir miyim?"
  },
  accountIncomingBalance: {
    text: "Yatrlanlar; size aktarlan ancak henz a tarafndan onaylanmayan tutarlar gsterir.",
    title: "Yatrlanlar ne demek?"
  },
  accountInfo: {
    xpub: {
      text: `Geniletilmi bir genel anahtar, bir hesabn tm alc adreslerinin tretildii bir kk anahtardr.
Burada Electrum veya Sentinel gibi yalnzca izlemek iin olan czdanlarla ileri dzeyde kullanm ve birlikte alabilirlik iin salanmtr.`,
      title: "Geniletilmi genel anahtar nedir?"
    }
  },
  accountRates: {
    text: "Kripto para kurlarn her dakika CoinGecko'dan gncelliyoruz.",
    title: "Hangi dviz kurlar uygulanyor?"
  },
  accountReload: {
    text: "Buna ihtiyacnz yok. lem bilgileriniz otomatik olarak gncellenir.",
    title: "lem gemiini yeniden ykleyebilir miyim?"
  },
  accountSendDisabled: {
    text: 'Bakiyeniz sfrdan fazla olduunda "Gnder" butonu etkinleir.',
    title: "Neden hibir ey gnderemiyorum {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: `Onaylar: lk ilem yaynnz, bir madenci bir bloa dahil edinceye kadar onaylanmaz, ardndan bir onay verilir. Ada yaynlanan her blok, ileminize baka bir onay ekler. Genel olarak, tccarlar ve dier a aktrler  ila alt onay aldnda ilemleri gerekletirir.
lem Kimlii: Bir blok gezgininde bir ilem aramanza izin veren benzersiz bir kimlik numaras.
cret: Madencilere, ilemleri onaylamalarn tevik etmek iin ilem creti denir. Daha fazla bilgi iin, gnder dmesine tklayn.`,
    title: "lem detaylarndaki bilgiler neler?"
  },
  accountTransactionConfirmation: {
    text: "Ada yaynlanan ancak henz onaylanmayan bir ilem.",
    title: "Beklemedeki ilem nedir?"
  },
  accountTransactionLabel: {
    text: "Kripto paralarnz aldnz veya gnderdiiniz adres.",
    title: "Her ilemde grntlenen adres hangisi?"
  },
  accountTransactionTime: {
    text: "Blockchain ilem onay sresi.",
    title: "Ne zaman grntlenir?"
  },
  appendix: {
    link: "Bizimle iletiime gein!",
    text: "Baka bir soru?"
  },
  backups: {
    check: {
      text: "'Yedeklemeyi kontrol et', geerli czdannza karlk gelen alan bir yedeklemeniz olduunu dorulamanza olanak tanr. Ayrca hala doru kurtarma ifresine sahip olduunuzu dorulamak iin kullanlabilir. Ana kurtarma ifrenizi veya gizli kurtarma ifrenizi kontrol edebilirsiniz.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: "Hayr, ancak kurtarma ifrenizin czdanda depolanan sedden retilmesi gerekir.",
      title: "Yedeklemeyi ifreleyebilir miyim?"
    },
    howOften: {
      text: `Yeni bir czdan oluturulduunda, yedekleme otomatik olarak oluturulur. Yalnzca microSD kartnz kaybolursa veya hasar grrse veya yedek olarak birden fazla microSD kart kullanmak istiyorsanz, yeni bir yedekleme yapmanz gerekir.
lem faaliyetinden sonra yeni yedeklemeler oluturmanza gerek yoktur. Tm ilem verileriniz, sizin iin otomatik olarak oluturulan tek bir yedeklemeyle yeniden oluturulabilir.`,
      title: "Ne sklkla yedekleme yapmam gerekir?"
    },
    whatIsABackup: {
      text: "Mikro SD kartnzdaki seedin bir kopyas. Seed, kurtarma ifrenizle birlikte czdannz oluturur.",
      title: "Yedek nedir?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Yedeklemeyi kontrol et' geerli czdannza karlk gelen alan bir yedeklemeniz olduunu dorulamanz salar.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: `Hayr. Seedler ifrelenmemi bir ekilde tutulduundan MicroSD kartnz gvende tutun. Seed'i ifreyle korumak istiyorsanz, "Cihaz ynet" altndaki gelimi ayarlardan istee bal bir ifre etkinletirebilirsiniz.`,
      title: "Yedeklemeyi ifreleyebilir miyim?"
    },
    whatIsABackup: {
      text: "Bir microSD karttaki seed'in bir kopyas.",
      title: "Yedek nedir?"
    }
  },
  bitbox: {
    "2FA": {
      text: `2FA etkinletirildiinde, para harcamak iin tm ilemlerin eletirilmi cep telefonunda onaylanmas gerekir. Bylece iifreli bir tek kullanmlk numara mobil uygulamaya gnderilir, orada ifresi zlr ve Kabul Et dmesine basldnda BitBox'a geri dndrlr. Cihazla bu iletiim, cep telefonu ile eletirme srasnda kurulan bu masast uygulamas arasndaki kanal zerinden yaplr.

2FA'y etkinletirmeden nce czdannz yedeklediinizden ve mobil uygulamay eletirdiinizden emin olun. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.`,
      title: "ki faktrl dorulama (2FA) nasl alr?"
    },
    disable2FA: {
      text: "2FA'y devre d brakmak iin, BitBox'nz sfrlamanz ve ardndan czdan yedekten geri yklemeniz gerekir. Yedeklemeye sahip microSD kartn hala olduundan ve kurtarma ifresini hala hatrladnzdan emin olun. Ardndan 'Cihaz sfrla' tuuna basn. Yeni bir cihaz ifresi belirleyin ve 'Veya yedei geri ykle'yi sein. Czdanda oluturduunuz yedeklemeyi sein, 'Geri Ykle'yi tklayn ve czdan olutururken kullandnz kurtarma ifresini girin.",
      title: "ki faktrl dorulamay (2FA) nasl devre d brakabilirim?"
    },
    ejectBitbox: {
      text: "",
      title: "BitBox' nasl karabilirim?"
    },
    ejectSD: {
      text: "MicroSD kart BitBox'tan istediiniz zaman yedekleme oluturma veya geri ykleme ilemi yapmadnz srece kaldrabilirsiniz.",
      title: "MicroSD kart nasl karabilirim?"
    },
    hiddenWallet: {
      text: "Ayn cihazda, makul bir reddedilebilirlik iin kullanabileceiniz farkl bir cihaz ifresi ve kurtarma ifresiyle korunan ikinci bir czdandr. Ayn yedek send hem normal, hem de gizli czdannz iin kullanlr, bu nedenle ek bir yedekleme gerekmez.",
      title: "Gizli czdan nedir?"
    },
    legacyHiddenWallet: {
      text: "nce aadaki dmeyi tklayn (BitBox ana cihaz ifresiyle almsa ve 2FA devre d braklmsa kullanlabilir), ardndan Bitbox'nz yeniden takp kilidini gizli cihaz ifrenizle an.",
      title: "Eski gizli czdanma nasl eriirim?"
    },
    pairing: {
      text: "Mobil uygulamamz iOS veya Android iin indirdikten sonra, mobil uygulama ile bu uygulama arasnda gvenli bir kanal kuran grntlenen QR kodunu tararsnz. Tarandktan sonra mobil uygulamadaki talimatlar izleyin.",
      title: "Telefonumla gvenli bir ekilde nasl eletirilir"
    }
  },
  receive: {
    address: {
      text: "Size bakalarnn kripto para gndermeleri iin adresinizi verebilirsiniz. Sadece doru adresi gnderdiinizden emin olun.",
      title: "Bir adres ile ne yapabilirim?"
    },
    addressChange: {
      text: "lem yaptnz anda, otomatik olarak listeye yeni bir adres eklenir, bylece her zaman kripto para almayan 20 adres bulunur.",
      title: "Adresler ne zaman deiir?"
    },
    howVerify: {
      text: `BitBox01 iin soldaki kenar ubuundaki BitBox simgesine tklayn ve Eletirme blmne bakn. Klavuz gncellenir ve oradaki talimatlar izlemeye devam edebilirsiniz.
BitBox02 iin, gnderme/alma ilemi srasnda adresleri dorudan cihaz zerinde dorulayabilirsiniz.`,
      title: "Bir adresi gvenli bir ekilde nasl dorulayabilirim?"
    },
    why20: {
      text: "",
      title: "Neden sadece 20 adres?"
    },
    whyMany: {
      text: "Gizlilii ve gvenlii salamak iin, ayn adresi asla iki kez vermeyin. Bir adres kullandysanz, yeni bir adres iin sa oka tklayn. Bir seferde 20 adede kadar adres oluturabilirsiniz. Fatura numaralar gibi adresleri dnn. Tm adresler, tek yedekleme senedinden tretilir.",
      title: "Neden bu kadar ok adres var?"
    },
    whyVerify: {
      text: "Orijinal adresleri oluturmak ve grntlemek iin bilgisayarnza gvenmemelisiniz. Byk bir saldr, donanm czdannzn daha savunmasz kalmasn salar. BitBox01'in gvenli bir ekilde dorulama dmesi, adresi QR kodunu da tarayabileceiniz ve dorulayabileceiniz eletirilmi bir cep telefonuna gnderir. BitBox02 iin, adres dorudan BitBox02 ekrannda dorulanabilir.",
      title: "Neden adresi gvenli bir ekilde dorulamalym?"
    }
  },
  send: {
    fee: {
      text: `cret, ilem miktarna deil ilem miktarna gre belirlenir. cret hedefleri, setiiniz her a ncelii iin Bitcoin Core'un cret tahmin algoritmas ile hesaplanr. Aadaki hedeften farkl bir deere sahiplerse gsterilirler.
Ekonomi: 24 blok (Bitcoin iin yaklak 4 saat, Litecoin iin 1 saat)
Dk: 12 blok (Bitcoin iin yaklak 2 saat, Litecoin iin 30 dakika)
Normal: 6 blok (Bitcoin iin yaklak 1 saat, Litecoin iin 15 dakika)
Yksek: 2 blok (Bitcoin iin yaklak 20 dakika, Litecoin iin 5 dakika)
(Bir blok Bitcoin iin ortalama on dakika srer (Litecoin'de 2.5 dakika) ve a yk yukardaki periyotlarda nemli lde deiebilir.)`,
      title: "cret nasl belirlenir?"
    },
    priority: {
      text: "demek istediiniz cret ne kadar yksekse, ileminiz genellikle a tarafndan daha erken onaylanr.",
      title: "A ncelii nedir?"
    },
    revert: {
      text: `Bir ilem imzalanp gnderildikten sonra (yani aa yaynlanr), artk geri alnamaz. mzalamadan nce ilemleri (cret dahil) doru bir ekilde dorulayn!
Alcy tanyorsanz ve ayn tutar (eksi ilem cretlerini) size geri gndermeye istekliyse, onlara yeni bir alc adresi gnderebilirsiniz.`,
      title: "Bir ilemi geri alabilir miyim?"
    },
    whyFee: {
      text: `lemler madenci tarafndan onaylanmak iin yaryor. Madenciler cretlerine gre Blockchain'e dahil edilecek ilemleri seiyorlar.
Madenciler ilem tarihine oy veriyor. lemleri onaylayacak gvenli bir nc taraf olmad iin (Blockchain'lerin hepsinde), madenciler bilgisayar gc gibi pahal bir kaynaktan fedakarlk yaparak ilemleri oyluyorlar. lerinin bir dl olarak, yeni oluturulan paralar ve ierdikleri tm ilemlerin cretini talep edebilirler.`,
      title: "Neden a creti var?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift sunucularn kullanmak yerine czdannza kendi tam node'larnzla g vermek mmkndr.",
      title: "Bu nedir?"
    }
  },
  settings: {
    servers: {
      text: `Bu uygulama, gncellemeleri kontrol etmek, ilemleri yklemek ve eletirilmi mobil uygulamalara bilgi gndermek iin Shift Crypto sunucular ile iletiim kurar.
Bu uygulama ayn zamanda CoinGecko'den en son dviz kurlarn alyor. Tm dnmler yerel olarak hesaplanr, bu ileminizin miktar ile ilgili hibir veri iletilmedii anlamna gelir.
Not: Ethereum ve ERC20 Tokens iin Etherscan.io API'lerini kullanyoruz.`,
      title: "Bu uygulama hangi sunucularla konuuyor?"
    }
  },
  title: "Klavuz",
  toggle: {
    close: "Klavuzu kapat",
    open: "Klavuz"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Kurtarma parolasn kullanarak cihaz sfrlamanz ve czdan bir yedekten geri yklemeniz gerekir.",
      title: "Cihaz ifresini unuttuumda ne yapmalym?"
    },
    reset: {
      text: "15 kez yanl cihaz ifresi girin. Son birka deneme, cihaza uzun sre dokunmay gerektirir.",
      title: "Cihaz nasl sfrlarm?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Cihaz yerletirildiinde bir kez yanp snmelidir. Etrafna doru yerletirildiinden emin olun. Eer sorun yayorsanz, ltfen aadaki balantdan bize ulan.",
      title: "BitBox01 tannmyor"
    },
    getDevice: {
      link: {
        text: "Bir BitBox siparii verin"
      },
      text: "Online maazamzda bir BitBox satn alabilirsiniz:",
      title: "Nasl bir cihaz nasl alabilirim?"
    },
    internet: {
      text: "Evet, czdan senkronize etmek, ilemleri gndermek ve en son kurlar almak iin bir internet balants gerekir.",
      title: "Bu uygulama internet balants gerektiriyor mu?"
    },
    lostDevice: {
      link: {
        text: "Yedekleme merkezi"
      },
      text: "Hesaplarnz yeni bir BitBox'la veya yedekleme merkezimizde kurtarabilirsiniz.",
      title: "Cihazm kaybettim. imdi ne olacak?"
    },
    useWithoutDevice: {
      text: "Ne yazk ki, u anda bu henz mmkn deil.",
      title: "Bir cihaz olmadan uygulamay kullanabilir miyim?"
    },
    welcome: {
      text: "Shift Crypto tarafndan svire'de retilen bu uygulamay kullandnz iin teekkr ederiz. Paylamanz gereken herhangi bir geri bildirimi takdir ediyoruz. Ltfen alttaki balanty kullanarak geri bildirimde bulunun.",
      title: "BitBoxApp'a Hogeldiniz!"
    }
  }
}, headerssync$6 = {
  blocksSynced: "{{blocks}} blok senkronize edildi"
}, hiddenWallet$6 = {
  info1HTML: "",
  info2HTML: "Aadaki gizli czdannzla ilikilendirmek istediiniz cihaz ifresini ve kurtarma ifresini tanmlayn. Cihaz ifresi ve kurtarma ifresi <strong>farkl</strong> birincil czdannz iin tanmladnzdan emin olun",
  passwordLabel: "Gizli kurtarma ifresi",
  passwordPlaceholder: "Ltfen gizli kurtarma ifresini onaylayn",
  pinLabel: "Gizli cihaz ifresi",
  pinRepeatLabel: "Gizli cihaz ifresini tekrarla",
  pinRepeatPlaceholder: "Ltfen gizli cihaz ifresini onayla",
  success: "Gizli czdan baaryla oluturuldu. Kilidini amak iin BitBox'nz deitirin."
}, initialize$6 = {
  create: "Cihaz ifresini ayarla",
  creating: "Cihaz ifresini ayarla",
  error: {
    e102: "Cihaz ifresi en az 4 karakterden olumaldr."
  },
  info: {
    description1: "Cihaz ifrenizi sein. Bu, BitBox'nzn kilidini amak iin kullanlacaktr.",
    description2: "Saylar, harfleri ve sembolleri kullanabilirsiniz. Daha uzun ifreler daha yksek gvenlik sunar.",
    description3: "Cihaz ifresini kaybederseniz, cihaznz sfrlamanz ve czdan yedeklemenizi geri yklemeniz gerekir.",
    subtitle: "imdi cihaz ifrenizi ayarlayacaksnz",
    title: "Cihaznz balatlyor"
  },
  input: {
    label: "Cihaz parolas",
    labelRepeat: "Cihaz ifresini tekrarla",
    placeholderRepeat: "Ltfen cihaz ifresini dorulayn"
  }
}, invalidFormat$6 = "Geersiz format", language$7 = {
  title: "Dil Sein"
}, legacyhiddenwallet$6 = {
  disable: "Eski gizli czdan devre d brak",
  enable: "Eski gizli czdan etkinletir",
  successDisable: "Eski gizli czdan baaryla devre d braktnz.",
  successEnable: "Eski gizli czdan baaryla etkinletirdi. Eski gizli czdannza erimek iin BitBox'nz deitirin ve gizli cihaz ifresini girin."
}, loading$6 = "Ykleniyor", notification$6 = {
  newTxs_one: "{{accountName}}'da yeni ilem",
  newTxs_other: "{{count}} Yeni ilem: {{accountName}}"
}, pairing$6 = {
  aborted: {
    text: "Eletirme ilemi mobil uygulamadan kaldrld.",
    title: "Kaldrld"
  },
  button: "Mobil Uygulamayla Eletir",
  confirm: "BitBox'nz eletirmek istediinizden emin misiniz? Sonradan, cep telefonunun bir ilem gerekletirmesi gerektiini unutmayn.",
  connectOnly: {
    button: "Mobil Uygulamay Bala",
    title: "'Yeni masast uygulamasna balan' esini seerek mobil uygulamamz ile tarayn"
  },
  error: {
    text: "Bir eyler yanl gitti. Ltfen tekrar bala.",
    title: "Hata"
  },
  reconnectOnly: {
    button: "Mobil Uygulamay Yeniden Bala"
  },
  start: {
    hideAppQRCode: "QR Kodunu Gizle",
    revealAppQRCode: "QR Kodunu Gster",
    step1: "Mobil uygulamanz yoksa, sahip olduunuz telefona bal olarak Apple App Store veya Google Play Store iin QR kodunu tarayabilirsiniz.",
    step2: "OS ve Android uygulama maazalarnda 'Digital Bitbox 2FA' ad altnda bulabileceiniz mobil uygulamamz ile tarayn:"
  },
  started: {
    text: "imdi mobil uygulamadaki talimatlar izleyin.",
    title: "Harika"
  },
  success: {
    text: "Tebrikler, BitBox'nz mobil uygulamayla baaryla eletirdiniz!",
    title: "Baarl"
  },
  timeout: {
    text: "Eletirme iki dakikann ardndan zaman amna urad. Mobil uygulamay hala eletirmek istiyorsanz tekrar balayn.",
    title: "Zaman am"
  },
  title: "Mobil Eletirme"
}, password$6 = {
  show: "Gster {{label}}",
  warning: {
    caps: "UYARI: Byk harf kilidi () aktif",
    paste: 'Metni yaptrmak iin "GSTER" butonunu etkinletirin {{label}}"'
  }
}, random$7 = {
  button: "Rastgele Say ret",
  description: "BitBox'nz aadaki {{bits}}-bit random saylar retti:"
}, receive$8 = {
  label: "Sizin adresiniz",
  onlyThisCoin: {
    description: "Baka token'lar almak iin, onlar ayarlardan etkinletirin. Dier token'lar yatrrsanz, eriilebilir olmayabilir.",
    warning: "Sadece bu adresle  {{coinName}} almak istediinize emin olun"
  },
  showFull: "Cihazdaki tam adresi gster ve dorula",
  title: "{{accountName}} Al",
  verify: "Adresi gvenli bir ekilde dorulayn",
  verifyBitBox01: "Mobil uygulamadaki adresi dorula",
  verifyBitBox02: "BitBox02'deki adresi dorulayn",
  verifyInstruction: "Ltfen aadaki adresin cihaznzda grntlenen adresiyle eletiini dorulayn.",
  warning: {
    secureOutput: "Gvenli adres dorulamasn etkinletirmek iin ltfen BitBox'nz mobil cihaznzla eletirin ve kenar ubuundaki 'Cihaz Ynet' seeneine tklayn."
  }
}, reset$6 = {
  description: "Cihazdaki tm veriler silinecek. Buna zel Anahtarnz da dahil!",
  notReset: "Cihaz SIFIRLAMA.",
  title: "Cihaz sfrla",
  understand: "Bir yedeim var ve kurtarma ifremi biliyorum",
  understandBB02: "Geerli bir yedeim var"
}, securityInformation$6 = {
  create: {
    description1: "Cihaznz kurmadan nce bunu gvenli bir ortamda yapmanz nerilir.",
    description2: "Sizden iki ifre oluturmanz istenecektir.",
    description3: "lki <strong>cihaz parolas</strong>. Bu ifre BitBox cihaznzn kilidini aar ve daha sonra deitirilebilir.",
    description4: "kincisi czdannzn kilidini aan <strong>kurtarma ifresi</strong>. Bu ifre daha sonra deitirilemez.",
    description5: "Oluturduunuz czdan, salanan mikro SD karttaki bir dosyaya yedeklenir. Bu, acil durumda <strong>kurtarma ifrenizi</strong> kullanarak fonlarnza ulamanz salar.",
    title: "Gvenlik Uyars"
  },
  restore: {
    description1: "Yedeklemenizi saklamak iin kullandnz mikro SD kart takmanz istenecektir.",
    description2: "Cihaznz geri yklemek iin kurtarma ifrenizin olmas gerekir. ",
    description3: "Ltfen kurtarma ifresini girerken dikkatli olun. Girdiiniz herhangi bir ifre geerli bir czdan yaratacaktr. Yanl ifre girerseniz, beklemediiniz bir czdan bakiyesi gsterilebilir.",
    title: "Gvenlik Uyars"
  }
}, seed$6 = {
  agreements: {
    "funds-access": "Kurtarma ifremi unutursam parama ulaamayacam",
    "password-change": "Kurtarma ifresini daha sonra deitiremem",
    "password-required": "Bir czdan bir yedekten geri yklemek kurtarma ifresi gerektirir."
  },
  create: "Czdan Olutur",
  creating: "Czdan oluturma",
  description: "Bunu kabul ediyorum:",
  error: {
    e102: "ifre en az 4 karakterden olumaldr.",
    e200: "Czdan oluturmak iin BitBox'nza bir mikro SD kart takmanz gerekir, bylece yedekleme otomatik olarak oluturulabilir."
  },
  info: {
    button: "Kurtarma ifresini imdi ayarla",
    description1: "Mikro SD kart BitBox'a takn",
    description2: "Czdan iin bir kurtarma ifresi ayarlayn ve imdi kurtarma ifresini ayarla seeneini tklayn.",
    description3: "Micro SD karta yedekleme ve kurtarma ifreniz, BitBox cihazn kaybolmas veya alnmas durumunda paranz kurtarmak iin tek yntemdir.",
    description4: "Paranz aktarmadan kurtarma ifrenizi  deitiremezsiniz.",
    title: "Yeni bir czdan olutur"
  },
  password: {
    label: "Kurtarma ifresi",
    repeatPlaceholder: "Kurtarma ifresini tekrarla"
  },
  walletName: {
    label: "Czdan ad"
  }
}, seedRestore$6 = {
  error: {
    e200: "Bir czdan yedekten geri yklemek iin mikro SD kart gerekir."
  },
  info: {
    description1: `Mikro SD kart BitBox'a takn ve "Devam Et" esine tklayn`,
    description2: 'Bir yedekleme sein ve "Geri Ykle" esini sein',
    description3: "Kurtarma ifresini girin",
    description4: "Yanl bir ifrenin farkl bir czdan yaratacan kabul ettiinizi onaylamanz gerekir.",
    title: "Bir czdan bir yedekten geri ykleme"
  }
}, send$8 = {
  abort: "lem iptal edildi.",
  address: {
    label: "Alc adresi",
    placeholder: "Adresi girin"
  },
  amount: {
    label: "Miktar",
    placeholder: "Miktar girin"
  },
  button: "mzala ve Gnder",
  coincontrol: {
    address: "Adres",
    outpoint: "kt",
    title: "ktdan Gnder"
  },
  confirm: {
    "selected-coins": "Seilmi Kripto Paralar",
    title: "lemi Onayla",
    total: "Toplam"
  },
  error: {
    insufficientFunds: "yetersiz bakiye",
    invalidAddress: "geersiz adres",
    invalidAmount: "geersiz miktar",
    invalidData: "geersiz veri"
  },
  fee: {
    customPlaceholder: "Miktar girin",
    label: "A creti",
    placeholder: "Kullanlabilir deil"
  },
  feeTarget: {
    description: {
      economy: "24 blok (Bitcoin iin yaklak 4 saat, Litecoin iin 1 saat)",
      high: "2 blok (Bitcoin iin yaklak 20 dakika, Litecoin iin 5 dakika)",
      low: "12 blok (Bitcoin iin yaklak 2 saat, Litecoin iin 30 dakika)",
      normal: "6 blok (Bitcoin iin yaklak 1 saat, Litecoin iin 15 dakika)"
    },
    estimate: "Tahmini bekleme sresi:",
    label: {
      economy: "ekonomi",
      high: "yksek",
      low: "dk",
      normal: "normal"
    },
    placeholder: "Hesaplanan tahmini cret"
  },
  maximum: "Hepsini gnder",
  scanQR: "QR Kodunu Tara",
  signprogress: {
    description: "Bu, ok fazla veri ieren bir ilemdir. lemi tamamen imzalamak iin  {{steps}} defa onaylamanz istenir.",
    label: "lerleme"
  },
  success: "lem imzaland ve gnderildi.",
  title: "Gnder {{accountName}}",
  toggleCoinControl: "Kripto para kontroln a"
}, settings$7 = {
  electrum: {
    add: "Bir sunucu ekle",
    "add-server": "Ekle",
    check: "Kontrol et",
    checkFailed: "Baarsz oldu",
    checkSuccess: "Baaryla balant kuruldu {{host}}",
    checking: "Kontrol ediliyor",
    "download-cert": "Uzak sertifikay indir",
    "remove-server": "Kaldr",
    removeConfirm: "Kaldr {{server}}?",
    reset: "Varsaylana sfrla",
    resetConfirm: "Tm sunucular kaldrmak ve varsaylan sunucular kurmak istiyor musunuz?",
    servers: "Sunucular",
    step1: "1",
    "step1-text": "Biti noktasn girin.",
    step2: "2",
    "step2-text": "Sunucunun sertifika zincirinden bir sertifikasn girin. Alternatif olarak, uzak sertifikay indirin ve grsel olarak karlatrn.",
    step3: "3",
    "step3-text": "Balantnz kontrol edin ve sunucuyu ekleyin.",
    step4: "4",
    "step4-text": "Czdannz yeniden balatn. Varsaylan sunucular kaldrmazsanz, kendi dmnz fazlalk olarak eklenir.",
    "title-btc": "Bitcoin Electrum Sunucular",
    "title-ltc": "Litecoin Electrum Sunucular",
    "title-tbtc": "Bitcoin Testnet Electrum Sunucular",
    "title-tltc": "Litecoin Testnet Electrum Sunucular"
  },
  expert: {
    coinControl: "Coin kontroln etkinletir",
    electrum: {
      title: "Kendi tam node'unuza balayn"
    },
    setProxyAddress: "Proxy adresini ayarla",
    title: "Uzman Ayarlar",
    useProxy: "Tor proxy'yi etkinletir"
  },
  header: {
    home: "Ev"
  },
  restart: "Ltfen deiikliklerin geerli olmas iin BitBoxAppi yeniden balatn.",
  success: "Deiikliklerin etkili olmas iin ltfen BitBoxun fiini ekin ve yeniden takn.",
  title: "Ayarlar"
}, setup$6 = "Cihaza Kurulum Yap", sidebar$7 = {
  device: "Cihaz Ynet",
  leave: "Ayrl",
  settings: "Ayarlar"
}, success$d = {
  create: {
    info1: "Czdannz micro SD Karta gvenli bir ekilde yedeklendi. karn ve gvenli bir yerde saklayn.",
    info2: "BitBox'un kilidini aan gvenli bir cihaz ifresi oluturdunuz.",
    info3: "Czdannz iin paranzn kilidini aan ve yedeklerinizi geri ykleyen gvenli bir kurtarma ifresi oluturdunuz.",
    summary: "te ilem zetiniz",
    title: "Baarl"
  },
  getstarted: "Balarken",
  restore: {
    summary: "Yedeklemenizden bir czdan baaryla geri yklediniz.",
    title: "Baarl"
  }
}, transaction$7 = {
  confirmation: "Onaylar",
  explorer: "lem Kimlii",
  explorerTitle: "Harici explorer'da a",
  fee: "cret",
  fiatHistorical: "Tarih",
  gas: "Gas",
  pending: "Bekleyen ilem",
  size: "Boyut",
  vsize: "Sanal boyut",
  weight: "Arlk"
}, transactions$6 = {
  placeholder: "Henz ilem yok."
}, unknownError$6 = "Bilinmeyen bir hata olutu: {{errorMessage}}", unlock$6 = {
  description: "Cihaznzn kilidini amak iin cihaz ifrenizi girin.",
  error: {
    e109_normal: "Cihaz ifresi yanl. Cihaz sfrlanmadan nce {{remainingAttempts}} yapabilirsiniz.",
    e109_touch: "$t(unlock.error.e109_normal) Bir sonraki giri iin dokunmatik dmeye basl tutmanz gerektirir.",
    e113: "Birok giri denemesi nedeniyle, bir sonraki giri iin dokunmatik dmeye 4 saniye basl tutmanz gerekiyor."
  },
  input: {
    label: "Cihaz ifresi",
    placeholder: "Cihazn kilidini amak iin cihaz ifrenizi girin."
  },
  unlocking: "Kilit alyor"
}, upgradeFirmware$7 = {
  button: "Donanm yazlmn ykselt",
  description: "Donanm yazlmn  {{currentVersion}}'dan {{newVersion}}'a ykseltmek istiyor musunuz??",
  label: "BitBox'nzn rn yazlmnn ykseltilmesi gerekiyor.",
  locked: " {{currentVersion}} den ykseltmek iin iin {{newVersion}}, ltfen uzun sre basl tutun.",
  title: "Donanm yazlmn ykselt",
  unlocked: "Bootloader kilidi ald. Devam etmek iin ltfen:",
  unlocked1: "Bitbox'nz karn ve yeniden takn",
  unlocked2: "BitBox'unuz tekrar takldnda LED yanacaktr",
  unlocked3: "LED yandnda dmeye dokunun"
}, warning$c = {
  receivePairing: "Gvenli adres dorulamasn etkinletirmek iin ltfen BitBox' eletirin. Kenar ubuunda 'Cihaz Ynet' seeneine gidin.",
  sdcard: "Yedeklemeleri ynetmek istemediiniz srece, mikro SD kart BitBox'tan ayr saklayn.",
  sendPairing: "lem ayrntlarn gvenli bir ekilde dorulamak iin ltfen BitBox' eletirin. Kenar ubuundan 'Cihaz Ynet' seeneine gidin."
}, welcome$6 = {
  insertBitBox02: "Devam etmek iin ltfen cihaza dokunun.",
  insertDevice: "Balamak iin ltfen cihaznz balayn",
  title: "Hogeldiniz"
}, appTranslationsTR = {
  account: account$6,
  accountInfo: accountInfo$6,
  accountSummary: accountSummary$6,
  addAccount: addAccount$7,
  app: app$6,
  backup: backup$6,
  bb02Bootloader: bb02Bootloader$6,
  bitbox: bitbox$6,
  bitbox02Interact: bitbox02Interact$6,
  bitbox02Settings: bitbox02Settings$6,
  bitbox02Wizard: bitbox02Wizard$6,
  blink: blink$6,
  bootloader: bootloader$6,
  button: button$a,
  changePin: changePin$6,
  checkSDcard: checkSDcard$6,
  clickHere: clickHere$6,
  confirm: confirm$8,
  confirmOnDevice: confirmOnDevice$6,
  device: device$6,
  deviceLock: deviceLock$6,
  deviceSettings: deviceSettings$6,
  deviceTampered: deviceTampered$6,
  dialog: dialog$7,
  fiat: fiat$8,
  footer: footer$8,
  genericError: genericError$6,
  goal: goal$6,
  guide: guide$7,
  headerssync: headerssync$6,
  hiddenWallet: hiddenWallet$6,
  initialize: initialize$6,
  invalidFormat: invalidFormat$6,
  language: language$7,
  legacyhiddenwallet: legacyhiddenwallet$6,
  loading: loading$6,
  notification: notification$6,
  pairing: pairing$6,
  password: password$6,
  random: random$7,
  receive: receive$8,
  reset: reset$6,
  securityInformation: securityInformation$6,
  seed: seed$6,
  seedRestore: seedRestore$6,
  send: send$8,
  settings: settings$7,
  setup: setup$6,
  sidebar: sidebar$7,
  success: success$d,
  transaction: transaction$7,
  transactions: transactions$6,
  unknownError: unknownError$6,
  unlock: unlock$6,
  upgradeFirmware: upgradeFirmware$7,
  warning: warning$c,
  welcome: welcome$6
}, account$5 = {
  disconnect: "....",
  exportTransactions: "CSV",
  fatalError: "",
  incoming: "",
  initializing: "",
  reconnecting: ""
}, accountInfo$5 = {
  address: "",
  extendedPublicKey: "",
  label: "",
  title: "",
  verify: ""
}, accountSummary$5 = {
  balance: "",
  exportSummary: "CSV",
  fiatBalance: "",
  name: "",
  noAccount: "",
  title: "",
  total: ""
}, addAccount$6 = {
  title: ""
}, app$5 = {
  upgrade: " {{current}}  {{version}}"
}, backup$5 = {
  check: {
    checking: "",
    confirmTitle: "",
    notOK: "",
    ok: "",
    password: {
      label: "",
      placeholder: "",
      showLabel: ""
    },
    success: "",
    title: ""
  },
  create: {
    alreadyExists: "",
    fail: "",
    info: "",
    name: {
      label: "",
      placeholder: ""
    },
    password: {
      label: "",
      placeholder: ""
    },
    title: "",
    verificationFailed: ""
  },
  description: " <strong></strong>",
  insert: "Micro SD",
  insertButton: "Micro SD",
  list: "microSD",
  noBackups: "microSD",
  restore: {
    confirmTitle: "",
    error: {
      e200: "()microSD"
    },
    password: {
      label: "",
      placeholder: "",
      repeatPlaceholder: "",
      showLabel: ""
    },
    restoring: "",
    title: "",
    understand: ""
  },
  showMnemonic: {
    description: `24()

<strong></strong>

<strong></strong>

<strong></strong>

`,
    title: ""
  },
  title: ""
}, bb02Bootloader$5 = {
  abort: "-",
  advanced: {
    label: "",
    toggleShowFirmwareHash: ""
  },
  flipscreen: "",
  orientation: "",
  success: "() {{rebootSeconds}} ..."
}, bitbox$5 = {
  error: {
    e10000: "",
    e10001: "",
    e102: "4",
    e112: ""
  }
}, bitbox02Interact$5 = {
  followInstructions: "BitBox02"
}, bitbox02Settings$5 = {
  deviceName: {
    current: "",
    input: "BitBox02 ",
    title: "BitBox02"
  }
}, bitbox02Wizard$5 = {
  attestationFailed: "",
  backup: {
    point1: "microSD",
    point2: "",
    restoreText: "",
    text1: "BitBox02microSDBitBox02",
    text2: "",
    text3: "microSD<strong></strong> microSDBitBox02",
    userConfirmation1: "",
    userConfirmation2: "",
    userConfirmation3: "BitBox02()",
    userConfirmation4: "BitBox02"
  },
  create: {
    button: " & ",
    info: "BitBox ",
    inputTitle: "",
    point1: "",
    point2: "BitBox",
    point3: "",
    text: ""
  },
  initialize: {
    passwordText: "BitBox",
    passwordTitle: "BitBox",
    text: "BitBox02() <strong>BitBox02microSD</strong>",
    tip: "",
    title: "BitBox"
  },
  insertSDCard: "<strong>BitBox02microSD</strong>",
  pairing: {
    failed: "BitBox02",
    paired: "",
    title: "",
    unpaired: "BitBox02()BitBox02"
  },
  restoreFromMnemonic: {
    failed: ""
  },
  stepBackup: {
    beforeProceed: "",
    createBackup: "microSD"
  },
  stepBackupSuccess: {
    fundsSafe: "",
    title: ""
  },
  stepConnected: {
    unlock: "BitBox02"
  },
  stepCreate: {
    nameLabel: "BitBox02",
    namePlaceholder: "BitBox02",
    title: "BitBox02",
    toastMicroSD: "microSDBitBox02"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02microSD",
    success: ""
  },
  stepPassword: {
    title: "BitBox02",
    useControls: "BitBox02"
  },
  stepUninitialized: {
    create: "BitBox02",
    restore: "",
    restoreMicroSD: "microSD",
    restoreMnemonic: "",
    title: "BitBox02"
  },
  success: {
    text: `BitBox02

BitBoxApp`,
    title: ""
  }
}, blink$5 = {
  button: ""
}, bootloader$5 = {
  button: "",
  progress: " {{progress}}",
  success: ""
}, button$9 = {
  abort: "",
  back: "",
  changepin: "",
  check: "",
  continue: "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "()",
  update: "",
  upgrade: ""
}, changePin$5 = {
  newTitle: "",
  oldLabel: ""
}, checkSDcard$5 = "microSD", clickHere$5 = "", confirm$7 = {
  abortInfo: " ",
  abortInfoRedText: "",
  approveInfo: "4 ",
  approveInfoGreenText: "",
  info: "BitBox",
  infoWhenPaired: "BitBox"
}, confirmOnDevice$5 = "", device$5 = {
  appUpradeRequired: "BitBox"
}, deviceLock$5 = {
  button: "2FA",
  condition1: "",
  condition2: "app",
  condition3: "2FA2FA",
  confirm: "(2FA)",
  title: "2FA"
}, deviceSettings$5 = {
  firmware: {
    newVersion: {
      label: ""
    },
    title: "",
    upToDate: "",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: "",
      label: "microSD",
      true: ""
    },
    title: ""
  },
  loading: "",
  pairing: {
    lock: {
      false: "",
      label: "2FA",
      true: ""
    },
    mobile: {
      false: "",
      label: "app",
      true: ""
    },
    status: {
      false: "",
      label: "",
      true: ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "",
    title: ""
  }
}, deviceTampered$5 = "BitBox Shift", dialog$6 = {
  cancel: "",
  confirm: ""
}, fiat$7 = {
  default: "",
  setDefault: " {{code}} ",
  title: "()"
}, footer$7 = {
  appVersion: "App"
}, genericError$5 = "", goal$5 = {
  buttons: {
    create: "",
    restore: ""
  },
  paragraph: "",
  step: {
    1: {
      title: ""
    },
    2: {
      description: "",
      title: ""
    },
    "3-create": {
      description: "",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$6 = {
  accountDescription: {
    text: " ",
    title: ""
  },
  accountFiat: {
    text: "",
    title: ""
  },
  accountIncomingBalance: {
    text: "()",
    title: "()"
  },
  accountInfo: {
    xpub: {
      text: `
watch-only(),ElectrumSentinel`,
      title: ""
    }
  },
  accountRates: {
    text: "CoinGecko",
    title: ""
  },
  accountReload: {
    text: "",
    title: ""
  },
  accountSendDisabled: {
    text: "",
    title: " {{unit}}"
  },
  accountTransactionAttributesBTC: {
    text: `

Segwit1()4()()(1MB)()`,
    title: "Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: `
ID
`,
    title: ""
  },
  accountTransactionConfirmation: {
    text: "",
    title: ""
  },
  accountTransactionLabel: {
    text: "",
    title: ""
  },
  accountTransactionTime: {
    text: "",
    title: ""
  },
  appendix: {
    link: "",
    text: ""
  },
  backups: {
    check: {
      text: "()",
      title: ""
    },
    encrypt: {
      text: "",
      title: ""
    },
    howOften: {
      text: `microSDmicroSD
`,
      title: ""
    },
    whatIsABackup: {
      text: "micro SD",
      title: ""
    }
  },
  backupsBB02: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "Micro SD",
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  bitbox: {
    "2FA": {
      text: `2FAappBitBox

2FAappmicro SDappBitBox`,
      title: "2FA"
    },
    disable2FA: {
      text: "2FABitBoxmicroSD",
      title: "2FA"
    },
    ejectBitbox: {
      text: "BitBox",
      title: "BitBox"
    },
    ejectSD: {
      text: "BitBoxmicroSD",
      title: "microSD"
    },
    hiddenWallet: {
      text: '"plausible deniability"',
      title: ""
    },
    legacyHiddenWallet: {
      text: "BitBox2FABitbox",
      title: "legacy"
    },
    pairing: {
      text: "iOSAndroidappappapp",
      title: ""
    }
  },
  receive: {
    address: {
      text: "",
      title: ""
    },
    addressChange: {
      text: "()20",
      title: ""
    },
    howVerify: {
      text: `BitBox01BitBox
BitBox02/`,
      title: ""
    },
    why20: {
      text: "appapp()()20gap limit2020",
      title: "20"
    },
    whyMany: {
      text: "()20",
      title: ""
    },
    whyVerify: {
      text: "BitBox01QRBitBox02BitBox02",
      title: ""
    }
  },
  send: {
    fee: {
      text: `()Bitcoin Core
2441
12230
/6115
2205
2.5`,
      title: ""
    },
    priority: {
      text: "",
      title: ""
    },
    revert: {
      text: `()
`,
      title: ""
    },
    whyFee: {
      text: `()
`,
      title: ""
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift",
      title: ""
    }
  },
  settings: {
    servers: {
      text: `appShift Cryptoapps
appCoinGecko
ERC20Etherscan.io API`,
      title: "app"
    }
  },
  title: "",
  toggle: {
    close: "",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "",
      title: ""
    },
    reset: {
      text: "15",
      title: ""
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "",
      title: "BitBox01"
    },
    getDevice: {
      link: {
        text: "BitBox"
      },
      text: "BitBox",
      title: ""
    },
    internet: {
      text: "",
      title: "app"
    },
    lostDevice: {
      link: {
        text: ""
      },
      text: "BitBox",
      title: ""
    },
    useWithoutDevice: {
      text: "",
      title: "app"
    },
    welcome: {
      text: "Shift Crypto",
      title: "BitBoxApp"
    }
  }
}, headerssync$5 = {
  blocksSynced: "{{blocks}} "
}, hiddenWallet$5 = {
  info1HTML: '"plausible deniability" <strong></strong> +',
  info2HTML: " <strong></strong> ",
  passwordLabel: "",
  passwordPlaceholder: "",
  pinLabel: "",
  pinRepeatLabel: "",
  pinRepeatPlaceholder: "",
  success: "BitBox"
}, initialize$5 = {
  create: "",
  creating: "...",
  error: {
    e102: "4"
  },
  info: {
    description1: "BitBox",
    description2: " & ",
    description3: "",
    subtitle: "",
    title: ""
  },
  input: {
    label: "",
    labelRepeat: "",
    placeholderRepeat: ""
  }
}, invalidFormat$5 = "", language$6 = {
  title: ""
}, legacyhiddenwallet$5 = {
  disable: "legacy",
  enable: "Legacy",
  successDisable: "legacy",
  successEnable: "legacyBitBoxlegacy"
}, loading$5 = "...", notification$5 = {
  newTxs_one: "{{count}}  {{accountName}}",
  newTxs_other: "{{count}}  {{accountName}}"
}, pairing$5 = {
  aborted: {
    text: "app",
    title: ""
  },
  button: "app",
  confirm: "BitBox",
  connectOnly: {
    button: "app",
    title: "app"
  },
  error: {
    text: "",
    title: ""
  },
  reconnectOnly: {
    button: "app"
  },
  start: {
    hideAppQRCode: "",
    revealAppQRCode: "",
    step1: "appApple App StoreGoogle Play",
    step2: "appiOSAndroid Digital Bitbox 2FAapp"
  },
  started: {
    text: "app",
    title: ""
  },
  success: {
    text: "BitBoxapp",
    title: ""
  },
  timeout: {
    text: "app",
    title: ""
  },
  title: ""
}, password$5 = {
  show: " {{label}}",
  warning: {
    caps: "",
    paste: " {{label}}"
  }
}, random$6 = {
  button: "",
  description: "BitBox {{bits}}"
}, receive$7 = {
  label: "",
  onlyThisCoin: {
    description: "",
    warning: " {{coinName}} "
  },
  showFull: "",
  title: " {{accountName}}",
  verify: "",
  verifyBitBox01: "app",
  verifyBitBox02: "BitBox02",
  verifyInstruction: "",
  warning: {
    secureOutput: "BitBox"
  }
}, reset$5 = {
  description: "",
  notReset: "",
  title: "",
  understand: "",
  understandBB02: ""
}, securityInformation$5 = {
  create: {
    description1: "",
    description2: "",
    description3: " <strong></strong> BitBox",
    description4: " <strong></strong> ",
    description5: "microSD <strong></strong>",
    title: ""
  },
  restore: {
    description1: "microSD",
    description2: " ",
    description3: "",
    title: ""
  }
}, seed$5 = {
  agreements: {
    "funds-access": "/",
    "password-change": "",
    "password-required": ""
  },
  create: "",
  creating: "",
  description: "",
  error: {
    e102: "4",
    e200: "BitBoxmicroSD"
  },
  info: {
    button: "",
    description1: "microSDBitBox",
    description2: "",
    description3: "BitBoxmicroSD",
    description4: "",
    title: ""
  },
  password: {
    label: "",
    repeatPlaceholder: ""
  },
  walletName: {
    label: ""
  }
}, seedRestore$5 = {
  error: {
    e200: "microSD"
  },
  info: {
    description1: "microSDBitBox",
    description2: "",
    description3: "",
    description4: "",
    title: ""
  }
}, send$7 = {
  abort: "",
  address: {
    label: "",
    placeholder: ""
  },
  amount: {
    label: "",
    placeholder: ""
  },
  button: "",
  coincontrol: {
    address: "",
    outpoint: "",
    title: ""
  },
  confirm: {
    "selected-coins": "",
    title: "",
    total: ""
  },
  error: {
    insufficientFunds: "",
    invalidAddress: "",
    invalidAmount: "",
    invalidData: ""
  },
  fee: {
    customPlaceholder: "",
    label: "",
    placeholder: ""
  },
  feeTarget: {
    description: {
      economy: "24Bitcoin4Litecoin1",
      high: "2Bitcoin20Litecoin5",
      low: "12Bitcoin2Litecoin30",
      normal: "6Bitcoin1Litecoin15"
    },
    estimate: "",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: "/"
    },
    placeholder: ""
  },
  maximum: "",
  scanQR: "",
  signprogress: {
    description: " {{steps}} ",
    label: ""
  },
  success: "",
  title: " {{accountName}}",
  toggleCoinControl: "coin"
}, settings$6 = {
  electrum: {
    add: "",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: " {{host}}",
    checking: "",
    "download-cert": "",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "",
    resetConfirm: "",
    servers: "",
    step1: "1",
    "step1-text": "endpoint",
    step2: "2",
    "step2-text": "",
    step3: "3",
    "step3-text": "",
    step4: "4",
    "step4-text": "",
    "title-btc": "Bitcoin Electrum",
    "title-ltc": "LitecoinElectrum",
    "title-tbtc": "BitcoinElectrum",
    "title-tltc": "LitecoinElectrum"
  },
  expert: {
    coinControl: "coin",
    electrum: {
      title: ""
    },
    setProxyAddress: "",
    title: "/",
    useProxy: "tor"
  },
  header: {
    home: ""
  },
  restart: "BitBoxApp",
  success: "BitBox",
  title: ""
}, setup$5 = "", sidebar$6 = {
  device: "",
  leave: "",
  settings: ""
}, success$c = {
  create: {
    info1: "microSDmicroSD",
    info2: "BitBox",
    info3: "",
    summary: "",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "",
    title: ""
  }
}, transaction$6 = {
  confirmation: "",
  explorer: "ID",
  explorerTitle: "",
  fee: "()",
  fiatHistorical: "",
  gas: "Gas",
  pending: "",
  size: "()",
  vsize: "()",
  weight: "()"
}, transactions$5 = {
  placeholder: ""
}, unknownError$5 = " {{errorMessage}}", unlock$5 = {
  description: "",
  error: {
    e109_normal: " {{remainingAttempts}} ",
    e109_touch: "$t(unlock.error.e109_normal",
    e113: "4"
  },
  input: {
    label: "",
    placeholder: ""
  },
  unlocking: "..."
}, upgradeFirmware$6 = {
  button: "",
  description: " {{currentVersion}} {{newVersion}}",
  label: "BitBox",
  locked: " {{currentVersion}}  {{newVersion}}()",
  title: "",
  unlocked: "",
  unlocked1: "Bitbox",
  unlocked2: "BitBoxLED",
  unlocked3: "LED"
}, warning$b = {
  receivePairing: "BitBox",
  sdcard: "microSDBitBox",
  sendPairing: "BitBox"
}, welcome$5 = {
  insertBitBox02: "BitBox02",
  insertDevice: "",
  title: ""
}, appTranslationsZH = {
  account: account$5,
  accountInfo: accountInfo$5,
  accountSummary: accountSummary$5,
  addAccount: addAccount$6,
  app: app$5,
  backup: backup$5,
  bb02Bootloader: bb02Bootloader$5,
  bitbox: bitbox$5,
  bitbox02Interact: bitbox02Interact$5,
  bitbox02Settings: bitbox02Settings$5,
  bitbox02Wizard: bitbox02Wizard$5,
  blink: blink$5,
  bootloader: bootloader$5,
  button: button$9,
  changePin: changePin$5,
  checkSDcard: checkSDcard$5,
  clickHere: clickHere$5,
  confirm: confirm$7,
  confirmOnDevice: confirmOnDevice$5,
  device: device$5,
  deviceLock: deviceLock$5,
  deviceSettings: deviceSettings$5,
  deviceTampered: deviceTampered$5,
  dialog: dialog$6,
  fiat: fiat$7,
  footer: footer$7,
  genericError: genericError$5,
  goal: goal$5,
  guide: guide$6,
  headerssync: headerssync$5,
  hiddenWallet: hiddenWallet$5,
  initialize: initialize$5,
  invalidFormat: invalidFormat$5,
  language: language$6,
  legacyhiddenwallet: legacyhiddenwallet$5,
  loading: loading$5,
  notification: notification$5,
  pairing: pairing$5,
  password: password$5,
  random: random$6,
  receive: receive$7,
  reset: reset$5,
  securityInformation: securityInformation$5,
  seed: seed$5,
  seedRestore: seedRestore$5,
  send: send$7,
  settings: settings$6,
  setup: setup$5,
  sidebar: sidebar$6,
  success: success$c,
  transaction: transaction$6,
  transactions: transactions$5,
  unknownError: unknownError$5,
  unlock: unlock$5,
  upgradeFirmware: upgradeFirmware$6,
  warning: warning$b,
  welcome: welcome$5
}, account$4 = {
  disconnect: "      ...",
  export: "",
  exportTransactions: "       CSV      ",
  fatalError: "  .",
  incoming: "",
  initializing: "    ...",
  reconnecting: "        ..."
}, accountInfo$4 = {
  address: "",
  extendedPublicKey: "   ",
  label: " ",
  title: " ",
  verify: "  "
}, accountSummary$4 = {
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: "   ",
  name: " ",
  noAccount: "    .",
  title: "  ",
  total: ""
}, addAccount$5 = {
  title: " "
}, app$4 = {
  upgrade: "    .      {{current}}   {{version}}  ."
}, backup$4 = {
  check: {
    checking: "  ...",
    confirmTitle: " ",
    notOK: "      .",
    ok: "      ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "     :",
    title: " "
  },
  create: {
    alreadyExists: "    .      ",
    fail: "      !",
    info: "         ",
    name: {
      label: " ",
      placeholder: "     "
    },
    password: {
      label: " ",
      placeholder: "     "
    },
    title: " ",
    verificationFailed: "       .    .    ' '      ."
  },
  description: "<strong>   </strong>  .",
  insert: "     microSD   ",
  insertButton: " microSD   ",
  list: "      microSD",
  noBackups: "      SD  .",
  restore: {
    confirmTitle: " ",
    error: {
      e200: " microSD  ."
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "  ...",
    title: "",
    understand: "            "
  },
  showMnemonic: {
    description: `   24           .      .
<strong>      .     </strong>
<strong>   .</strong>
<strong>     .</strong>
            .
`,
    title: "  "
  },
  title: "  "
}, bb02Bootloader$4 = {
  abort: "     ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "        "
  },
  flipscreen: " ",
  orientation: "   ",
  success: "    !   {{rebootSeconds}} ..."
}, bitbox$4 = {
  error: {
    e10000: "  .",
    e10001: "  ",
    e102: "     ",
    e112: "         "
  }
}, bitbox02Interact$4 = {
  followInstructions: "        BitBox02  ."
}, bitbox02Settings$4 = {
  deviceName: {
    current: "  ",
    input: " BitBox02",
    title: "  BitBo02"
  }
}, bitbox02Wizard$4 = {
  attestationFailed: "                        .        .",
  backup: {
    point1: "      microSD  ",
    point2: "      ",
    restoreText: "     !",
    text1: "  BitBox02         .         .     microSD   BitBo02      .",
    text2: "                .",
    text3: "      microSD      <strong> </strong>  .  microSD   .          BitBox02  ",
    userConfirmation1: "          .",
    userConfirmation2: "    .                .",
    userConfirmation3: "  Bitbox02                .",
    userConfirmation4: "      BitBox02               "
  },
  create: {
    button: "    ",
    info: "         BitBox        : ",
    inputTitle: "  ",
    point1: "  ",
    point2: "    ",
    point3: " ",
    text: "        !"
  },
  initialize: {
    passwordText: "       .            BitBox   .",
    passwordTitle: "   BitBox ",
    text: "  BitBox02   !        .                 .         microSD  BitBox02    ",
    tip: "        .",
    title: "  BitBox "
  },
  insertSDCard: "<strong>       microSD  BitBox02   .</strong>",
  pairing: {
    failed: "  .  BitBox02     .",
    paired: "           .              .",
    title: "    ",
    unpaired: "BitBox02    .                  .          BitBox02              ."
  },
  restoreFromMnemonic: {
    failed: "         ."
  },
  stepBackup: {
    beforeProceed: "          :",
    createBackup: "     microSD    ."
  },
  stepBackupSuccess: {
    fundsSafe: "          :",
    title: "   "
  },
  stepConnected: {
    unlock: " BitBox02       ."
  },
  stepCreate: {
    nameLabel: " BitBox02",
    namePlaceholder: "BitBox02 ",
    title: " BitBox02   ",
    toastMicroSD: "      microSD   BitBox02  ."
  },
  stepCreateSuccess: {
    removeMicroSD: "  microSD   BitBox02            .",
    success: "        ."
  },
  stepPassword: {
    title: " BitBox02   ",
    useControls: "        BitBox02  ."
  },
  stepUninitialized: {
    create: "   BitBox02    .",
    restore: "           .",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "   ",
    title: "BitBox02    "
  },
  success: {
    text: `!  BitBox02    .

         BitBoxApp                  .`,
    title: "   !"
  }
}, blink$4 = {
  button: " "
}, bootloader$4 = {
  button: "  ",
  progress: ": {{progress}}%",
  success: "   !      .      ."
}, button$8 = {
  abort: "",
  back: "",
  changepin: "  ",
  check: " ",
  continue: "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "   ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: " ",
  upgrade: ""
}, changePin$4 = {
  newTitle: "  ",
  oldLabel: "   "
}, checkSDcard$4 = "  microSD", clickHere$4 = "  .", confirm$6 = {
  abortInfo: "  ",
  abortInfoRedText: "",
  approveInfo: "4    ",
  approveInfoGreenText: " ",
  info: " BitBox",
  infoWhenPaired: "      BitBox"
}, confirmOnDevice$4 = "      .", device$4 = {
  appUpradeRequired: "BitBox      .        ."
}, deviceLock$4 = {
  button: "      (2FA)",
  condition1: "  ",
  condition2: "      ",
  condition3: "           .      2     .",
  confirm: "      (2FA)",
  title: "      (2FA)"
}, deviceSettings$4 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: " ",
    upToDate: "   ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: " ",
      label: " microSD",
      true: " "
    },
    title: " "
  },
  loading: "  ...",
  pairing: {
    lock: {
      false: "",
      label: "    (2FA)",
      true: ""
    },
    mobile: {
      false: " ",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
}, deviceTampered$4 = " BitBox                   . Shift              ", dialog$5 = {
  cancel: "",
  confirm: ""
}, fiat$6 = {
  default: " ",
  setDefault: "{{code}}      ",
  title: ""
}, footer$6 = {
  appVersion: " :"
}, genericError$4 = "              .", goal$4 = {
  buttons: {
    create: "     ",
    restore: "    "
  },
  paragraph: "        :",
  step: {
    1: {
      title: " "
    },
    2: {
      description: "     ",
      title: ""
    },
    "3-create": {
      description: "     ",
      title: " "
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$5 = {
  accountDescription: {
    text: '               .    ""       . ',
    title: "          "
  },
  accountFiat: {
    text: "                             .",
    title: "        "
  },
  accountIncomingBalance: {
    text: "                  .",
    title: "  "
  },
  accountInfo: {
    xpub: {
      text: `                      .
              Electrum  Sentinel   .`,
      title: "    "
    }
  },
  accountRates: {
    text: "",
    title: "    "
  },
  accountReload: {
    text: "        .",
    title: "       "
  },
  accountSendDisabled: {
    text: "            .",
    title: "     {{unit}}  "
  },
  accountTransactionAttributesBTC: {
    text: ` :       .              .
:                .
:  Segwit              .                .                  .`,
    title: "     "
  },
  accountTransactionAttributesGeneric: {
    text: `:             .                    .                .                       -   .
 :                  .
:                     .         .`,
    title: "         "
  },
  accountTransactionConfirmation: {
    text: "            .",
    title: "   "
  },
  accountTransactionLabel: {
    text: "                  .",
    title: "        "
  },
  accountTransactionTime: {
    text: "      .",
    title: "     "
  },
  appendix: {
    link: "  ",
    text: " "
  },
  backups: {
    check: {
      text: "                     .         .              .",
      title: '" " '
    },
    encrypt: {
      text: "             .",
      title: "      "
    },
    howOften: {
      text: `              .           microSD                 microSD    .
         .                   .`,
      title: "       "
    },
    whatIsABackup: {
      text: "         SD .            .",
      title: " "
    }
  },
  backupsBB02: {
    check: {
      text: '"  "                    .',
      title: "'  ' "
    },
    encrypt: {
      text: '.     microSD                 .                       " "  .',
      title: "       "
    },
    whatIsABackup: {
      text: "        microSD .",
      title: "  "
    }
  },
  bitbox: {
    "2FA": {
      text: `                     .                               BitBox   .                    .

       2               .       SD         .    BitBox           .`,
      title: "    (2FA)    "
    },
    disable2FA: {
      text: '            BitBox        .        SD            .  " "   .           "  "   .       ""                 .',
      title: "         "
    },
    ejectBitbox: {
      text: "   BitBox          .",
      title: "   BitBox   "
    },
    ejectSD: {
      text: "    microSD   BitBox              .",
      title: "    microSD   "
    },
    hiddenWallet: {
      text: "                              .                     .",
      title: "   "
    },
    legacyHiddenWallet: {
      text: "       (      BitBox                )  BitBox           .",
      title: "      legacy    "
    },
    pairing: {
      text: "       IOS  Android   QR       .            .          .",
      title: "       "
    }
  },
  receive: {
    address: {
      text: "          .          .",
      title: "     "
    },
    addressChange: {
      text: "                      .          .",
      title: "     "
    },
    howVerify: {
      text: ` BitBox01   BitBox             .                 .
 BitBox02                 .`,
      title: "          "
    },
    why20: {
      text: '                            .                       .          20           .  " "   20         .  20       .',
      title: "  20 "
    },
    whyMany: {
      text: "              .              .         .         .     seed     .",
      title: "     "
    },
    whyVerify: {
      text: "         BitBox                .                  .       BitBox                    QR     .  BitBox02          BitBox02",
      title: "      "
    }
  },
  send: {
    fee: {
      text: `          .        Bitcoin            .             .
:   (    Bitcoin    Litecoin)
:   (    Bitcoin    Litecoin)
:   (    Bitcoin    Litecoin)
:   (    Bitcoin    Litecoin)
(   Bitcoin         (.   Litecoin)                 .)`,
      title: "     "
    },
    priority: {
      text: "              .",
      title: "  "
    },
    revert: {
      text: `        (     )    .        ( )   .
         (  )          .`,
      title: "     "
    },
    whyFee: {
      text: `          .              .
      .               (       )                 .                     .`,
      title: "     "
    }
  },
  "settings-electrum": {
    what: {
      text: "     Shift             .",
      title: " "
    }
  },
  settings: {
    servers: {
      text: `    Shift Crypto                .           CoinGecko   . (             .)
:    Ethereum  ERC20    API  Etherscan.io   .`,
      title: "       "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "               .",
      title: "           "
    },
    reset: {
      text: "                  .",
      title: "    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "         .           .                .",
      title: "BitBox01    "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox       :",
      title: "     "
    },
    internet: {
      text: "                .",
      title: "      "
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "        BitBox        .",
      title: "       "
    },
    useWithoutDevice: {
      text: "        .",
      title: "          "
    },
    welcome: {
      text: "          Shift Crypto      .                  .             .",
      title: "  BitBox  !"
    }
  }
}, headerssync$4 = {
  blocksSynced: "{{blocks}}     "
}, hiddenWallet$4 = {
  info1HTML: "                     +     .",
  info2HTML: "                 .       <strong></strong>          .",
  passwordLabel: "   ",
  passwordPlaceholder: "       ",
  pinLabel: "   ",
  pinRepeatLabel: "      ",
  pinRepeatPlaceholder: "       ",
  success: "       BitBox          ."
}, initialize$4 = {
  create: "     ",
  creating: "   ...",
  error: {
    e102: "       ."
  },
  info: {
    description1: "         BitBox      .",
    description2: "       .     .",
    description3: "                   .",
    subtitle: "        ",
    title: "  "
  },
  input: {
    label: " ",
    labelRepeat: "     ",
    placeholderRepeat: "     "
  }
}, invalidFormat$4 = " ", language$5 = {
  title: "     "
}, legacyhiddenwallet$4 = {
  disable: "     legacy ",
  enable: "    legacy ",
  successDisable: "    legacy    ",
  successEnable: "    legacy   . BitBox                legacy   ."
}, loading$4 = "  ", notification$4 = {
  newTxs_one: "{{count}}   : {{accountName}}"
}, pairing$4 = {
  aborted: {
    text: "      .",
    title: " "
  },
  button: "   ",
  confirm: "    BitBox                      ",
  connectOnly: {
    button: "   ",
    title: "              ."
  },
  error: {
    text: "      ",
    title: ""
  },
  reconnectOnly: {
    button: "    "
  },
  start: {
    hideAppQRCode: "   QR",
    revealAppQRCode: "  QR",
    step1: "          QR   App Store   Google Play         .",
    step2: '            "Digital Bitbox 2FA"     iOS  Android  :'
  },
  started: {
    text: "        .",
    title: ""
  },
  success: {
    text: "      BitBox       !",
    title: ""
  },
  timeout: {
    text: "        .            .",
    title: ""
  },
  title: "  "
}, password$4 = {
  show: " {{label}}",
  warning: {
    caps: ":  Caps lock ()  ",
    paste: '  " {{label}}"   .'
  }
}, random$5 = {
  button: "  ",
  description: "BitBox    {{bits}}-    :"
}, receive$6 = {
  label: " ",
  onlyThisCoin: {
    description: "           .                .",
    warning: "     {{coinName}}      ."
  },
  showFull: "      ",
  title: " {{accountName}}",
  verify: "  ",
  verifyBitBox01: "       ",
  verifyBitBox02: "   BitBox02  ",
  verifyInstruction: "              .",
  warning: {
    secureOutput: " BitBox             .       ' ' ."
  }
}, reset$4 = {
  description: "       .       !",
  notReset: "     .",
  title: "  ",
  understand: "             ",
  understandBB02: "    "
}, securityInformation$4 = {
  create: {
    description1: "                .",
    description2: "          .",
    description3: "         BitBox            .",
    description4: "             .      ",
    description5: "            microSD   .                     .",
    title: " "
  },
  restore: {
    description1: "       microSD          .",
    description2: "          .",
    description3: "       .            .                .",
    title: " "
  }
}, seed$4 = {
  agreements: {
    "funds-access": "              ",
    "password-change": "     ",
    "password-required": "           "
  },
  create: "  ",
  creating: "   ",
  description: "  :",
  error: {
    e102: "      .",
    e200: "     microSD  BitBox              ."
  },
  info: {
    button: "  ",
    description1: " microSD   BitBox  ",
    description2: '        "  "   .',
    description3: "    microSD                  BitBox .",
    description4: "           .",
    title: "   "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "     "
  },
  walletName: {
    label: "  "
  }
}, seedRestore$4 = {
  error: {
    e200: "         microSD ."
  },
  info: {
    description1: " microSD   BitBox       .",
    description2: '        ""  ',
    description3: "     ",
    description4: "               .",
    title: "          "
  }
}, send$6 = {
  abort: "  .",
  address: {
    label: " ",
    placeholder: "   "
  },
  amount: {
    label: "",
    placeholder: "   "
  },
  button: "  ",
  coincontrol: {
    address: "",
    outpoint: "",
    title: "  "
  },
  confirm: {
    "selected-coins": "   ",
    title: " ",
    total: ""
  },
  error: {
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: "  "
  },
  fee: {
    customPlaceholder: "   ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "  (    Bitcoin    Litecoin)",
      high: "  (    Bitcoin    Litecoin)",
      low: "  (    Bitcoin    Litecoin)",
      normal: "  (    Bitcoin    Litecoin)"
    },
    estimate: "  :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "   ..."
  },
  maximum: " ",
  scanQR: "  QR",
  signprogress: {
    description: "        .             {{steps}}   .",
    label: ""
  },
  success: "     .",
  title: " {{accountName}}",
  toggleCoinControl: "    "
}, settings$5 = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "  {{host}}    .",
    checking: "",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "     ",
    resetConfirm: "              ",
    servers: " ",
    step1: "",
    "step1-text": "    ",
    step2: "",
    "step2-text": "        .               .",
    step3: "",
    "step3-text": "        .",
    step4: "",
    "step4-text": "                     .",
    "title-btc": " Bitcoin Electrum",
    "title-ltc": " Litecoin Electrum",
    "title-tbtc": "  Bitcoin Electrum ",
    "title-tltc": "  Litecoin Electrum "
  },
  expert: {
    coinControl: "    ",
    electrum: {
      title: "     "
    },
    setProxyAddress: "    ",
    title: " ",
    useProxy: "   Tor"
  },
  header: {
    home: ""
  },
  restart: "  BitBox        .",
  success: " BitBox          .",
  title: ""
}, setup$4 = "  ", sidebar$5 = {
  device: " ",
  leave: "",
  settings: ""
}, success$b = {
  create: {
    info1: "     microSD     .          .",
    info2: "         BitBox    .",
    info3: "                         .",
    summary: "         ",
    title: ""
  },
  getstarted: " ",
  restore: {
    summary: "        .",
    title: ""
  }
}, transaction$5 = {
  confirmation: " ",
  explorer: " ",
  explorerTitle: "     ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  pending: "  ",
  size: "",
  vsize: " ",
  weight: ""
}, transactions$4 = {
  placeholder: "   ."
}, unknownError$4 = "     : {{errorMessage}}", unlock$4 = {
  description: "        .",
  error: {
    e109_normal: "   . {{remainingAttempts}}        .",
    e109_touch: "$t(unlock.error.e109_normal)          ",
    e113: "              4   ."
  },
  input: {
    label: " ",
    placeholder: "          "
  },
  unlocking: "     "
}, upgradeFirmware$5 = {
  button: "  ",
  description: "       {{currentVersion}}   {{newVersion}}  ",
  label: "BitBox      .",
  locked: "    {{currentVersion}}   {{newVersion}}      .",
  title: "  ",
  unlocked: " bootloader  .    :",
  unlocked1: "Bitbox       ",
  unlocked2: "  BitBox      LED   ",
  unlocked3: "           "
}, warning$a = {
  receivePairing: " BitBox            .          .",
  sdcard: " microSD    BitBox          .",
  sendPairing: " BitBox        .       "
}, welcome$4 = {
  insertBitBox02: "  BitBox02      .",
  insertDevice: "       ",
  title: " "
}, appTranslationsFA = {
  account: account$4,
  accountInfo: accountInfo$4,
  accountSummary: accountSummary$4,
  addAccount: addAccount$5,
  app: app$4,
  backup: backup$4,
  bb02Bootloader: bb02Bootloader$4,
  bitbox: bitbox$4,
  bitbox02Interact: bitbox02Interact$4,
  bitbox02Settings: bitbox02Settings$4,
  bitbox02Wizard: bitbox02Wizard$4,
  blink: blink$4,
  bootloader: bootloader$4,
  button: button$8,
  changePin: changePin$4,
  checkSDcard: checkSDcard$4,
  clickHere: clickHere$4,
  confirm: confirm$6,
  confirmOnDevice: confirmOnDevice$4,
  device: device$4,
  deviceLock: deviceLock$4,
  deviceSettings: deviceSettings$4,
  deviceTampered: deviceTampered$4,
  dialog: dialog$5,
  fiat: fiat$6,
  footer: footer$6,
  genericError: genericError$4,
  goal: goal$4,
  guide: guide$5,
  headerssync: headerssync$4,
  hiddenWallet: hiddenWallet$4,
  initialize: initialize$4,
  invalidFormat: invalidFormat$4,
  language: language$5,
  legacyhiddenwallet: legacyhiddenwallet$4,
  loading: loading$4,
  notification: notification$4,
  pairing: pairing$4,
  password: password$4,
  random: random$5,
  receive: receive$6,
  reset: reset$4,
  securityInformation: securityInformation$4,
  seed: seed$4,
  seedRestore: seedRestore$4,
  send: send$6,
  settings: settings$5,
  setup: setup$4,
  sidebar: sidebar$5,
  success: success$b,
  transaction: transaction$5,
  transactions: transactions$4,
  unknownError: unknownError$4,
  unlock: unlock$4,
  upgradeFirmware: upgradeFirmware$5,
  warning: warning$a,
  welcome: welcome$4
}, account$3 = {
  disconnect: "Conexin perdida. Reintentando... ",
  export: "Exportar ",
  exportTransactions: "Exportar transacciones a la carpeta de descargas como archivo CSV",
  fatalError: "Ha habido un error inesperado.",
  incoming: "Entrante",
  initializing: "Obteniendo informacin de la blockchain ...",
  maybeProxyError: "Tor Proxy activado. Asegrese de que su Tor proxy est funcionando correctamente, o desactive la configuracin del proxy.",
  reconnecting: "Conexin perdida, reconectando...",
  syncedAddressesCount: "Escaneado {{count}} direcciones"
}, accountInfo$3 = {
  address: "Direccin",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Crypto",
    information: {
      looksEmpty: "Parece que esta cartera est vaca.",
      start: "Comience depositando algunas monedas en la cartera o comprando directamente a travs de la BitBoxApp."
    }
  },
  extendedPublicKey: "Clave pblica extendida",
  label: "Informacin de la cuenta",
  scriptType: "Tipo de script",
  title: "Informacin de la cuenta",
  verify: "Verificar en el dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Ver clave pblica extendida legacy P2PKH",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Native Segwit",
    "p2wpkh-p2sh": "Ver clave pblica extendida antiguo Segwit"
  },
  xpubTypeInfo: "Actualmente mostrando {{scriptType}} clave pblica extendida ({{current}} de {{numberOfXPubs}})"
}, accountSummary$3 = {
  availableBalance: "Saldo disponible",
  balance: "Saldo",
  exportSummary: "Resumen de cuentas de exportacin a la carpeta de descargas como archivo CSV",
  fiatBalance: "Saldo de Fiat",
  name: "Nombre de cuenta",
  noAccount: "No hay cuentas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Mi portfolio",
  total: "Total",
  transactionHistory: "Historial de operaciones"
}, addAccount$4 = {
  chooseName: {
    nextButton: "Aadir cuenta",
    step: "Nombre de la cuenta",
    title: "Nombre de su cuenta"
  },
  selectCoin: {
    nextButton: "Siguiente",
    step: "Elija moneda",
    title: "Elija cryptomoneda"
  },
  success: {
    addAnotherAccount: "Aadir otra cuenta",
    message: "<strong>{{accountName}}</strong> ha sido ahora aadida a sus cuentas.",
    nextButton: "Hecho",
    step: "Finalizado",
    title: "Cuenta aadida"
  },
  title: "Aadir cuenta"
}, aopp$2 = {
  addressRequest: "{{host}} est solicitando una direccin de recepcin.",
  addressRequestWithLogo: "est solicitando una direccin de recepcin",
  banner: "Solicitud de direccin en curso. Conecte su dispositivo para continuar.",
  errorTitle: "Error durante la solicitud de direccin",
  labelAddress: "Direccin",
  labelMessage: "Mensaje",
  reverifyInfoText: "Verifique la direccin",
  signing: "Para proceder, firme el mensaje en su BitBox02",
  success: {
    message: "Proceder con {{host}}",
    title: "Direccin enviada con xito"
  },
  syncing: "Sincronizando la cuenta, por favor espere.",
  title: "Solicitud de direccin"
}, app$3 = {
  upgrade: "Una nueva versin de esta aplicacin est disponible! Por favor actualiza desde {{current}} a {{version}}."
}, auth$3 = {
  authButton: "Autentificar",
  title: "Por favor, autentifquese para continuar"
}, backup$3 = {
  check: {
    checking: "Comprobando copia de seguridad ...",
    confirmTitle: "Comprobar la copia de seguridad",
    notOK: "Copia de seguridad NO coincide con el monedero.",
    ok: "Copia de seguridad coincide con el monedero.",
    password: {
      label: "Contrasea de recuperacin",
      placeholder: "Contrasea de recuperacin",
      showLabel: "contrasea de recuperacin"
    },
    success: "Copia de seguridad verificada con xito:",
    title: "Comprobar la copia de seguridad"
  },
  create: {
    alreadyExists: "Ya tienes una copia de seguridad vlida. Quieres volverla a crear?",
    fail: "La creacin de la copia de seguridad ha FALLADO!",
    info: "Por favor ingresa la contrasea de recuperacin del monedero actual para su verificacin.",
    name: {
      label: "Nombre de la copia de seguridad",
      placeholder: "Por favor pon el nombre de la copia de seguridad"
    },
    password: {
      label: "Contrasea de recuperacin",
      placeholder: "Por favor ingresa tu contrasea de recuperacin"
    },
    title: "Crea copia de seguridad",
    verificationFailed: "La contrasea de recuperacin NO COINCIDE con el monedero actual. La copia de seguridad ha sido creada. Por favor utiliza 'Comprueba copia de seguridad' para verificar tu contrasea de recuperacin nuevamente."
  },
  description: "Selecciona <strong>archivo de copia de seguridad del monedero</strong>",
  insert: "Por favor, inserta la tarjeta micro SD para administrar las copias de seguridad.",
  insertButton: "He insertado la tarjeta micro SD",
  list: "Tus copias de seguridad en la microSD",
  noBackups: "No hay copias de seguridad en esta tarjeta microSD.",
  restore: {
    confirmTitle: "Recupera copia de seguridad",
    error: {
      e200: "Tarjeta SD no encontrada",
      general: "Error restaurando copia de seguridad"
    },
    password: {
      label: "Contrasea de recuperacin o contrasea de recuperacin oculta",
      placeholder: "Contrasea de recuperacin",
      repeatPlaceholder: "Repita la contrasea de recuperacin",
      showLabel: "Contrasea de recuperacin"
    },
    restoring: "Restaurando copia de seguridad ...",
    selectedBackup: "<strong>{{backupName}}</strong> creada en {{createdDateTime}} ser restaurada.",
    title: "Restaurar",
    understand: "Entiendo que una contrasea de recuperacin incorrecta crear un monedero diferente"
  },
  showMnemonic: {
    description: `Se le presentarn sus palabras de recuperacin, que constituyen una copia de seguridad de su cartera. Escrbalas en un papel..

<strong>No las almacenes digitalmente ni le tomes fotos.</strong>

<strong>No las diga en voz alta.</strong>

<strong>Esta copia de seguridad no est protegida por una contrasea.</strong>

A continuacin, se le pedir que confirme cada palabra. `,
    title: "Muestra las claves de recuperacin",
    warning: "<strong>Nunca compartas tus palabras de recuperacin con nadie.</strong> Tus palabras de recuperacin dan acceso completo a tu billetera. Si alguien te pide tus palabras de recuperacin, es un estafador, no las compartas! "
  },
  title: "Administrar copias de seguridad"
}, bb02Bootloader$3 = {
  abort: "No actualices - vuelve atrs",
  abort_noUpgrade: "Llvame atrs",
  advanced: {
    label: "Configuracin avanzada",
    toggleShowFirmwareHash: "Mostrar el hash del firmware en cada inicio"
  },
  flipscreen: "Gira la foto en la pantalla",
  orientation: "Est el dispositivo orientado de manera incorrecta?",
  success: "Actualizado con xito! Continuando en {{rebootSeconds}} segundos...",
  success_install: "Instalacin satisfactoria! Contina en {{rebootSeconds}} segundos..."
}, bitbox$3 = {
  error: {
    e10000: "Contrasea del dispositivo actual incorrecta.",
    e10001: "Error al reemplazar la contrasea del dispositivo",
    e102: "La contrasea debe contener al menos 4 caracteres.",
    e112: "La contrasea oculta del dispositivo no puede ser la misma que la contrasea principal del dispositivo."
  }
}, bitbox02Interact$3 = {
  confirmDate: "Confirma la fecha de hoy en tu BitBox02",
  confirmDateText: "Esta fecha se utilizar para crear tu copia de seguridad.",
  confirmName: "Confirma el nombre en tu BitBox02",
  confirmWords: "Escriba la {{amount}} de palabras recuperacin de su BitBox02",
  confirmWordsText: "Despus el BitBox02 te pedir que confirmes cada palabra para verificar que la copia de seguridad es correcta.",
  followInstructions: "Por favor, sigue las instrucciones en tu BitBox02",
  followInstructionsMnemonic: "Sigue las instrucciones de tu BitBox02 para introducir las palabras de recuperacin de tu copia de seguridad y restaurar tu billetera.",
  followInstructionsMnemonicTitle: "Restaurar desde las palabras de recuperacin"
}, bitbox02Settings$3 = {
  deviceName: {
    current: "Nombre del dispositivo actual",
    error: "No se ha podido establecer el nombre del dispositivo",
    error_104: "La confirmacin del nombre del dispositivo fue abortada en el dispositivo.",
    input: "Nombre de la BitBox02",
    placeholder: "Nuevo nombre del dispositivo",
    title: "Establece el nombre de la BitBox02"
  },
  gotoStartupSettings: {
    description: "Esto reiniciar tu BitBox02 y entrar en la configuracin de inicio.",
    title: "Ir a configuracin de inicio"
  }
}, bitbox02Wizard$3 = {
  advanced: {
    button: "Opciones avanzadas",
    outOfDate: "Firmware obsoleto para esta funcin",
    seed12WordInfo: "Tenga en cuenta que el nmero de palabras no se puede cambiar despus de crear la billetera.",
    seed12WordLabel: "Crear semilla de 12 palabras en lugar de 24 palabras",
    seed12WordText: "Predeterminadamente, la BitBox02 utiliza una semilla de 24 palabras. Ambas longitudes de semilla son seguras contra la fuerza bruta en la prctica. Algunos usuarios pueden preferir la conveniencia de la semilla de 12 palabras.",
    skipSDCardLabel: "Omitir la copia de seguridad de la tarjeta microSD y escribir las palabras de recuperacin en su lugar",
    skipSDCardText: "Siempre tienes la opcin de crear una copia de seguridad de la tarjeta microSD o escribir tus palabras de recuperacin despus de la configuracin. Esto se puede hacer desde los ajustes.",
    title: "Opciones avanzadas de copia de seguridad"
  },
  attestationFailed: "La comprobacin genuina del dispositivo ha fallado, que puede ser debido al reinicio de la aplicacin mientras el dispositivo estaba esperando la interaccin por parte del usuario. Por favor conecte de nuevo y intntelo otra vez. Por favor contacte con support@bitbox.swiss si el error persiste.",
  backup: {
    point1: "Selecciona una copia de seguridad de la tarjeta microSD",
    point2: "Establece una contrasea para su dispositivo",
    restoreText: "Ok, restablezcamos una copia de seguridad!",
    text1: "Genial, has establecido la contrasea de tu BitBox02 y tu billetera se ha creado. Ahora es momento de crear tu primera copia de seguridad (backup). Por favor asegrate de que tu tarjeta microSD se haya introducido en tu BitBox02 y continua.",
    text2: "Por favor sigue las instrucciones que aparecen en la pantalla de tu dispositivo para crear la copia de seguridad. ",
    text3: "Despus de que tu copia de seguridad se haya creado, por favor extrae la tarjeta microSD y gurdala en un <strong>lugar seguro</strong>. El contenido de la tarjeta microSD no est protegido con contrasea. Nunca la insertes en ningn otro dispositivo que no sea tu BitBox02. ",
    userConfirmation1: "Debo guardar mi copia de seguridad en un lugar seguro.",
    userConfirmation2: "Mi copia de seguridad no est protegida por contrasea. Cualquiera con acceso a ella tiene acceso a mi billetera.",
    userConfirmation3: "Si pierdo o dao mi BitBox02, la nica forma de recuperar mis fondos es recuperar mi billetera desde mi copia de seguridad.",
    userConfirmation4: "En caso de perder o daar tanto mi copia de seguridad como mi BitBox02, mis fondos se habrn perdido.",
    userConfirmation5: "No debera insertar mi copia de seguridad de la tarjeta microSD en el ordenador, telfono, impresora o en ningn otro dispositivo que no sea BitBox02.",
    userConfirmation5mnemonic: "No debo poner mis palabras de recuperacin en un computador, telfono, impresora o cualquier otro dispositivo que no sea un BitBox02."
  },
  create: {
    button: "Dale un nombre al dispositivo y continua",
    info: "Aqu estn los pasos bsicos que seguirs para instalar tu BitBox:",
    inputTitle: "Nombre del monedero",
    point1: "Dale un nombre a tu dispositivo",
    point2: "Establece una contrasea para su dispositivo",
    point3: "Crea una copia de seguridad",
    text: "Ok, creemos un nueva billetera!"
  },
  createBackupAborted: "Creacin de copia de seguridad abortada.",
  createBackupFailed: "Creacin de copia de seguridad fallida, vuelve a intentarlo.",
  initialize: {
    passwordText: "Ahora establezcamos una contrasea para tu dispositivo. Utiliza los controles en tu BitBox para introducir y escoger una contrasea.",
    passwordTitle: "Establece una contrasea para tu BitBox",
    text: "Tu BitBox02 se ha conectado con xito! Ahora vamos a iniciar tu dispositivo. Empecemos seleccionando crear una billetera nueva o restablecer una billetera desde una copia de seguridad existente.<strong>Por favor asegrate de tener una tarjeta microSD introducida en tu BitBox02</strong>",
    tip: "Te recomendamos que continuas en un entorno seguro.",
    title: "Inicia tu BitBox"
  },
  insertSDCard: "<strong>Por favor asegrate de haber introducido una tarjeta microSD en tu BitBox02.</strong>",
  noPasswordMatch: "Las contraseas no coinciden, por favor, vuelve a intentarlo.",
  pairing: {
    failed: "Conexin no confirmada. Por favor vuelve a conectar tu BitBox02.",
    paired: "Has confirmado el siguiente cdigo en tu dispositivo.  Por favor continua.",
    title: "Comprueba el cdigo de conexin.",
    unpaired: "Se ha detectado un BitBox02 no emparejado. Verifique que el cdigo de emparejamiento coincida con lo que se muestra en su BitBox02. "
  },
  restoreFromMnemonic: {
    e104: "Se cancel la restauracin desde las palabras de recuperacin.",
    failed: "El restablecimiento desde tu clave de recuperacin ha fallado, por favor vuelve a intentarlo."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, por favor lee estas importantes consideraciones de seguridad:",
    createBackup: "Ahora crears una copia de seguridad en tu tarjeta microSD.",
    createBackupMnemonic: "Ahora escribirs las palabras de recuperacin."
  },
  stepBackupSuccess: {
    fundsSafe: "Para mantener seguros tus fondos, por favor recuerda lo siguiente:",
    title: "Copia de seguridad restablecida!"
  },
  stepConnected: {
    unlock: "Introduce la contrasea de tu BitBox02 para desbloquearla."
  },
  stepCreate: {
    description: "Este nombre es utilizado como el nombre del dispositivo y el de la copia de seguridad.",
    nameLabel: "Nombre de la BitBox02",
    namePlaceholder: "Mi BitBox02",
    title: "Selecciona el nombre de la BitBox02",
    toastMicroSD: "Por favor, inserte su tarjeta microSD en su BitBox02 que se utilizar para almacenar una copia de seguridad de la billetera."
  },
  stepCreateSuccess: {
    removeMicroSD: "Por favor, extrae la tarjeta microSD de tu BitBox02 y gurdala en un lugar seguro. ",
    storeMnemonic: "Guarde sus palabras de recuperacin en un lugar seguro",
    success: "Ha creado su copia de seguridad con xito."
  },
  stepInsertSD: {
    insertSDCard: "Por favor, introduce una microSD en tu BitBox02 para continuar.",
    insertSDcardTitle: "Introduce la tarjeta microSD"
  },
  stepPassword: {
    e104: "Se cancel la configuracin de la contrasea.",
    title: "Establece la contrasea de tu BitBox02",
    useControls: "Utiliza los controles de tu BitBox02 para establecer la contrasea."
  },
  stepUninitialized: {
    create: "Quiero configurar una nueva BitBox02.",
    restore: "Quiero recuperar mi billetera desde una copia de seguridad.",
    restoreMicroSD: "Recupera desde una tarjeta microSD",
    restoreMnemonic: "Restaurar desde las palabras de recuperacin",
    title: "Instala tu BitBox02"
  },
  success: {
    text: `Perfecto! Tu BitBox02 est lista para ser usada. 

Para ms informacin sobre cmo usar la BitBoxApp, por favor utiliza la gua in-app haciendo clic en el signo de interrogacin de la esquina superior derecha. `,
    title: "Estas preparado para usar la billetera BitBox."
  }
}, blink$3 = {
  button: "Parpadeo"
}, bootloader$3 = {
  button: "Actualiza ahora el firmware",
  button_install: "Instalar el nuevo firmware ahora",
  progress: "Actualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Actualizacin completada! Por favor, vuelva a conectar el dispositivo. Esta vez, no toque el botn."
}, button$7 = {
  abort: "Cancel",
  back: "Atrs",
  buy: "Compra",
  changepin: "Cambia contrasea del dispositivo",
  check: "Comprobar la copia de seguridad",
  continue: "Continua",
  copy: "Copia",
  create: "Crea",
  dismiss: "Descartar",
  done: "Hecho",
  download: "Descarga",
  hiddenwallet: "Crea el monedero oculto",
  next: "Siguiente",
  ok: "OK",
  previous: "Anterior",
  receive: "Recibe",
  restore: "Restaurar",
  select: "Selecciona",
  send: "Enva",
  unlock: "Desbloquea",
  update: "Actualiza",
  upgrade: "Actualizar"
}, buy$4 = {
  exchange: {
    bankTransfer: "Transferencia bancaria",
    bestDeal: "La mejor oferta",
    creditCard: "Tarjeta de crdito",
    fast: "Rpido",
    fee: "tarifa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferencia bancaria: {{fee}}%%.",
          creditDebitCard: "Tarjeta de crdito/dbito: {{fee}}%%.",
          learnMore: "Ms informacin sobre Moonpay",
          title: "Tasas"
        },
        fullCurrenciesList: "Consulte aqu la lista completa de monedas",
        payment: {
          asteriskText: "* No disponible para residentes en EE.UU.",
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            pix: "PIX (transacciones BR slo en Brasil)",
            sepa: "SEPA y SEPA Instant (slo transacciones en euros en pases SEPA)",
            uk: "Pagos rpidos en el Reino Unido (transacciones en GBP slo en el Reino Unido)"
          },
          creditDebitCard: "Tarjeta de crdito/dbito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa y Maestro"
          },
          learnMore: "Ver ms detalles sobre los mtodos de pago",
          title: "Formas de pago"
        },
        supportedCurrencies: "Compatible con las principales monedas fiduciarias: USD, EUR, CHF y ms."
      },
      pocket: {
        fees: {
          info: "Transferencia bancaria: {{fee}}% ",
          title: "Tasas"
        },
        learnMore: "Ms informacin sobre Pocket",
        payment: {
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            sepa: "SEPA y SEPA Instant (slo transacciones en euros en pases SEPA)",
            sic: "Swiss Interbank Clearing (transacciones en CHF solo en CH/LI)",
            uk: "UK Faster Payments (transacciones en GBP slo en el Reino Unido)"
          },
          bankTransferReccuring: "Cmo configurar compras recurrentes con una orden permanente? ",
          title: "Formas de pago"
        },
        supportedCurrencies: "Admite monedas europeas: EUR, GBP y CHF. ",
        verification: {
          info: "Solo requiere verificacin de identidad por encima de los puntos de inicio diarios y anuales. ",
          link: "Encuentre los puntos de inicio actuales aqu ",
          title: "Verificacin de identidad "
        }
      },
      region: {
        title: "Seleccione la regin en la que est registrada su cuenta bancaria para ver las opciones disponibles."
      }
    },
    noExchanges: "Lo sentimos, no hay intercambios disponibles en esta regin.",
    region: "Regin",
    selectRegion: "No especificado",
    title: "Comprar {{nombre}}"
  },
  info: {
    continue: "Acepta y continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nos asociamos con MoonPay para ofrecerte una forma sencilla de comprar {{name}} directamente con BitBoxApp. Con unos pocos clics.  ",
        "MoonPay es una plataforma que hace fcil y rpida la compra de {{name}} en ms de 160 pases."
      ],
      payment: {
        details: "Puedes comprar {{name}} inmediatamente a travs de MoonPay con los siguientes mtodos de pago. Los pedidos con tarjeta de crdito o dbito son inmediatos y prcticos, pero ms caros debido al mayor riesgo de retrocesos de cargos a tarjetas. Recomendamos utilizar la opcin de transferencia bancaria para grandes cantidades. La tarifa mnima es de 4 EUR.",
        footnote: "Tenga en cuenta que los tipos de cambio de MoonPay pueden diferenciarse de los utilizados en BitBoxApp, lo que se nota en cantidades ligeramente diferentes.",
        table: {
          "1_description": "Tarifa baja, puede tardar 3 das laborales",
          "1_method": "Transferencias bancarias (SEPA)",
          "2_description": "Tarifas altas pero inmediato y rpido",
          "2_method": "Tarjetas de crdito & dbito",
          description: "Descripcin",
          fee: "Comisin",
          method: "Metodo"
        },
        title: "Mtodos de pago y tarifas"
      },
      privacyPolicy: "MoonPay poltica de privacidad",
      protection: {
        description: "BitBoxApp no recopila ningn dato al comprar {{name}}, los fondos entrantes se tratan como una transaccin normal. MoonPay necesita recoger algunos datos personales para operar. Su Poltica de privacidad explica en detalle cmo se manejan esos datos.",
        descriptionGeneric: "BitBoxApp no recopila ningn dato cuando se compra {{name}}, los fondos entrantes se tratan como una transaccin normal. Sin embargo, las bolsas asociadas necesitan recopilar cierta informacin para operar. Consulta sus respectivas polticas de privacidad para ver con ms detalle cmo se gestionan los datos.",
        title: "Proteccin de Datos"
      },
      security: {
        description: `Cuando compras {{name}} por MoonPay, utilizas un servicio externo. Este servicio est fuera del alcance de la modelacin de riesgos de seguridad BitBox02 y depende de la seguridad y proteccin del entorno en el que se ejecuta el software BitBoxApp.

`,
        descriptionGeneric: "Cuando compras {{name}} a travs de una casa de cambio asociada, ests utilizando un servicio externo. Este servicio est fuera del alcance del modelo de amenazas de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp.",
        link: "Modelacin de riesgos",
        title: "Modelo de seguridad"
      },
      title: "Bienvenido. Estas en el sitio correcto para comprar {{name}}"
    },
    next: "Siguiente",
    selectLabel: "Elige tu cuenta",
    selectPlaceholder: "Seleccione una moneda",
    skip: "No mostrar de nuevo",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Poltica de privacidad de Pocket",
      p1: "La BitBoxApp no recoge ningn dato al comprar bitcoin, los fondos entrantes se tratan como una transaccin normal. Pocket necesita recoger algunos datos personales para funcionar. Su Poltica de Privacidad explica en detalle cmo se manejan esos datos.",
      title: "Proteccin de datos"
    },
    kyc: {
      link: "Preguntas ms frecuentes de Pocket",
      p1: "Pocket intenta reducir al mnimo los requisitos de identificacin. Para compras inferiores a 950 EUR (1000 CHF) al da, no se requieren documentos adicionales. Para compras superiores a esta cantidad, tendrs que programar una llamada con Pocket para completar el proceso KYC/AML necesario.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puedes comprar bitcoin instantneamente con Pocket a travs de una transferencia bancaria SEPA. La comisin es del 1,5% y el bitcoin se deposita en su BitBox lo antes posible despus de que Pocket reciba la transferencia bancaria (normalmente en el mismo da).",
      p2: "Tenga en cuenta que los tipos de cambio de Pocket pueden diferir de los utilizados en la BitBoxApp, dando lugar a importes ligeramente diferentes.",
      title: "Formas de pago y tasas"
    },
    previousTransactions: "El historial de transacciones de esta cuenta no est vaco. Compartir esta cuenta har que todas sus transacciones pasadas y futuras sean visibles para Pocket. Proceder de todos modos?",
    security: {
      link: "Modelo de amenazas a la seguridad BitBox02",
      p1: "Cuando compras bitcoin a travs de Pocket, ests utilizando un servicio externo. Este servicio est fuera del alcance del modelo de amenaza de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp. Sin embargo, trabajamos juntos para mejorar la seguridad utilizando un mecanismo de autenticacin de dos factores para verificar la direccin a la que ests recibiendo.",
      title: "Modelo de seguridad"
    },
    usedAddress: "La direccin {{address}} ya ha sido utilizada, por favor comience de nuevo con una nueva direccin.",
    verifyBitBox02: "Compruebe que la direccin que ha recibido por correo electrnico coincide con la que aparece en su Bitbox. Si es posible, debera abrir el correo electrnico en un segundo dispositivo para mayor seguridad. ",
    welcome: {
      p1: "Nos asociamos con Pocket para ofrecerte una forma sencilla de comprar bitcoin directamente dentro de la BitBoxApp. Es slo un par de clics.",
      p2: "Pocket es una plataforma suiza que facilita y agiliza la compra de bitcoins en la mayor parte de Europa (en cualquier lugar donde se admitan transferencias bancarias SEPA).",
      p3: "Con Pocket, tambin puede hacer compras peridicas a travs de rdenes bancarias permanentes, por lo que puede hacer DCA (dollar-cost averaging) con facilidad.",
      title: "Bienvenido a su ventanilla nica para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
}, changePin$3 = {
  newTitle: "Nueva contrasea del dispositivo",
  oldLabel: "Contrasea actual del dispositivo"
}, chart$4 = {
  dataMissing: "Recopilando tus datos histricos. Permanece atento.",
  dataOldTimestamp: "Actualizacin de los tipos de cambio histricos. El grfico no muestra datos despus de {{time}}.",
  dataUpdating: "actualizando datos",
  filter: {
    all: "Todo",
    month: "Mes",
    week: "Semana",
    year: "Ao"
  }
}, checkSDcard$3 = "comprobando tarjeta micro SD", clickHere$3 = "Haz clic aqu.", confirm$5 = {
  abortInfo: "Toque para ",
  abortInfoRedText: "Cancel",
  approveInfo: "Mantenga 4+ segundos para ",
  approveInfoGreenText: "confirma",
  info: "Continua en tu Bitbox",
  infoWhenPaired: "Primero en el mvil sincronizado y luego tu BitBox"
}, confirmOnDevice$3 = "Por favor confirma en tu dispositivo.", connectKeystore$3 = {
  promptNoName: "Por favor conecta tu BitBox02 para continuar",
  promptWithName: 'Por favor, conecta tu BitBox02 llamada "{{nombre}}" para continuar '
}, darkmode$3 = {
  toggle: "Modo oscuro"
}, device$3 = {
  appUpradeRequired: "Tu BitBox no es compatible con esta aplicacin de escritorio. Por favor descarga e instale la ltima versin.",
  keystoreConnected: "Billetera conectada"
}, deviceLock$3 = {
  button: "Activa autorizacin de dos factores (2FA)",
  condition1: "Tienes una copia de seguridad?",
  condition2: "Funciona la verificacin de la aplicacin mvil?",
  condition3: "2FA DESACTIVA las copias de seguridad y la sincronizacin con las aplicaciones mviles. El dispositivo debe ser REINICIADO para salir de 2FA!",
  confirm: "Activa autorizacin de dos factores (2FA)",
  title: "Activa autorizacin de dos factores (2FA)"
}, deviceSettings$3 = {
  backups: {
    manageBackups: {
      description: "Crea o verifica la copia de seguridad de tu tarjeta microSD."
    },
    showRecoveryWords: {
      description: "Mostrar y verificar palabras de recuperacin."
    },
    title: "Copias de seguridad"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp comprueba si tu dispositivo es autntico."
    },
    deviceName: {
      description: "Cambia el nombre de tu dispositivo."
    },
    rootFingerprint: {
      description: "La huella raz es un identificador nico para la billetera actualmente en uso. Puede ayudarte a distinguir entre diferentes billeteras si utilizas frases de contrasea."
    },
    securechip: {
      description: "El modelo del chip seguro."
    },
    title: "Informacin del dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Restablece tu dispositivo a los valores de fbrica. Esto borra la billetera de tu BitBox02!",
      title: "Restablecimiento de fbrica"
    },
    goToStartupSettings: {
      description: "Entra en el bootloader de la BitBox02. Puedes activar el hash del firmware desde aqu."
    },
    passphrase: {
      description: "",
      title: "Contrasea"
    }
  },
  firmware: {
    firmwareVersion: "Versin del firmware",
    newVersion: {
      label: "Versin disponible"
    },
    title: "Firmware",
    upToDate: "Tu dispositivo est actualizado.",
    upgradeAvailable: "Nueva actualizacin disponible",
    version: {
      label: "Versin"
    }
  },
  hardware: {
    attestation: {
      false: "Error en la comprobacin de autenticidad",
      label: "Comprobacin de autenticidad",
      true: "Su BitBox02 es autntico"
    },
    sdcard: {
      false: "No insertado",
      label: "Tarjeta micro SD",
      true: "Insertado"
    },
    securechip: "Chip de seguridad",
    title: "Hardware"
  },
  loading: "Recuperando informacin del dispositivo ...",
  pairing: {
    lock: {
      false: "Desactivado",
      label: "Autorizacin de dos factores (2FA)",
      true: "Activado"
    },
    mobile: {
      false: "Cerrado",
      label: "Aplicacin mvil",
      true: "Abre"
    },
    status: {
      false: "No sincronizado",
      label: "Estado",
      true: "Sincronizado"
    },
    title: "Sincronizacin"
  },
  secrets: {
    manageBackups: "Administrar copias de seguridad",
    title: "Seguridad"
  }
}, deviceTampered$3 = "Tu BitBox ha sido suministrado con una contrasea de recuperacin? Si es as, detenga el proceso de configuracin y ponte en contacto con el servicio de asistencia inmediatamente. Shift nunca te dar una billetera confeccionado ni har recomendaciones de contrasea.", dialog$4 = {
  cancel: "Cancela",
  confirm: "Confirma",
  confirmTitle: "Confirmacin"
}, error$4 = {
  accountAlreadyExists: "La cuenta ya existe.",
  accountLimitReached: "No se puede aadir la cuenta. El nmero mximo de cuentas para esta moneda ha sido alcanzado.",
  aoppCallback: "Ha habido un error entregando la direccin a{{host}}.",
  aoppInvalidRequest: "Solicitud invlida.",
  aoppNoAccounts: "No hay cuentas disponibles.",
  aoppSigningAborted: "Solicitud de propiedad de la direccin cancelada.",
  aoppUnknown: "Un error desconocido ha ocurrido.",
  aoppUnsupportedAsset: "El activo no es soportado.",
  aoppUnsupportedFormat: "No hay cuentas disponibles que soporten el formato de direcciones solicitado.",
  aoppUnsupportedKeystore: "El dispositivo conectado no puede firmar mensajes para este activo.",
  aoppVersion: "Versin desconocida.",
  wrongKeystore: "Se ha conectado una billetera incorrecta. Por favor, asegrese de insertar el dispositivo correcto que coincida con esta cuenta.",
  wrongKeystore2: " Si utiliza la frase de contrasea opcional, asegrese de haber introducido la frase de contrasea correcta para la cuenta."
}, fiat$5 = {
  default: "predeterminado",
  setDefault: "Establecer {{code}} predeterminado",
  title: "Monedas"
}, footer$5 = {
  appVersion: "Versin de app:"
}, generic$4 = {
  enabled_false: "Desactivado",
  enabled_true: "Activado"
}, genericError$3 = "Ocurri un error. Si observa algn problema, por favor reinicie la aplicacin.", goal$3 = {
  buttons: {
    create: "Crear una billetera nueva",
    restore: "Restaurar una billetera desde una copia de seguridad"
  },
  paragraph: "Por favor, selecciona una de las siguientes opciones:",
  step: {
    1: {
      title: "Informacin de seguridad"
    },
    2: {
      description: "Establece una contrasea del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crear una billetera nueva",
      title: "Billetera"
    },
    "3-restore": {
      description: "desde una copia de seguridad",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumen"
    },
    "4-restore": {
      title: "Resumen"
    }
  }
}, guide$4 = {
  accountDescription: {
    text: "Este es el resumen de tu cuenta. Muestra las transacciones entrantes y salientes. El saldo se muestra para cada cuenta por separado. Consulta la gua de configuracin para obtener ms informacin sobre los diferentes tipos de cuentas.",
    title: "Qu me muestra esta pgina?"
  },
  accountFiat: {
    text: "S. Puedes hacer clic en cualquier ticker para rotar a travs de varias monedas fiat. Tambin puedes cambiar la lista de monedas en la configuracin.",
    title: "Puedo mostrar otros tipos de cambio?"
  },
  accountIncomingBalance: {
    text: '"Entrante" resume los importes transferidos pero que todava no han sido confirmados por la red.',
    title: 'Qu significa "Entrante"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: `Cada xpub est relacionada con el "Tipo" mostrado: tanto "Native Segwit (bech32)", "Wrapped Segwit" como "Taproot" (Bitcoin only). Estos son tipos de script utilizados por {{coinName}}. La BitBoxApp las combina, soportando mltiples tipos de script en la misma cuenta. Porque cada tipo de script proporciona una xpub diferente, hay mltiples xpubs por cuenta.

Si constantemente recibe en la direccin por defecto (Native Segwit), solo necesita la "bech32" xpub. Sin embargo, si tambin recibe fondos en "Wrapped Segwit" o "Taproot", tambin necesitara utilizar las claves pblicas extendidas de "Wrapped Segwit" y "Taproot" respectivamente.`,
      title: "Porqu hay mltiples xpubs?"
    },
    privacy: {
      text: `Para esta cuenta especfica, la clave pblica extendida revela todo el historial financiero, el balance en la cuenta, y todas las transacciones futuras. Pero el xpub no permite que nadie gaste tus monedas.

Si le proporcionas una xpub a alguien, debers tener en cuenta que esa persona o empresa pueden ver otras transacciones de la misma cuenta. Por lo tanto, es una buena idea utilizar esa cuenta solamente con ese propsito y guardar otros fondos en cuentas diferentes.`,
      title: "Necesito guardar mi xpub en secreto?"
    },
    verify: {
      text: "Si, siempre es una buena idea hacer una doble verificacin de tu xpub. Si alguien va a generar direcciones a partir de esta xpub para mandarte dinero, esto es especialmente importante. Tendr que verificarla en el dispositivo para asegurarse que esa xpub le pertenece; en caso contrario, todos los fondos podran ir a direcciones incorrectas.",
      title: "Necesito verificar la xpub en el dispositivo?"
    },
    xpub: {
      text: `Una clave pblica extendida (xpub) es una clave raz de la cual se obtienen todas las direcciones de recepcin de una cuenta.
Se proporciona para uso avanzado e interoperabilidad con billeteras watch-only, como Electrum o Sentinel. Si recibe otro tipo de direcciones, por favor importe todos los formatos de xpub en la billetera watch-only para poder visualizar todas las monedas.
Tenga en cuenta que, las billeteras de terceros puede que no soporten Taproot xpubs todava.`,
      title: "Qu es una clave pblica extendida?"
    }
  },
  accountRates: {
    text: "Los tipos de cambio se actualizan cada minuto desde CoinGecko.",
    title: "Qu tipo de cambio se utiliza?"
  },
  accountReload: {
    text: "No hace falta. Toda la informacin de las transacciones se actualiza automticamente.",
    title: "Puedo recargar el historial de transacciones?"
  },
  accountSendDisabled: {
    text: 'El botn "Enviar" se activa cuando tu saldo es mayor que cero.',
    title: "Por qu no puedo enviar ningn {{unit}}?"
  },
  accountSummaryAmount: {
    text: `La cantidad total es la suma de todas tus cuentas criptogrficas. Los tipos de cambio se consiguen de coingecko.com.

Nota: Si usas MyEtherWallet para tokens no admitidos en BitBoxApp, no se incluirn en la cantidad que se muestra.`,
    title: "Cmo se calcula la suma total?"
  },
  accountSummaryDescription: {
    text: "Aqu puede ver el rendimiento de tu billetera a lo largo del tiempo. Debajo del grfico se muestra un resumen de sus cuentas criptogrficas individuales.",
    title: "Qu me muestra esta pgina?"
  },
  accountTransactionAttributesBTC: {
    text: `Tamao virtual: se utiliza para determinar la tarifa de la red. Habrs ahorrado con xito en comisiones si son ms pequeas que la transaccin.
Tamao: Tamao real de la transaccin en bytes cuando se presenta por entregas de acuerdo con la blockchain por debajo.
Peso: Introducido con Segwit, es una nueva mtrica para evaluar los tamaos de transaccin y bloque. Cada byte testigo segregado cuenta como uno, todo lo dems como cuatro unidades de peso. En lugar de un megabyte en tamao real, el lmite de tamao de bloque ahora es de cuatro millones de unidades de peso.`,
    title: "Detalles de la transaccin relacionados con Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmaciones: Cuando tu transaccin se transmita por primera vez, no se confirmar. Tienes que esperar a que un minero lo incluya en un bloque, despus de lo cual tendr 1 confirmacin. Desde ese momento, cada bloque transmitido en la red agregar otra confirmacin a tu transaccin. En general, los comerciantes y otros actores de la red solo aceptarn transacciones con confirmaciones de entre 3-6 antes de considerar la transaccin como liquidada.
ID de transaccin: un nmero de identificacin nico que se puede usar para buscar una transaccin en un explorador de bloques.
Cuota: los mineros reciben una tarifa de transaccin como incentivo para incluir las transacciones en los bloques que explotan. Para obtener ms informacin, haz clic en el botn enviar.`,
    title: "Cul es la informacin que se muestra en los detalles de la transaccin?"
  },
  accountTransactionConfirmation: {
    text: "Esta es una transaccin que se ha transmitido a la red y espera ser confirmada.",
    title: "Qu es una transaccin pendiente?"
  },
  accountTransactionLabel: {
    text: `Es la direccin donde recibiste o enviaste tus monedas. 
Una direccin codifica cmo (y por lo tanto, por quin) se pueden gastar las monedas.`,
    title: "Qu direccin se muestra para cada transaccin?"
  },
  accountTransactionTime: {
    text: "El tiempo que la transaccin ha sido confirmada en el blockchain.",
    title: "Qu hora se muestra?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin y Litecoin pueden tener una cantidad arbitraria de cuentas. Despus de cinco cuentas, slo se puede aadir otra cuenta si se ha utilizado la anterior. 
Otras monedas pueden tener un mximo de cinco cuentas.`,
      title: "Cuntas cuentas puedo crear?"
    },
    howtoAddTokens: {
      text: 'Tokens que utilicen el estndar ERC20 estn conectados a una cuenta especfica de Ethereum. Para permitir o inutilizar un token en particular, abra la ventana de "Administrar cuentas", despliegue su cuenta Ethereum y active o desactive su token deseado.',
      title: "Cmo puedo aadir tokens adicionales?"
    },
    moveFunds: {
      text: "Si. Pero porque las cuentas son independientes, necesitar enviar los fondos utilizando una transaccin normal.",
      title: "Puedo mover fondos entre cuentas?"
    },
    recoverAccounts: {
      text: "Si. La BitBoxApp crea cuentas utilizando estndares muy establecidos compatibles con la mayora de otras carteras crypto.",
      title: "Puedo recuperar mis cuentas de otras carteras?"
    },
    whatAreAccounts: {
      text: "Su cartera puede administrar cuentas de la misma moneda. Las cuentas son tiles cuando se quiere guardar los fondos de forma separada.",
      title: "Qu son las cuentas?"
    },
    whatIsRememberWallet: {
      text: `Activando "Recordar billetera" podrs ver las cuentas de esta billetera en la BitBoxApp incluso cuando la BitBox02 no est conectada. Esto te permite comprobar tu saldo y portafolio siempre que quieras. La BitBox02 necesita estar conectada y desbloqueada para enviar o recibir monedas.

Desactivar "Recordar billetera" requiere que conectes la BitBox02 respectiva (o frase de contrasea) para ver esas cuentas en la BitBoxApp.`,
      title: 'Qu ocurre cuando activo/desactivo "Recordar billetera"?'
    },
    whyIsThisUseful: {
      text: 'Las cuentas son geniales para la gestin de fondos para diferentes personas o propsitos porque estn separados. Tambin puede compartir la "clave pblica extendida" de una cuenta sin revelar nada sobre las otras cuentas. Esto permite recibir fondos repetidamente sin reutilizar direcciones, tanto para recibir su salario o comprar crypto de forma habitual.',
      title: "Porqu es esto til?"
    }
  },
  appendix: {
    link: "Contacta con nosotros!",
    text: "Otra pregunta?"
  },
  backups: {
    check: {
      text: '"Comprobar copia de seguridad" te permite verificar que tienes una copia de seguridad operativa correspondiente a tu monedero actual. Tambin se puede usar para verificar que todava tienes la contrasea de recuperacin correcta. Puedes verificar tu contrasea de recuperacin principal o tu contrasea de recuperacin oculta.',
      title: "Qu es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: "No, pero necesitas tu contrasea de recuperacin para obtener el monedero de la semilla guardada.",
      title: "Puedo encriptar la copia de seguridad?"
    },
    howOften: {
      text: `La copia de seguridad se genera automticamente cuando se crea un nuevo monedero. Slo tienes que hacer una nueva copia de seguridad si tu tarjeta micro SD est perdida o daada, o si quieres usar varias tarjetas micro SD como copias de seguridad.
No es necesario crear nuevas copias de seguridad despus de la actividad de transaccin. Todos tus datos de transaccin pueden ser recreados por tu nica copia de seguridad que se gener automticamente para ti.`,
      title: "Con qu frecuencia tengo que hacer una copia de seguridad?"
    },
    whatIsABackup: {
      text: "Esto es una copia de la semilla en una tarjeta micro SD. La semilla junto con tu contrasea de recuperacin genera tu monedero.",
      title: "Qu es una copia de seguridad?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Comprobar copia de seguridad' te permite verificar que tienes una copia de seguridad funcional y que corresponde a tu monedero actual.",
      title: "Qu es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: 'No. Por favor mantn la microSD en un lugar seguro porque contiene la semilla para recuperar tu monedero sin encriptar. Si deseas proteger con contrasea tu semilla, puedes activar una frase de contrasea (passphrase) opcional en los ajustes, debajo de "Ajustes del dispositivo". ',
      title: "Puedo encriptar la copia de seguridad?"
    },
    whatIsABackup: {
      text: "Es una copia de la semilla en la tarjeta microSD.",
      title: "Qu es una copia de seguridad?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Cuando 2FA est habilitado, todas las transacciones deben aprobarse en el telfono mvil sincronizado para poder gastar monedas. Tcnicamente, se enva un nmero encriptado de un solo uso a la aplicacin mvil, donde se descifra y se devuelve al BitBox al presionar el botn Aceptar. Esta comunicacin con el dispositivo se realiza a travs del canal entre el telfono mvil y esta aplicacin de escritorio establecida durante la sincronizacin.

Asegrate de hacer una copia de seguridad de tu monedero y sincroniza la aplicacin mvil antes de habilitar 2FA. Una vez habilitado, las sincronizaciones entre la ranura micro SD y las aplicaciones mviles se deshabilitan. Se pueden volver a habilitar reiniciando el BitBox, algo que borrar el dispositivo.`,
      title: "Cmo funciona la autorizacin de dos factores (2FA)?"
    },
    disable2FA: {
      text: `Para deshabilitar 2FA, debes restablecer su BitBox y luego restaurar el monedero desde su copia de seguridad. Asegrate de que todava tienes la tarjeta micro SD con la copia de seguridad y que an recuerdas la contrasea de recuperacin. Luego pulsa 'Restablecer dispositivo'. Establece una nueva contrasea de dispositivo y elija 'O restaurar una copia de seguridad'. Selecciona la copia de seguridad que has hecho del monedero, haz clic en "Restaurar" e ingresa la contrasea de recuperacin que utilizaste al crear el monedero.`,
      title: "Cmo puedo desactivar la autorizacin de dos factores (2FA)?"
    },
    ejectBitbox: {
      text: "Puedes desconectar el BitBox en cualquier momento sin tener que expulsarlo primero.",
      title: "Cmo puedo expulsar el BitBox?"
    },
    ejectSD: {
      text: "Puedes retirar la tarjeta micro SD de BitBox en cualquier momento siempre que no est en el proceso de crear o restaurar una copia de seguridad.",
      title: "Cmo puedo expulsar la tarjeta micro SD?"
    },
    hiddenWallet: {
      text: "Es un segundo monedero en el mismo dispositivo protegido por una contrasea de dispositivo y una contrasea de recuperacin diferentes, que puedes usar para una negacin creble. La misma semilla de copia de seguridad se usa para tu monedero normal y oculto, por lo que no se requiere una copia de seguridad adicional.",
      title: "Qu es un monedero oculto?"
    },
    legacyHiddenWallet: {
      text: "Primero haz clic en el botn de abajo (disponible si el BitBox est desbloqueado con la contrasea del dispositivo principal y la 2FA est desactivada), luego vuelve a conectar su Bitbox y desbloquea con la contrasea oculta del dispositivo.",
      title: "Cmo accedo el monedero oculto heredado?"
    },
    pairing: {
      text: "Despus de haber descargado nuestra aplicacin mvil para iOS o Android, escanea el cdigo QR mostrado, que establece un canal seguro entre la aplicacin mvil y esta aplicacin. Una vez escaneado, sige las instrucciones en la aplicacin mvil.",
      title: "Cmo sincronizo de forma segura con mi telfono"
    }
  },
  cointracking: {
    text: `Haga click en el botn "Exportar" y abra la carpeta de descargas donde encontrar el CSV exportado.
A continuacin haga click en el enlace de abajo, cargue su archivo BitBox CSV e importe los datos para ser utilizados por su gestor de CoinTracking y crear sus informes fiscales.`,
    title: "Cmo importar mis transacciones a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Ms informacin sobre el control de autenticidad"
      },
      text: "La BitBoxApp realiza una comprobacin de atestacin en la BitBox02 para verificar si el dispositivo es genuino. La comprobacin se realiza localmente y no se conecta a ningn servidor.",
      title: "Cmo funciona el control de autenticidad?"
    },
    name: {
      text: "Este es el nombre de tu wallet y de la copia de seguridad. El nombre se utiliza para futuras copias de seguridad y se puede utilizar para ayudar a distinguir entre diferentes billeteras. Se puede cambiar en cualquier momento, pero ten en cuenta que las copias de seguridad realizadas antes del cambio seguirn utilizando el nombre anterior.",
      title: "Para qu se utiliza el nombre BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Ms informacin sobre el chip seguro"
      },
      text: "Esta informacin muestra el nmero de modelo del chip seguro, el chip ms actualizado es ATECC608B con caractersticas de seguridad mejoradas en comparacin con los modelos anteriores.",
      title: "Por qu mostrar el modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Puedes dar la direccin a otras personas para que te enven monedas. Solo tienes que asegurarte de que enven a la direccin correcta.",
      title: "Qu hago con una direccin?"
    },
    addressChange: {
      text: "En cuanto se utilice una direccin en una transaccin, se agrega una nueva direccin a la lista para reemplazarla. Siempre habr 20 direcciones no utilizadas disponibles en la lista.",
      title: "Cundo cambian las direcciones?"
    },
    addressFormats: {
      text: `Por defecto, el tipo de direccin es Native Segwit. Esta direccin es ampliamente adoptada por otras carteras/exchanges y proporciona las mejores comisiones para las transacciones del da a da. En cambio, se puede elegir enviar a Taproot (Bitcoin Only), que es el ltimo tipo de direcciones, pero puede que no sea ampliamente soportada todava. Como alternativa, si tiene complicaciones enviando a Native Segwit (el tipo de direccin por defecto), puede intentar cambiar al antiguo tipo de direccin Wrapped Segwit que puede ser compatible con mas carteras/exchanges.
`,
      title: 'Cundo utilizar "cambio de tipo de direccin"?'
    },
    howVerify: {
      text: `Para la BitBox01, haz clic en el icono BitBox en la barra lateral de la izquierda y revisa las opciones de emparejamiento. Esta gua se actualizar y podrs seguir las nuevas instrucciones desde all.
Para la BitBox02, puedes verificar las direcciones directamente en tu dispositivo durante el proceso de envo y recepcin. `,
      title: "Cmo puedo verificar una direccin de forma segura?"
    },
    plugout: {
      text: "No, una vez ha enviado las monedas a su direccin de BitBox, no tendr que dejar su BitBox enchufada. Puede desconectar su BitBox cuando quiera.",
      title: "Necesito dejar conectada mi BitBox mientras recibo?"
    },
    why20: {
      text: 'Durante la inicializacin, la app genera direcciones derivadas de tu semilla para ver si han recibido fondos. Como la app puede generar un nmero casi infinito de direcciones, se podra pasar aos determinando el saldo. Para limitar esta bsqueda se para despus de encontrar 20 direcciones que nunca han recibido fondos. Esto es un "intervalo lmite" y  20 es el estndar de-facto aunque el nmero es arbitrario. Estas son las 20 direcciones que puedes escoger.',
      title: "Por qu solo 20 direcciones?"
    },
    whyMany: {
      text: "Por razones de privacidad y seguridad, nunca debes utilizar la misma direccin dos veces. Haz clic en 'Siguiente' para obtener una nueva direccin para un propsito diferente. Puedes generar hasta 20 direcciones a la vez. Todas las direcciones se derivan de tu semilla nica de la copia de seguridad.",
      title: "Por qu hay tantas direcciones?"
    },
    whyVerify: {
      text: "Una de las razones por las que comprar una cartera de hardware como la BitBox es que no debes confiar en tu ordenador debido a sus numerosos vectores de ataque. No debes confiar en que tu ordenador genere y muestre direcciones autnticas. El botn para verificar la direccin de manera segura hace que BitBox enve la direccin a un telfono mvil sincronizado, desde el cual tambin puedes escanear y verificar el cdigo QR.",
      title: "Por qu debo verificar la direccin de forma segura?"
    }
  },
  send: {
    change: {
      text: "El cambio ser devuelto a una direccin Taproot si al menos tiene un UTXO Taproot. Si utiliza coin control, el cambio ser devuelto a una direccin Taproot si al menos hay un Taproot UTXO entre los UTXOs seleccionados. En el resto de casos, el cambio ser devuelto a una direccin Native Segwit.",
      title: "Cmo se determina la direccin de cambio?"
    },
    fee: {
      text: `La tarifa se basa en el tamao de los datos de la transaccin y no en su cantidad. Los objetivos de tiempo de la tarifa se calculan mediante el algoritmo de estimacin de tarifa de Bitcoin Core para cada prioridad de red que elijas. Sern mostrados si tienen un valor diferente del siguiente objetivo.
Econmico: 24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)
Bajo: 12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)
Normal: 6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)
Alto: 2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)
(Un bloque de Bitcoin tarda un promedio diez minutos para que se mine (2.5 minutos en Litecoin), y la congestin de la red puede hacer variar considerablemente los perodos arriba mencionados).`,
      title: "Cmo se determina la comisin?"
    },
    plugout: {
      text: "No, una vez ya ha realizado la transaccin, no necesita dejar su BitBox conectada. Puede desconectar su BitBox cuando quiera.",
      title: "Necesito dejar mi BitBox conectada mientras envo?"
    },
    priority: {
      text: "Cuanto mayor sea la comisin que ests dispuesto a pagar, ms rpido se confirmar tu transaccin por la red.",
      title: "Cul es la prioridad de la red?"
    },
    revert: {
      text: `Una vez que se firma y se enva una transaccin (que se transmite a la red), ya no puede revertirse. Verifica las transacciones (tambin la comisin) correctamente antes de firmar!
Si conoces al destinatario y l o ella est dispuesto a enviarte la misma cantidad de vuelta (menos los cargos por transaccin), puedes entonces enviarle una nueva direccin de recepcin.`,
      title: "Puedo revertir una transaccin?"
    },
    whyFee: {
      text: `Las transacciones compiten para ser confirmadas por un minero. Los mineros eligen las transacciones que se incluirn en la blockchain en funcin de tu tarifa.
Los mineros votan sobre el historial de las transacciones. Dado que no hay un tercero de confianza para imponer un voto por persona (que es el eje central de las blockchains), los mineros votan sobre las transacciones sacrificando un recurso caro como la potencia de clculo. Como recompensa por su trabajo, pueden reclamar monedas recin creadas y la tarifa de todas las transacciones que incluyeron.`,
      title: "Por qu hay una tarifa de red?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Si solo tiene la intencin de conectarse a tu nodo cuando est en la misma red (por ejemplo, la red wifi de tu hogar), entonces es suficiente usar la comunicacin de red regular.
En este caso, es recomendable que el servidor Electrum proporcione un certificado TLS para encriptar la comunicacin.
Si tu intencin es conectarse a tu nodo desde cualquier lugar, usar Tor es la mejor opcin. En ese caso, no es necesario ningn certificado TLS.

`,
      title: "Debo usar Clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Gua para conectar tu nodo"
      },
      text: "Para el tutorial competo, por favor visita nuestra gua: ",
      title: "Como conecto mi BitBoxApp con mi nodo?"
    },
    options: {
      text: `Hay varias opciones para usar su propio nodo, como comprar un dispositivo terminado, construir el tuyo propio o usar Bitcoin Core.
Si quieres conectar tu BitBoxApp a tu nodo, asegrate de que ejecutas un servidor Electrum. Este es un programa que permite que una app del monedero se comunica con su nodo completo.
Las opciones  incluyencompatibles Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).`,
      title: "Qu opciones existen para ejecutar un nodo?"
    },
    tor: {
      text: `Tor significa 'The Onion Router', es un software gratuito y de fuente abierta que ofrece muchos beneficios de privacidad. Es muy til cuando se usa Bitcoin.
Si tienes la intencin de conectarte a su nodo a travs de Tor, asegrate de que Tor est instalado en tu ordenador y luego activa Tor Proxy en la configuracin de BitBoxApp.
En la mayora de los sistemas operativos, hay dos formas de ejecutar Tor:
1. Tor Browser: descarga y abre el Tor Browser. Esto permitir que BitBoxApp se conecte a la red Tor configurando el puerto 9150 en la configuracin del proxy Tor.
2. Servicio Tor en segundo plano: instala el Tor daemon, que siempre se usa en segundo plano. BitBoxApp puede conectarse configurando el puerto 9050 en la configuracin del proxy Tor.

`,
      title: "Que es un Tor, Tor proxy y en que puerto lo debera usar?"
    },
    what: {
      text: "Es posible conectar tu wallet a tu propio nodo completo Bitcoin en vez de utilizar los servidores Shift.",
      title: "Qu es esto?"
    },
    why: {
      text: `No es necesario ejecutar su propio nodo, pero mejora la privacidad y reduce la necesidad de confiar en los dems.
En primer lugar, significa que ests utilizando Bitcoin de forma ms privada, ya que BitBoxApp no se conectar a nuestros servidores para recuperar su historial de transacciones; en su lugar, obtendr esa informacin de su propio nodo.
En segundo lugar, ejecutar tu propio nodo significa que tu nodo verifica todas las transacciones por s mismo, asegurndose de que se cumplan las reglas de consenso.`,
      title: "Por qu debera ejecutar mi propio nodo?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" para abreviar) es la unidad ms pequea de Bitcoin. Un Satoshi es la cienmillonsima parte de un bitcoin (0,00000001 BTC). Debe su nombre al creador de Bitcoin, Satoshi Nakamoto.',
      title: "Qu es un Satoshi?"
    },
    servers: {
      text: `Esta aplicacin se comunica con los servidores de Shift Crypto para buscar actualizaciones, cargar transacciones y enviar informacin a aplicaciones mviles sincronizadas.
Adems, recupera los ltimos tipos de cambio de CoinGecko. Todas las conversiones se calculan de forma local lo que significa que no se envan las cantidades que uno tiene a ningn servidor. 
Nota: Para Ethereum y tokens ERC20, utilizamos la API de Etherscan.io`,
      title: "Con qu servidores se comunica esta aplicacin?"
    }
  },
  title: "Gua",
  toggle: {
    close: "Cerrar la gua",
    open: "Gua"
  },
  trackingModePortfolioChart: {
    text: "En el ordenador de sobremesa, site el cursor sobre el grfico. En mvil, mantn el dedo sobre el grfico y arrstralo horizontalmente.",
    title: "Cmo ver los valores histricos en el grfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Debe restablecer el dispositivo y recuperar el mondero desde una copia de seguridad, utilizando la contrasea de recuperacin.",
      title: "Qu hago si olvido la contrasea del dispositivo?"
    },
    reset: {
      text: "Introduzca una contrasea de dispositivo incorrecta 15 veces. Los ltimos intentos requieren mantener pulsado el dispositivo .",
      title: "Cmo reinicio el dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `El dispositivo debe parpadear una vez se haya insertado. Asegrese de que se inserta de la manera correcta. Si tiene problemas, por favor contctenos a travs del siguiente enlace.
La BitBox01 no es soportada en los mviles/celulares. Por favor utilice la BitBoxApp de escritorio para conectar su BitBox01.`,
      title: "Mi dispositivo no est reconocido"
    },
    getDevice: {
      link: {
        text: "Encargue un BitBox"
      },
      text: "Puedes comprar un BitBox en nuestra tienda online:",
      title: "Cmo puedo obtener un dispositivo?"
    },
    internet: {
      text: "S, se necesita una conexin a Internet para sincronizar el monedero, enviar transacciones y recuperar los ltimos tipos de cambio.",
      title: "Esta aplicacin requiere conexin a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de respaldo (backup)"
      },
      text: "Puede recuperar sus cuentas en un nuevo BitBox o con nuestro centro de copia de seguridad.",
      title: "Perd mi dispositivo. Ahora qu?"
    },
    useWithoutDevice: {
      text: "Lamentablemente, esto todava no es posible en este momento.",
      title: "Puedo usar la aplicacin sin un dispositivo?"
    },
    welcome: {
      text: "Gracias por utilizar esta aplicacin creada por Shift Crypto en Suiza. Todava est en beta y agradecemos cualquier comentario que tenga que compartir. Por favor, de su opinin utilizando el enlace en la parte inferior.",
      title: "Bienvenido a la aplicacin de BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si ests usando un nuevo telfono/ordenador con la BitBoxApp, entonces tendrs que conectarte de nuevo a la DApps. A continuacin, ver sus monedas en la dapp de nuevo como de costumbre.",
      title: "No veo mis conexiones previas."
    },
    supportedNetworks: {
      text: "Actualmente, slo Ethereum mainnet es compatible utilizando WalletConnect en la BitBoxApp. Para utilizar otras cadenas compatibles con EVM, por favor utilice la extensin de navegador Rabby wallet.",
      title: "Qu redes son compatibles?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect es un protocolo de comunicacin para aplicaciones web3. Permite conectarse cmodamente a DApps basadas en Ethereum y billeteras web sin necesidad de utilizar una app de terceros, lo que resulta especialmente til para los usuarios de Android de la BitBoxApp.",
      title: "Qu es WalletConnect?"
    }
  }
}, headerssync$3 = {
  blocksSynced: "{{blocks}} bloques sincronizados"
}, hiddenWallet$3 = {
  info1HTML: "Para fines de negacin plausible, se puede crear un monedero oculto basada en una <strong>diferente</strong> combinacin de contrasea de recuperacin y contrasea del dispositivo.",
  info2HTML: "Defina la contrasea del dispositivo y la contrasea de recuperacin que quieres asociar con su monedero oculto a continuacin. La contrasea del dispositivo y la contrasea de recuperacin deben ser <strong>diferentes</strong> de los que has definido para tu monedero principal.",
  passwordLabel: "Contrasea de recuperacin oculta",
  passwordPlaceholder: "Por favor confirma la contrasea de recuperacin oculta",
  pinLabel: "Contrasea oculta del dispositivo",
  pinRepeatLabel: "Repita la contrasea del dispositivo oculto",
  pinRepeatPlaceholder: "Por favor confirma la contrasea oculta del dispositivo",
  success: "Monedero oculto creado con xito. Vuelve a enchufar tu BitBox para desbloquearlo."
}, initialize$3 = {
  create: "Establece contrasea del dispositivo",
  creating: "Configuracin de la contrasea del dispositivo ...",
  error: {
    e102: "La contrasea del dispositivo debe constar de al menos 4 caracteres."
  },
  info: {
    description1: "Elije la contrasea de tu dispositivo. Esto se utilizar para desbloquear su BitBox.",
    description2: "Puedes usar nmeros, letras y smbolors. Las contraseas largas ofrecen mayor seguridad.",
    description3: "Si pierdes la contrasea del dispositivo, tendrs que restablecer tu dispositivo y recuperar la copia de seguridad de su monedero.",
    subtitle: "Ahora configurar la contrasea de su dispositivo.",
    title: "Iniciando su dispositivo"
  },
  input: {
    label: "Contrasea del dispositivo",
    labelRepeat: "Repita la contrasea del dispositivo",
    placeholderRepeat: "Por favor confirma la contrasea del dispositivo"
  }
}, invalidFormat$3 = "Formato invlido", language$4 = {
  title: "Selecciona el idioma"
}, legacyhiddenwallet$3 = {
  disable: "Desactiva monedero oculto heredado",
  enable: "Activa monedero oculto heredado",
  successDisable: "Se desactiv con xito el legado del monedero oculto.",
  successEnable: "El monedero oculto heredado se habilit con xito. Vuelva a enchufar su BitBox e ingresa la contrasea del dispositivo oculto para acceder al monedero oculto heredado."
}, loading$3 = "cargando", manageAccounts$2 = {
  accountHidden: "Esta cuenta ha sido ocultada de tus cuentas de slo vigilancia. Para volver a verla, conecta tu BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nombre de cuenta",
  noAccounts: "No se han encontrado cuentas",
  settings: {
    hideTokens: "Ocultar tokens",
    showTokens: "Mostrar tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aadir y mostrar/ocultar cuentas",
  title: "Administrar cuentas",
  watchAccount: "Cuenta de vigilancia",
  watchAccountDescription: "Esta cuenta forma parte de tus cuentas de vigilancia. Puedes ocultarla de tus cuentas de solo vigilancia utilizando el conmutador."
}, mobile$3 = {
  usingMobileDataWarning: `Uso de datos mviles: esta aplicacin puede descargar hasta unos cientos de megabytes de datos de blockchain despus de desbloquear una cuenta. Por favor, conctate a una red Wi-Fi para evitar el uso de datos mviles. Despus de descartarlo, este mensaje no se mostrar nuevamente.

`
}, newSettings$2 = {
  about: {
    appVersion: {
      title: "Versin de la aplicacin"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloquea el acceso a la aplicacin con bloqueo de pantalla/huella dactilar.",
      title: "Bloqueo de pantalla"
    },
    coinControl: {
      description: ""
    },
    customFees: {
      description: "Le permite introducir su propia tarifa al enviar."
    },
    torProxy: {
      description: "Conctate a travs de Tor para mejorar la privacidad."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Estas monedas adicionales se pueden cambiar a travs de la pgina de su cuenta.",
      title: "Divisas activas"
    },
    darkmode: {
      description: "Ver la BitBoxApp en modo oscuro."
    },
    defaultCurrency: {
      description: "Selecciona tu moneda predeterminada",
      title: "Moneda predeterminada"
    },
    enableWallet: {
      description: "Deshabilitar tu cuenta significa que no aparecer en la barra lateral ni en la billetera. Siempre puedes volver a activarla desde aqu. Las monedas de esta cuenta no se vern afectadas y permanecern seguras.",
      title: "Activar/desactivar billetera"
    },
    hideAmounts: {
      description: "Muestra un conmutador para ocultar tu saldo y los importes para mejorar tu privacidad cuando utilices la aplicacin en pblico.",
      hideAmounts: "Ocultar importes",
      showAmounts: "Mostrar importes",
      title: "Permitir ocultar importes"
    },
    language: {
      description: "Qu idioma quieres que utilice la BitBoxApp.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Recuerde la billetera",
      warning: "Esto eliminar tu billetera recordada. Para verlo de nuevo, necesitar conectar la BitBox02 para esta billetera. Las monedas de esta billetera no se vern afectadas. Desea continuar?",
      warningTitle: "Desactivar recuerde la billetera"
    },
    toggleSats: {
      description: "Habilitar o deshabilitar Satoshis."
    }
  }
}, note$4 = {
  input: {
    description: "(opcional)",
    placeholder: "aade nota"
  },
  title: "Nota"
}, notification$3 = {
  newTxs_one: "Nueva transaccin en: {{accountName}}",
  newTxs_other: "{{count}} nuevas transacciones en: {{accountName}}"
}, pairing$3 = {
  aborted: {
    text: "La sincronizacin ha sido cancelada desde la aplicacin mvil.",
    title: "Abortado"
  },
  button: "Sincronizar aplicacin mvil",
  confirm: "Ests seguro de que quieres sincronizar su BitBox? Ten en cuenta que despus, se necesitar el telfono mvil para realizar una transaccin.",
  connectOnly: {
    button: "Conectar aplicacin mvil",
    title: "Escanea con nuestra aplicacin mvil seleccionando el elemento de men 'Conectar a la nueva aplicacin de escritorio'"
  },
  error: {
    text: "Algo sali mal. Por favor empieza de nuevo.",
    title: "Error"
  },
  pullFailed: {
    text: "Ha habido un error recibiendo un mensaje de tu mvil a travs del relay server.  ste puede estar sin conexin, por favor contacte al soporte tcnico.",
    title: "Solicitud fallida"
  },
  reconnectOnly: {
    button: "Volver a conectar la aplicacin mvil"
  },
  scanningFailed: {
    text: "El mvil no ha podido escanear el mensaje con xito. Por favor intntalo de nuevo.",
    title: "Escaneo fallido"
  },
  start: {
    hideAppQRCode: "Ocultar cdigo QR",
    revealAppQRCode: "Mostrar cdigo QR",
    step1: "Si no tiene la aplicacin mvil, puede escanear el cdigo QR para la App Store de Apple o la Play Store de Google, segn el telfono que tengas.",
    step2: "Escanee con nuestra aplicacin mvil, que puede encontrar bajo el nombre 'Digital Bitbox 2FA' en las tiendas de aplicaciones para iOS y Android:"
  },
  started: {
    text: "Ahora sige por favor las instrucciones en la aplicacin mvil.",
    title: "Genial"
  },
  success: {
    text: "Enhorabuena, has sincronizado su BitBox con la aplicacin mvil!",
    title: "xito"
  },
  timeout: {
    text: "La sincronizacin expir despus de dos minutos. Empieza de nuevo si an quieres sincronizar la aplicacin mvil.",
    title: "Se acab el tiempo"
  },
  title: "Sincronizacin mvil"
}, passphrase$2 = {
  considerations: {
    button: "Consideraciones de la copia de seguridad",
    message: `La frase de contrasea aade una capa de proteccin a tu billetera de copia de seguridad (de la tarjeta microSD o palabras de recuperacin). Si alguien tiene acceso a tu copia de seguridad, tambin necesitar la frase de contrasea para acceder a tu billetera. 


Sin embargo, esto significa que necesitars <strong>tanto la frase de contrasea como la copia de seguridad de tu billetera</strong> para restaurar tu billetera con la frase de contrasea, en caso de que tu BitBox02 se pierda o se rompa. Si olvidas o pierdes tu contrasea, perders el acceso a todas las monedas de esa billetera.

Cuando almacenes tu frase de contrasea, considera ponerla en un lugar distinto a la de tu copia de seguridad. De este modo, si alguien encuentra la copia de seguridad, no encontrar tambin la frase de contrasea.`,
    title: "Consideraciones de la copia de seguridad"
  },
  disable: "Desactivar passphrase",
  disableInfo: {
    button: "Desactivar",
    message: `Tras desactivar la passphrase, no se le volver a preguntar para que introduzca una passphrase tras desbloquear su BitBox02. Por lo que entrara en su cartera por defecto.
Cualquier moneda de su cartera con passphrase seguir estando en esa cartera, sin embargo no tendr acceso a ella porque tras desbloquear su BitBox02, abrir su cartera por defecto.
Para acceder a su cartera con passphrase de nuevo, simplemente vuelva a activar la opcin de passphrase e introduzca la passphrase correcta tras desbloquear la BitBox02.
<strong>Consejo:</strong> Puede seguir entrando en su cartera original dejando la passphrase vaca.`
  },
  enable: "Activar passphrase",
  error: {
    e104: "El cambio en la caracterstica de passphrase fue abortado."
  },
  how: {
    button: "Cmo se ve",
    message: `Una passphrase no funciona como una contrasea a las que estamos habituados. Si se equivoca en un carcter de su passphrase, no ser notificado. Esto es porque <strong>cada passphrase crea una cartera diferente y vlida al mismo tiempo</strong>. Esto significa que se pueden utilizar tantas pasprases como carteras se deseen. Pero solo se puede acceder a cada cartera cuando se introduce su passphrase correspondiente.
Cuando conecte su BotBox02, ser preguntado por su contrasea como siempre. Despus, se le solicitar que introduzca la passphrase en el dispositivo.
Tras introducir la passphrase, se le mostrar la passphrase que ha introducido. Esto es para confirmar que ha sido introducida correctamente.`,
    title: "Como funciona"
  },
  intro: {
    message: `Una passphrase proporciona una capa de seguridad por encima de su cartera.
Aprendamos cmo funciona.`,
    title: "Configurar passphrase"
  },
  progressDisable: {
    message: "Confirme en su BitBox que quiere <strong>desactivar</strong> la opcin de passphrase.",
    title: "Confirme en el dispositivo"
  },
  progressEnable: {
    message: "Confirme en su BitBox que quiere <strong>activar</strong> la opcin de passphrase.",
    title: "Confirme en el dispositivo"
  },
  successDisabled: {
    message: `Passphrase opcional <strong>activada satisfactoriamente</strong>!
A partir de ahora se le solicitara introducir una passphrase.`,
    messageEnd: "Por favor vuelva a conectar ahora su BitBox02.",
    title: "Passphrase activado"
  },
  successEnabled: {
    message: `Passphrase opcional <strong>desactivada satisfactoriamente</strong>!
A partir de ahora no se le solicitar introducir una passphrase.`,
    messageEnd: "Por favor vuelva a conectar su BitBox02 ahora.",
    tips: "Consejos",
    tipsList: [
      "Le sugerimos enviar una pequea cantidad a su cartera con passphrase primero. Despus desconecte y vuelva a conectar la BitBox02 e introduzca su contrasea y su passphrase. Si ha introducido la passphrase correctamente, debera ver las monedas en su cartera.",
      "Si quiere entrar en su cartera original sin passphrase, puede seguir hacindolo no introduciendo nada cuando le solicite introducir la passphrase. O puede desactivar la caracterstica de passphrase."
    ],
    title: "Passphrase desactivada"
  },
  summary: {
    button: "Activar passphrase",
    title: "Resumen",
    understand: "Entiendo como funciona la passphrase y sus riesgos asociados.",
    understandList: [
      "La passphrase es una capa adicional de seguridad por encima de su copia de seguridad.",
      "Introducir un passphrase diferente siempre generar carteras diferentes.",
      "Para restaurar su cartera necesita <strong>tanto la passphrase como la copia de seguridad</strong>.",
      "Si olvidas tu frase de contrasea, ya no podrs <strong>acceder a tus monedas</strong>."
    ]
  },
  what: {
    button: "Aprenda como funciona",
    message: `Una billetera se crea (deriva) a partir de un nmero aleatorio muy grande, tambin conocido como semilla. Esta semilla se crea cuando configuras por primera vez tu BitBox02 y se respalda con la tarjeta microSD o las palabras de recuperacin. Cualquiera que tenga acceso a la semilla tiene control total sobre los fondos de esa billetera.

Una frase de contrasea es un <strong>secreto opcional</strong>, aadido a la semilla. Cuando se utiliza una frase de contrasea, cada frase de contrasea crea una nueva billetera basada en la semilla + frase de contrasea (secreto opcional). Una frase de contrasea puede ser cualquier cosa: letras, palabras, caracteres especiales o incluso puede estar vaca. De hecho, la billetera predeterminadamente se deriva de la semilla + frase de contrasea vaca.

La frase de contrasea forma parte del estndar BIP39, lo que significa que es compatible con todos las billeteras que admitan el mismo estndar.`,
    title: "Qu es una passphrase?"
  },
  why: {
    button: "Porqu utilizar una passphrase",
    message: `La BitBox02 protege la semilla contra la extraccin desde el propio dispositivo, pero la copia de seguridad (tarjeta microSD o palabras de recuperacin) da acceso completo a la billetera. Por eso debe guardarse en un lugar seguro!


Dado que una frase de contrasea crea una nueva billetera utilizando tu semilla existente, la billetera con frase de contrasea requiere tanto tu <strong>reserva de seguridad</strong> COMO tu frase de contrasea para restaurarla. La ventaja de esto es que si alguien encuentra tu copia de seguridad, seguir necesitando la frase de contrasea para acceder a la billetera con la frase de contrasea.


Adems, la funcin de la frase de contrasea permite crear varias billeteras en el mismo dispositivo, o "billeteras ocultas", adems del predeterminado.`,
    title: "Porqu utilizar una passphrase?"
  }
}, password$3 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "AVISO: el bloqueo de maysculas () est activado",
    paste: 'para pegar texto, activa "MOSTRAR {{label}}"'
  }
}, random$4 = {
  button: "Generar nmero aleatorio",
  description: "Tu BitBox ha generado el siguiente nmero aleatorio de {{bits}} bits:"
}, receive$5 = {
  changeScriptType: "Tipo de direccin del cambio",
  label: "Tu direccin",
  onlyThisCoin: {
    description: "Para recibir otros tokens, por favor actvalos en la configuracin. Si depositas otros tokens, podran no ser accesibles. ",
    warning: "Asegrate de recibir solo {{coinName}} en esta direccin."
  },
  scriptType: {
    p2tr: "Taproot (Nuevo formato)",
    p2wpkh: "Native Segwit (por defecto)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatible)"
  },
  selectAccount: "Seleccionar cuenta ",
  showFull: "Muestra y verifica la direccin completa en el dispositivo",
  taprootWarning: "Nota: Taproot es una nueva caracterstica de Bitcoin y todava no es ampliamente aceptada. Los fondos recibidos en direcciones Taproot pueden no ser mostradas en carteras de terceros. Muchas carteras y exchanges no pueden enviar a direcciones Taproot.",
  title: "Recibe {{accountName}}",
  verify: "Verificar la direccin de forma segura",
  verifyBitBox01: "Verifica la direccin completa en la app mvil",
  verifyBitBox02: "Verifica la direccin en la BitBox02",
  verifyInstruction: "Por favor, verifica que esta direccin encaja con la de tu dispositivo.",
  warning: {
    secureOutput: "Por favor, sincroniza su BitBox con tu dispositivo mvil para activar la verificacin segura de la direccin. Ve a 'Administrar dispositivo' en la barra lateral."
  }
}, reset$3 = {
  description: "Todos los datos sern borrados de este dispositivo. Eso incluye tu clave privada!",
  notReset: "Dispositivo NO reseteado.",
  title: "Resetear dispositivo de fbrica",
  understand: "Tengo una copia de seguridad y conozco mi contrasea de recuperacin",
  understandBB02: "Tengo una copia de seguridad vlida"
}, securityInformation$3 = {
  create: {
    description1: "Antes de configurar su dispositivo, se recomienda que lo hagas en un entorno seguro.",
    description2: "Se le pedir que crea dos contraseas.",
    description3: "La primera es la <strong>contrasea del dispositivo</strong> que desbloquea su dispositivo BitBox y puede cambiarse ms tarde.",
    description4: "El segundo es el <strong>contrasea de recuperacin</strong> que desbloquea tu monedero. Esta contrasea no se puede cambiar ms tarde.",
    description5: "Se realizar una copia de seguridad del monedero que creaste en un archivo de la tarjeta micro SD proporcionada. Esto se puede usar en una emergencia para recuperar tus fondos usando tu <strong>contrasea de recuperacin</strong>.",
    title: "Informacin de seguridad"
  },
  restore: {
    description1: "Se te pedir que insertes la tarjeta micro SD que utiliz para guardar su copia de seguridad.",
    description2: "Para recuperar tu dispositivo necesitars tu contrasea de recuperacin. ",
    description3: "Por favor ten cuidado al ingresar la contrasea de recuperacin. Cualquier contrasea que ingreses crear un monedero vlida. Si introduces la contrasea incorrecta, es posible que ves un saldo del monedero que no esperas.",
    title: "Informacin de seguridad"
  }
}, seed$3 = {
  agreements: {
    "funds-access": "NO podr acceder a mis fondos si olvido mi contrasea de recuperacin",
    "password-change": "NO puedo cambiar la contrasea de recuperacin ms tarde",
    "password-required": "La contrasea de recuperacin es necesaria para restaurar un monedero desde una copia de seguridad"
  },
  create: "Crea monedero",
  creating: "Creando monedero",
  description: "Entiendo que:",
  error: {
    e102: "La contrasea debe contener al menos 4 caracteres.",
    e200: "Debe insertar una tarjeta micro SD en su BitBox para crear un mondero, de modo que se pueda crear una copia de seguridad automticamente."
  },
  info: {
    button: "Establecer contrasea de recuperacin ahora",
    description1: "Inserta la tarjeta micro SD en el BitBox",
    description2: 'Elija una contrasea de recuperacin para el monedero y seleccione "Establecer contrasea de recuperacin ahora"',
    description3: "La copia de seguridad en la tarjeta micro SD y su contrasea de recuperacin es el nico mtodo para recuperar sus fondos en caso de prdida o robo del dispositivo BitBox.",
    description4: "No puede cambiar su contrasea de recuperacin ms adelante sin transferir sus fondos.",
    title: "Crear una cartera nueva"
  },
  password: {
    label: "Contrasea de recuperacin",
    repeatPlaceholder: "Repita la contrasea de recuperacin"
  },
  walletName: {
    label: "Nombre del monedero"
  }
}, seedRestore$3 = {
  error: {
    e200: "La recuperacin de un monedero a partir de una copia de seguridad requiere la tarjeta micro SD."
  },
  info: {
    description1: 'Inserta la tarjeta micro SD en el BitBox y haga clic en "Continuar"',
    description2: 'Elija una copia de seguridad y haga clic en "Restablecer"',
    description3: "Ingresa la contrasea de recuperacin",
    description4: "Debes confirmar para entender que una contrasea incorrecta crear una cartera diferente.",
    title: "Cmo restaurar un monedero desde una copia de seguridad"
  }
}, send$5 = {
  abort: "La transaccin ha sido cancelada.",
  address: {
    label: "Direccin del receptor",
    placeholder: "Introduce direccin!"
  },
  amount: {
    label: "Cantidad",
    placeholder: "Introduzca la cantidad"
  },
  availableBalance: "Saldo disponible",
  button: "Revisar ",
  coincontrol: {
    address: "Direccin",
    outpoint: "Anotar",
    title: "Enviar desde salida"
  },
  confirm: {
    "selected-coins": "Monedas seleccionadas",
    title: "Confirma y enva la transaccin",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que no tiene suficiente Ether para pagar esta transaccin ERC20. Por favor, asegrese de que tiene suficiente Ether en su wallet.",
    feeTooLow: "La tarifa de red es demasiado baja",
    feesNotAvailable: "No se pueden estimar las tarifas de red",
    insufficientFunds: "fondos insuficientes",
    invalidAddress: "direccin invlida",
    invalidAmount: "Cantidad invlida",
    invalidData: "Datos invlidos"
  },
  fee: {
    customPlaceholder: "Introduzca la cantidad",
    label: "Tarifa de red",
    placeholder: "No disponible"
  },
  feeTarget: {
    customLabel: "Tarifa de red",
    customLabel_eth: "Precio del Gas",
    description: {
      economy: "24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)",
      economy_eth: "30 minutos o menos",
      economy_ltc: "1 hora (24 bloques)",
      high: "2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)",
      high_eth: "30 segundos o menos",
      high_ltc: "5 minutos (2 bloques)",
      low: "12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)",
      low_eth: "5 minutos o menos",
      low_ltc: "30 minutos (12 bloques)",
      normal: "6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)",
      normal_eth: "2 minutos o menos",
      normal_ltc: "15 minutos (6 bloques)"
    },
    estimate: "Tiempo de espera estimado:",
    label: {
      custom: "A medida",
      economy: "Econmico",
      high: "Alto",
      low: "Bajo",
      normal: "Normal"
    },
    placeholder: "Calculando la tarifa de red..."
  },
  maximum: "Enviar todo",
  maximumSelectedCoins: "Enviar monedas seleccionadas",
  noFeeTargets: "Las estimaciones de tarifas no estn disponibles actualmente. Vuelva a intentarlo ms tarde o introduzca una tarifa personalizada.",
  priority: "Prioridad",
  scanQR: "Escanear cdigo QR",
  signprogress: {
    description: "Esta es una transaccin que contiene una gran cantidad de datos. Para firmar en su totalidad la transaccin, se le pedir que confirme {{steps}} veces.",
    label: "En curso"
  },
  success: "La transaccin ha sido firmada y enviada.",
  title: "Enva {{accountName}}",
  toggleCoinControl: "Activar/Desactivar control de monedas/UTXO",
  transactionDetails: "Detalles de la transaccin"
}, settings$4 = {
  about: "Acerca de",
  accounts: "Cuentas",
  advancedSettings: "Configuracin avanzada",
  appearance: "Apariencia",
  electrum: {
    add: "Aadir un servidor",
    "add-server": "Aadir",
    check: "Comprobar",
    checkFailed: "Fall",
    checkSuccess: "La conexin establecida con xito a {{host}}",
    checking: "Comprobacin",
    "download-cert": "Descarga certificado remoto",
    "remove-server": "Elimina",
    removeConfirm: "Eliminar {{server}}?",
    reset: "Restablecer a predeterminados",
    resetConfirm: "Desea eliminar todos los servidores e instalar los servidores predeterminados?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Introduzca el punto final.",
    step2: "2",
    "step2-text": "Introduzca un certificado de la cadena de certificados del servidor. Alternativamente, descarga el certificado remoto y comprelo visualmente.",
    "step2-text-tcp": "Puedes omitir este paso si no quieres utilizar TLS.",
    step3: "3",
    "step3-text": "Comprueba la conexin y aade el servidor.",
    step4: "4",
    "step4-text": "Reinicia el monedero. Si no eliminas los servidores predeterminados, tu propio nodo se agregar como redundancia.",
    "title-btc": "Servidores de Bitcoin Electrum",
    "title-ltc": "Servidores de Litecoin Electrum",
    "title-tbtc": "Servidores de Bitcoin Testnet Electrum",
    "title-tltc": "Servidores de Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activa control de monedas",
    electrum: {
      description: "Puedes conectarte a tu propio nodo Electrum completo.",
      title: "Conecta tu propio nodo completo"
    },
    fee: "Activar tarifas de red personalizadas",
    setProxyAddress: "Establece direccin proxy",
    title: "Configuracin avanzada",
    useProxy: "Activar tor proxy",
    useSats: "Mostrar valores BTC en Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nueva actualizacin disponible",
    title: "Informacin",
    "up-to-date": "Su aplicacin est actualizada",
    version: "Versin del App"
  },
  restart: "Por favor, reinicia la BitBoxApp para que los cambios tengan efecto.",
  services: {
    title: "Servicios"
  },
  success: "Por favor desenchufa y vuelva a enchufar el BitBox para que los cambios surjan efecto.",
  title: "Ajustes"
}, setup$3 = "Dispositivo de configuracin", sidebar$4 = {
  buy: "Compra criptomoneda",
  device: "Administra dispositivo",
  leave: "Salir",
  settings: "Ajustes"
}, success$a = {
  create: {
    info1: "Su monedero se ha respaldado de manera segura en la tarjeta micro SD. Retrelo y gurdalo en un lugar seguro. ",
    info2: "Has creado una contrasea de dispositivo seguro que desbloquea el BitBox.",
    info3: "Has creado una contrasea de recuperacin segura para su monedero que desbloquea sus fondos y recupera sus copias de seguridad.",
    summary: "Aqu hay un resumen de lo que has hecho.",
    title: "xito"
  },
  getstarted: "Empieza",
  restore: {
    summary: "Has restaurado con xito un monedero de su copia de seguridad.",
    title: "xito"
  }
}, transaction$4 = {
  confirmation: "Confirmaciones",
  details: {
    activity: "Actividades",
    address: "Direccin",
    amount: "Cantidad",
    date: "Fecha",
    fiat: "Fiat",
    fiatAmount: "Cantidad Fiat",
    fiatAtTime: "Fiat en el momento de la transaccin",
    status: "Estado",
    type: "Tipo"
  },
  explorer: "ID de transaccin",
  explorerTitle: "Abrir en el bloque externo Explorer",
  fee: "Tarifa de red",
  fiatHistorical: "Historial",
  gas: "Gas",
  note: {
    edit: "Edita nota",
    save: "Guarda nota"
  },
  pending: "Transaccin pendiente",
  size: "Tamao",
  status: {
    complete: "Acabado",
    failed: "Fall",
    pending: "Pendiente"
  },
  tx: {
    received: "Recibido a",
    sent: "Enviado a"
  },
  vsize: "Tamao virtual",
  weight: "Peso"
}, transactions$3 = {
  errorLoadTransactions: "Se ha producido un error al cargar las transacciones",
  placeholder: "Sin transacciones todava."
}, unknownError$3 = "Ocurri un error desconocido: {{errorMessage}}", unlock$3 = {
  description: "Ingresa la contrasea de tu dispositivo para desbloquear el dispositivo.",
  error: {
    e109_normal: "Contrasea incorrecta del dispositivo. {{remainingAttempts}} intentos permanecen antes de que el dispositivo se reinicie.",
    e109_touch: "$t(unlock.error.e109_normal) El siguiente inicio de sesin requiere mantener presionado el botn tctil.",
    e113: "Debido a muchos intentos de inicio de sesin, el siguiente inicio de sesin requiere mantener presionado el botn tctil durante 4 segundos."
  },
  input: {
    label: "Contrasea del dispositivo",
    placeholder: "Ingresa la contrasea de tu dispositivo para desbloquear el dispositivo"
  },
  unlocking: "Desbloqueando..."
}, upgradeFirmware$4 = {
  button: "Actualizacin de firmware",
  description: "Quieres actualizar el Firmware de la versin {{currentVersion}} a {{newVersion}}?",
  label: "Se requiere una actualizacin de firmware para tu BitBox.",
  locked: "Para actualizar desde {{currentVersion}} a {{newVersion}}, por favor haz un toque largo.",
  title: "Actualizacin de firmware",
  unlocked: "El gestor de arranque est desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecta y vuelva a conectar su Bitbox",
  unlocked2: "El LED se encender cuando su BitBox se vuelva a enchufar.",
  unlocked3: "Toque el botn tctil cuando el LED se encienda"
}, walletConnect$4 = {
  connect: {
    button: "Conectar",
    dappLabel: "Introduzca la direccin URI de la aplicacin ",
    invalidPairingUri: "Uri de emparejamiento no vlido"
  },
  dashboard: {
    allSessions: "Todas las sesiones",
    disclaimer: "Walletconnect es un protocolo para conectarse a dapps basadas en Ethereum. Estas dapps estn gestionadas por servicios de terceros, as que conctate solo a dapps en las que confes y asegrate de saber siempre lo que ests firmando al realizar una transaccin.",
    newConnection: "Nueva conexin",
    noConnectedSessions: "Actualmente no hay cuentas conectadas a ninguna dapps."
  },
  invalidPairingChain: "Error al aprobar el emparejamiento. Asegrese de utilizar una de las cadenas admitidas: {{cadenas}}",
  pairingRequest: {
    approve: "Aprobar conexin",
    reject: "Rechazar",
    title: "Nueva solicitud de conexin de"
  },
  pairingSuccess: "Dapp conectada con xito. Puede continuar en el sitio web de la dapp.",
  signingRequest: {
    account: "Cuenta",
    chain: "Cadena",
    dapp: "Dapp",
    data: "Datos",
    dataParsingError: "Error al analizar los datos",
    decodeError: "No se ha podido descodificar el mensaje",
    method: {
      sendTransaction: "Firmar y enviar la transaccin",
      signMessage: "Firmar el mensaje",
      signTransaction: "Firmar la transaccin",
      signTypedData: "Firmar los datos escritos"
    },
    successfullySigned: "Solicitud firmada con xito",
    walletConnectRequest: "Solicitud de WalletConnect"
  },
  useNewUri: "Este URI ya ha sido utilizado para intentar una conexin. Por favor, utilice un nuevo URI.",
  walletConnect: "WalletConnect"
}, warning$9 = {
  receivePairing: "Por favor, sincroniza el BitBox para activar la verificacin segura de la direccin. Ve a 'Administrar dispositivo' en la barra lateral.",
  sdcard: "Manten la tarjeta micro SD guardada aparte del BitBox, a menos que desee administrar las copias de seguridad.",
  sendPairing: "Por favor, sincroniza el BitBox para verificar con seguridad los detalles de la transaccin. Vaya a 'Administrar dispositivo' en la barra lateral."
}, welcome$3 = {
  connect: "Conecta tu BitBox02",
  getStarted: "Vamos a comenzar instalando el firmware en su BitBox02.",
  insertBitBox02: "Si ests usando BitBox02, por favor toca el dispositivo para continuar.",
  insertDevice: "Por favor conecta tu dispositivo para comenzar",
  title: "Bienvenido"
}, appTranslationsES = {
  account: account$3,
  accountInfo: accountInfo$3,
  accountSummary: accountSummary$3,
  addAccount: addAccount$4,
  aopp: aopp$2,
  app: app$3,
  auth: auth$3,
  backup: backup$3,
  bb02Bootloader: bb02Bootloader$3,
  bitbox: bitbox$3,
  bitbox02Interact: bitbox02Interact$3,
  bitbox02Settings: bitbox02Settings$3,
  bitbox02Wizard: bitbox02Wizard$3,
  blink: blink$3,
  bootloader: bootloader$3,
  button: button$7,
  buy: buy$4,
  changePin: changePin$3,
  chart: chart$4,
  checkSDcard: checkSDcard$3,
  clickHere: clickHere$3,
  confirm: confirm$5,
  confirmOnDevice: confirmOnDevice$3,
  connectKeystore: connectKeystore$3,
  darkmode: darkmode$3,
  device: device$3,
  deviceLock: deviceLock$3,
  deviceSettings: deviceSettings$3,
  deviceTampered: deviceTampered$3,
  dialog: dialog$4,
  error: error$4,
  fiat: fiat$5,
  footer: footer$5,
  generic: generic$4,
  genericError: genericError$3,
  goal: goal$3,
  guide: guide$4,
  headerssync: headerssync$3,
  hiddenWallet: hiddenWallet$3,
  initialize: initialize$3,
  invalidFormat: invalidFormat$3,
  language: language$4,
  legacyhiddenwallet: legacyhiddenwallet$3,
  loading: loading$3,
  manageAccounts: manageAccounts$2,
  mobile: mobile$3,
  newSettings: newSettings$2,
  note: note$4,
  notification: notification$3,
  pairing: pairing$3,
  passphrase: passphrase$2,
  password: password$3,
  random: random$4,
  receive: receive$5,
  reset: reset$3,
  securityInformation: securityInformation$3,
  seed: seed$3,
  seedRestore: seedRestore$3,
  send: send$5,
  settings: settings$4,
  setup: setup$3,
  sidebar: sidebar$4,
  success: success$a,
  transaction: transaction$4,
  transactions: transactions$3,
  unknownError: unknownError$3,
  unlock: unlock$3,
  upgradeFirmware: upgradeFirmware$4,
  walletConnect: walletConnect$4,
  warning: warning$9,
  welcome: welcome$3
}, account$2 = {
  disconnect: "Povezava je prekinjena. Poizkuam ponovno...",
  export: "Izvoz",
  exportTransactions: "Izvozite transakcije v CSV datoteko in odloite v lokalno mapo.",
  fatalError: "Ups, nepriakovana napaka",
  incoming: "Dohodni",
  initializing: "Pridobivam podatke iz verige blokov...",
  maybeProxyError: "Tor proxy omogoen. Prepriajte se, da Tor proxy deluje pravilno, ali onemogoite proxy.",
  reconnecting: "Povezava je prekinjena, poizkuam s ponovno vzpostavitvijo...",
  syncedAddressesCount: "Preteto t. naslovov: {{count}}"
}, accountInfo$2 = {
  address: "Naslov",
  buyCTA: {
    buy: "Kupi",
    buyCrypto: "Kupi kripto",
    information: {
      looksEmpty: "Denarnica je prazna.",
      start: "Zanite tako, da poljete nekaj kovancev v denarnico ali jih kupite neposredno v aplikaciji BitBoxApp."
    }
  },
  extendedPublicKey: "Razirjen javni klju",
  label: "Podatki o raunu",
  scriptType: "Tip skripte",
  title: "Podatki o raunu",
  verify: "Potrdi na napravi",
  xpubTypeChangeBtn: {
    p2pkh: "Ogled razirjenega javnega kljua P2PKH",
    p2tr: "Oglejte Taproot",
    p2wpkh: "Ogled Native Segwit",
    "p2wpkh-p2sh": "Ogled razirjenega javnega kljua P2SH"
  },
  xpubTypeInfo: "Prikazan je {{scriptType}} razirjen javni klju ({{current}} od {{numberOfXPubs}})"
}, accountSummary$2 = {
  availableBalance: "Razpololjivo stanje",
  balance: "Stanje",
  exportSummary: "Izvozi povzetek rauna v mapo za prenos, kot datoteko CSV",
  fiatBalance: "Stanje v fiat valuti",
  name: "Ime rauna",
  noAccount: "Ni raunov za prikaz.",
  subtotalWithCoinName: "Skupaj ({{coinName}})",
  title: "Moj portfelj",
  total: "Skupaj",
  transactionHistory: "Zgodovina transakcij"
}, addAccount$3 = {
  chooseName: {
    nextButton: "Dodaj raun",
    step: "Poimenuj raun",
    title: "Poimenuj raun"
  },
  selectCoin: {
    nextButton: "Naprej",
    step: "Izberi kovanec",
    title: "Izberi kriptovaluto"
  },
  success: {
    addAnotherAccount: "Dodajte nov raun",
    message: "<strong> {{accountName}} </strong> je zdaj dodan med vae raune.",
    nextButton: "OK",
    step: "Zaklljueno",
    title: "Raun dodan"
  },
  title: "Dodajte raun"
}, aopp$1 = {
  addressRequest: "{{host}} zahteva naslov prejemnika.",
  addressRequestWithLogo: "zahteva naslov prejemnika",
  banner: "Zahteva po naslovu je v teku.",
  errorTitle: "Napaka med zahtevo za naslov",
  labelAddress: "Naslov",
  labelMessage: "Sporoilo",
  reverifyInfoText: "Potrdite naslov",
  signing: "Za nadaljevanje podpiite sporoilo na napravi",
  success: {
    message: "Nadaljujte na {{host}}",
    title: "Naslov uspeno poslan"
  },
  syncing: "Poakajte trenutek, poteka sinhronizacija rauna.",
  title: "Zahteva za naslov"
}, app$2 = {
  upgrade: "Na voljo je nova verzija te aplikacije! Prosimo vas, da jo nadgradite iz verzije  {{current}} na {{version}}."
}, auth$2 = {
  authButton: "Potrdi",
  title: "Za nadaljevanje potrdite"
}, backup$2 = {
  check: {
    checking: "Preverjam varnostno kopijo...",
    confirmTitle: "Preverite varnostno kopijo",
    notOK: "Varnostna kopija se NE ujema s trenutno denarnico.",
    ok: "Varnostna kopija se ujema z denarnico.",
    password: {
      label: "Geslo za obnovo varnostne kopije",
      placeholder: "Geslo za obnovo varnostne kopije",
      showLabel: "geslo za obnovo varnostne kopije"
    },
    success: "Varnostna kopija uspeno preverjena:",
    title: "Preverite varnostno kopijo"
  },
  create: {
    alreadyExists: "Veljavno varnostno kopijo e imate. Ali jo ponovno elite ustvariti?",
    fail: "Ustvarjanje varnostne kopije NI uspelo!",
    info: "Prosimo vnesite geslo za obnovo trenutne denarnice za potrditev.",
    name: {
      label: "Ime varnostne kopije",
      placeholder: "Poimenujte varnostno kopijo"
    },
    password: {
      label: "Obnovitveno geslo",
      placeholder: "Prosimo vnesite obnovitveno geslo"
    },
    title: "Ustvarite varnostno kopijo - backup",
    verificationFailed: 'Obnovitveno geslo se NE ujema s trenutno denarnico. Varnostna kopija je bila ustvarjena. Prosimo uporabite "Preverite varnostno kopijo" da potrdite geslo za obnovo.'
  },
  description: "Izberite <strong>datoteko z varnostno kopijo denarnice</strong>",
  insert: "Prosimo vstavite microSD kartico za upravljanje z varnostnimi kopijami.",
  insertButton: "Vstavil sem microSD kartico",
  list: "Varnostne kopije na microSD kartici",
  noBackups: "Na tej microSD kartici ni varnostnih kopij.",
  restore: {
    confirmTitle: "Obnovite varnostno kopijo",
    error: {
      e200: "MicroSD kartica ni bila zaznana",
      general: "Napaka pri obnovitvi varnostne kopije"
    },
    password: {
      label: "Geslo za obnovitev ali skrito geslo za obnovitev varnostne kopije",
      placeholder: "Geslo za obnovitev",
      repeatPlaceholder: "Ponovite geslo za obnovitev",
      showLabel: "Geslo za obnovitev"
    },
    restoring: "Obnavljanje varnostne kopije ...",
    selectedBackup: "<strong>{{backupName}}</strong> ustvarjen {{createdDateTime}} bo obnovljen.",
    title: "Obnovi",
    understand: "Razumem, da bo nepravilno geslo za obnovitev ustvarilo drugo, novo denarnico"
  },
  showMnemonic: {
    description: `Prikazano vam bo do 24 besed, ki tvorijo varnostno kopijo denarnice. Zapiite jih na papir.

<strong>Ne hranite jih digitalno in jih ne fotografirajte.</strong>

<strong>Ne izgovarjajte besed na glas.</strong>

<strong>Ta varnostna kopija ni zaitena z geslom.</strong>

Po konanem prikazu besed boste morali vsako e potrditi na napravi.`,
    title: "Prikai seznam besed",
    warning: "<strong>Nikoli ne delite obnovitvenih besed z nikomer.</strong> Te besede omogoajo popoln dostop do vae denarnice. e vas kdo sprauje po teh besedah, gre zelo verjetno za prevaro. Ne delite jih z neznanci!"
  },
  title: "Upravljanje varnostnih kopij"
}, bb02Bootloader$2 = {
  abort: "Ne nadgradi - vrni me nazaj",
  abort_noUpgrade: "Vrni me nazaj",
  advanced: {
    label: "Napredne nastavitve",
    toggleShowFirmwareHash: "Ob zagonu vedno prikai binarno vrednost strojne programske opreme (firmware hash)"
  },
  flipscreen: "Obrnite sliko na zaslonu",
  orientation: "Je zaslon na napravi obrnjen v napano smer?",
  success: "Nadgradnja uspena! Nadaljevanje v {{rebootSeconds}} sekundah...",
  success_install: "Namestitev uspena! Nadaljevanje v {{rebootSeconds}} sekundah..."
}, bitbox$2 = {
  error: {
    e10000: "Trenutno geslo naprave je napano.",
    e10001: "Gesla naprave ni bilo mogoe zamenjati",
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e112: "Geslo skrite denarnice ne more biti enako kot geslo glavne denarnice."
  }
}, bitbox02Interact$2 = {
  confirmDate: "Potrdite dananji datum na BitBox02",
  confirmDateText: "Vneen datum bo uporabljen za kreiranje varnostne kopije.",
  confirmName: "Potrdite ime na zaslonu BitBox02",
  confirmWords: "Zapiite si {{amount}} obnovitvenih besed iz vaega BitBoxa",
  confirmWordsText: "Po tem koraku BitBox02 zahteva potrditev vsake besede na zaslonu, da se prepriate, da ste varnostno kopijo zapisali pravilno.",
  followInstructions: "Prosimo upotevajte navodila na zaslonu naprave.",
  followInstructionsMnemonic: "Upotevajte navodila za obnovitev iz seznama besed na napravi in obnovite denarnico.",
  followInstructionsMnemonicTitle: "Obnovi iz seznama besed"
}, bitbox02Settings$2 = {
  deviceName: {
    current: "Trenutno ime naprave",
    error: "Imena naprave ni bilo mogoe nastaviti",
    error_104: "Potrditev imena je bilo prekinjeno na napravi",
    input: "Novo ime",
    placeholder: "Novo ime naprave",
    title: "Nastavite ime tej napravi"
  },
  gotoStartupSettings: {
    description: "To bo znova zagnalo va BitBox02 in zaelo nastavitev zagona.",
    title: "Pojdite na zaetne nastavitve"
  }
}, bitbox02Wizard$2 = {
  advanced: {
    button: "Napredne monosti",
    outOfDate: "Strojna programska oprema (firmware) je prestara za to funkcijo",
    seed12WordInfo: "tevilo besed kasneje ni mono spremeniti.",
    seed12WordLabel: "Ustvari 12 besedno seme namesto 24 besednega",
    seed12WordText: "BitBox privzeto uporablja 24 besedno seme. Na voljo je tudi 12 besedno seme. Obe podprti dolini semena sta dovolj varni proti strojnemu uganjevanju (brute force). ",
    skipSDCardLabel: "Ne ustvari varnostne kopije na micro SD kartico ampak prikai semenske besede",
    skipSDCardText: "Kasneje lahko vedno ustvarite varnostno kopijo na micro SD kartico ali ponovno prikaete semenske besede. To opcijo najdete v Nastavitvah.",
    title: "Napredne monosti arhivske kopije"
  },
  attestationFailed: "Preverjanje ni uspelo, kar je lahko posledica ponovnega zagona aplikacije, medtem ko je naprava akala na uporabniki vnos (dotik). Napravo znova vklopite in poskusite znova. e teava ne izgine, se obrnite na support@bitbox.swiss (v angleini).",
  backup: {
    point1: "Izberite varnostno kopijo na microSD kartici",
    point2: "Nastavite geslo za svojo napravo",
    restoreText: "Ok, obnovimo varnostno kopijo!",
    text1: "Super, vae geslo za BitBox02 je zdaj nastavljeno in denarnica je ustvarjena. Zdaj je as, da ustvarite prvo varnostno kopijo. Prepriajte se, da je microSD kartica vstavljena v BitBox02 in nato nadaljujte.",
    text2: "e elite ustvariti varnostno kopijo, sledite navodilom na zaslonu naprave.",
    text3: "Ko ustvarite varnostno kopijo, odstranite microSD kartico in jo shranite na <strong>varno lokacijo</strong>. Vsebina kartice ni zaitena z geslom. Nikoli je ne vstavite v nobeno drugo napravo, razen v va BitBox02.",
    userConfirmation1: "Varnostno kopijo je potrebno hraniti na varnem mestu",
    userConfirmation2: "Moja varnostna kopija ni zaitena z geslom. Vsak, ki ima dostop do nje, lahko dostopa do moje denarnice.",
    userConfirmation3: "e izgubim ali pokodujem svoj BitBox02, je edini nain, da povrnem svoja sredstva, obnovitev iz varnostne kopije.",
    userConfirmation4: "e izgubim ali pokodujem tako varnostno kopijo kot svoj BitBox02, so moja sredstva izgubljena.",
    userConfirmation5: "Ustvarjeno varnostno kopijo na microSD kartici ne smem vtakniti v PC, telefon, tiskalnik ali katero koli drugo napravo razen v BitBox02.",
    userConfirmation5mnemonic: "Semenskih besed NE bom vpisoval v raunalnike, telefone, tablice ali katere koli druge naprave, kot le v BitBox02."
  },
  create: {
    button: "Poimenujte napravo in nadaljujte",
    info: "To so osnovni koraki, ki jih boste izvedli za nastavitev BitBoxa: ",
    inputTitle: "Ime denarnice",
    point1: "Poimenujte napravo",
    point2: "Izberite si geslo za svojo napravo",
    point3: "Ustvarite varnostno kopijo",
    text: "Ok, pa ustvarimo novo denarnico!"
  },
  createBackupAborted: "Kreiranje varnostne kopije je prekinjeno.",
  createBackupFailed: "Ustvarjanje varnostne kopije ni uspelo, poskusite znova.",
  initialize: {
    passwordText: "Zdaj pa doloite geslo za vao napravo. Za vnos in izbiro gesla uporabite kontrolne drsnike na BitBoxu.",
    passwordTitle: "Nastavite geslo za va BitBox",
    text: "Seznanjanje je bilo uspeno! Zdaj pa pripravimo vao napravo. Zanite z ustvarjanjem nove denarnice ali obnovitvijo denarnice iz obstojee varnostne kopije. <strong>Prepriajte se, da imate v BitBox02 vstavljeno microSD kartico </strong>",
    tip: "Priporoamo vam, da te postopke opravite v varnem in zasebnem okolju.",
    title: "Zaenite in nastavite BitBox02"
  },
  insertSDCard: "<strong>Prepriajte se, da imate v BitBox02 vstavljeno microSD kartico.</strong>",
  noPasswordMatch: "Gesli se nista ujemali. Poskusite znova.",
  pairing: {
    failed: "Seznanjanje je bilo prekinjeno. Ponovno priklopite BitBox02.",
    paired: "Na napravi ste potrdili, da se koda ujema. Prosimo nadaljujte.",
    title: "Potrditev seznanitvene kode",
    unpaired: "Zaznana je bila nova BitBox02 naprava. Preverite, ali se prikazana koda ujema s tisto na zaslonu naprave."
  },
  restoreFromMnemonic: {
    e104: "Ponastavitev iz semenskih besed je bilo ustavljeno.",
    failed: "Obnova iz seznama besed ni uspela. Poskusite znova."
  },
  stepBackup: {
    beforeProceed: "Pred nadaljevanjem preberite naslednje pomembne varnostne vidike:",
    createBackup: "Zdaj boste ustvarili varnostno kopijo na microSD kartici .",
    createBackupMnemonic: "Zdaj zapiite semenske besede na papir ali jeklo"
  },
  stepBackupSuccess: {
    fundsSafe: "e elite ohraniti sredstva varna, upotevajte naslednje:",
    title: "Varnostna kopija obnovljena!"
  },
  stepConnected: {
    unlock: "Vnesite izbrano geslo, kot ponazarja video"
  },
  stepCreate: {
    description: "To ime je uporabljeno kot ime naprave in ime varnostne kopije.",
    nameLabel: "Vnesite eljeno ime naprave",
    namePlaceholder: "Moj BitBox02",
    title: "Izberite ime za va BitBox02",
    toastMicroSD: "Vstavite microSD kartico v BitBox02. Na njo bo zapisana varnostna kopija denarnice."
  },
  stepCreateSuccess: {
    removeMicroSD: "Odstranite microSD kartico z naprave in jo shranite na varno mesto.",
    storeMnemonic: "Predlagamo, da shranite te obnovitvene besede na varno lokacijo",
    success: "Uspeno ste ustvarili varnostno kopijo."
  },
  stepInsertSD: {
    insertSDCard: "Vstavite microSD kartico v BitBox02.",
    insertSDcardTitle: "Vstavite microSD kartico"
  },
  stepPassword: {
    e104: "Nastavitev gesla je bila prekinjena.",
    title: "Nastavite geslo za BitBox02",
    useControls: "S pomojo drsnikov na robu naprave si nastavite geslo."
  },
  stepUninitialized: {
    create: "elim postaviti nov BitBox02.",
    restore: "elim obnoviti denarnico iz varnostne kopije.",
    restoreMicroSD: "Obnovi iz microSD kartice",
    restoreMnemonic: "Obnovi iz seznama besed",
    title: "Nastavite svoj BitBox02"
  },
  success: {
    text: `Bravo! Va BitBox02 je zdaj pripravljen za uporabo.

Za dodatne informacije o uporabi aplikacije BitBoxApp uporabite vodnik. Na voljo je s klikom na vpraaj v zgornjem desnem kotu.`,
    title: "Zdaj ste pripravljeni za delo z BitBox denarnico!"
  }
}, blink$2 = {
  button: "Sproi utripanje na napravi"
}, bootloader$2 = {
  button: 'Nadgradi "firmware"',
  button_install: "Namestite firmware",
  progress: "Nadgrajujem: {{progress}}%",
  progress_install: "Nameanje: {{progress}}%",
  success: "Nadgradnja uspena! Izkljuite in ponovno prikljuite napravo v USB reo. Tokrat se ne dotikajte gumba."
}, button$6 = {
  abort: "Prekini",
  back: "Nazaj",
  buy: "Kupi",
  changepin: "Spremenite geslo naprave",
  check: "Preverite varnostno kopijo",
  continue: "Nadaljujte",
  copy: "Kopiraj",
  create: "Ustvari",
  dismiss: "Zavrnite",
  done: "Potrdi izbiro",
  download: "Prenesi",
  hiddenwallet: "Ustvarite skrito denarnico",
  next: "Naprej",
  ok: "OK",
  previous: "Nazaj",
  receive: "Prejmi",
  restore: "Obnovi",
  select: "Izberite",
  send: "Polji",
  unlock: "Odklenite denarnico",
  update: "Osvei",
  upgrade: "Nadgradi"
}, buy$3 = {
  exchange: {
    bankTransfer: "Banno nakazilo",
    bestDeal: "Najbolja ponudba",
    creditCard: "Kreditna karica",
    fast: "Hitro",
    fee: "provizija",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Banno nakazilo: {{fee}}%",
          creditDebitCard: "Kreditna/debetna kartica: {{fee}}%",
          learnMore: "Ve o storitvi MoonPay",
          title: "Provizije"
        },
        fullCurrenciesList: "Tu je na voljo seznam vseh valut",
        payment: {
          asteriskText: "* Ni na voljo za rezidente ZDA",
          bankTransfer: "Banno nakazilo*",
          bankTransferDetails: {
            pix: "PIX (BR transakcije, samo v Braziliji)",
            sepa: "SEPA in SEPA Instant (samo EUR transakcije v dravah SEPA)",
            uk: "UK Faster Payments (samo GBP transakcije v Zdruenem kraljestvu)"
          },
          creditDebitCard: "Kreditna/debetna kartica",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa in Maestro"
          },
          learnMore: "Oglejte si podrobnosti o nainih plaila",
          title: "Naini plaila"
        },
        supportedCurrencies: "Podpira vse glavne fiat valute: USD, EUR, CHF in druge"
      },
      pocket: {
        fees: {
          info: "Banno nakazilo: {{fee}}%",
          title: "Provizije"
        },
        learnMore: "Ve o storitvi Pocket",
        payment: {
          bankTransfer: "Banno nakazilo",
          bankTransferDetails: {
            sepa: "SEPA in SEPA instant (transakcije v EUR znotraj SEPA podprtih drav)",
            sic: "vicarska medbanna poravnava (samo za transakcije v CHF v CH/LIE)",
            uk: "UK Faster Payments (samo transakcije v GBP v UK)"
          },
          bankTransferReccuring: "Kako nastavimo ponavljajoe nakupe z enim naroilom?",
          title: "Naini plaila"
        },
        supportedCurrencies: "Podpira evropske valute: EUR, GBP in CHF",
        verification: {
          info: "Preverjanje identitete je zahtevano le nad dnevnim in letnim limitom.",
          link: "Trenutni limiti",
          title: "Preverjanje identitete"
        }
      },
      region: {
        title: "Izberite regijo, v kateri je registriran va banni raun, da vidite monosti, ki so vam na voljo."
      }
    },
    noExchanges: "V tej regiji al ni razpololjivih menjalnic.",
    region: "Regija",
    selectRegion: "Ni navedeno",
    title: "Kupi {{name}}"
  },
  info: {
    continue: "Potrdi in nadaljuj",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "V sodelovanju z MoonPay vam ponujamo monost nakupa {{name}} neposredno znotraj BitBoxApp. S samo nekaj kliki.",
        "MoonPay je regulirana platforma za finanne storitve, ki omogoa preprost in hiter nakup {{name}} v ve kot 160 dravah"
      ],
      payment: {
        details: "{{name}} je mono kupiti takoj prek storitve MoonPay z naslednjimi naini plaila. Plaila s kreditno ali debetno kartico so takojnja in prirona, vendar draja. Za veje zneske priporoamo uporabo bannega nakazila. Minimalna pristojbina je 4 EUR.",
        footnote: "Menjalni teaji storitve MoonPay se lahko razlikujejo od tistih, ki se uporabljajo v BitBoxApp.",
        table: {
          "1_description": "Najnija provizija, lahko traja do 3 delovne dni",
          "1_method": "Banno nakazilo (SEPA)",
          "2_description": "Vija provizija a takojnja izvritev",
          "2_method": "Kreditna ali debetna kartica",
          description: "Opis",
          fee: "Provizija",
          method: "Nain plaila"
        },
        title: "Naini plaila in provizije"
      },
      privacyPolicy: "Politika zasebnosti storitve MoonPay",
      protection: {
        description: `BitBoxApp ne zbira nobenih podatkov ob nakupu preko MoonPay. 
Prilivi se obravnavajo in so prikazani kot obiajna transakcija. MoonPay za svoje delovanje zbira nekaj osebnih podatkov. Njihova politika zasebnosti podrobno pojasnjuje, kako ravna s temi podatki.`,
        descriptionGeneric: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu {{name}}, vhodna sredstva se obravnavajo kot obiajna transakcija. Priakujemo, da morajo partnerske borze zbrati nekaj vaih informacij za njihovo poslovanje. Oglejte si njihove pravilnike o zasebnosti, da vidite kako postopajo z vaimi podatki.",
        title: "Zaita podatkov"
      },
      security: {
        description: "Za nakup {{name}} preko MoonPay uporabljate zunanjo storitev. Ta storitev ne sodi v obseg zaite, ki jo nudi BitBox02 in temelji na varnosti in zaiti okolja, v katerem deluje programska oprema BitBoxApp.",
        descriptionGeneric: "Pojasnilo: Ko uporabite partnerske menjalnice za nakup {{name}}, uporabljate zunanjo storitev. Le-ta ni del nae varnostne politike in ni del zaite, ki jo ponuja BitBox02 temve je odvisna od okolja (operacijski sistem, omreje) na katerem uporabljate BitBoxApp.",
        link: "Ve o varni uporabi",
        title: "Model varnostnega sistema"
      },
      title: "Dobrodoli! Ste na pravem na mestu za nakup {{name}}"
    },
    next: "Naprej",
    selectLabel: "Izberite svoj raun",
    selectPlaceholder: "Izberi kovanec",
    skip: "Ne prikazuj ve",
    title: "Kupi  {{name}}"
  },
  pocket: {
    data: {
      link: "Varovanje zasebnosti storitve Pocket",
      p1: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu bitcoina, vhodna sredstva se obravnavajo kot obiajna transakcija. Pocket mora za svoje delovanje zbrati nekaj vaih osebnih podatkov. Njihov pravilnik o zasebnosti podrobno pojasnjuje, kako ravnajo s temi podatki.",
      title: "Varovanje podatkov"
    },
    kyc: {
      link: "Preberite FAQ (odgovore na pogosta vpraanja) storitve Pocket",
      p1: "Storitev Pocket skua tevilo postopkov za KYC (know-your-customer; prepoznavo kupca) opraviti v najmanji moni meri. Za nakupe pod 1000 CHF na dan dodatni dokumenti niso potrebni. Za nakupe nad tem zneskom se boste morali dogovoriti za klic z drubo Pocket, da opravite potreben postopek KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin lahko zelo hitro kupite s storitvijo Pocket z bannim nakazilom tipa SEPA. Provizija znaa 1,5 %, bitcoin pa se v vao denarnico nakae takoj, ko Pocket prejme vae banno nakazilo (obiajno v istem dnevu).",
      p2: "Upotevajte, da se lahko menjalni teaji v aplikaciji BitBoxApp razlikujejo od menjalnih teajev v aplikaciji Pocket, zaradi esar so zneski nekoliko drugani.",
      title: "Naini plaila in provizije"
    },
    previousTransactions: "Zgodovina transakcij tega rauna ni prazna. e boste ta raun delili, bodo vse pretekle in prihodnje transakcije na njem vidne storitvi Pocket. Ali vseeno nadaljujete?",
    security: {
      link: "Model varnosti in zaite BitBox02",
      p1: `Ob nakupu bitcoina preko storitve Pocket, uporabljate zunanjo storitev. Le-ta je izven zaite, ki jo nudi BitBox02. Varnost in zaita sta odvisna od okolja v katerem uporabljate BitBoxApp. 
Skupaj s storitvijo Pocket delujemo na nain, da z dvofaktorsko avtentikacijo preverjamo naslov na katerega prejemate bitcoin.`,
      title: "Varnostni model storitve Pocket"
    },
    usedAddress: "Naslov {{address}} je bil e uporabljen. Prosimo zanite ponovno.",
    verifyBitBox02: "Preverite, ali se naslov, ki ste ga prejeli po e-poti, ujema z naslovom, prikazanim na napravi. e bolj varno je, da e-potno sporoilo odprete in preberete v drugi napravi, e je to mogoe.",
    welcome: {
      p1: "S storitvijo Pocket sodelujemo, da bi vam omogoili enostaven nain nakupa bitcoina neposredno v BitBoxApp. V le nekaj klikih.",
      p2: "Pocket je vicarska platforma ki omogoa hiter in enostaven nakup bitcoina v veini Evropskih drav.",
      p3: "S storitvijo Pocket lahko enostavno vzpostavite redni intervalni nakup bitcoina s pomojo rednih bannih nakazil. T.i. DCA (dollar-cost averaging) ",
      title: "Dobrodoli na pravem mestu za nakup bitcoinov"
    }
  },
  title: "Kupi {{name}}"
}, changePin$2 = {
  newTitle: "Novo geslo naprave",
  oldLabel: "Trenutno geslo naprave"
}, chart$3 = {
  dataMissing: "e vedno pridobivamo informacije. Poskusite znova ez nekaj minut. ii pa aki",
  dataOldTimestamp: "Nalagamo teaje. Graf ne prikazuje vrednosti po {{time}}.",
  dataUpdating: "posodabljam...",
  filter: {
    all: "Vse",
    month: "Mesec",
    week: "Teden",
    year: "Leto"
  }
}, checkSDcard$2 = "preverjanje microSD kartice", clickHere$2 = "Kliknite tukaj.", confirm$4 = {
  abortInfo: "Hiter dotik za ",
  abortInfoRedText: "prekinitev",
  approveInfo: "Dotaknite se gumba za vsaj 4 sekunde ",
  approveInfoGreenText: " za potrditev",
  info: "Nadaljujte na BitBoxu.",
  infoWhenPaired: "Najprej na seznanjeni mobilni napravi in nato na BitBoxu"
}, confirmOnDevice$2 = "Nadgradnjo potrdite na BitBox-u", connectKeystore$2 = {
  promptNoName: "Za nadaljevanje priklopite BitBox02",
  promptWithName: 'Za nadaljevanje priklopite va BitBox02 z imenom "{{name}}"'
}, darkmode$2 = {
  toggle: "Temen nain"
}, device$2 = {
  appUpradeRequired: "BitBox ni zdruljiv s to verzijo namizne aplikacije. Prenesite in namestite najnovejo razliico."
}, deviceLock$2 = {
  button: "Omogoite dvofaktorsko avtentikacijo (2FA)",
  condition1: "Imate varnostno kopijo?",
  condition2: "Ali deluje preverjanje v mobilni aplikaciji?",
  condition3: "2FA ONEMOGOA varnostne kopije in seznanjanje z mobilno aplikacijo. Naprava mora biti resetirana za izhod iz dvofaktorskega (2FA) naina!",
  confirm: "Omogoite dvofaktorsko avtentikacijo (2FA)",
  title: "Omogoite dvofaktorsko avtentikacijo (2FA)"
}, deviceSettings$2 = {
  backups: {
    manageBackups: {
      description: "Prikai in preveri varnostno kopijo na Micro SD kartici."
    },
    showRecoveryWords: {
      description: "Prikai in potrdi semenske besede."
    },
    title: "Varnostne kopije"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp preverja, e je naprava avtentina."
    },
    deviceName: {
      description: "Spremenite ime naprave"
    },
    rootFingerprint: {
      description: "Korenski prstni odtis je unikaten identifikator denarnice, ki je trenutno v uporabi. e uporabljate frazemska gesla (passphrases), vam lahko pomaga pri razlikovanju med razlinimi denarnicami."
    },
    securechip: {
      description: "Model varnega ipa"
    },
    title: "Informacije o napravi"
  },
  expert: {
    factoryReset: {
      description: "Ponastavite napravo na tovarnike nastavitve. Ta postopek izbrie denarnico na BitBoxu.",
      title: "Tovarnika nastavitev"
    },
    goToStartupSettings: {
      description: 'Vstopite v nain "bootloader" na napravi. S tem lahko omogoite prikaz zgoene vrednosti strojne programske opreme (firmware hash).'
    },
    passphrase: {
      description: "Vklopi ali izklopi monost geselske fraze",
      title: "Geselska fraza"
    }
  },
  firmware: {
    firmwareVersion: "Razliica strojne programske opreme (firmware)",
    newVersion: {
      label: "Razpololjiva razliica"
    },
    title: "Verzija strojne programske opreme (firmware)",
    upToDate: "Vaa naprava je posodobljena",
    upgradeAvailable: "Na voljo je nova nadgradnja",
    version: {
      label: "Razliica"
    }
  },
  hardware: {
    attestation: {
      false: "Preverjanje pristnosti ni uspelo",
      label: "Preverjanje pristnosti",
      true: "BitBox02 je pristen!"
    },
    sdcard: {
      false: "Ni vstavljena",
      label: "microSD kartica",
      true: "Vstavljena"
    },
    securechip: "Verzija varnega ipa",
    title: "Naprava"
  },
  loading: "Pridobivam informacije o napravi ...",
  pairing: {
    lock: {
      false: "Onemogoeno",
      label: "Dvo faktorska avtentikacija (2FA)",
      true: "Omogoeno"
    },
    mobile: {
      false: "Zaprto",
      label: "Mobilna aplikacija",
      true: "Odpri"
    },
    status: {
      false: "Ni uparjen",
      label: "Status",
      true: "Uparjen"
    },
    title: "Seznanjanje (uparitev)"
  },
  secrets: {
    manageBackups: "Upravljanje varnostnih kopij",
    title: "Varnost"
  }
}, deviceTampered$2 = `Ali ste prejeli BitBox skupaj z geslom za obnovitev?
e je tako, takoj zaustavite postopek namestitve in stopite v stik z nami.
Shift nikoli ne izroa pred-pripravljene denarnice ali pred pripravljenih gesel.`, dialog$3 = {
  cancel: "Nazaj",
  confirm: "Potrdite",
  confirmTitle: "Potrditev"
}, error$3 = {
  accountAlreadyExists: "Ta raun e obstaja.",
  accountLimitReached: "Novega rauna ni mogoe dodati. Doseeno je najveje tevilo raunov za ta kovanec.",
  aoppCallback: "Napaka pri dostavi naslova do {{host}}.",
  aoppInvalidRequest: "Napana poizvedba",
  aoppNoAccounts: "Nobenega rauna ni na razpolago.",
  aoppSigningAborted: "Aopp postopek preklican",
  aoppUnknown: "Neznana napaka...",
  aoppUnsupportedAsset: "Izbrano sredstvo ni podprto.",
  aoppUnsupportedFormat: "Na voljo ni raunov, ki podpirajo zahtevano obliko naslova.",
  aoppUnsupportedKeystore: "Povezana naprava ne more podpisati sporoil za to sredstvo",
  aoppVersion: "Neznana razliica",
  wrongKeystore: "Prikljuena je napana denarnica. Vstavite pravo napravo BitBox02, ki ustreza temu raunu.",
  wrongKeystore2: "e uporabljate frazemsko geslo (passphrase), se prepriajte, da ste ga pravilno vnesli za ta raun."
}, fiat$4 = {
  default: "Privzeto",
  setDefault: "Nastavite {{code}} kot privzeto",
  title: "Valute"
}, footer$4 = {
  appVersion: "Razliica aplikacije:"
}, generic$3 = {
  enabled_false: "Onemogoeno",
  enabled_true: "Omogoeno"
}, genericError$2 = "Pojavila se je napaka. e opazite kakrne koli teave, znova zaenite aplikacijo.", goal$2 = {
  buttons: {
    create: "Ustvarite novo denarnico",
    restore: "Obnovite denarnico iz varnostne kopije"
  },
  paragraph: "Izberite eno od naslednjih monosti:",
  step: {
    1: {
      title: "Varnostne informacije"
    },
    2: {
      description: "Ustvarite geslo naprave",
      title: "Naprava"
    },
    "3-create": {
      description: "Ustvarite novo denarnico",
      title: "Denarnica"
    },
    "3-restore": {
      description: "iz varnostkopije",
      title: "Obnovi"
    },
    "4-create": {
      title: "Povzetek"
    },
    "4-restore": {
      title: "Povzetek"
    }
  }
}, guide$3 = {
  accountDescription: {
    text: "To je pregled vaega rauna. Prikazuje dohodne in odhodne transakcije. Stanje je prikazano za vsak raun posebej. Oglejte si pomo v Nastavitvah, e elite izvedeti ve o razlinih vrstah raunov.",
    title: "Kaj mi prikazuje ta stran?"
  },
  accountFiat: {
    text: "Seveda, kliknite na oznako valute in jo zamenjate. V nastavitvah lahko doloate seznam valut, ki se prikazujejo tu.",
    title: "Ali lahko preverim vrednost v drugih fiat valutah?"
  },
  accountIncomingBalance: {
    text: "Tu je zbrana vsota zneskov, ki se prenaajo na va raun, vendar jih omreje e ni potrdilo.",
    title: "Kaj pomeni dohodni?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Vsak xpub (razirjen javni klju) je vezan na prikazan tip naslova: "Native Segwit (bech32)", "Wrapped Segwit" ali "Taproot" (samo za Bitcoin). To so vrste skript, ki jih uporablja {{coinName}}. Aplikacija BitBoxApp jih zdruuje in podpira ve vrst skript na istem raunu. Ker vsaka vrsta skripta daje drugaen xpub, je na raunu ve xpubov.

e sredstva stalno prejemate na privzeti naslov (Native Segwit), potrebujete samo "bech32" xpub. e pa sredstva prejemate tudi na tip naslova "Wrapped Segwit" ali "Taproot", morate uporabiti tudi razirjene javne kljue "Wrapped Segwit" oziroma "Taproot".`,
      title: "Zakaj je tu ve xpub-ov?"
    },
    privacy: {
      text: `xpub ali razirjen javni klju za doloen raun, razkriva celotno finanno zgodovino tega rauna: transakcije v preteklosti, stanje rauna in prihodnje transakcije. Dostop do xpub-a pa nikomur ne omogoa premika vaih kovancev.

V kolikor nekomu posredujete xpub se morate zavedati, da lahko ta oseba ali podjetje vidi vse dogajanje na temu raunu (za vsak naslov tega rauna). Premislite torej katera in koliko sredstev boste upravljali na raunu, ki ga dajete nekomu na vpogled.`,
      title: "Ali moram svoje xpub-e ohraniti zasebne in na varnem?"
    },
    verify: {
      text: "Da, vedno je dobro dvakrat preveriti xpub. e bo nekdo drug iz tega xpub-a ustvaril naslove za prejemanje in vam poiljal denar, je to e posebej pomembno. Preveriti ga morate na napravi, da se prepriate, da ta xpub pripada vam. V nasprotnem primeru bi lahko vsa sredstva la na napane naslove (ki si jih morda ne lastite vi).",
      title: "Ali moram preveriti xpub na napravi?"
    },
    xpub: {
      text: `Razirjeni javni klju (xpub) je osnovni klju, iz katerega izhajajo vsi prejemni naslovi rauna.
Tu jih prikazujemo za namene napredne uporabe, kot na primer za uporabo v opazovalnih denarnicah (watch only wallets), kot sta Electrum ali Sentinel. e imate prejeme sredstev na razline tipe naslovov, uporabite "xpub" vseh tipov naslovov, da jih boste lahko videli vse svoje kovance v teh denarnicah.

Pozor, nekatere denarnice e ne podpirajo vseh tipov naslovov, kot je npr Taproot.`,
      title: "Kaj je razirjeni javni klju?"
    }
  },
  accountRates: {
    text: "Menjalni teaji se vsako minuto posodobijo s strani CoinGecko.",
    title: "Od kod izvirajo prikazani menjalni teaji?"
  },
  accountReload: {
    text: "Vsi podatki o transakcijah se posodabljajo samodejno.",
    title: "Kako lahko ponovno naloim zgodovino transakcij?"
  },
  accountSendDisabled: {
    text: "Gumb Polji se aktivira, ko je stanje veje od ni.",
    title: "Zakaj ne morem poslati nobenega {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Skupni znesek je vsota vseh vaih kripto raunov. Menjalni teaji so na voljo na spletnem mestu coingecko.com.

Opomba: e MyEtherWallet uporabljate za etone, ki jih BitBoxApp ne podpira, ti ne bodo vkljueni v prikazani znesek.`,
    title: "Kako se izraunava skupni znesek?"
  },
  accountSummaryDescription: {
    text: "Tu si lahko ogledate gibanje vaega skupnega portfelja skozi as. Povzetek posameznih raunov je prikazan pod grafom.",
    title: "Kaj prikazuje ta stran?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtualna velikost: Uporablja se za doloanje omrenine. Na omrenini ste uspeno prihranili, ko je ta manja od velikosti transakcije.
Velikost: Dejanska velikost transakcije v bajtih, ko je serializirana glede na izbrano verigo blokov.
Tea: Uvedena s sistemom Segwit, je nova metrika za ovrednotenje velikosti transakcij in blokov. Vsak bajt "segregated witness" teje kot ena, vsi ostali kot tiri enote tee. Namesto enega megabajta dejanske velikosti je zdaj nova omejitev velikosti blokov na tiri milijone enot tee.`,
    title: "Kako je s podatki o Bitcoin transakcijah?"
  },
  accountTransactionAttributesGeneric: {
    text: `Potrditve: Ko se transakcija objavi v omreju, je sprva nepotrjena. Poakati je potrebno da jo nek rudar vkljui v blok in s tem potrdi (rudari). Po tem bo imela transakcija 1 (eno) potrditev. Vsak novi blok, ki se objavi v omreju s to transakcijo, doda e eno potrditev. V splonem velja, da trgovci in drugi prejemniki, kot dokonne sprejemajo samo transakcije s 3 do 6 potrditvami.
ID transakcije: Unikatna identifikacijska tevilka transakcije, ki jo lahko uporabite za iskanje v raziskovalcih verige blokov.
Omrenina: Rudarjem se plaa omrenina (provizija), kot spodbuda za vkljuitev transakcij v bloke, ki jih rudarijo oz izraunavajo.
e elite izvedeti ve, kliknite gumb Polji.`,
    title: "Kaj je prikazano v podatkih o transakcijah?"
  },
  accountTransactionConfirmation: {
    text: "To je transakcija, ki je e objavljena v omreju, vendar e ni potrjena.",
    title: "Kaj je nepotrjena transakcija?"
  },
  accountTransactionLabel: {
    text: "To je naslov, na katerega ste prejeli kovance ali iz njega kovance poslali.",
    title: "Kateri naslov je prikazan za vsako transakcijo?"
  },
  accountTransactionTime: {
    text: "Zabeleen as, ko je transakcija potrjena v verigi blokov (v blockchainu).",
    title: "Kateri as je prikazan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Za Bitcoin in Litecoin lahko odprete ve raunov. Po petih odprtih raunih, lahko dodate novega le e je zadnji e v uporabi. Pri vseh preostalih kovancih podpiramo najve pet raunov.",
      title: "Koliko raunov lahko ustvarim?"
    },
    howtoAddTokens: {
      text: "etoni, ki uporabljajo standard ERC20, so vezani na doloen Ethereum raun. e elite omogoiti ali onemogoiti doloen eton, odprite Upravljanje raunov, razirite raun Ethereum in vklopite ali izklopite eleni eton.",
      title: "Kako lahko dodam dodatne etone?"
    },
    moveFunds: {
      text: "Lahko a z obiajno transakcijo, iz enega naslova na drugega. Rauni so neodvisni med seboj, zato drugana pot ni mogoa.",
      title: "Ali je mono premikati sredstva med rauni?"
    },
    recoverAccounts: {
      text: "Da. BitBoxApp ustvarja raune z uveljavljenimi standardi, zdruljivimi z veino drugih kripto denarnic.",
      title: "Ali lahko obnovim raune na drugih denarnicah?"
    },
    whatAreAccounts: {
      text: "Vaa denarnica lahko upravlja ve raunov istega kovanca. Rauni so koristni, e elite sredstva hraniti loeno.",
      title: "Kaj so rauni?"
    },
    whyIsThisUseful: {
      text: 'Rauni so odlini za upravljanje sredstev za razline ljudi ali namene, ker so loeni. Svoj "razirjeni javni klju" rauna lahko delite, ne da bi razkrili esarkoli o svojih drugih raunih. To vam omogoa vekratno prejemanje sredstev brez ponovne uporabe naslovov, na primer prejemanja plae ali rednega nakupa kriptovalut.',
      title: "Zakaj je to uporabno?"
    }
  },
  appendix: {
    link: "Kontaktirajte nas!",
    text: "Imate e kakno vpraanje?"
  },
  backups: {
    check: {
      text: "Preverba varnostne kopije slui preverjanju, ali imate pravilno ustvarjeno in aktualno varnostno kopijo, ki ustreza vai trenutni denarnici. To uporabite tudi za preverjanje vaega gesla za obnovitev.",
      title: 'Kaj je "Preverba varnostne kopije"?'
    },
    encrypt: {
      text: "Ne, vendar je geslo za obnovo potrebno za pridobitev denarnice iz shranjenega semena.",
      title: "Ali lahko kriptiram varnostno kopijo?"
    },
    howOften: {
      text: `Varnostna kopija se ustvari samodejno, ko ustvarite novo denarnico. Novo varnostno kopijo morate ustvariti le v primeru, e je vaa microSD kartica z aktualno varnostno kopijo izgubljena, pokodovana ali e elite ve varnostnih kopij.
Po posameznih transakcijah vam ni treba ustvarjati novih varnostnih kopij! 
Vse transakcije, ki ste jih naredili po kreiranju varnostne kopije, lahko obnovite z eno samo varnostno kopijo.`,
      title: "Kako pogosto moram narediti varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena ki jo naprava shrani na microSD kartico. Seme, skupaj z vaim geslom za obnovitev, ustvari denarnico.",
      title: "Kaj je varnostna kopija?"
    }
  },
  backupsBB02: {
    check: {
      text: "To preverjanje vam omogoa, da ugotovite, ali imate delujoo varnostno kopijo, ki ustreza trenutni denarnici.",
      title: 'Kaj je "Preveri varnostne kopije"?'
    },
    encrypt: {
      text: "Ne. Prosimo, hranite microSD kartico na varnem mestu, saj vsebuje neifrirano seme (seed) za obnovitev denarnice. e elite zaititi svoje seme z geselsko frazo, jo lahko omogoite v naprednih nastavitvah v razdelku Upravljanje naprave.",
      title: "Ali lahko ifriram varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena na microSD kartici.",
      title: "Kaj je varnostna kopija?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Ko je 2FA omogoena, je potrebno na uparjenem telefonu odobriti vse izvedene transakcije, da bi premaknili kovance. 
V ozadju se kriptirana unikatna vrednost polje v aplikacijo na telefonu, se tam deifrira in ko pritisnete gumb "Sprejmi" se vrne v BitBox. Komunikacija z napravo se izvaja preko kanala, ki je bil vzpostavljen med uparjevanjem s telefonom, in to namizno aplikacijo.

POZOR: Predno omogoite 2FA, bodite pozorni, da varnostno kopirate svojo denarnico in uparite telefon. Ko je 2FA omogoena, je namre microSD kartica onemogoena in uparjevanje s telefonom ni mono. To dvoje lahko znova omogoite le po ponastavitvi BitBox01, ki izbrie napravo (in s tem denarnico)!`,
      title: "Kako deluje dvofaktorska avtentikacija (2FA)?"
    },
    disable2FA: {
      text: `e elite onemogoiti 2FA, morate ponastaviti (resetirati) in s tem izbrisati denarnico na BitBox-u in jo nato obnoviti iz varnostne kopije. Prepriajte se, da imate e vedno microSD kartico z varnostno kopijo in shranjeno veljavno in pravilno geslo za obnovo te denarnice.
ele nato pritisnite Ponastavi napravo. Nastavite novo geslo naprave in izberite Obnovite varnostno kopijo. Izberite pravo varnostno kopijo, ki ste jo naredili iz denarnice, kliknite Obnovi in vnesite geslo za obnovitev, ki ste ga kreirali pri ustvarjanju denarnice.`,
      title: "Kako onemogoim dvo faktorsko avtentikacijo (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox lahko izklopite kadarkoli oz. iztaknete iz USB vhoda.",
      title: "Kako lahko odklopim BitBox?"
    },
    ejectSD: {
      text: "MicroSD lahko odstranite iz BitBoxa kadarkoli, razen, ko ste v procesu ustvarjanja ali obnavljanja varnostne kopije.",
      title: "Kdaj lahko odstranim microSD kartico?"
    },
    hiddenWallet: {
      text: "Gre za drugo denarnico na isti napravi, zaiteno z razlinim geslom naprave in obnovitvenim geslom, ki ga lahko uporabite za verodostojno zanikanje. Enako rezervno seme se uporablja za normalno in skrito denarnico, zato dodatna varnostna kopija ni potrebna.",
      title: "Kaj je skrita denarnica?"
    },
    legacyHiddenWallet: {
      text: "Najprej kliknite spodnji gumb (na voljo le, e je BitBox odklenjen z glavnim geslom naprave in je 2FA onemogoen), nato ponovno vklopite Bitbox in ga odklenite s svojim alternativnim geslom naprave.",
      title: "Kako dostopam do skrite denarnice?"
    },
    pairing: {
      text: "Ko naloite nao mobilno aplikacijo za iOS ali Android, skenirajte prikazano QR kodo, ki vzpostavi varen kanal med mobilno aplikacijo in to aplikacijo. Poskenirajte in sledite navodilom v mobilni aplikaciji.",
      title: "Kako varno uparite BitBox01 s telefonom"
    }
  },
  cointracking: {
    text: 'Kliknite gumb "Izvozi" in odprite mapo za prenose, v kateri boste nali izvoz v .CSV datoteki. Nato kliknite spodnjo povezavo, naloite to .CSV datoteko in uvozite podatke, da jih boste lahko uporabili za storitev CoinTracking in za pripravo davnih poroil (samo za doloene drave!).',
    title: "Kako uvozim svoje transakcije v storitev CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Preberite si ve o preverjanju pristnosti"
      },
      text: "Aplikacija BitBoxApp opravi preverjanje pristnosti na napravi BitBox02, da preveri, ali je naprava originalna. Preverjanje se opravi lokalno in brez povezave z zunanjim strenikom.",
      title: "Kako poteka preverjanje pristnosti?"
    },
    name: {
      text: "To je ime vae denarnice in varnostne kopije. Ime se uporablja za prihodnje varnostne kopije in se lahko uporablja za laje razlikovanje med razlinimi denarnicami. Spremenite ga lahko kadar koli, vendar upotevajte, da bodo varnostne kopije, izdelane pred spremembo, e vedno uporabljale prejnje ime.",
      title: "Za kaj se uporablja ime denarnice BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Preberite ve o varnem ipu"
      },
      text: "Ker je verzija ipa dobra informacija o varnosti naprave. Najsodobneji ip je ATECC608B z izboljanimi varnostnimi funkcijami v primerjavi s starejimi modeli.",
      title: "Zakaj prikazujemo model varnega ipa?"
    }
  },
  receive: {
    address: {
      text: `Poljite ali predajte ga drugim, da vam lahko nanj poiljajo kovance.
Priporoamo, da se s prejemnikom naslova prepriate, da je prejel enak naslov, kot ste mu ga poslali. Obstaja namre monost, da na poti do prejemnika naslova programska oprema zamenjala naslov s svojim.`,
      title: "Kaj lahko ponem z naslovom?"
    },
    addressChange: {
      text: "Takoj, ko opravite transakcijo, se na seznam samodejno doda nov naslov. Tako je vedno na voljo 20 naslovov, ki e nikoli niso prejeli nobenega kovanca.",
      title: "Kdaj se naslovi spremenijo?"
    },
    addressFormats: {
      text: `Privzet tip naslova je "Native Segwit" t.i. bech32 tip naslova. Podprt je e v mnogih drugih denarnicah in menjalnicah, saj ponuja najnije provizije na transakcije. Poleg tega, lahko izbirate e med drugimi tipi naslovov. Noveji je Taproot (velja samo za Bitcoin), stareji pa "Wrapped Segwit".
`,
      title: "Kdaj uporabiti Spremenite tip naslova?"
    },
    howVerify: {
      text: `e imate BitBox01 kliknite ikono BitBox na stranskem stolpcu na levi strani in glejte poglavje seznanitve. Vodnik se bo posodobil in od tam lahko nadaljujete po navodilih.
Z BitBox02 lahko med postopkom poiljanja/prejemanja preverite naslove neposredno na napravi.`,
      title: "Kako lahko varno preverim naslov?"
    },
    plugout: {
      text: "Ne, BitBox lahko odklopite. Ko poljete kovance na naslov generiran z BitBox02, vam naprave ni treba pustiti prikljuene v raunalnik ali telefon.",
      title: "Je potrebno imeti BitBox02 priklopljen vse dokler ne prejmem sredstev?"
    },
    why20: {
      text: `Med zagonom aplikacija ustvari naslove, pridobljene iz vaega semena, in preveri, ali so prejeli sredstva. Aplikacija lahko ustvari skoraj neskonno tevilo naslovov in bi lahko porabila leta, da doloi pravo stanje za vsak naslov.
Da omejimo as iskanja, se prikaz ustavi po prvih 20 najdenih naslovov, ki nikoli niso prejeli sredstev. To je namenska omejitev in 20 je de-facto standard, eprav je tevilo poljubno. To je 20 naslovov, med katerimi lahko izbirate.`,
      title: "Zakaj le 20 naslovov?"
    },
    whyMany: {
      text: `Za ohranjanje vae zasebnosti in varnosti nikoli ne uporabite istega naslova dvakrat. 
e ste e uporabili naslov, kliknite na puico v desno za nov naslov. Naenkrat lahko ustvarite do 20 naslovov. Na naslove lahko gledate, kot na tevilke izdanih raunov. Vsi naslovi so pridobljeni iz istega semena.`,
      title: "Zakaj toliko naslovov?"
    },
    whyVerify: {
      text: `Vaemu raunalniku ne zaupajte, da ustvarja in prikazuje pristne naslove. Zaradi velike kompleksnosti je bistveno laja tara in bolj obutljiv kot denarnica s strojno opremo. 
Za BitBox01 - gumb za preverjanje naslova varno polje naslov na seznanjen mobilni telefon, iz katerega lahko tudi skenirate in preverite QR kodo. 
Na BitBox02 lahko naslov preverite neposredno na zaslonu.`,
      title: "Zakaj moram varno preveriti naslov?"
    }
  },
  send: {
    change: {
      text: "Viek (change) bo vrnjen na naslov Taproot, e imate vsaj en Taproot UTXO (Taproot naslov z nekaj sredstvi). e uporabljate nadzor kovancev, bo sprememba vrnjena na Taproot naslov, e je med izbranimi UTXO vsaj en tipa Taproot. V vseh drugih primerih se sprememba vrne na Native Segwit (bech32) naslov.",
      title: "Kako je definirano vrailo vikov?"
    },
    fee: {
      text: `Omrenina (ali prostovoljni prispevek rudarjem, provizija) temelji na velikosti podatkov v transakciji in ne na njenem znesku. Ciljne omrenine se izraunajo po algoritmu za ocenjevanje omrenin Bitcoin Core glede na izbrano prioriteto. Prikaejo se, e imajo drugano vrednost od spodnjih.
Varna: 24 blokov (priblino 4 ure za Bitcoin, 1 ura za Litecoin)
Nizka: 12 blokov (priblino 2 uri za Bitcoin, 30 minut za Litecoin)
Obiajna: 6 blokov (priblino 1 ura za Bitcoin, 15 minut za Litecoin)
Visoka: 2 bloka (priblino 20 minut za Bitcoin, 5 minut za Litecoin)
(Izraun bloka v Bitcoin omreju traja v povpreju deset minut in 2,5 minute za Litecoin. Obremenitev omreja in s tem omrenine se lahko v zgornjih obdobjih mono razlikujejo.)`,
      title: "Kako se doloi vrednost omrenine?"
    },
    plugout: {
      text: "Ne, ko enkrat opravite prenos sredstev (transakcijo), vam BitBoxa ni treba imeti ve priklopljenega. Lahko jo izkljuite.",
      title: "Ali moram imeti BitBox priklopljen ves as poiljanja?"
    },
    priority: {
      text: "Vijo omrenino, ki ste jo pripravljeni plaati, hitreje bo vaa transakcija potrjena v omreju.",
      title: "Kakna je prednost omreja?"
    },
    revert: {
      text: `Ko je transakcija podpisana in poslana (tj. predvajana v omreje), je ni ve mogoe razveljaviti. Pred podpisom torej preverite transakcije (vkljuno s provizijo)!
e prejemnika poznate in vam je pripravljen poslati isti znesek (minus transakcijske provizije), mu lahko poljete nov naslov za prejem kovancev.`,
      title: "Ali lahko povrnem transakcijo?"
    },
    whyFee: {
      text: `S prispevkom oz. omrenino, ki jo prinaajo, transakcije med seboj tekmujejo, da jih potrdi rudar. Rudarji praviloma najprej izberejo tiste transakcije, ki jim prinaajo vije omrenine (provizije).
Bitcoin rudarji lahko za nagrado za opravljeno raunsko delo poberejo omrenine, plaane pri transakcijah, ki jih potrdijo, skupaj z novo nastalimi bitcoini. Rudarjenje je specializiran in konkurenen trg, kjer se nagrade delijo glede na tevilo opravljenih izraunov. `,
      title: "Zakaj obstaja omrenina?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `e se elite s svojim vozliem (full node) povezati le, ko ste v istem omreju (npr. domai wifi), zadostuje uporaba obiajne omrene komunikacije.
V tem primeru je priporoljivo, da strenik Electrum zagotovi potrdilo TLS za ifriranje komunikacije.
e se nameravate s svojim vozliem povezati od kjer koli drugje, je bolja monost uporaba omreja Tor. V tem primeru ni potrebno potrdilo TLS.`,
      title: "Ali naj uporabim neifrirano povezavo TCP, TLS ali Tor?"
    },
    instructions: {
      link: {
        text: "Vodnik za povezavo lastnega vozlia"
      },
      text: "Za obirneja navodila obiite na vodi (v angleini):",
      title: "Kako poveem BitBoxApp s svojim polnim vozliem?"
    },
    options: {
      text: `Obstaja ve monosti za postavitev lastnega vozlia, kot na primer nakup konanega izdelka, ki je namenjen le temu, izdelava lastnega ali zagon programja Bitcoin Core na raunalniku.
e elite BitBoxApp povezati s svojim vozliem, se prepriajte, da na njem tee tudi strenik Electrum. To je namenski program, ki aplikaciji denarnice (kot je BitBoxApp) omogoa komunikacijo s polnim vozliem.
Podprte monosti vkljuujejo programje Electrs, Electrum Personal Server (EPS) ali Bitcoin Wallet Tracker (BTW).`,
      title: "Kakne monosti obstajajo za zagon/nakup vozlia?"
    },
    tor: {
      text: `Tor pomeni 'The Onion Router', ki je brezplana in odprtokodna programska oprema, ki ponuja vijo stopnjo zasebnosti in je e posebej uporabna pri uporabi Bitcoina.
e se nameravate povezati s vozliem prek omreja Tor, se prepriajte, da je Tor nameen na raunalniku in nato v nastavitvah BitBoxApp omogoite Tor Proxy.
V veini operacijskih sistemov obstaja dva naina dostopa do Tor-a:
1. Brskalnik Tor: prenesite in odprite brskalnik Tor. To bo omogoilo BitBoxApp, da se povee z omrejem Tor. V nastavitvah vpiite vrata (port) 9150 v nastavitvah za proxy strenik.
2. To v ozadju: Namestite demon Tor, ki vedno deluje v ozadju operacijskega sistema. Nato se lahko BitBoxApp povee preko Tor-a z nastavitvijo vrat 9050 v nastavitvah za proxy strenik.`,
      title: 'Kaj je Tor, Tor proxy in kater "port" naj uporabim?'
    },
    what: {
      text: "Denarnico lahko poveete s svojim polnim vozliem, namesto da uporabljate strenike podjetja Shift.",
      title: "Kaj je to?"
    },
    why: {
      text: `Vzdrevanje lastnega vozlia ni potrebno, izbolja pa zasebnost in znia potrebo po zaupanju drugim.
Prvi, to pomeni, da bolj zasebno uporabljate Bitcoin (omreje), saj se BitBoxApp ne bo povezal z naimi streniki, da bi prejel vao zgodovino transakcij; namesto tega bo podatke prejel od vaega vozlia.
Drugi, imeti lastno vozlie pomeni, da vozlie samo preverja vse transakcije in poskrbi, da so pravila omreja Bitcoin za vas uveljavljena.`,
      title: "Zakaj naj poganjam svoje vozlie?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (satoi, kraje sat) je najmanja enota Bitcoina. En satoi je stomilijonska enota bitcoina (0,00000001 BTC). Ime je dobila po avtorju Bitcoina, Satoshiju Nakamotu.",
      title: "Kaj je Satoshi?"
    },
    servers: {
      text: `Ta aplikacija komunicira s streniki podjetja Shift Crypto AG, da preveri posodobitve, naloi transakcije in poilja informacije v uparjene mobilne aplikacije.
Aplikacija pridobiva najnoveje teaje pri CoinGecko. Vse konverzije so izraunane lokalno, kar pomeni, da se podatki o znesku vae transakcije nikoli ne poljejo ven iz aplikacije.
Opomba: Za Ethereum in ERC20 etone uporabljamo API-je Etherscan.io.`,
      title: "S katerimi streniki govori ta aplikacija?"
    }
  },
  title: "Vodi vam v pomo",
  toggle: {
    close: "Zapri",
    open: "Pomo"
  },
  trackingModePortfolioChart: {
    text: "V namizni aplikaciji pojdite z miko ez graf. V mobilni aplikaciji, pritisnite na grafi in podrsajte po njem levo ali desno.",
    title: "Kako preverim vrednosti na grafu za doloen dan?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Ponastaviti morate napravo (reset) in obnoviti denarnico iz varnostne kopije z geslom za obnovitev.",
      title: "Kaj lahko storim, e pozabim geslo naprave?"
    },
    reset: {
      text: "Vnesite napano geslo naprave 15-krat. V zadnjih nekaj poskusih je potreben dolg dotik naprave.",
      title: "Kako ponastavim napravo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Ko jo vstavite, naprava utripne enkrat. Prepriajte se, da je pravilno obrnjena v USB rei. e imate teave, nas kontaktirajte preko spodnje povezave.

BitBox01 ni podprt v mobilni aplikaciji. Za povezavo z BitBox01 uporabite BitBoxApp na namizju.`,
      title: "Moj BitBox01 ni prepoznan"
    },
    getDevice: {
      link: {
        text: "Naroite BitBox"
      },
      text: "BitBox lahko kupite v nai spletni trgovini (link spodaj) ali pri naih partnerjih.",
      title: "Kje lahko kupim BitBox?"
    },
    internet: {
      text: "Da, internetna povezava je potrebna za sinhronizacijo denarnice, za poiljanje transakcij in pridobivanje menjalnih teajev.",
      title: "Ali ta aplikacija zahteva internetno povezavo?"
    },
    lostDevice: {
      link: {
        text: "Varnostne kopije"
      },
      text: "Vaa sredstva lahko enostavno obnovite z novo BitBox denarnico ali z drugo BIP39 napravo. V pomo smo spisali postopek v lanku:",
      title: "Izgubil sem napravo. Kaj pa zdaj?"
    },
    useWithoutDevice: {
      text: "Na alost to trenutno e ni mogoe.",
      title: "Ali lahko aplikacijo uporabljam brez BitBoxa?"
    },
    welcome: {
      text: `Podjetje Shift Crypto iz vice se vam zahvaljuje, ker uporabljate BitBoxApp. 
Vae predloge za izboljavo zelo cenimo in si jih elimo. Va odziv priakujemo na povezavi na dnu.`,
      title: "Pozdravljeni v aplikaciji BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "e uporabljate nov telefon ali raunalnik z aplikacijo BitBoxApp, se boste morali ponovno povezati z DApps. Svoje kovance boste nato ponovno videli v izbranih DApp kot obiajno.",
      title: "Mojih prejnjih povezav ne vidim."
    },
    supportedNetworks: {
      text: "V BitBoxApp je trenutno z WalletConnect podprto le Ethereum omreje. Za uporabo drugih verig, zdruljivih z EVM, uporabite storitev Rabby v brskalniku (browser extension wallet).",
      title: "Katera omreja so podprta?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikacijski protokol za web3 aplikacije. Omogoa vam prirono povezavo z decentraliziranimi avtonomnimi aplikacijami (DApps) in spletnimi denarnicami, ki temeljijo na Ethereumu, brez uporabe aplikacije tretje osebe. To je e posebej uporabno za uporabnike aplikacije BitBoxApp na Androidu.",
      title: "Kaj je WalletConnect?"
    }
  }
}, headerssync$2 = {
  blocksSynced: "{{blocks}} sinhroniziranje blokov"
}, hiddenWallet$2 = {
  info1HTML: "Za namene verodostojnega zanikanja (obstoja prave denarnice) lahko ustvarite skrito denarnico na podlagi <strong>drugane (alternativne)</strong> kombinacije gesla in gesla za obnovitev varnostne kopije. ",
  info2HTML: "Doloite geslo naprave in geslo za obnovitev, ki ju elite povezati s spodnjo skrito denarnico. To geslo naprave in geslo za obnovitev morata biti <strong> drugana </strong> od tistih, ki ste ju doloili za primarno denarnico.",
  passwordLabel: "Skrito geslo za obnovitev",
  passwordPlaceholder: "Potrdite skrito geslo za obnovitev",
  pinLabel: "Geslo za skrito denarnico",
  pinRepeatLabel: "Ponovite geslo skrite denarnice",
  pinRepeatPlaceholder: "Prosimo potrdite geslo skrite denarnice",
  success: "Skrita denarnica je bila uspeno ustvarjena. Iztaknite in ponovno vtaknite BitBox v USB vhod, da jo odklenete."
}, initialize$2 = {
  create: "Ustvarite geslo naprave",
  creating: "Kreiram geslo naprave ...",
  error: {
    e102: "Geslo naprave mora vsebovati najmanj 4 znake."
  },
  info: {
    description1: "Vpiite novo geslo naprave. To bo uporabljeno za odklepanje BitBox-a.",
    description2: "Uporabite lahko tevilke, rke in simbole. Dalja gesla so varneja.",
    description3: "e izgubite geslo naprave, boste morali ponastaviti napravo in obnoviti varnostno kopijo denarnice.",
    subtitle: "Zdaj boste vpisali novo geslo naprave",
    title: "Izvaja se prvi zagon vae naprave"
  },
  input: {
    label: "Geslo naprave",
    labelRepeat: "Ponovite geslo naprave",
    placeholderRepeat: "Prosimo, potrdite geslo naprave"
  }
}, invalidFormat$2 = "Neveljavna oblika", language$3 = {
  title: "Izberite jezik"
}, legacyhiddenwallet$2 = {
  disable: "Onemogoi starejo skrito denarnico (legacy wallet)",
  enable: "Omogoi skrito denarnico starejega formata (legacy)",
  successDisable: "Skita denarnica bitcoin rauna stareje generacije je onemogoena.",
  successEnable: "Skrita denarnica starejega formata je uspeno omogoena. Znova prikljuite svoj BitBox in skrbno vnesite geslo naprave za dostop do stareje skrite denarnice."
}, loading$2 = "nalaganje", manageAccounts$1 = {
  accountHidden: "Ta raun je bil skrit in ga ni ve na seznamu opazovalnih raunov. e ga elite videti ponovno, priklopite va Bitbox02.",
  editAccount: "Uredi",
  editAccountNameTitle: "Uredi ime rauna",
  noAccounts: "ni raunov",
  settings: {
    hideTokens: "Skrij etone",
    showTokens: "Prikai etone ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Dodajaj in aktiviraj/deaktiviraj raune",
  title: "Upravljanje raunov",
  watchAccount: "Opazovalni raun",
  watchAccountDescription: "Ta raun je del vaih opazovalnih raunov. Z drsnikom ga lahko skrijete."
}, mobile$2 = {
  usingMobileDataWarning: `Uporaba podatkov na mobilni napravi: ta aplikacija lahko po odklepanju rauna naloi do nekaj sto megabajtov podatkov. e elite prepreiti uporabo mobilnih podatkov, se poveite z Wi-Fi omrejem. 
To sporoilo ne bo ve prikazano, e ga ugasnete.`
}, newSettings$1 = {
  about: {
    appVersion: {
      title: "Verzija aplikacije"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Preprei dostop do aplikacije z zaklepom zaslona.",
      title: "Zaklep zaslona"
    },
    coinControl: {
      description: "Za vejo stopnnjo zasebnosti izberite kateri UTXO naj bo del transakcije."
    },
    customFees: {
      description: "To vam omogoa vnos poljubne viine provizije za transakcijo."
    },
    torProxy: {
      description: "Poveite se preko Tor omreja za ve zasebnosti."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Te dodatne valute lahko izmenjujoe prikazujete na strani raunov.",
      title: "Aktivne valute"
    },
    darkmode: {
      description: "BitBoxApp v temnem nainu"
    },
    defaultCurrency: {
      description: "Izberite privzeto valuto",
      title: "Privzeta valuta"
    },
    hideAmounts: {
      description: "Prikae preklopnik za skrivanje stanja in zneskov, za vao vejo zasebnost, ko aplikacijo uporabljate na javnem mestu.",
      hideAmounts: "Skrij zneske",
      showAmounts: "Prikai zneske",
      title: "Dovoli skrivanje zneskov"
    },
    language: {
      description: "Izberite jezik, ki ga elite uporabiti v BitBoxApp-u.",
      title: "Jezik"
    },
    toggleSats: {
      description: "Prikaite ali skrijte Satoije (sats)."
    }
  }
}, note$3 = {
  input: {
    description: "(opcijsko)",
    placeholder: "Dodaj opombo"
  },
  title: "Opomba"
}, notification$2 = {
  newTxs_one: "{{count}} novih transakcij na: {{accountName}}",
  newTxs_other: "{{count}} novih transakcij na: {{accountName}}"
}, pairing$2 = {
  aborted: {
    text: "Uparjanje je bilo prekinjeno s strani mobilne aplikacije.",
    title: "Prekinjeno"
  },
  button: "Uparite z mobilno aplikacijo",
  confirm: "Ali ste prepriani, da elite upariti svoj BitBox? Upotevajte, da je po uparitvi mobilni telefon vedno potreben za izvedbo transakcije.",
  connectOnly: {
    button: "Poveite z mobilno aplikacijo",
    title: "Skenirajte z nao mobilno aplikacijo tako, da izberete menijsko toko Connect to new desktop app"
  },
  error: {
    text: "Nekaj je lo narobe. Prosimo, zanite znova.",
    title: "Napaka"
  },
  pullFailed: {
    text: "Sporoila iz mobilnega telefona ni bilo mogoe pridobiti prek relejskega strenika. Strenik je morda brez povezave. Prosimo, obrnite se na podporo.",
    title: "Parjenje ni uspelo"
  },
  reconnectOnly: {
    button: "Ponovno vzpostavite povezavo z mobilno aplikacijo"
  },
  scanningFailed: {
    text: "Mobilnik ni uspeno skeniral sporoila. Prosimo poskusite ponovno.",
    title: "Skeniranje ni uspelo"
  },
  start: {
    hideAppQRCode: "Skrij kodo QR",
    revealAppQRCode: "Prikai QR kodo",
    step1: "e mobilne aplikacije e nimate, lahko skenirate QR kodo za Apple App Store ali Google Play Store, odvisno od tega, kateri telefon imate.",
    step2: "Skenirajte z nao mobilno aplikacijo, ki jo najdete pod imenom Digital Bitbox 2FA v trgovinah z aplikacijami za iOS in Android:"
  },
  started: {
    text: "Prosimo sledite navodilom v mobilni aplikaciji.",
    title: "Super"
  },
  success: {
    text: "estitamo, uspeno ste uparili BitBox z mobilno aplikacijo!",
    title: "Uspelo je!"
  },
  timeout: {
    text: "Seznanitev je potekla po dveh minutah. Zanite znova, e elite BitBox e vedno upariti z mobilno aplikacijo.",
    title: "Odmor"
  },
  title: "Mobilno seznanjanje"
}, passphrase$1 = {
  considerations: {
    button: "",
    message: `Geselska fraza zagotavlja dodaten nivo zaite varnostni kopiji vae denarnice (bodisi na microSD kartici ali 24 besedam). e nekdo pridobi dostop do vae varnostne kopije (na kartici ali besede), bo za dostop do vae denarnice potreboval tudi geselsko frazo.

To pa pomeni, da boste potrebovali <strong>oboje - geselsko frazo in varnostno kopijo denarnice</strong>, da bi obnovili tako zaiteno denarnico, e se va BitBox02 pokvari ali ga izgubite. e pozabite ali izgubite to geslo, boste izgubili dostop do vseh kovancev v tej denarnici!

Geselsko frazo shranjujte loeno od varnostne kopije. S tem prepreite vdor v denarnico, e nekdo najde le njeno varnostno kopijo.`,
    title: "Razmislek o varnostni kopiji"
  },
  disable: "Onemogoi geselsko frazo",
  disableInfo: {
    button: "Izklopi",
    message: `Po izklopu geselske fraze, vas BitBox ob odklepu ne bo ve spraeval po njej. S tem boste vstopili v privzeto denarnico.

Vsi kovanci v denarnici, zaiteni z izbrano geselsko frazo, bodo e vedno v tej denarnici, vendar do njih ne boste mogli dostopati, saj boste po odklepanju naprave odprli svojo privzeto denarnico.

Da bi znova odprli denarnico, ki je zaitena z geselsko frazo, enostavno ponovno omogoite to funkcijo in vnesite izbrano geselsko frazo na BitBox02.

<strong>Namig:</strong> Kljub temu lahko dostopate do privzete denarnice, le geselske fraze ne vtipkavajte ob vstopu v BitBox.`
  },
  enable: "Omogoi geselsko frazo",
  error: {
    e104: "Sprememba geselske fraze je bila prekinjena..."
  },
  how: {
    button: "Kako izgleda",
    message: `Geselska fraza ne deluje tako kot "navadno" geslo, ki ste ga vajeni. e se ob vnosu geselske fraze zatipkate, na napako NE boste opozorjeni. To pa zato, ker <strong>vsaka geselska fraza ustvari razlino a veljavno denarnico</strong>. To pomeni, da lahko uporabljate ve geselskih fraz za ve denarnic na BitBox02. Vse te denarnice so na BitBox02 dostopne le po vsakokratnem vnosu ustrezne geselske fraze.

Ob prikljuitvi naprave BitBox02 boste, kot obiajno, pozvani k vpisu gesla naprave. Nato boste morali v napravo vnesti e geselsko frazo.

Po vnosu fraze se vam bo ta prikazala na zaslonu. Tako boste lahko potrdili, da ste jo vnesli pravilno oz. da ste vnesli eljeno.
`,
    title: "Kako deluje"
  },
  intro: {
    message: `Geselska fraza zagotavlja dodatni nivo varnosti za vao denarnico.
Spoznajmo, kako deluje.`,
    title: "Vnesite eljeno geselsko frazo"
  },
  progressDisable: {
    message: "Na BitBoxu potrdite, da elite <strong>onemogoiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  progressEnable: {
    message: "Na BitBoxu potrdite, da elite <strong>omogoiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  successDisabled: {
    message: `Geselska fraza <strong>uspeno omogoena</strong>!
Odslej jo boste vselej vnaali v napravo.`,
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    title: "Geselska fraza omogoena"
  },
  successEnabled: {
    message: `Geselska fraza <strong>uspeno onemogoena</strong>!
Naprava vas po njej ne bo ve spraevala ob odklepanju.`,
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    tips: "Namigi",
    tipsList: [
      "Priporoamo, da v denarnico zaiteno s frazo najprej poljete majhen znesek. Nato BitBox ponovno priklopite in vnesite geslo ter frazo. e vse vnesete pravilno, boste lahko videli in upravljali kovance na tej denarnici.   ",
      "e elite dostopati do privzete denarnice, nezaitene z geselsko frazo, to e vedno lahko storite tako, da preskoite korak, ko vas BitBox povabi k vnosu faze."
    ],
    title: "Geselska fraza onemogoena"
  },
  summary: {
    button: "Omogoite geselsko frazo",
    title: "Povzetek",
    understand: "Razumem kako deluje geselska fraza in vsa povezana tveganja.",
    understandList: [
      "Geselska fraza je dodaten nivo zaite za varnostno kopijo.",
      "e vnesete razlino geselsko frazo, boste vedno ustvarili razlino denarnico.",
      "Za obnovitev denarnice potrebujete <strong>oboje, geselsko frazo in varnostno kopijo</strong>.",
      "e pozabite ali izgubite svojo geselsko frazo, <strong>izgubite dostop do svojih kovancev.</strong>"
    ]
  },
  what: {
    button: "Spoznajte kako to deluje",
    message: `Denarnica je ustvarjena (pridobljena) iz zelo velikega nakljunega tevila, znanega tudi kot seme (seed). To seme je ustvarjeno ob prvi nastavitvi naprave BitBox02 in je varnostno kopirano na microSD kartici ali z 24 besedami. Vsakdo, ki ima dostop do semena, ima popoln nadzor nad sredstvi v tej denarnici.

Geselska fraza ali passphrase je <strong>opcijska skrivnost</strong>, ki je dodana semenu. Pri uporabi geselske fraze vsaka ustvari novo denarnico na podlagi prerauna semena + geselske fraze. Geselska fraza je lahko karkoli: rke, besede, posebni znaki ali pa je lahko celo prazna. Privzeta denarnica dejansko izhaja iz semena + prazne fraze.

"Passphrase" ali geselska fraza je del BIP39 priporoila, kar pomeni, da je kompatibilna z vsemi denarnicami, ki sledijo temu priporoilu (ali kvazi standardu)`,
    title: "Kaj je geselska fraza?"
  },
  why: {
    button: "Zakaj uporabiti geselsko frazo?",
    message: `BitBox02 varuje seme (skrivnost, ki jo ustvari) pred odtujitvijo (kopiranjem) iz same naprave, vendar varnostna kopija (na microSD kartici ali izpis 24 besed) omogoa popoln dostop do denarnice. Zato jo je treba hraniti na varnem mestu!

Ker geselska fraza ustvari novo denarnico z uporabo vaega obstojeega semena, denarnica zaitena s frazo za obnovo zahteva oboje <strong>varnostno kopijo in geselsko frazo</strong>. Prednost tega je, da e nekdo najde vao varnostno kopijo (v obliki 24 besed ali na microSD kartici), za dostop do kovancev e vedno potrebuje geselsko frazo.

Poleg tega lahko z uporabo ve geselskih fraz na enem BitBox-u upravljate mnogo med seboj loenih denarnic!`,
    title: "Zakaj uporabiti geselsko frazo?"
  }
}, password$2 = {
  show: "Prikai {{label}}",
  warning: {
    caps: "OPOZORILO: Vklopljene imate VELIKE RKE ()",
    paste: 'da prilepite besedilo, omogoite "PRIKAI {{label}}"'
  }
}, random$3 = {
  button: "Ustvari nakljuno tevilo",
  description: "BitBox je ustvaril {{bits}}-bitno nakljuno tevilo:"
}, receive$4 = {
  changeScriptType: "Spremenite tip naslova",
  label: "Va naslov",
  onlyThisCoin: {
    description: "e elite prejemati druge podprte etone, jih omogoite v nastavitvah. e na naslove, ki so na voljo nakaete/poljete nepodprte etone, zelo verjetno ne bodo vidni/ dostopni.",
    warning: "Prepriajte se, da na ta naslov prejemate le {{coinName}}."
  },
  scriptType: {
    p2tr: "Taproot (najnoveja oblika)",
    p2wpkh: "Native Segwit (privzeto)",
    "p2wpkh-p2sh": "Wrapped Segwit (stareji tip)"
  },
  selectAccount: "Izberite raun",
  showFull: "Pokai in preveri polni naslov na napravi",
  taprootWarning: "Opomba: Taproot je nov tip Bitcoin naslova, ki ni e povsod podprt. Sredstva, prejeta na Taproot naslov, morda ne bodo vidna v drugih denarnicah s katerim dostopate do svoje naprave. tevilne denarnice in menjalnice e niso zmone poslati na Taproot naslove.",
  title: "Prejmi {{accountName}}",
  verify: "Skrbno preverite naslov",
  verifyBitBox01: "Preverite naslov v mobilni aplikaciji",
  verifyBitBox02: "Preverite naslov na BitBox02",
  verifyInstruction: "Preverite, da se prikazan naslov ujema s tistim, ki je prikazan na BitBoxu in to potrdite na napravi.",
  warning: {
    secureOutput: "Prosimo, uparite BitBox z mobilno aplikacijo, da omogoite varno preverjanje naslovov. Pojdite na Upravljanje naprave v stranski vrstici."
  }
}, reset$2 = {
  description: "Vsi podatki na napravi bodo izbrisani. To vkljuuje va zasebni klju!",
  notReset: "Naprava NI ponastavljena.",
  title: "Ponastavi napravo (reset)",
  understand: "Imam varnostno kopijo in poznam geslo za njeno obnovitev",
  understandBB02: "Imam veljavno varnostno kopijo"
}, securityInformation$2 = {
  create: {
    description1: "Priporoamo, da prvo nastavitev naprave izvedete v varnem okolju, kjer vas nihe ne opazuje in ne more beleiti vnaanja gesla.",
    description2: "Od vas se bo zahtevalo, da ustvarite dve gesli.",
    description3: "Prvo je <strong> geslo naprave</strong>, ki odklene va BitBox (napravo). Pozneje ga lahko spremenite.",
    description4: "Drugo je <strong>geslo za obnovitev</strong>, ki odklene vao denarnico. Tega gesla kasneje ni mogoe spremeniti!",
    description5: "Ko ustvarite denarnico, bo ta shranjena v datoteko na microSD kartico. To lahko uporabite v nujnih primerih za povrnitev sredstev s pomojo  <strong>gesla za obnovitev</strong>.",
    title: "Pomembne informacije"
  },
  restore: {
    description1: "Vstaviti boste morali microSD kartico, ki ste jo uporabili za shranjevanje varnostne kopije.",
    description2: "e elite obnoviti denarnico, boste potrebovali geslo za obnovitev.",
    description3: "Bodite previdni in natanni pri vnosu gesla. Vsako geslo, ki ga vnesete, bo ustvarilo novo veljavno denarnico. e vnesete napano geslo, se vam bo verjetno prikazalo stanje denarnice, ki ga ne priakujete.",
    title: "Varnostne informacije"
  }
}, seed$2 = {
  agreements: {
    "funds-access": "da ostanem BREZ DOSTOPA do svojih sredstev, e pozabim to geslo!",
    "password-change": "pozneje NI MONO spremeniti gesla za obnovitev!",
    "password-required": "Obnovitveno geslo je potrebno za obnovitev denarnice iz varnostne kopije"
  },
  create: "Ustvari denarnico",
  creating: "Ustvarjanje denarnice",
  description: "Razumem da:",
  error: {
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e200: "Za kreiranje nove denarnice morate v BitBox vstaviti microSD kartico. S tem omogoite samodejno kreiranje varnostne kopije."
  },
  info: {
    button: "Zdaj nastavite geslo za obnovo denarnice",
    description1: "Vstavite microSD kartico v BitBox",
    description2: 'Ustvarite geslo za obnovitev denarnice in izberite "Nastavi geslo za obnovitev"',
    description3: "Varnostna kopija na microSD kartici in geslo za obnovitev je edina metoda za povrnitev sredstev v primeru izgubljenega, unienega ali ukradene denarnice BitBox01.",
    description4: "Pozneje ni mono spremeniti gesla za obnovitev brez prenosa sredstev.",
    title: "Ustvarite novo denarnico"
  },
  password: {
    label: "Geslo za obnovitev",
    repeatPlaceholder: "Ponovite geslo za obnovitev"
  },
  walletName: {
    label: "Ime denarnice"
  }
}, seedRestore$2 = {
  error: {
    e200: "Obnova oz. priklic denarnice iz varnostne kopije zahteva microSD kartico."
  },
  info: {
    description1: 'Vstavite microSD kartico v BitBox in kliknite "Nadaljujte"',
    description2: "Izberite varnostno kopijo in kliknite Obnovi",
    description3: "Vnesite geslo za obnovo",
    description4: "Potrdite, da razumete, da bo napano geslo ustvarilo drugo, novo denarnico.",
    title: "Kako obnoviti denarnico iz varnostne kopije"
  }
}, send$4 = {
  abort: "Transakcija je bila prekinjena.",
  address: {
    label: "Naslov prejemnika",
    placeholder: "Vnesite naslov"
  },
  amount: {
    label: "Znesek",
    placeholder: "Vnesite znesek"
  },
  availableBalance: "Razpololjivo stanje",
  button: "Podpii in polji",
  coincontrol: {
    address: "Naslov",
    outpoint: "",
    title: "Polji iz (output):"
  },
  confirm: {
    "selected-coins": "Izbrani kovanci",
    title: "Potrdite in poljite transakcijo",
    total: "Skupaj"
  },
  error: {
    erc20InsufficientGasFunds: "Kot kae na vaem raunu ni dovolj ETH za plailo transakcije za premik ERC02 etona. Poskrbite za zadostno koliino ETH na vaem Ethereum raunu.",
    feeTooLow: "Omrenina je prenizka",
    feesNotAvailable: "Provizije ni mo oceniti",
    insufficientFunds: "nezadostna sredstva",
    invalidAddress: "neveljaven naslov",
    invalidAmount: "neveljaven znesek",
    invalidData: "neveljavni podatki"
  },
  fee: {
    customPlaceholder: "Vnesite znesek",
    label: "Omrenina",
    placeholder: "Ni na voljo"
  },
  feeTarget: {
    customLabel: "Stopnja provizije",
    customLabel_eth: "Vrednost Gas-a",
    description: {
      economy: "4 ure (24 blokov)",
      economy_eth: "30 minut ali manj",
      economy_ltc: "1 ura (24 blokov)",
      high: "20 minut (2 bloka)",
      high_eth: "30 sekund ali manj",
      high_ltc: "5 minut (2 bloka)",
      low: "2 uri (12 blokov)",
      low_eth: "5 minut ali manj",
      low_ltc: "30 minut (12 blokov)",
      normal: "1 ura (6 blokov)",
      normal_eth: "2 minuti ali manj",
      normal_ltc: "15 minut (6 blokov)"
    },
    estimate: "Predviden as potrditve:",
    label: {
      custom: "Po meri",
      economy: "Ekonomina",
      high: "Visoka",
      low: "Nizka",
      normal: "Normalna"
    },
    placeholder: "Preraunavam..."
  },
  maximum: "Polji vse",
  maximumSelectedCoins: "Polji izbrane kovance",
  noFeeTargets: "Generirane provizije trenutno niso dostopne. Prosimo poizkusite ponovno ali vnesite poljubno viino provizije.",
  priority: "Omrenina",
  scanQR: "Skenirajte QR kodo",
  signprogress: {
    description: "Ta transakcija vsebuje veliko podatkov. e elite v celoti podpisati transakcijo, boste morali potrditi {{steps}} krat.",
    label: "V teku"
  },
  success: "Transakcija je bila podpisana in poslana.",
  title: "Polji {{accountName}}",
  toggleCoinControl: "Odpri nadzor nad kovanci",
  transactionDetails: "Podrobnosti transakcije"
}, settings$3 = {
  about: "O nastavitvah",
  accounts: "Rauni",
  advancedSettings: "Napredne nastavitve",
  appearance: "Izgled",
  electrum: {
    add: "Dodaj strenik",
    "add-server": "Dodaj",
    check: "Preveri",
    checkFailed: "Ni uspelo",
    checkSuccess: "Uspelo je vzpostaviti povezavo do {{host}}",
    checking: "Preverjam",
    "download-cert": "Prenesite oddaljeni certifikat",
    "remove-server": "Odstrani",
    removeConfirm: "Odstrani {{server}}?",
    reset: "Ponastavi na privzeto",
    resetConfirm: "Ali elite odstraniti vse strenike in namestiti privzete strenike?",
    servers: "Streniki",
    step1: "1",
    "step1-text": "Vnesite konno toko.",
    step2: "2",
    "step2-text": "Vnesite certifikat strenike verige potrdil. Lahko pa prenesete oddaljeno potrdilo in ga vizualno primerjate.",
    "step2-text-tcp": "Ta korak lahko preskoite, e ne elite uporabljati TLS.",
    step3: "3",
    "step3-text": "Preverite povezavo in dodajte strenik.",
    step4: "4",
    "step4-text": "Znova zaenite denarnico. e ne odstranite privzetih strenikov, bo vae lastno vozlie dodano kot redundanno.",
    "title-btc": "Streniki Bitcoin Electrum-a",
    "title-ltc": "Streniki Litecoin Electrum-a",
    "title-tbtc": "Streniki Bitcoin Testnet Electrum-a",
    "title-tltc": "Streniki Litecoin Testnet Electrum-a"
  },
  expert: {
    coinControl: "Omogoi nadzor nad kovanci (Coin control)",
    electrum: {
      description: "Poveete lahko svoje Electrum vozlie.",
      title: "Poveite svoje polno vozlie"
    },
    fee: "Omogoi provizije po meri",
    setProxyAddress: "Nastavite naslov proxy strenika",
    title: "Napredne nastavitve",
    useProxy: "Omogoi tor proxy",
    useSats: "Prikai vrednosti v Satoshi-jih"
  },
  header: {
    home: "Domov"
  },
  info: {
    "out-of-date": "Na voljo je nova nadgradnja",
    title: "Info",
    "up-to-date": "Aplikacija je posodobljena",
    version: "Verzija aplikacije"
  },
  restart: "Znova zaenite BitBoxApp, da spremembe zanejo veljati.",
  services: {
    title: "Storitve"
  },
  success: "Iztaknite in ponovno vtaknite BitBox v USB, da zanejo veljati ustvarjene spremembe.",
  title: "Nastavitve"
}, setup$2 = "Nastavitev naprave", sidebar$3 = {
  buy: "Kupite kripto",
  device: "Upravljanje naprave",
  leave: "Zapusti",
  settings: "Nastavitve"
}, success$9 = {
  create: {
    info1: `Vaa denarnica je arhivirana na microSD kartico. 
Odstranite jo in jo varno shranite.`,
    info2: "Ustvarili ste varno geslo, ki odklene BitBox.",
    info3: "Ustvarili ste varno geslo za obnovitev denarnice, ki odklene sredstva in obnovi varnostne kopije.",
    summary: "Preberite povzetek storjenega:",
    title: "Uspelo je!"
  },
  getstarted: "Zanite",
  restore: {
    summary: "Uspeno ste obnovili denarnico.",
    title: "Uspelo je!"
  }
}, transaction$3 = {
  confirmation: "t. potrditev",
  details: {
    activity: "Dejavnost",
    address: "Naslov",
    amount: "Znesek",
    date: "Datum",
    fiat: "V fiat valuti",
    fiatAmount: "Znesek v fiat valuti",
    fiatAtTime: "Vrednost v asu transakcije",
    status: "Stanje",
    type: "Tip"
  },
  explorer: "ID transakcije",
  explorerTitle: "Odpri v zunanjem raziskovalcu",
  fee: "Omrenina",
  fiatHistorical: "Zgodovinsko",
  gas: "Gas",
  note: {
    edit: "Uredi opombo",
    save: "Shrani opombo"
  },
  pending: "Nedokonana transakcija",
  size: "Velikost",
  status: {
    complete: "Zakljueno",
    failed: "Ni uspelo",
    pending: "V teku"
  },
  tx: {
    received: "Prejeto na",
    sent: "Poslano na"
  },
  vsize: "Virtualna velikost",
  weight: "Ute"
}, transactions$2 = {
  errorLoadTransactions: "Napaka pri nalaganju transakcij.",
  placeholder: "Ni transakcij."
}, unknownError$2 = "Prilo je do neznane napake: {{errorMessage}}", unlock$2 = {
  description: "Vnesite geslo, da odklenete napravo.",
  error: {
    e109_normal: "Napano geslo naprave. t. poskusov pred ponastavitvijo naprave: {{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) Naslednja prijava zahteva dalje dranje gumba na dotik.",
    e113: "Zaradi prevelikega tevila poskusov prijave, morate za novo prijavo pridrati tipko za dotik vsaj 4 sekunde."
  },
  input: {
    label: "Geslo naprave",
    placeholder: "...vnesite tukaj."
  },
  unlocking: "Odklepanje..."
}, upgradeFirmware$3 = {
  button: "Nadgradite strojno programsko opremo",
  description: "Ali elite nadgraditi strojno programsko opremo iz razliice {{currentVersion}} na {{newVersion}}?",
  label: "Va BitBox zahteva nadgradnjo strojne programske opreme.",
  locked: "Za nadgradnjo z {{currentVersion}} na {{newVersion}}, izvedite dolg pritisk na LED luko.",
  title: "Nadgradite strojno programsko opremo",
  unlocked: "Zaganjalnik (bootloader) je odklenjen. e elite nadaljevati:",
  unlocked1: "Iztaknite in ponovno prikljuite svoj Bitbox",
  unlocked2: "Ko bo BitBox01 ponovno prikljuen bo zasvetila LED luka",
  unlocked3: "Ko zasveti LED luka, se jo dotaknite"
}, walletConnect$3 = {
  connect: {
    button: "Povei",
    dappLabel: "Vnesi URI naslov za DApp",
    invalidPairingUri: "Napaen povezovalni URI"
  },
  dashboard: {
    allSessions: "Vse seje",
    disclaimer: "WalletConnect je protokol za povezavo z decentraliziranimi avtonomnimi aplikacijami (Dapps), ki temeljijo na Ethereumu. Te Dapps-e upravljajo tretje oseb (in ne Shift Crypto ali WalletConnect), zato se poveite le s tistimi, ki jim zaupate, in se prepriajte, da vedno veste, kaj podpisujete, ko opravljate transakcijo.",
    newConnection: "Nova povezava",
    noConnectedSessions: "Noben raun ni povezan s katero od DApp-ov"
  },
  invalidPairingChain: "Napaka pri potrditvi povezave. Prepriajte se, da uporabljate eno od podprtih verig: {{chains}}",
  pairingRequest: {
    approve: "Potrdi povezavo",
    reject: "Zavrni",
    title: "Zahteva za novo povezavo od"
  },
  pairingSuccess: "DApp je uspeno povezana. Nadaljujete lahko na spletni strani te DApp.",
  signingRequest: {
    account: "Raun",
    chain: "Omreje",
    dapp: "Dapp",
    data: "Podatki",
    dataParsingError: "Podatkov nismo uspeli razleniti",
    decodeError: "Sporoila nismo uspeli dekodirati",
    method: {
      sendTransaction: "Podpii in polji transakcijo",
      signMessage: "Podpii sporoilo",
      signTransaction: "Podpii transakcijo",
      signTypedData: "Podpii vnesene podatke"
    },
    successfullySigned: "Zahteva je uspeno podpisana",
    walletConnectRequest: "WalletConnect zahteva "
  },
  useNewUri: "Ta URI je bil e uporabljen za poskus vzpostavitve povezave. Uporabite nov URI.",
  walletConnect: "WalletConnect"
}, warning$8 = {
  receivePairing: "Prosimo, da seznanite BitBox01 s pametnim telefonom, da si omogoite varno preverjanje naslovov. Pojdite na Upravljanje naprave v stranski vrstici.",
  sdcard: "MicroSD kartico hranite loeno od BitBoxa, razen ko upravljate z varnostnimi kopijami.",
  sendPairing: `Za varno preverjanje podrobnosti o transakcijah seznanite BitBox
z mobilno napravo. Pojdite na Upravljanje naprave v stranski vrstici.`
}, welcome$2 = {
  connect: "Vklopi BitBox02",
  getStarted: "Zanimo z namestitvijo strojne programske opreme (firmware)",
  insertBitBox02: "Na BitBox02 se dotaknite eljene strani zaslona. ",
  insertDevice: "Za zaetek, prikljuite denarnico",
  title: "Dobrodoli"
}, appTranslationsSL = {
  account: account$2,
  accountInfo: accountInfo$2,
  accountSummary: accountSummary$2,
  addAccount: addAccount$3,
  aopp: aopp$1,
  app: app$2,
  auth: auth$2,
  backup: backup$2,
  bb02Bootloader: bb02Bootloader$2,
  bitbox: bitbox$2,
  bitbox02Interact: bitbox02Interact$2,
  bitbox02Settings: bitbox02Settings$2,
  bitbox02Wizard: bitbox02Wizard$2,
  blink: blink$2,
  bootloader: bootloader$2,
  button: button$6,
  buy: buy$3,
  changePin: changePin$2,
  chart: chart$3,
  checkSDcard: checkSDcard$2,
  clickHere: clickHere$2,
  confirm: confirm$4,
  confirmOnDevice: confirmOnDevice$2,
  connectKeystore: connectKeystore$2,
  darkmode: darkmode$2,
  device: device$2,
  deviceLock: deviceLock$2,
  deviceSettings: deviceSettings$2,
  deviceTampered: deviceTampered$2,
  dialog: dialog$3,
  error: error$3,
  fiat: fiat$4,
  footer: footer$4,
  generic: generic$3,
  genericError: genericError$2,
  goal: goal$2,
  guide: guide$3,
  headerssync: headerssync$2,
  hiddenWallet: hiddenWallet$2,
  initialize: initialize$2,
  invalidFormat: invalidFormat$2,
  language: language$3,
  legacyhiddenwallet: legacyhiddenwallet$2,
  loading: loading$2,
  manageAccounts: manageAccounts$1,
  mobile: mobile$2,
  newSettings: newSettings$1,
  note: note$3,
  notification: notification$2,
  pairing: pairing$2,
  passphrase: passphrase$1,
  password: password$2,
  random: random$3,
  receive: receive$4,
  reset: reset$2,
  securityInformation: securityInformation$2,
  seed: seed$2,
  seedRestore: seedRestore$2,
  send: send$4,
  settings: settings$3,
  setup: setup$2,
  sidebar: sidebar$3,
  success: success$9,
  transaction: transaction$3,
  transactions: transactions$2,
  unknownError: unknownError$2,
  unlock: unlock$2,
  upgradeFirmware: upgradeFirmware$3,
  walletConnect: walletConnect$3,
  warning: warning$8,
  welcome: welcome$2
}, account$1 = {
  disconnect: "... .  ",
  export: "",
  exportTransactions: "     ",
  fatalError: ".   ",
  incoming: "",
  initializing: "  ..",
  reconnecting: "... ,   ",
  syncedAddressesCount: " {{count}} "
}, accountInfo$1 = {
  address: "",
  extendedPublicKey: "  ",
  label: " ",
  title: " ",
  verify: "  "
}, accountSummary$1 = {
  availableBalance: " ",
  balance: "",
  exportSummary: "      ",
  fiatBalance: "  ",
  name: " ",
  noAccount: "  ",
  title: " ",
  total: " ",
  transactionHistory: " "
}, addAccount$2 = {
  title: " "
}, app$1 = {
  upgrade: "     !   {{current}} {{version}}"
}, backup$1 = {
  check: {
    checking: "... ",
    confirmTitle: " ",
    notOK: ".    ",
    ok: ".   ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: ":  ",
    title: " "
  },
  create: {
    alreadyExists: "?  .    ",
    fail: "!   ",
    info: ".         ",
    name: {
      label: " ",
      placeholder: "   "
    },
    password: {
      label: " ",
      placeholder: "    "
    },
    title: " ",
    verificationFailed: ".      .  .      "
  },
  description: " <strong>  </strong>",
  insert: "      ",
  insertButton: "   ",
  list: "   ",
  noBackups: "    ",
  restore: {
    confirmTitle: " ",
    error: {
      e200: "   ",
      general: "  "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "     ",
      showLabel: " "
    },
    restoring: "... ",
    title: "",
    understand: "       "
  },
  showMnemonic: {
    description: `.  24 ,   .     

<strong>      </strong>
<strong>    </strong>
<strong>   </strong>

. ,    `,
    title: "mnemonic seed -"
  },
  title: " "
}, bb02Bootloader$1 = {
  abort: "  -   ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "      "
  },
  flipscreen: " ",
  orientation: "?   ",
  success: "... !   {{rebootSeconds}} "
}, bitbox$1 = {
  error: {
    e10000: ".    ",
    e10001: "   ",
    e102: ".    4  ",
    e112: ".         "
  }
}, bitbox02Interact$1 = {
  confirmDate: "     02",
  confirmDateText: ".   ",
  confirmName: "   02",
  followInstructions: "    02",
  followInstructionsMnemonic: "mnemonic seed -     02    "
}, bitbox02Settings$1 = {
  deviceName: {
    current: "  ",
    input: " 02",
    placeholder: "  ",
    title: "  02"
  }
}, bitbox02Wizard$1 = {
  attestationFailed: ".  ,            .    ",
  backup: {
    point1: "   ",
    point2: "  ",
    restoreText: "!,  ",
    text1: ".,  02   .       .       02 - ",
    text2: "           ",
    text3: ".  ,         <strong> </strong>.       .       02  ",
    userConfirmation1: ".      ",
    userConfirmation2: ".    .         ",
    userConfirmation3: ".   02 ,         ",
    userConfirmation4: ".   , 02 ,   ",
    userConfirmation5: "        , ,      "
  },
  create: {
    button: "   ",
    info: ":    ",
    inputTitle: " ",
    point1: "  ",
    point2: "  ",
    point3: " ",
    text: "!,    "
  },
  createBackupFailed: ".  ,  ",
  initialize: {
    passwordText: ".   .      ",
    passwordTitle: "   ",
    text: "   !     02.          . <strong>       02</strong>",
    tip: ".    ",
    title: "  "
  },
  insertSDCard: "<strong>      02</strong>",
  noPasswordMatch: ".  ,   ",
  pairing: {
    failed: ".  .    02",
    paired: ".    .   ,       ",
    title: "  ",
    unpaired: ".02  .        .   ,         "
  },
  restoreFromMnemonic: {
    failed: ".,    mnemonic seed - "
  },
  stepBackup: {
    beforeProceed: ": ,       ",
    createBackup: ".    "
  },
  stepBackupSuccess: {
    fundsSafe: ":-   , ",
    title: "! "
  },
  stepConnected: {
    unlock: "   02   "
  },
  stepCreate: {
    nameLabel: " 02",
    namePlaceholder: "02 ",
    title: "  02",
    toastMicroSD: ".       02"
  },
  stepCreateSuccess: {
    removeMicroSD: ".     02    ",
    success: ".  "
  },
  stepInsertSD: {
    insertSDCard: ".     02  ",
    insertSDcardTitle: ".  "
  },
  stepPassword: {
    title: "  02",
    useControls: ".     02"
  },
  stepUninitialized: {
    create: ".   02 ",
    restore: ".      ",
    restoreMicroSD: "  ",
    restoreMnemonic: "mnemonic seed -",
    title: "  02 "
  },
  success: {
    text: `.! 02   

.     ,          `,
    title: "!  "
  }
}, blink$1 = {
  button: ""
}, bootloader$1 = {
  button: "  ",
  progress: "%: {{progress}}",
  success: ". !     . ,   "
}, button$5 = {
  abort: "",
  back: "",
  buy: "",
  changepin: "  ",
  check: " ",
  continue: "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: "",
  upgrade: ""
}, buy$2 = {
  title: " {{name}}"
}, changePin$1 = {
  newTitle: "  ",
  oldLabel: "  "
}, chart$2 = {
  dataMissing: "   ,      ",
  dataUpdating: "... ",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
}, checkSDcard$1 = "  ", clickHere$1 = ". ", confirm$3 = {
  abortInfo: " ",
  abortInfoRedText: "",
  approveInfo: " 4+  ",
  approveInfoGreenText: "",
  info: ". ",
  infoWhenPaired: "    "
}, confirmOnDevice$1 = ".   ", device$1 = {
  appUpradeRequired: ".    - .     "
}, deviceLock$1 = {
  button: "  -",
  condition1: "?  ",
  condition2: "?    ",
  condition3: " -     .       -",
  confirm: "  -",
  title: "  -"
}, deviceSettings$1 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "  ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      false: " ",
      label: " ",
      true: ""
    },
    title: ""
  },
  loading: "   ",
  pairing: {
    lock: {
      false: "",
      label: " -",
      true: ""
    },
    mobile: {
      false: "",
      label: " ",
      true: ""
    },
    status: {
      false: " ",
      label: "",
      true: ""
    },
    title: ""
  },
  secrets: {
    manageBackups: " ",
    title: ""
  }
}, deviceTampered$1 = ".     ?  ,        .          ", dialog$2 = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
}, fiat$3 = {
  default: " ",
  setDefault: " {{code}}  ",
  title: ""
}, footer$3 = {
  appVersion: " :"
}, generic$2 = {
  enabled_false: "",
  enabled_true: ""
}, genericError$1 = " .    ,    .", goal$1 = {
  buttons: {
    create: "  ",
    restore: "  "
  },
  paragraph: "   :",
  step: {
    1: {
      title: "  "
    },
    2: {
      description: "  ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
}, guide$2 = {
  accountDescription: {
    text: ".            .   ' '      ",
    title: "?    "
  },
  accountFiat: {
    text: "..         .      ",
    title: "?     "
  },
  accountIncomingBalance: {
    text: ".       ",
    title: "?  "
  },
  accountInfo: {
    xpub: {
      text: `.         
.         ,    `,
      title: "?    "
    }
  },
  accountRates: {
    text: "        -.",
    title: "?   "
  },
  accountReload: {
    text: ". .     ",
    title: "?      "
  },
  accountSendDisabled: {
    text: ". ''    ",
    title: "?      {{unit}}"
  },
  accountSummaryAmount: {
    text: `coingecko.com        .    

    ,      MyEtherWallet :    

`,
    title: "?   "
  },
  accountSummaryDescription: {
    text: "         .         ",
    title: "?    "
  },
  accountTransactionAttributesBTC: {
    text: `. :    .        
.:        
.     .      ,     .  -   ,          SegWit :    `,
    title: "?      "
  },
  accountTransactionAttributesGeneric: {
    text: `.:          ,    .         .             
. :        
.:          .  ,    `,
    title: "?    "
  },
  accountTransactionConfirmation: {
    text: ".     ",
    title: "?   "
  },
  accountTransactionLabel: {
    text: ".        ",
    title: "?     "
  },
  accountTransactionTime: {
    text: ".     ",
    title: "?   "
  },
  appendix: {
    link: "  ",
    text: " ?"
  },
  backups: {
    check: {
      text: ". '           .          .          '",
      title: "'  ' "
    },
    encrypt: {
      text: ". Seed -,          ",
      title: "?    "
    },
    howOften: {
      text: `.      .           ,       
.     .          `,
      title: "?    "
    },
    whatIsABackup: {
      text: ".       Seed -   .  Seed -   ",
      title: "?  "
    }
  },
  backupsBB02: {
    check: {
      text: ". '           '",
      title: "?'  ' "
    },
    encrypt: {
      text: '. ,         "  Seed -     .      Seed -.      ,     ',
      title: "?    "
    },
    whatIsABackup: {
      text: ".    Seed -    ",
      title: "?  "
    }
  },
  bitbox: {
    "2FA": {
      text: `.  - ,           .          -,  ,       .                  

.             -.  ,       .           `,
      title: "?  - "
    },
    disable2FA: {
      text: "-    -,           .               .    ' '.       '  '.       ''          .",
      title: "?      -"
    },
    ejectBitbox: {
      text: ".    ",
      title: "?    "
    },
    ejectSD: {
      text: ".      ,      ",
      title: "?     "
    },
    hiddenWallet: {
      text: ".     ,      Seed -     ,        ",
      title: "?   "
    },
    legacyHiddenWallet: {
      text: ".     (          - ),             ",
      title: "?     "
    },
    pairing: {
      text: `.      , QR       ,     
. ,     `,
      title: "      "
    }
  },
  receive: {
    address: {
      text: "        .      ",
      title: "?    "
    },
    addressChange: {
      text: ".  ,     ,     20     ",
      title: "?  "
    },
    addressFormats: {
      text: " ,       .       ,        ",
      title: "?       "
    },
    howVerify: {
      text: `01,           .        
02,           `,
      title: "?     "
    },
    why20: {
      text: '.    .         ,      .          20     .  " " - 20   -     .  20     Seed - ,     ',
      title: "?  20 "
    },
    whyMany: {
      text: ".   Seed -    ,       .   ,       .     20   .      .    ",
      title: "?   -  "
    },
    whyVerify: {
      text: "         .           .  01,          ,       -.  02,         02",
      title: "      ?"
    }
  },
  send: {
    fee: {
      text: `.        .               .         
(: 24  ( 4  ,   
(: 12  (  , 30   
(: 6  ( , 15   
(: 2  ( 20  , 5   
      (2.5  )        `,
      title: "?  "
    },
    priority: {
      text: ".        ,      ",
      title: "?   "
    },
    revert: {
      text: `!    ,   .    ( )   
.            (  )  ,      `,
      title: "?   "
    },
    whyFee: {
      text: `.    .        
    .           (     ),            .   ,              `,
      title: "?   "
    }
  },
  "settings-electrum": {
    connection: {
      text: `          (,   ),    
 ,      ..  
      ,    .    ..  `,
      title: "?   , ..  .."
    },
    instructions: {
      link: {
        text: "   "
      },
      text: ": ,   ",
      title: "?        "
    },
    options: {
      text: `     .    ,       
       ,      .         
   ,     `,
      title: "?    "
    },
    tor: {
      text: `         ,    .       ,           .        :
 -        9150
 -    
       9050  `,
      title: "?  ,      "
    },
    what: {
      text: "           ",
      title: "? "
    },
    why: {
      text: "              . ,       ,       -    . ,       .",
      title: "?    "
    }
  },
  settings: {
    servers: {
      text: `  ,        Shift Crypto -    
          -
,    ,          
.Etherscan.io APIs -   ERC20 -   `,
      title: "?    "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: ".        ,   ",
      title: "?      "
    },
    reset: {
      text: ".   15 .        ",
      title: "?    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "     .     .   ,      ",
      title: " 01   "
    },
    getDevice: {
      link: {
        text: "  "
      },
      text: ":     ",
      title: "?    "
    },
    internet: {
      text: ",       ,      ",
      title: "    ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "          ",
      title: "?  .  "
    },
    useWithoutDevice: {
      text: ".,    ",
      title: "?     "
    },
    welcome: {
      text: `        
   ,     `,
      title: "!   "
    }
  }
}, headerssync$1 = {
  blocksSynced: "{{blocks}}  "
}, hiddenWallet$1 = {
  info1HTML: ".<strong></strong>  ,         +  ",
  info2HTML: ".          .      <strong></strong>     ",
  passwordLabel: "  ",
  passwordPlaceholder: "     ",
  pinLabel: "  ",
  pinRepeatLabel: "    ",
  pinRepeatPlaceholder: "     ",
  success: ".   .         "
}, initialize$1 = {
  create: "  ",
  creating: "...  ",
  error: {
    e102: ".     4 "
  },
  info: {
    description1: ".   .       ",
    description2: ".  ,  .     ",
    description3: ".   ,       ",
    subtitle: "     ",
    title: "  "
  },
  input: {
    label: " ",
    labelRepeat: "   ",
    placeholderRepeat: "    "
  }
}, invalidFormat$1 = " ", language$2 = {
  title: " "
}, legacyhiddenwallet$1 = {
  disable: "     ",
  enable: "     ",
  successDisable: "      ",
  successEnable: "      .               "
}, loading$1 = "...", mobile$1 = {
  usingMobileDataWarning: `.     WiFi-  :        -        .   
. ,     `
}, note$2 = {
  input: {
    description: "",
    placeholder: "... "
  },
  title: ""
}, notification$1 = {
  newTxs_one: "{{count}}   : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
}, pairing$1 = {
  aborted: {
    text: ".  -  ",
    title: ""
  },
  button: "  ",
  confirm: ".      ?     ,     ",
  connectOnly: {
    button: "  ",
    title: "'    , -   '  "
  },
  error: {
    text: ". .  ",
    title: ""
  },
  pullFailed: {
    text: ".       .       ,     ",
    title: " "
  },
  reconnectOnly: {
    button: "    "
  },
  scanningFailed: {
    text: ".      .  ",
    title: " "
  },
  start: {
    hideAppQRCode: "QR  ",
    revealAppQRCode: "QR  ",
    step1: ".     ,     QR      ,   ",
    step2: "Digital BitBox 2FA -   ,          "
  },
  started: {
    text: ",     ",
    title: ""
  },
  success: {
    text: "! ,         ",
    title: ""
  },
  timeout: {
    text: "     .        ",
    title: " "
  },
  title: " "
}, password$1 = {
  show: " {{label}}",
  warning: {
    caps: ":  () ",
    paste: "  ,   {{label}}"
  }
}, random$2 = {
  button: "  ",
  description: ":     {{bits}}- "
}, receive$3 = {
  label: "",
  onlyThisCoin: {
    description: ".   ,   .    ,     ",
    warning: ".    {{coinName}}   "
  },
  showFull: "    ",
  title: " {{accountName}}",
  verify: "   ",
  verifyBitBox01: "   ",
  verifyBitBox02: "  02",
  verifyInstruction: ".            ",
  warning: {
    secureOutput: ".           .  ' '  "
  }
}, reset$1 = {
  description: "!   ,      ",
  notReset: ".  ",
  title: "  ",
  understand: "    ",
  understandBB02: "   "
}, securityInformation$1 = {
  create: {
    description1: ".      ,         ",
    description2: ".   ",
    description3: ".  <strong> </strong>          ",
    description4: ".  <strong> </strong>    .       ",
    description5: "        .           <strong> </strong>",
    title: "  "
  },
  restore: {
    description1: ".       ",
    description2: "   ,    ",
    description3: ".        .      .            ",
    title: "  "
  }
}, seed$1 = {
  agreements: {
    "funds-access": "          ",
    "password-change": "        ",
    "password-required": "      "
  },
  create: " ",
  creating: " ",
  description: ":  ",
  error: {
    e102: ".    4 ",
    e200: ".     , -  ,    "
  },
  info: {
    button: "   ",
    description1: "    ",
    description2: "        ",
    description3: ".           ,       ",
    description4: ".      ,    ",
    title: "  "
  },
  password: {
    label: " ",
    repeatPlaceholder: "   "
  },
  walletName: {
    label: " "
  }
}, seedRestore$1 = {
  error: {
    e200: ".     "
  },
  info: {
    description1: "       ",
    description2: "   ",
    description3: "   ",
    description4: ".        ",
    title: "   "
  }
}, send$3 = {
  abort: " ",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: "",
  coincontrol: {
    address: "",
    outpoint: " ",
    title: " "
  },
  confirm: {
    "selected-coins": " ",
    title: "  ",
    total: " "
  },
  error: {
    feeTooLow: "  ",
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: " "
  },
  feeTarget: {
    description: {
      economy: "(: 24 ( 4  ,  ",
      economy_ltc: "( (24 ",
      high: "(: 2 ( 20  , 5  ",
      high_ltc: "(  (2 ",
      low: "(: 12 (  , 30  ",
      low_ltc: "(  (12 ",
      normal: "(: 6 (  ,   ",
      normal_ltc: "(  (6 "
    },
    estimate: ":  ",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "...  "
  },
  maximum: " ",
  priority: "",
  scanQR: "QR  ",
  signprogress: {
    description: ".    .      ,   {{steps}} ",
    label: ""
  },
  success: "  ",
  title: " {{accountName}}",
  toggleCoinControl: "  ",
  transactionDetails: " "
}, settings$2 = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "   {{host}}",
    checking: "",
    "download-cert": "  ",
    "remove-server": "",
    removeConfirm: "? {{server}}",
    reset: "  ",
    resetConfirm: "?          ",
    servers: "",
    step1: "1",
    "step1-text": "  ",
    step2: "2",
    "step2-text": "      . ,       ",
    "step2-text-tcp": "TLS -        ",
    step3: "3",
    "step3-text": "     ",
    step4: "4",
    "step4-text": "   .       ,    ",
    "title-btc": "  ",
    "title-ltc": "  ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "  ",
    electrum: {
      title: "    "
    },
    fee: "  ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: "  "
  },
  header: {
    home: ""
  },
  restart: ".      ",
  services: {
    title: ""
  },
  success: ".       ",
  title: ""
}, setup$1 = " ", sidebar$2 = {
  device: " ",
  leave: "",
  settings: ""
}, success$8 = {
  create: {
    info1: "      .    .",
    info2: "       .",
    info3: ".     ,       ",
    summary: "    ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: ".    ",
    title: ""
  }
}, transaction$2 = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: " ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "   ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  note: {
    edit: " ",
    save: " "
  },
  pending: " ",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: ""
  },
  tx: {
    received: " ",
    sent: " "
  },
  vsize: " ",
  weight: ""
}, transactions$1 = {
  placeholder: ".  "
}, unknownError$1 = "   : {{errorMessage}}", unlock$1 = {
  description: ".       ",
  error: {
    e109_normal: ".  . {{remainingAttempts}}     ",
    e109_touch: ".$t(unlock.error.e109_normal)       ",
    e113: ".  ,         4 "
  },
  input: {
    label: " ",
    placeholder: "       "
  },
  unlocking: "... "
}, upgradeFirmware$2 = {
  button: " ",
  description: "?     {{currentVersion}} {{newVersion}}",
  label: "    ",
  locked: "  {{currentVersion}} {{newVersion}}},   ",
  title: " ",
  unlocked: ": .  ",
  unlocked1: "    ",
  unlocked2: "       ",
  unlocked3: "     "
}, warning$7 = {
  receivePairing: ".    -     .  ' '  ",
  sdcard: "     ,      ",
  sendPairing: ".    -   .  ' '  "
}, welcome$1 = {
  insertBitBox02: "   ",
  insertDevice: "    ",
  title: " "
}, appTranslationsHE = {
  account: account$1,
  accountInfo: accountInfo$1,
  accountSummary: accountSummary$1,
  addAccount: addAccount$2,
  app: app$1,
  backup: backup$1,
  bb02Bootloader: bb02Bootloader$1,
  bitbox: bitbox$1,
  bitbox02Interact: bitbox02Interact$1,
  bitbox02Settings: bitbox02Settings$1,
  bitbox02Wizard: bitbox02Wizard$1,
  blink: blink$1,
  bootloader: bootloader$1,
  button: button$5,
  buy: buy$2,
  changePin: changePin$1,
  chart: chart$2,
  checkSDcard: checkSDcard$1,
  clickHere: clickHere$1,
  confirm: confirm$3,
  confirmOnDevice: confirmOnDevice$1,
  device: device$1,
  deviceLock: deviceLock$1,
  deviceSettings: deviceSettings$1,
  deviceTampered: deviceTampered$1,
  dialog: dialog$2,
  fiat: fiat$3,
  footer: footer$3,
  generic: generic$2,
  genericError: genericError$1,
  goal: goal$1,
  guide: guide$2,
  headerssync: headerssync$1,
  hiddenWallet: hiddenWallet$1,
  initialize: initialize$1,
  invalidFormat: invalidFormat$1,
  language: language$2,
  legacyhiddenwallet: legacyhiddenwallet$1,
  loading: loading$1,
  mobile: mobile$1,
  note: note$2,
  notification: notification$1,
  pairing: pairing$1,
  password: password$1,
  random: random$2,
  receive: receive$3,
  reset: reset$1,
  securityInformation: securityInformation$1,
  seed: seed$1,
  seedRestore: seedRestore$1,
  send: send$3,
  settings: settings$2,
  setup: setup$1,
  sidebar: sidebar$2,
  success: success$8,
  transaction: transaction$2,
  transactions: transactions$1,
  unknownError: unknownError$1,
  unlock: unlock$1,
  upgradeFirmware: upgradeFirmware$2,
  warning: warning$7,
  welcome: welcome$1
}, account = {
  disconnect: "Connessione interrotta. Riprovo...",
  export: "Esporta",
  exportTransactions: "Esporta transazioni in formato CSV nella cartella download",
  fatalError: "Si  verificato un errore inatteso",
  incoming: "In entrata",
  initializing: "Raccolgo informazioni dalla blockchain",
  maybeProxyError: "Proxy Tor attivato. Assicurati che il tuo proxy Tor funzioni correttamente, oppure disabilita l'impostazione del proxy.",
  reconnecting: "Connessione persa, provo a riconnettermi...",
  syncedAddressesCount: "{{count}} indirizzi letti"
}, accountInfo = {
  address: "Indirizzo",
  buyCTA: {
    buy: "Acquista {{unit}}",
    buyCrypto: "Acquista cryptovalute",
    information: {
      looksEmpty: "Sembra che il portafoglio sia vuoto.",
      start: "Iniziate depositando alcune valute nel portafoglio o acquistando direttamente nella BitBoxApp."
    }
  },
  extendedPublicKey: "Chiave pubblica estesa",
  label: "Informazioni sull'account",
  scriptType: "Tipo di script",
  title: "Informazioni sull'account",
  verify: "Verifica sul dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizza la chiave pubblica estesa di P2PKH",
    p2tr: "Visualizza Taproot",
    p2wpkh: "Visualizza Native Segwit",
    "p2wpkh-p2sh": "Visualizza la chiave pubblica estesa Segwit pi vecchia"
  },
  xpubTypeInfo: "Attualmente viene visualizzata la chiave pubblica estesa {{scriptType}} ({{current}} di {{numberOfXPubs}})"
}, accountSummary = {
  availableBalance: "Saldo disponibile",
  balance: "Saldo",
  exportSummary: "Esporta il riepilogo dell'account in formato CSV nella cartella download",
  fiatBalance: "Saldo fiat",
  name: "Nome account",
  noAccount: "Non ci sono account da mostrare",
  subtotalWithCoinName: "Totale ({{coinName}})",
  title: "Il mio portafoglio",
  total: "Totale",
  transactionHistory: "Storico transazioni"
}, addAccount$1 = {
  chooseName: {
    nextButton: "Aggiungi account",
    step: "Nome dell'account",
    title: "Assegna un nome all'account"
  },
  selectCoin: {
    nextButton: "Avanti",
    step: "Seleziona valuta",
    title: "Seleziona cryptovaluta"
  },
  success: {
    addAnotherAccount: "Aggiungi un nuovo account",
    message: "<strong>{{accountName}}</strong>  stato aggiunto ai tuoi account.",
    nextButton: "Fatto",
    step: "Finito",
    title: "Account aggiunto"
  },
  title: "Aggiungi account"
}, aopp = {
  addressRequest: "{{host}} richiede un indirizzo di ricezione.",
  addressRequestWithLogo: `richiede un indirizzo di ricezione
`,
  banner: "Richiesta dell'indirizzo in corso",
  errorTitle: "Errore durante la richiesta dell'indirizzo",
  labelAddress: "Indirizzo",
  labelMessage: "Messaggio",
  reverifyInfoText: "Verifica indirizzo",
  signing: `Per procedere, firmare il messaggio sul BitBox02
`,
  success: {
    message: "Continua su {{host}}",
    title: "Indirizzo inviato con successo"
  },
  syncing: `Sincronizzazione dell'account, attendere prego.
`,
  title: "Richiesta di indirizzo"
}, app = {
  upgrade: "E' disponibile una nuova versione di questa app! Aggiorna dalla {{current}} alla {{version}}."
}, auth$1 = {
  authButton: "Autenticati",
  title: "Autenticati per continuare"
}, backup = {
  check: {
    checking: "Sto verificando backup...",
    confirmTitle: "Verifica backup",
    notOK: "Il backup NON combacia con il portafoglio.",
    ok: "Il backup combacia con il portafoglio.",
    password: {
      label: "Password di recupero",
      placeholder: "Password di recupero",
      showLabel: "password di recupero"
    },
    success: "Back verificato con successo:",
    title: "Verifica backup"
  },
  create: {
    alreadyExists: "Hai gi un backup valido. Vuoi ricrearlo?",
    fail: "Creazione backup FALLITA!",
    info: "Inserisci la password di recupero del portafoglio attuale per la verifica.",
    name: {
      label: "Nome del backup",
      placeholder: "Assegna un nome al backup"
    },
    password: {
      label: "Password di recupero",
      placeholder: "Inserisci la tua password di recupero"
    },
    title: "Crea backup",
    verificationFailed: "La password di recupero NON corrisponde al portafoglio attuale. Il backup  stato creato. Per favore usa 'Controlla backup' per verificare di nuovo la tua password di recupero."
  },
  description: "Scegli <strong>il file di backup del wallet</strong>",
  insert: "Inserisci la carta microSD per gestire i backup.",
  insertButton: "Ho inserito la carta microSD",
  list: "I tuoi backup sulla carta microSD",
  noBackups: "Non ci sono backup su questa carta microSD",
  restore: {
    confirmTitle: "Ripristina backup",
    error: {
      e200: "Carta microSD non trovata",
      general: "Errore nel ripristino del backup"
    },
    password: {
      label: "Password di recupero o password di recupero nascosta",
      placeholder: "Password di recupero",
      repeatPlaceholder: "Ripeti password di recupero",
      showLabel: "Password di recupero"
    },
    restoring: "Ripristino backup...",
    selectedBackup: "<strong>{{backupName}}</strong> creato in data {{createdDateTime}} verr ripristinato.",
    title: "Ripristina",
    understand: "Capisco che una password di recupero errata creer un portafoglio diverso"
  },
  showMnemonic: {
    description: `Ti verranno mostrate le parole di recupero, che formano un backup del tuo portafoglio. Scrivile su carta.

<strong>Non custodirle digitalmente e non fotografarle.</strong>

<strong>Non pronunciare le parole ad alta voce.</strong>

<strong>Questo backup non  protetto da password.</strong>

In seguito ti sar richiesto di confermare ogni parola.`,
    title: "Mostra le parole di recupero",
    warning: "<strong>Non condividere le tue parole di recupero con nessuno.</strong> Le parole di recupero danno pieno accesso al tuo portafogli. Se qualcuno ti chiede le tue parole di recupero, vuole truffarti. Non condividerle!"
  },
  title: "Gestisci i backup"
}, bb02Bootloader = {
  abort: "Non aggiornare - riportami indietro",
  abort_noUpgrade: "Indietro",
  advanced: {
    label: "Impostazioni avanzate",
    toggleShowFirmwareHash: "Mostrami l'hash del firmware ogni volta all'avvio"
  },
  flipscreen: "Capovolgi schermo",
  orientation: "Orientamento del dispositivo sbagliato?",
  success: "Aggiornamento riuscito! Passo successivo in {{rebootSeconds}} secondi...",
  success_install: "Installazione riuscita! Continua tra {{rebootSeconds}} secondi..."
}, bitbox = {
  error: {
    e10000: "Password errata per questo dispositivo",
    e10001: "Impossibile sostituire la password del dispositivo",
    e102: "La password deve essere di almeno 4 caratteri.",
    e112: "La password nascosta non pu essere uguale alla password principale del dispositivo."
  }
}, bitbox02Interact = {
  confirmDate: "Conferma la data di oggi sul tuo BitBox02",
  confirmDateText: "Questa data sar usata per creare il tuo backup.",
  confirmName: "Conferma il nome sul BitBox02",
  confirmWords: "Prendi nota delle {{amount}} parole di recupero dal tuo BitBox02",
  confirmWordsText: "In seguito il BitBox02 ti chieder di confermare ogni parola per verificare la correttezza del tuo backup.",
  followInstructions: "Segui le istruzioni sul tuo BitBox02",
  followInstructionsMnemonic: "Segui le istruzioni sul tuo BitBox02 per ripristinare utilizzando le parole di recupero.",
  followInstructionsMnemonicTitle: `Ripristina da parole di recupero
`
}, bitbox02Settings = {
  deviceName: {
    current: "Nome attuale del dispositivo",
    error: "Non  stato possibile configurare il nome del dispositivo",
    error_104: "La conferma del nome del dispositivo  stata abortita sul dispositivo.",
    input: "Nome del BitBox02",
    placeholder: "Nuovo nome del dispositivo",
    title: "Imposta il nome del BitBox02"
  },
  gotoStartupSettings: {
    description: "Questo riavvia il BitBox02 e inizializza le impostazioni di avvio.",
    title: `Vai alle impostazioni di avvio
`
  }
}, bitbox02Wizard = {
  advanced: {
    button: "Opzioni avanzate",
    outOfDate: "Firmware non aggiornato per questa funzionalit",
    seed12WordInfo: "Attenzione, il numero di parole non potr essere modificato dopo la creazione del portafogli.",
    seed12WordLabel: "Crea un seed da 12 parole invece di 24",
    seed12WordText: "Il BitBox02 di default usa un seed da 24 parole. All'atto pratico, entrambe le lunghezze del seed sono sicure contro attacchi di tipo brute force. Alcuni utenti potrebbero preferire la comodit di un seed da 12 parole.",
    skipSDCardLabel: "Salta il backup su microSD e sostituiscilo annotando le parole di recupero",
    skipSDCardText: "Hai sempre l'opzione di creare un backup su microSD o annotare le parole di recupero dopo il setup. Puoi farlo dalle impostazioni.",
    title: "Opzioni di backup avanzate"
  },
  attestationFailed: "L'attestazione del dispositivo non  riuscita. Ci potrebbe essere dovuto al riavvio dell'app mentre il dispositivo stava aspettando l'input dell'utente. Si prega di ricollegarsi e riprovare. Contattare support@bitbox.swiss se l'errore persiste.",
  backup: {
    point1: "Scegli un backup sulla carta microSD",
    point2: "Imposta una password per il tuo dispositivo",
    restoreText: "Ok, ripristiniamo un backup!",
    text1: "Bene, la tua password di BitBox02  ora impostata e il portafoglio creato. Ora  il momento di creare il tuo primo backup. Assicurati che la tua scheda microSD sia inserita nel tuo BitBox02 e continua.",
    text2: "Segui le istruzioni sullo schermo del tuo dispositivo per creare un backup.",
    text3: "Dopo che il backup  stato creato, rimuovi la scheda microSD e conservala in un luogo <strong>sicuro</strong>. Il contenuto della scheda microSD non  protetto da password. Non inserirla mai in nessun altro dispositivo che non sia il tuo BitBox02.",
    userConfirmation1: "Devo conservare il backup in un luogo sicuro.",
    userConfirmation2: "Il backup non  protetto da una password. Chiunque abbia accesso ad esso pu accedere anche al mio portafoglio.",
    userConfirmation3: "Se perdo o danneggio il mio BitBox02, l'unico modo per recuperare i miei fondi  ripristinare il backup.",
    userConfirmation4: "Se perdo o danneggio sia il backup che il dispositivo BitBox02, i miei fondi andranno persi.",
    userConfirmation5: "Non devo inserire il mio backup su scheda microSD in un computer, telefono, stampante o qualsiasi altro dispositivo che non sia un BitBox02.",
    userConfirmation5mnemonic: "Non devo inserire le mie parole di recupero in un computer, telefono, stampante o altro dispositivo diverso da BitBox02."
  },
  create: {
    button: "Assegnare un nome al dispositivo e continuare",
    info: "Ecco i passaggi necessari per configurare il tuo BitBox: ",
    inputTitle: "Nome del portafoglio",
    point1: "Dai un nome al tuo dispositivo",
    point2: "Imposta una password per il tuo dispositivo",
    point3: "Crea un backup",
    text: "Bene, ora creiamo un nuovo portafoglio!"
  },
  createBackupAborted: "Creazione del backup interrotta.",
  createBackupFailed: "Creazione del backup fallita. Riprovare.",
  initialize: {
    passwordText: "Ora impostiamo la password del dispositivo. Usa i controlli sul tuo BitBox per scegliere i caratteri della password.",
    passwordTitle: "Imposta la password per il tuo BitBox",
    text: "BitBox02 abbinato con successo! Ora inizializziamo il tuo dispositivo. Inizia scegliendo se creare un nuovo portafoglio o ripristinare un portafoglio da un backup esistente. <strong>Assicurati di avere una scheda microSD inserita nel tuo BitBox02</strong>",
    tip: "Ti consigliamo di procedere in un luogo sicuro.",
    title: "Inizializza il tuo BitBox"
  },
  insertSDCard: "<strong>Assicurati di aver inserito la scheda microSD nel tuo BitBox02.</strong>",
  noPasswordMatch: "Le password non corrispondono. Riprovare.",
  pairing: {
    failed: "Abbinamento non confermato. Ricollega il tuo BitBox02.",
    paired: "Hai confermato il seguente codice sul tuo dispositivo. Puoi continuare.",
    title: "Verifica il codice di abbinamento",
    unpaired: " stato rilevato un nuovo BitBox02. Si prega di verificare che il seguente codice corrisponda a quello mostrato sul tuo dispositivo. Se il codice corrisponde, tocca sotto il segno di spunta sul tuo BitBox02 e poi clicca sul pulsante qui sotto per continuare."
  },
  restoreFromMnemonic: {
    e104: "Il ripristino tramite parole di recupero  stato cancellato.",
    failed: "Ripristino con parole di recupero non riuscito. Riprovare."
  },
  stepBackup: {
    beforeProceed: "Prima di procedere, leggi queste importanti considerazioni sulla sicurezza:",
    createBackup: "Ora si procede a creare un backup sulla scheda microSD.",
    createBackupMnemonic: "Scrivi le parole di recupero."
  },
  stepBackupSuccess: {
    fundsSafe: "Per tenere i tuoi fondi al sicuro, ricordati quanto segue:",
    title: "Backup ripristinato!"
  },
  stepConnected: {
    unlock: "Inserisci la password del BitBox02 per sbloccare."
  },
  stepCreate: {
    description: "Questo nome viene utilizzato come nome del dispositivo e per il backup.",
    nameLabel: "Nome del BitBox02",
    namePlaceholder: "Il mio BitBox02",
    title: "Scegli il nome del BitBox02",
    toastMicroSD: "Inserisci nel tuo BitBox02 la scheda microSD che sar utilizzata per salvare un backup del tuo portafogli."
  },
  stepCreateSuccess: {
    removeMicroSD: "Rimuovere la scheda microSD dal BitBox02 e conservarla in un luogo sicuro.",
    storeMnemonic: "Custodisci le tue parole di recupero in un posto sicuro",
    success: "Il backup  stato creato con successo."
  },
  stepInsertSD: {
    insertSDCard: "Inserisci la scheda microSD nel BitBox02 per continuare.",
    insertSDcardTitle: "Inserire la scheda microSD"
  },
  stepPassword: {
    e104: "L'impostazione della password  stata cancellata.",
    title: "Impostare la password del BitBox02",
    useControls: "Usa i controlli sul tuo BitBox02 per impostare la password."
  },
  stepUninitialized: {
    create: "Vorrei configurare un nuovo BitBox02.",
    restore: "Vorrei ripristinare il mio portafoglio da un backup.",
    restoreMicroSD: "Ripristina dalla scheda microSD",
    restoreMnemonic: "Ripristina utilizzando le parole di recupero",
    title: "Configurare il BitBox02"
  },
  success: {
    text: `Urr! Il tuo BitBox02  ora pronto all'uso. 

Per ulteriori informazioni su come utilizzare la BitBoxApp, si prega di utilizzare la guida in-app cliccando sul punto di domanda in alto a destra.`,
    title: "Pronti a partire!"
  }
}, blink = {
  button: "Lampeggia"
}, bootloader = {
  button: "Aggiornare il firmware",
  button_install: "Installa il firmware adesso",
  progress: "Aggiornamento: {{progress}}%",
  progress_install: `Installazione: {{progress}}%
`,
  success: "Aggiornamento riuscito! Ricollegare il dispositivo. Questa volta non toccare il pulsante."
}, button$4 = {
  abort: "Interrompere",
  back: "Indietro",
  buy: "Acquista",
  changepin: "Cambia la password del dispositivo",
  check: "Verifica il backup",
  continue: "Continua",
  copy: "Copia",
  create: "Creare",
  dismiss: "Sospendi",
  done: "Fatto",
  download: "Scarica",
  hiddenwallet: "Crea un portafoglio nascosto",
  next: "Successivo",
  ok: "OK",
  previous: "Precedente",
  receive: "Ricevi",
  restore: "Ripristina",
  select: "Selezionare",
  send: "Invia",
  unlock: "Sblocca",
  update: "Aggiorna",
  upgrade: "Aggiorna"
}, buy$1 = {
  exchange: {
    bankTransfer: "Bonifico bancario",
    bestDeal: "Miglior prezzo",
    creditCard: "Carta di credito",
    fast: "Rapido",
    fee: "commissione",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bonifico Bancario: {{fee}}%",
          creditDebitCard: "Carta di debito/credito: {{fee}}%",
          learnMore: "Scopri di pi su Moonpay",
          title: "Commissioni"
        },
        fullCurrenciesList: "Vedi la lista completa di valute qui",
        payment: {
          asteriskText: "* Non disponibile per i residenti in US",
          bankTransfer: "Bonifico bancario*",
          bankTransferDetails: {
            pix: "PIX (Transazioni BR esclusivamente in Brasile)",
            sepa: "SEPA e SEPA istantaneo (transazioni EUR esclusivamente in Paesi SEPA)",
            uk: "UK Faster Payments (transazioni GBP esclusivamente in UK)"
          },
          creditDebitCard: "Carta di credito/debito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Vedi pi dettagli sui metodi di pagamento",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta tutte le principali valute fiat: USD, EUR, CHF, and altre."
      },
      pocket: {
        fees: {
          info: "Bonifico bancario: {{fee}}%",
          title: "Commissioni"
        },
        learnMore: "Scopri di pi su Pocket",
        payment: {
          bankTransfer: "Bonifico bancario",
          bankTransferDetails: {
            sepa: "SEPA e SEPA istantaneo (per le transazioni in EUR nei Paesi SEPA)",
            sic: "Swiss Interbank Clearing (per le transazioni in CHF in CH/LI)",
            uk: "UK Faster Payments (per le transazioni GBP in UK)"
          },
          bankTransferReccuring: "Come impostare degli acquisti ricorrenti tramite un ordine permanente?",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta le seguenti valute Europee: EUR, GBP e CHF",
        verification: {
          info: "Richiede una verifica dell'identit solamente al di sopra delle soglie giornaliere ed annuali",
          link: "Trova le soglie aggiornate qui",
          title: "Verifica dell'identit"
        }
      },
      region: {
        title: "Selezione il Paese in cui hai registrato il tuo conto bancario per vedere le opzioni disponibili per te."
      }
    },
    noExchanges: "Mi dispiace, non ci sono exchange disponibili in questo Paese",
    region: "Paese",
    selectRegion: "Non specificato",
    title: "Compra {{name}}"
  },
  info: {
    continue: "Accetta e continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Siamo una partnership MoonPay per offrirti un modo semplice per comprare {{name}} direttamente all'interno della BitBoxApp. Bastano pochi click.",
        "MoonPay  una piattaforma che rende comprare {{name}} facile e veloce in oltre 160 paesi."
      ],
      payment: {
        details: "Puoi comprare {{name}} istantaneamente tramite MoonPay con i seguenti metodi di pagamento. Gli ordini con carta di credito o di debito sono immediati e convenienti, ma pi costosi a causa del maggior rischio di chargeback. Raccomandiamo di usare l'opzione del bonifico bancario per importi maggiori. La tariffa minima  di 4 USD/EUR o equivalente.",
        footnote: "Si prega di notare che i tassi di cambio di MoonPay possono differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
        table: {
          "1_description": "Tariffe pi basse, possono richiedere fino a 3 giorni lavorativi",
          "1_method": "Trasferimenti bancari (SEPA)",
          "2_description": "Commissioni pi alte, ma veloce ed istantaneo",
          "2_method": "Carte di debito e credito",
          description: "Descrizione",
          fee: "Commissione",
          method: "Metodo"
        },
        title: "Metodi di pagamento e commissioni"
      },
      privacyPolicy: "Privacy policy di MoonPay",
      protection: {
        description: "La BitBoxApp non raccoglie alcun dato quando si acquista {{name}} ed i fondi in entrata sono trattati come una normale transazione. MoonPay ha bisogno di raccogliere alcuni dati personali per operare. La loro privacy policy spiega in dettaglio come questi dati vengono gestiti.",
        descriptionGeneric: "BitBoxApp non registra nessun dato durante l'acquisto di {{name}}, i fondi in entrata sono trattati come comuni transazioni. Ci nonostante, gli exchange partner hanno bisogno di alcune informazioni per poter operare. Fai riferimento alle rispettive privacy policy per verificare come i dati vengono gestiti.",
        title: "Protezione dei dati"
      },
      security: {
        description: `Quando acquisti {{name}} tramite MoonPay, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione.`,
        descriptionGeneric: `Quando acquisti {{name}} tramite un exchange partner, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione.`,
        link: "Security threat model",
        title: "Security model"
      },
      title: "Benvenuto nel tuo sportello unico per l'acquisto di {{name}}"
    },
    next: "Prossimo",
    selectLabel: "Scegli un account",
    selectPlaceholder: "Seleziona una valuta",
    skip: "Non mostrare pi",
    title: "Acquista {{name}}"
  },
  pocket: {
    data: {
      link: "Privacy policy di Pocket",
      p1: "BitBoxApp non registra nessun dato durante l'acquisto di Bitcoin, i fondi in entrata sono trattati come comuni transazioni. Pocket ha bisogno di alcune informazioni personali per poter operare. La loro privacy policy spiega in dettaglio come i dati vengono gestiti.",
      title: "Protezione dei dati"
    },
    kyc: {
      link: "Leggi le FAQ di Pocket",
      p1: "Pocket cerca di mantenere al minimo il KYC. Per acquisti al di sotto dei 950 EUR (1000 CHF) al giorno, non  necessario nessun documento aggiuntivo. Per acquisti di importi superiori, sar necessario programmare una call con Pocket per completare le necessarie procedure KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puoi comprare Bitcoin istantaneamente con Pocket tramite un bonifico bancario SEPA. La commissione  del 1,5% e i Bitcoin vengono depositati sul tuo BitBox appena possibile una volta che Pocket ha ricevuto il bonifico (di solito in giornata).",
      p2: "Si prega di notare che i tassi di scambio utilizzati da Pocket potrebbero differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
      title: "Metodi di pagamento e commissioni"
    },
    previousTransactions: "Lo storico di transazioni di questo account non  vuoto. Condividere questo account render tutte le transazioni passate e future visibili per Pocket. Procedere comunque? ",
    security: {
      link: '"BitBox02 security threat model"',
      p1: `Quando acquisti Bitcoin tramite Pocket, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione. Comunque, lavoriamo insieme per migliorare la sicurezza utilizzando un meccanismo di autenticazione a due fattori per verificare il tuo indirizzo di ricezione.`,
      title: "Modello di sicurezza "
    },
    usedAddress: "L'indirizzo {{address}}  gi stato utilizzato, per favore ricomincia da capo con un nuovo indirizzo.",
    verifyBitBox02: "Per favore, verifica che l'indirizzo che hai ricevuto via email corrisponda a quello visualizzato sul tuo BitBox. Se possibile, dovresti aprire la mail su un secondo dispositivo per maggiore sicurezza.",
    welcome: {
      p1: "Collaboriamo con Pocket per offrirti un modo fluido per acquistare Bitcoin direttamente nella BitBoxApp. Sono solo pochi click.",
      p2: "Pocket  una piattaforma Svizzera che rende semplice e veloce acquistare Bitcoin in gran parte dell'Europa (ovunque un bonifico bancario SEPA sia supportato).",
      p3: "Con Pocket, puoi anche acquistare regolarmente tramite singoli bonifici bancari, quindi puoi fare DCA (dollar-cost averaging) con semplicit.",
      title: "Benvenuto nel tuo sportello unico per l'acquisto di Bitcoin"
    }
  },
  title: "Acquista {{name}}"
}, changePin = {
  newTitle: "Nuova password del dispositivo",
  oldLabel: "Password attuale del dispositivo"
}, chart$1 = {
  dataMissing: "Raccolta di dati ... rimanete collegati.",
  dataOldTimestamp: "Aggiornamento dei tassi di cambio storici. Il grafico non visualizza dati posteriori al {{time}}",
  dataUpdating: "aggiornamento dei dati ...",
  filter: {
    all: "Tutto",
    month: "Mese",
    week: "Settimana",
    year: "Anno"
  }
}, checkSDcard = "verifica della scheda microSD", clickHere = "Clicca qui.", confirm$2 = {
  abortInfo: "Tocca per",
  abortInfoRedText: "interrompere",
  approveInfo: "Tocca per almeno 4 secondi per",
  approveInfoGreenText: "confermare",
  info: "Continua sul tuo BitBox",
  infoWhenPaired: "Prima sul cellulare accoppiato e poi sul tuo BitBox"
}, confirmOnDevice = "Conferma sul tuo dispositivo.", connectKeystore$1 = {
  promptNoName: "Connetti il tuo BitBox02 per continuare",
  promptWithName: 'Connetti il tuo BitBox02 con nome "{{name}}" per continuare'
}, darkmode$1 = {
  toggle: "Modalit scura"
}, device = {
  appUpradeRequired: "Il tuo BitBox non  compatibile con questa versione dell'applicazione desktop. Installa l'ultima versione."
}, deviceLock = {
  button: "Abilita autenticazione a due fattori (2FA)",
  condition1: "Hai un backup?",
  condition2: "La verifica via applicazione mobile funziona?",
  condition3: "2FA DISABILITA i backup e l'abbinamento dell'applicazione mobile. Il dispositivo deve essere resettato per uscire da 2FA!",
  confirm: "Abilita autenticazione a due fattori (2FA)",
  title: "Abilita autenticazione a due fattori (2FA)"
}, deviceSettings = {
  backups: {
    manageBackups: {
      description: "Crea o verifica il tuo backup su microSD."
    },
    showRecoveryWords: {
      description: "Mostra e verifica le parole di recupero."
    },
    title: "Backup"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp verifica che il tuo dispositivo sia autentico."
    },
    deviceName: {
      description: "Modifica il nome del tuo dispositivo."
    },
    rootFingerprint: {
      description: "La root fingerprint  un identificatore univoco del portafogli attualmente in uso. Ti pu aiutare a distinguere portafogli diversi se usi la passphrase."
    },
    securechip: {
      description: "Modello del secur chip."
    },
    title: "Informazioni sul dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Ripristina il dispositivo alle impostazioni di fabbrica. Questo cancella il portafogli sul tuo BitBox02!",
      title: "Ripristino alle impostazioni di fabbrica"
    },
    goToStartupSettings: {
      description: "Entra nel bootloader del BitBox02. Da qui puoi abilitare il firmware hash"
    },
    passphrase: {
      description: "Abilita o disabilita la passphrase.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Versione Firmware",
    newVersion: {
      label: "Versione disponibile"
    },
    title: "Firmware",
    upToDate: "Il tuo dispositivo  aggiornato",
    upgradeAvailable: "Nuovo upgrade disponibile",
    version: {
      label: "Versione"
    }
  },
  hardware: {
    attestation: {
      false: "Verifica di autenticit fallita",
      label: "Verifica di autenticit",
      true: "Il tuo Bitbox02  autentico"
    },
    sdcard: {
      false: "Non inserita",
      label: "carta microSD",
      true: "Inserita"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Recupero delle informazioni sul dispositivo...",
  pairing: {
    lock: {
      false: "Disabilitato",
      label: "Autenticazione a due fattori",
      true: "Abilitato"
    },
    mobile: {
      false: "Chiuso",
      label: "Applicazione mobile",
      true: "Aperto"
    },
    status: {
      false: "Non abbinato",
      label: "Status",
      true: "Abbinato"
    },
    title: "Abbinamento"
  },
  secrets: {
    manageBackups: "Gestione backup",
    title: "Segreti"
  }
}, deviceTampered = "Il tuo BitBox  stato fornito con una password di recupero? Se  cos, interrompi il processo di configurazione e contatta il supporto immediatamente. Shift non ti fornir mai un portafoglio pronto n ti consiglier una password.", dialog$1 = {
  cancel: "Annulla",
  confirm: "Conferma",
  confirmTitle: "Conferma"
}, error$2 = {
  accountAlreadyExists: "L'account esiste gi.",
  accountLimitReached: "Impossibile aggiungere un account.  stato raggiunto il numero massimo di account per questa moneta.",
  aoppCallback: `Si  verificato un errore nella consegna dell'indirizzo a {{host}}.
`,
  aoppInvalidRequest: "Richiesta non valida",
  aoppNoAccounts: "Non ci sono account disponibili.",
  aoppSigningAborted: `Richiesta di propriet dell'indirizzo annullata.
`,
  aoppUnknown: `Si  verificato un errore sconosciuto.
`,
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "Non ci sono account disponibili che supportino il formato di indirizzo richiesto.",
  aoppUnsupportedKeystore: `Il dispositivo collegato non pu firmare i messaggi per questo asset.
`,
  aoppVersion: "Versione sconosciuta.",
  wrongKeystore: "Portafogli connesso errato. Assicurati di inserire il dispositivo corretto per questo account.",
  wrongKeystore2: "Se stai utilizzando la passphrase opzionale, assicurati di avere inserito quella corretta per questo account."
}, fiat$2 = {
  default: "predefinito",
  setDefault: "Imposta {{code}} come valuta predefinita",
  title: "Valute"
}, footer$2 = {
  appVersion: "Versione dell'app:"
}, generic$1 = {
  enabled_false: "Disabilitato",
  enabled_true: "Abilitato"
}, genericError = "Si  verificato un errore. Se noti qualche problema, riavvia l'applicazione.", goal = {
  buttons: {
    create: "Creare un nuovo portafoglio",
    restore: "Ripristina un portafoglio dal backup"
  },
  paragraph: "Seleziona una delle seguenti opzioni:",
  step: {
    1: {
      title: "Informazioni sulla sicurezza"
    },
    2: {
      description: "Impostare la password del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crea un nuovo portafoglio",
      title: "Portafoglio"
    },
    "3-restore": {
      description: "da un backup",
      title: "Ripristina"
    },
    "4-create": {
      title: "Riassunto"
    },
    "4-restore": {
      title: "Riassunto"
    }
  }
}, guide$1 = {
  accountDescription: {
    text: "La panoramica dell'account mostra il tuo saldo disponibile e le transazioni in entrata e in uscita. La nostra guida in 'Impostazioni' contiene maggiori informazioni sui diversi tipi di account. ",
    title: "Cosa contiene questa pagina?"
  },
  accountFiat: {
    text: "Si. Clicca su qualsiasi ticker per scorrere tra le valute fiat. Puoi cambiare la lista delle valute nelle impostazioni.",
    title: "Posso visualizzare altri tassi di conversione?"
  },
  accountIncomingBalance: {
    text: "Le somme in entrata riassumono gli importi trasferiti a voi ma non ancora confermati dalla rete.",
    title: "Cosa significa somme in entrata?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Ogni xpub  legata al "Tipo" indicato: "Native Segwit (bech32)", "Wrapped Segwit" o "Taproot" (solo Bitcoin). Questi sono i tipi di script utilizzati da {{coinName}}. La BitBoxApp li combina, supportando pi tipi di script nello stesso account. Poich ogni tipo di script fornisce un xpub diverso, esistono pi xpub per account.

Se si riceve sempre sull'indirizzo predefinito (Native Segwit),  necessario solo l'xpub "bech32". Tuttavia, se si ricevono fondi anche su "Wrapped Segwit" o "Taproot",  necessario utilizzare anche le chiavi pubbliche estese "Wrapped Segwit" e "Taproot" rispettivamente.`,
      title: `Perch ci sono diverse xpub?
`
    },
    privacy: {
      text: `Per questo specifico account, la chiave pubblica estesa rivela l'intera storia finanziaria, il saldo dell'account e tutte le transazioni future. L'xpub per non consente a nessuno di spendere i tuoi fondi.

Se si condivide un'xpub con qualcuno, si deve essere consapevoli che questa persona o azienda pu vedere tutte le altre transazioni dello stesso account. Pertanto,  bene utilizzare quell'account solo per questo scopo e conservare gli altri fondi in account diversi.`,
      title: "Devo tenere la my xpub segreta?"
    },
    verify: {
      text: "S,  sempre una buona idea ricontrollare la propria xpub. E' particolarmente importante nel caso in cui qualcun altro generi indirizzi di ricezione da questa xpub per inviare denaro.  necessario verificarla sul dispositivo per assicurarsi che questa xpub appartenga a voi; in caso contrario, tutti i fondi potrebbero andare a indirizzi sbagliati.",
      title: ` necessario verificare l'xpub sul dispositivo?
`
    },
    xpub: {
      text: `Una chiave pubblica estesa  una chiave "root" da cui derivano tutti gli indirizzi di ricezione di un account. 

 fornita qui per un uso avanzato e per l'interoperabilit con portafogli watch-only, come Electrum o Sentinel. Se hai ricevuto su diversi tipi di indirizzo, importa tutti i diversi formati xpub nel portafoglio watch-only per vedere tutte le tue valute.

Nota bene: i portafogli di terze parti potrebbero non supportare ancora gli xpub di Taproot.`,
      title: "Cos' una chiave pubblica estesa?"
    }
  },
  accountRates: {
    text: "Aggiorniamo i tassi di cambio ogni minuto da CoinGecko.",
    title: "Quali tassi di cambio si applicano?"
  },
  accountReload: {
    text: "Non ce n' bisogno. Le informazioni sulla tua transazione vengono aggiornate automaticamente.",
    title: "Posso ricaricare la cronologia delle transazioni?"
  },
  accountSendDisabled: {
    text: "Il pulsante 'Invia'  attivo quando hai un saldo maggiore di zero.",
    title: "Perch non posso inviare {{unit}}?"
  },
  accountSummaryAmount: {
    text: `L'importo totale  la somma di tutti i tuoi account. I tassi di cambio sono ottenuti da coingecko.com.

Nota: se usi MyEtherWallet per i token non supportati nella BitBoxApp, questi non saranno inclusi nell'importo visualizzato.`,
    title: "Come viene calcolato l'importo totale?"
  },
  accountSummaryDescription: {
    text: "Qui pui vedere la performance del tuo portafogli nel tempo. Sotto il grafico viene visualizzato un riepilogo dei diversi account.",
    title: "Cosa contiene questa pagina?"
  },
  accountTransactionAttributesBTC: {
    text: `Dimensione virtuale: Determina la tassa di rete. Si risparmia sulle commissioni se  pi piccola della dimensione della transazione.
Dimensione: Dimensione effettiva della transazione in byte quando serializzata secondo la blockchain sottostante.
Peso: Una nuova metrica introdotta con Segwit per valutare le dimensioni delle transazioni e dei blocchi. Ogni byte del "segregated witness" conta come uno, tutto il resto come quattro unit di peso. Invece di un megabyte di dimensione effettiva, il limite della dimensione del blocco  ora di quattro milioni di unit di peso.`,
    title: "E i dettagli delle transazioni in Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: `Conferme: La tua prima transazione trasmessa non  confermata fino a quando un minatore la include in un blocco, dopo di che ha una conferma. Ogni blocco trasmesso sulla rete aggiunge un'altra conferma alla tua transazione. Generalmente i commercianti e gli altri attori della rete saldano solo le transazioni con un numero di conferme compreso tra tre e sei.
ID della transazione: Un numero di identificazione unico che permette di cercare una transazione in un esploratore di blocchi.
Commissione: Ai minatori viene pagata una tassa di transazione come incentivo per includere le transazioni nei blocchi che estraggono. Per saperne di pi, clicca sul pulsante invia.`,
    title: "Quali sono le informazioni nei dettagli della transazione?"
  },
  accountTransactionConfirmation: {
    text: "Una transazione trasmessa alla rete ma non ancora confermata.",
    title: "Cos' una transazione in sospeso?"
  },
  accountTransactionLabel: {
    text: "L'indirizzo da cui hai ricevuto o a cui hai inviato delle monete.",
    title: "Quale indirizzo viene visualizzato per ogni transazione?"
  },
  accountTransactionTime: {
    text: "Il tempo di conferma della transazione su blockchain.",
    title: "Che ora viene visualizzata?"
  },
  accounts: {
    howManyAccounts: {
      text: `Non c' un limite al numero di account Bitcoin e Litecoin supportati. Dopo il quinto account, potrai aggiungerne uno nuovo solo se il precedente  gi stato utilizzato.
`,
      title: "Quanti account posso creare?"
    },
    howtoAddTokens: {
      text: 'I token che utilizzano lo standard ERC20 sono legati a uno specifico account Ethereum. Per attivare o disattivare un determinato token, aprire la schermata "Gestisci account", espandere il proprio account Ethereum e attivare o disattivare il token desiderato.',
      title: `Come posso aggiungere pi token?
`
    },
    moveFunds: {
      text: `S, ma poich gli account sono indipendenti,  necessario inviare i fondi con una transazione regolare.
`,
      title: "Posso spostare fondi tra account diversi?"
    },
    recoverAccounts: {
      text: "S. BitBoxApp crea account utilizzando standard consolidati e compatibili con la maggior parte degli altri portafogli di criptovalute.",
      title: `Posso recuperare i miei account con altri portafogli?
`
    },
    whatAreAccounts: {
      text: "Il portafoglio pu gestire pi account della stessa moneta. Diversi account sono utili quando si desidera mantenere i fondi separati.",
      title: "Cosa sono gli account?"
    },
    whyIsThisUseful: {
      text: 'Gli account sono ottimi per gestire fondi per persone o scopi diversi, perch sono separati.  inoltre possibile condividere la "chiave pubblica estesa" di un account senza rivelare nulla degli altri account. Ci consente di ricevere ripetutamente fondi senza riutilizzare gli indirizzi, ad esempio per ricevere lo stipendio o per acquistare regolarmente criptovalute.',
      title: "Perch  utile?"
    }
  },
  appendix: {
    link: "Contattaci",
    text: "Altre domande?"
  },
  backups: {
    check: {
      text: "'Controlla backup' ti permette di verificare di avere un backup funzionante corrispondente al tuo portafoglio attuale. Pu anche essere usato per verificare che tu abbia ancora la password di recupero corretta. Puoi controllare la tua password di recupero principale o la tua password di recupero nascosta.",
      title: "Cos' il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No, ma la tua password di recupero  necessaria per ricavare il portafoglio dal "seed" memorizzato.',
      title: "Posso criptare il backup?"
    },
    howOften: {
      text: `Il backup viene generato automaticamente quando viene creato un nuovo portafoglio. Devi fare un nuovo backup solo se la tua scheda microSD viene persa o danneggiata, o se vuoi usare pi schede microSD come backup.
Non  necessario creare nuovi backup dopo l'attivit di transazione. Tutti i dati delle tue transazioni possono essere ricreati dal tuo singolo backup che  stato generato automaticamente per te.`,
      title: "Quanto spesso devo fare un backup?"
    },
    whatIsABackup: {
      text: ' una copia del "seed" su una scheda microSD. Il "seed" insieme alla tua password di recupero genera il tuo portafoglio.',
      title: "Cos' un backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Controlla backup' ti permette di verificare che hai un backup funzionante corrispondente al tuo portafoglio attuale.",
      title: "Cos' il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No. Tieni la scheda microSD al sicuro, perch contiene il "seed" non criptato per recuperare il tuo portafoglio. Se desideri proteggere con una password il tuo seed, puoi abilitare una passphrase opzionale nelle impostazioni avanzate sotto " Gestisci dispositivo ".',
      title: "Posso criptare il backup?"
    },
    whatIsABackup: {
      text: ' una copia del "seed" su una scheda microSD.',
      title: "Cos' un backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando la 2FA  abilitata, tutte le transazioni devono essere approvate sul cellulare abbinato per poter spendere fondi. Un numero monouso criptato viene inviato all'applicazione mobile, decriptato l, e restituito al BitBox quando si preme il pulsante "Accetta". Questa comunicazione con il dispositivo avviene tramite un canale tra il telefono cellulare e l'applicazione desktop stabilita durante l'abbinamento.

Assicurati di fare il backup del tuo portafoglio e di abbinare l'applicazione mobile prima di abilitare il 2FA. Una volta abilitato, lo slot microSD e l'abbinamento dell'applicazione mobile sono disabilitati. Possono essere riabilitati resettando il BitBox, che cancella il dispositivo.`,
      title: "Come funziona l'autorizzazione a due fattori (2FA)?"
    },
    disable2FA: {
      text: "Per disabilitare il 2FA,  necessario resettare il BitBox e poi ripristinare il portafoglio dal suo backup. Assicurati di avere ancora la scheda microSD con il backup e di ricordare ancora la password di recupero. Poi premi 'Reset dispositivo'. Imposta una nuova password del dispositivo e scegli 'Ripristina un backup'. Seleziona il backup che hai fatto dal portafoglio, clicca su 'Ripristina' e inserisci la password di recupero che hai usato quando hai creato il portafoglio.",
      title: "Come posso disabilitare l'autorizzazione a due fattori (2FA)?"
    },
    ejectBitbox: {
      text: " possibile scollegare il BitBox in qualsiasi momento senza doverlo prima espellere.",
      title: "Come posso espellere il BitBox?"
    },
    ejectSD: {
      text: " possibile rimuovere la scheda microSD dal BitBox in qualsiasi momento, purch non si stia creando o ripristinando un backup.",
      title: "Come posso espellere la scheda microSD?"
    },
    hiddenWallet: {
      text: 'Si tratta di un secondo portafoglio sullo stesso dispositivo protetto da una password diversa da quella del dispositivo e quella di recupero, che puoi usare per una negazione plausibile. Lo stesso "seed" di backup viene utilizzato sia per il portafoglio normale che per quello nascosto, quindi non  necessario un backup aggiuntivo.',
      title: "Cos' un portafoglio nascosto?"
    },
    legacyHiddenWallet: {
      text: "Prima clicca il pulsante qui sotto (disponibile se il BitBox  sbloccato con la password del dispositivo principale e 2FA  disabilitato), poi ricollega il tuo Bitbox e sbloccalo con la tua password del dispositivo nascosto.",
      title: "Come si accede al portafoglio nascosto legacy?"
    },
    pairing: {
      text: "Dopo aver scaricato la nostra applicazione mobile per iOS o Android, scansiona il codice QR visualizzato, che stabilisce un canale sicuro tra l'applicazione mobile e questa applicazione. Una volta scansionato, segui le istruzioni dell'applicazione mobile.",
      title: "Come abbinare in modo sicuro il tuo telefono"
    }
  },
  cointracking: {
    text: `Fai clic sul pulsante "Esporta" e apri la cartella dei download dove troverai l'esportazione CSV. Quindi fai clic sul link sottostante, carica il tuo file CSV BitBox e importa i dati per utilizzarli nel tuo gestore del portafoglio CoinTracking e per creare le tue dichiarazioni fiscali.
`,
    title: "Come importo le mie transazioni in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leggi di pi sulla verifica di autenticit"
      },
      text: "La BitBoxApp effettua una verifica di autenticit sul BitBox02 per assicurarsi che il dispositivo sia autentico. La verifica viene eseguita localmente e non si connette a nessun server",
      title: "Come funziona la verifica di autenticit?"
    },
    name: {
      text: "Questo  il nome del tuo portafoglio e del backup. Il nome  utilizzato per i backup futuri e pu essere utilizzato per distinguere tra differenti portafogli. Pu essere cambiato in ogni momento, ma tieni presente che i backup fatti prima del cambio avranno il nome precedente.",
      title: "Per cosa  utilizzato il nome del BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leggi di pi sul secure chip"
      },
      text: "Questa informazione mostra il modello del secure chip. Quello pi aggiornato  ATECC608B, con funzionalit di sicurezza migliorate rispetto ai modelli precedenti.",
      title: "Perch mostrare il modello del secure chip?"
    }
  },
  receive: {
    address: {
      text: "Puoi dare l'indirizzo ad altri per farti inviare dei fondi. Assicurati che stiano inviando all'indirizzo corretto.",
      title: "Cosa devo fare con un indirizzo?"
    },
    addressChange: {
      text: "Non appena si effettua una transazione, un nuovo indirizzo viene automaticamente aggiunto alla lista, quindi ci sono sempre 20 indirizzi disponibili che non hanno mai ricevuto fondi.",
      title: "Quando cambiano gli indirizzi?"
    },
    addressFormats: {
      text: "Da impostazione predefinita, il tipo di indirizzo  Native Segwit. Questo tipo di indirizzo  ampiamente adottato da altri portafogli/exchange e offre le migliori tariffe per le transazioni quotidiane. Tuttavia, si pu anche scegliere di inviare a Taproot (solo Bitcoin), il tipo di indirizzo pi recente, ma potenzialmente non ancora ampiamente supportato. In alternativa, se avete problemi a inviare a Native Segwit (predefinito), potete provare a passare al tipo di indirizzo pi vecchio Wrapped Segwit, che potrebbe essere compatibile con pi portafogli/scambi.",
      title: 'Quando uso "Cambia tipo di indirizzo"?'
    },
    howVerify: {
      text: `Per il BitBox01, clicca sull'icona BitBox nella barra laterale a sinistra e vedi la sezione Abbinamento. La guida si aggiorner e potrai continuare a seguire le istruzioni da l.
Per il BitBox02,  possibile verificare gli indirizzi direttamente sul dispositivo durante il processo di invio/ricezione.`,
      title: "Come posso verificare un indirizzo in modo sicuro?"
    },
    plugout: {
      text: "No, una volta inviate le valute al proprio indirizzo BitBox, non  necessario lasciare il BitBox collegato. Siete liberi di scollegare il vostro BitBox.",
      title: " necessario lasciare il BitBox collegato durante la ricezione?"
    },
    why20: {
      text: `Durante l'avvio l'app genera indirizzi derivati dal vostro "seed" per vedere se hanno ricevuto fondi. Poich l'app pu generare un numero quasi infinito di indirizzi, potrebbero passare anni perch determini il saldo. Per limitare questa ricerca, la app si ferma quando vede 20 indirizzi che non hanno mai ricevuto fondi. Questo  il "gap limit" e 20  uno standard applicato de-facto anche se il numero  arbitrario. Questi sono i 20 indirizzi tra cui puoi scegliere.`,
      title: "Perch solo 20 indirizzi?"
    },
    whyMany: {
      text: 'Per mantenere la privacy e la sicurezza, non dare mai lo stesso indirizzo due volte. Se hai usato un indirizzo, clicca sulla freccia a destra per un nuovo indirizzo. Puoi generare fino a 20 indirizzi alla volta. Pensa agli indirizzi come ai numeri di fattura. Tutti gli indirizzi sono derivati dal tuo singolo "seed" di backup.',
      title: "Perch cos tanti indirizzi?"
    },
    whyVerify: {
      text: "Non dovresti fidarti del computer per generare e visualizzare indirizzi genuini. L'ampia superficie di attacco lo rende molto pi vulnerabile di un hardware wallet. Nel caso del BitBox01, il pulsante per verificare l'indirizzo invia in modo sicuro l'indirizzo a un telefono cellulare associato, dal quale  anche possibile scansionare e verificare il codice QR. Per il BitBox02, l'indirizzo pu essere verificato direttamente sul display del BitBox02.",
      title: "Perch dovrei verificare l'indirizzo in modo sicuro?"
    }
  },
  send: {
    change: {
      text: "Il resto verr restituito a un indirizzo Taproot se  presente almeno un UTXO Taproot. Se si usa il coin control, il resto verr restituito a un indirizzo Taproot se c' almeno un UTXO Taproot tra gli UTXO selezionati. In tutti gli altri casi, il resto viene restituito a un indirizzo Native Segwit.",
      title: "Come viene determinato l'output del resto?"
    },
    fee: {
      text: `La commissione si basa sulla dimensione dei dati della transazione e non sulla sua quantit. 
le commissioni sono calcolate dall'algoritmo di stima di Bitcoin Core per ogni priorit di rete scelta. Sono mostrate se hanno un valore diverso rispetto a quelli qui sotto.
Economica: 24 blocchi (circa 4 ore per Bitcoin, 1 ora per Litecoin)
Basso: 12 blocchi (circa 2 ore per Bitcoin, 30 minuti per Litecoin)
Normale: 6 blocchi (circa 1 ora per il Bitcoin, 15 minuti per il Litecoin)
Alto: 2 blocchi (circa 20 minuti per il Bitcoin, 5 minuti per il Litecoin)
(Un blocco impiega in media dieci minuti per Bitcoin (2,5 minuti in Litecoin) per essere estratto e il carico della rete pu variare considerevolmente nei periodi di cui sopra).`,
      title: "Come sono determinate le commissioni?"
    },
    plugout: {
      text: "No, una volta effettuata una transazione, non  necessario lasciare il BitBox collegato. Si  liberi di scollegare il BitBox.",
      title: " necessario lasciare il BitBox collegato durante l'invio?"
    },
    priority: {
      text: "Pi commissioni paghi, tipicamente pi velocemente le transazioni sono confermate dalla rete",
      title: "Cos' la priorit di rete?"
    },
    revert: {
      text: `Una volta che una transazione  firmata e inviata (cio trasmessa alla rete), non pu pi essere annullata. Verificate bene le transazioni (compresa la commissione) prima di firmare!
Se conosci il destinatario e lui/lei  disposto/a a rimandarti lo stesso importo (meno le commissioni della transazione), puoi inviargli/le un nuovo indirizzo di ricezione.`,
      title: "Posso revocare una transazione?"
    },
    whyFee: {
      text: `Le transazioni sono in competizione per essere confermate da un minatore. I minatori scelgono le transazioni da includere nella blockchain in base al loro compenso.
I minatori votano sulla storia delle transazioni. Dal momento che non c' una terza parte fidata che faccia rispettare un voto per persona (che  l'intero scopo delle blockchain), i minatori votano sulle transazioni sacrificando una risorsa costosa come la potenza di calcolo. Come ricompensa per il loro lavoro, possono reclamare fondi appena creati e le commissioni di tutte le transazioni che hanno incluso.`,
      title: "Perch ci sono delle commissioni di rete?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Se intendete connettervi al vostro nodo solo quando siete sulla stessa rete (ad esempio il wifi di casa vostra), allora  sufficiente utilizzare la normale comunicazione di rete.
In questo caso  consigliabile che il vostro server Electrum fornisca un certificato TLS per cifrare la comunicazione.
Se avete intenzione di connettervi al vostro nodo da qualsiasi luogo, usare Tor  l'opzione migliore. In questo caso non  necessario alcun certificato TLS.`,
      title: "Meglio usare clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guida per collegare il tuo nodo"
      },
      text: "Per un tutorial completo, visitate la nostra guida:",
      title: "Come faccio a collegare la mia BitBoxApp al mio full node?"
    },
    options: {
      text: `Ci sono diverse opzioni per utilizzare il proprio nodo come acquistare un dispositivo finito, costruire il proprio o utilizzare Bitcoin Core.
Se vuoi collegare la BitBoxApp al tuo nodo, assicurati che esegua un server Electrum. Questo  un programma dedicato che permette ad un'app portafoglio di comunicare con il tuo nodo.
Le opzioni supportate includono Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).`,
      title: "Quali opzioni ci sono per gestire un nodo?"
    },
    tor: {
      text: `Tor  l'acronimo di 'The Onion Router', che  un software gratuito e open source che offre un sacco di vantaggi per la privacy ed  particolarmente utile quando si usa Bitcoin.
Se hai intenzione di connetterti al tuo nodo tramite Tor, assicurati che Tor sia installato sul tuo computer e poi abilita il Proxy Tor nelle impostazioni di BitBoxApp.
Sulla maggior parte dei sistemi operativi ci sono due modi per eseguire Tor:
1. 1. Tor Browser: scaricare e aprire il Tor Browser. Questo permetter alla BitBoxApp di connettersi alla rete Tor impostando la porta 9150 nelle impostazioni del proxy Tor.
2. Servizio Tor in background: installare il daemon Tor, che viene sempre eseguito in background. La BitBoxApp pu quindi connettersi impostando la porta 9050 nelle impostazioni del proxy Tor.`,
      title: "Cos' Tor, Tor proxy e quale porta usare?"
    },
    what: {
      text: " possibile utilizzare il tuo portafoglio con il mio full node invece di usare i server di Shift?",
      title: "Cosa significa?"
    },
    why: {
      text: `Utilizzare il proprio nodo non  necessario, ma migliora la privacy e riduce la necessit di fidarsi degli altri.
In primo luogo, significa che stai usando Bitcoin pi privatamente, poich la BitBoxApp non si connetter ai nostri server per recuperare la tua storia delle transazioni; invece recuperer quelle informazioni dal tuo nodo.
In secondo luogo, utilizzare il tuo nodo significa che il tuo nodo verifica tutte le transazioni, assicurandosi che le regole di consenso siano applicate.`,
      title: "Perch dovrei utilizzare il mio nodo?"
    }
  },
  settings: {
    sats: {
      text: "Un Satoshi ('sat' in breve)  la pi piccola unit di Bitcoin. Un Satoshi  un centomilionesimo di Bitcoin (0.00000001 BTC). E' stato chiamato cos in omaggio al creatore di Bitcoin, Satoshi Nakamoto.",
      title: "Cos' un Satoshi? "
    },
    servers: {
      text: `Questa app comunica con i server Shift Crypto per controllare gli aggiornamenti, caricare le transazioni e inviare informazioni alle app mobili abbinate.
L'app recupera anche gli ultimi tassi di cambio da CoinGecko. Tutte le conversioni sono calcolate localmente, il che significa che nessun dato sull'importo della tua transazione viene mai trasmesso.
Nota: Per Ethereum e i Token ERC20, usiamo le API di Etherscan.io.`,
      title: "A quali server si connette questa app?"
    }
  },
  title: "Guida",
  toggle: {
    close: "Chiudi guida",
    open: "Guida"
  },
  trackingModePortfolioChart: {
    text: "Su Desktop, sposta il cursore sopra al grafico. Da mobile, tieni il dito premuto sul grafico e spostalo orizzontalmente.",
    title: "Come visualizzare lo storico dei prezzi sul grafico? "
  },
  unlock: {
    forgotDevicePassword: {
      text: "Devi resettare il dispositivo e ripristinare il portafoglio da un backup, utilizzando la password di recupero.",
      title: "Cosa devo fare se ho dimenticato la password del dispositivo?"
    },
    reset: {
      text: "Inserisci una password errata del dispositivo per 15 volte. Gli ultimi tentativi richiedono un lungo tocco sul dispositivo.",
      title: "Come faccio a resettare il dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Il dispositivo dovrebbe lampeggiare una volta quando viene inserito. Assicurati che sia inserito nel modo giusto. Se hai problemi, contattaci attraverso il link qui sotto.

Il BitBox01 non  supportato su dispositivi mobili. Utilizzare la BitBoxApp su desktop per collegare il BitBox01.`,
      title: "Il mio BitBox01 non viene riconosciuto"
    },
    getDevice: {
      link: {
        text: "Ordina un BitBox"
      },
      text: "Puoi comprare una BitBox nel nostro negozio online:",
      title: "Come posso ottenere un dispositivo?"
    },
    internet: {
      text: "S,  necessaria una connessione internet per sincronizzare il portafoglio, inviare transazioni e recuperare gli ultimi tassi di cambio.",
      title: "Questa app richiede una connessione a internet?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Puoi recuperare i tuoi account su un nuovo BitBox o con il nostro Backup center.",
      title: "Ho perso il mio dispositivo. E adesso?"
    },
    useWithoutDevice: {
      text: "Purtroppo, questo non  ancora possibile al momento.",
      title: "Posso usare l'applicazione senza un dispositivo?"
    },
    welcome: {
      text: "Grazie per aver usato questa app costruita da Shift Crypto in Svizzera. Apprezziamo qualsiasi input che hai da condividere. Inviaci il tuo feedback utilizzando il link in basso.",
      title: "Benvenuti nella BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se utilizzi la BitBoxApp su un nuovo telefono/computer, dovrai riconnetterti alle DApp per vedere le valute collegate come al solito.",
      title: "Non vedo le mie connessioni precedenti."
    },
    supportedNetworks: {
      text: "Al momento, solo la mainnet Ethereum  supportata da WalletConnect nella BiBoxApp. Se hai bisogno di un portafogli per altre chain EVM puoi utilizzare l'estensione per il browser Rabby.",
      title: "Quali reti sono supportate?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect  un protocollo di comunicazione per applicazioni web3. Ti permette di connetterti comodamente a DApp e portafogli web senza dover usare un'altra app. Particolarmente utile per gli utenti Android della BitBoxApp.",
      title: "Cos' WalletConnect?"
    }
  }
}, headerssync = {
  blocksSynced: "{{blocks}} blocchi sincronizzati"
}, hiddenWallet = {
  info1HTML: "Per scopi di negazione plausibile, un portafoglio nascosto pu essere creato sulla base di una combinazione <strong>diversa</strong> di password del dispositivo + password di recupero.",
  info2HTML: "Definisci la password del dispositivo e la password di recupero che vuoi associare al tuo portafoglio nascosto qui sotto. La password del dispositivo e la password di recupero devono essere <strong>diverse</strong> da quelle che hai definito per il tuo portafoglio principale.",
  passwordLabel: "Password di recupero nascosta",
  passwordPlaceholder: "Si prega di confermare la password di recupero nascosta",
  pinLabel: "Password nascosta del dispositivo",
  pinRepeatLabel: "Ripetere la password del dispositivo nascosto",
  pinRepeatPlaceholder: "Si prega di confermare la password del dispositivo nascosto",
  success: "Portafoglio nascosto creato con successo. Ricollega il tuo BitBox per sbloccarlo."
}, initialize = {
  create: "Imposta la password del dispositivo",
  creating: "Impostazione della password del dispositivo...",
  error: {
    e102: "La password del dispositivo deve essere composta da almeno 4 caratteri."
  },
  info: {
    description1: "Scegli la password del tuo dispositivo. Questa sar usata per sbloccare il tuo BitBox.",
    description2: "Puoi usare numeri, lettere e simboli. Password pi lunghe offrono maggiore sicurezza.",
    description3: "Se perdi la password del dispositivo, dovrai resettare il tuo dispositivo e ripristinare il backup del portafoglio.",
    subtitle: "Ora imposterai la password del tuo dispositivo",
    title: "Inizializzazione del dispositivo"
  },
  input: {
    label: "Password del dispositivo",
    labelRepeat: "Ripetere la password del dispositivo",
    placeholderRepeat: "Si prega di confermare la password del dispositivo"
  }
}, invalidFormat = "Formato non valido", language$1 = {
  title: "Seleziona lingua"
}, legacyhiddenwallet = {
  disable: "Disattiva il portafoglio nascosto legacy",
  enable: "Abilita il portafoglio nascosto legacy",
  successDisable: "Portafoglio nascosto legacy disattivato con successo",
  successEnable: "Il portafoglio nascosto legacy  stato attivato con successo. Ricollega il tuo BitBox e inserisci la password del dispositivo nascosto per accedere al portafoglio nascosto legacy."
}, loading = "caricamento...", manageAccounts = {
  accountHidden: "Questo account  stato nascosto dalla lista degli account watch-only. Per vederlo di nuovo, connetti il tuo BitBox02",
  editAccount: "Modifica",
  editAccountNameTitle: "Modifica il nome dell'account",
  noAccounts: "Nessun account trovato",
  settings: {
    hideTokens: "Nascondi token",
    showTokens: "Mostra token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aggiungi e mostra/nascondi gli account",
  title: "Gestisci gli account",
  watchAccount: "Watch-only account",
  watchAccountDescription: "Questo account  stato aggiunto alla lista degli account watch-only. Disattiva per nasconderlo."
}, mobile = {
  usingMobileDataWarning: "Utilizzo di dati mobili: dopo aver sbloccato un account questa app pu scaricare fino a qualche centinaio di megabyte di dati dell'intestazione della blockchain. Si prega di connettersi al Wi-Fi per evitare di utilizzare i dati mobili. Dopo averlo chiuso, questo messaggio non verr pi visualizzato."
}, newSettings = {
  about: {
    appVersion: {
      title: "Versione dell'app"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Blocca l'accesso all'app con blocco schermo/impronta digitale.",
      title: "Blocco schermo"
    },
    coinControl: {
      description: "Seleziona quali UTXOs fanno parte di una transazione per aiutarti ad aumentare la tua privacy."
    },
    customFees: {
      description: "Ti permette di inserire una fee a tua discrezione all'invio."
    },
    torProxy: {
      description: "Connettiti tramite Tor per una migliore privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Puoi ruotare tra queste valute aggiuntive dalla pagina del tuo account.",
      title: "Valute attive"
    },
    darkmode: {
      description: "Visualizza la BitBoxApp in modalit scura."
    },
    defaultCurrency: {
      description: "Selezione la valuta di default",
      title: "Valuta di default"
    },
    hideAmounts: {
      description: "Visualizza un'opzione per nascondere il tuo bilancio e gli importi per aumentare la tua privacy quando usi l'app in pubblico.",
      hideAmounts: "Nascondi importi",
      showAmounts: "Mostra importi",
      title: "Abilita importi nascosti"
    },
    language: {
      description: "In che lingua preferisci visualizzare la BitBoxApp.",
      title: "Lingua"
    },
    toggleSats: {
      description: "Abilita o disabilita i Satoshi"
    }
  }
}, note$1 = {
  input: {
    description: "(facoltativo)",
    placeholder: "Aggiungi nota..."
  },
  title: "Nota"
}, notification = {
  newTxs_one: "Nuova transazione in: {{accountName}}",
  newTxs_other: "{{count}} nuove transazioni in: {{accountName}}"
}, pairing = {
  aborted: {
    text: "L'abbinamento  stato interrotto dall'applicazione mobile.",
    title: "Interrotto"
  },
  button: "Abbina l'applicazione mobile",
  confirm: "Sei sicuro/a di voler abbinare il tuo BitBox? Si noti che in seguito, il telefono cellulare sar necessario per eseguire transazioni.",
  connectOnly: {
    button: "Collegare l'applicazione mobile",
    title: "Esegui la scansione con la nostra applicazione mobile selezionando la voce di menu 'Connetti a nuova applicazione desktop'."
  },
  error: {
    text: "Qualcosa  andato storto. Per favore, ricomincia.",
    title: "Errore"
  },
  pullFailed: {
    text: "Impossibile estrarre un messaggio dal tuo cellulare attraverso il server relay. Il server potrebbe essere offline, contatta il supporto.",
    title: "Fallito"
  },
  reconnectOnly: {
    button: "Riconnetti applicazione mobile"
  },
  scanningFailed: {
    text: "Il cellulare non  stato in grado di scansionare il messaggio con successo. Si prega di riprovare.",
    title: "Scansione fallita"
  },
  start: {
    hideAppQRCode: "Nascondi il codice QR",
    revealAppQRCode: "Mostra il codice QR",
    step1: "Se non hai l'applicazione mobile, puoi scansionare il codice QR per l'App Store di Apple o il Play Store di Google, a seconda del telefono che usi.",
    step2: "Scansiona con la nostra applicazione mobile, che puoi trovare sotto il nome 'Digital Bitbox 2FA' negli app store per iOS e Android:"
  },
  started: {
    text: "Ora segui le istruzioni dell'applicazione mobile.",
    title: "Ottimo"
  },
  success: {
    text: "Congratulazioni, hai abbinato con successo il tuo BitBox con l'applicazione mobile",
    title: "Successo"
  },
  timeout: {
    text: "L'abbinamento  scaduto dopo due minuti. Ricomincia se vuoi ancora abbinare l'applicaione mobile.",
    title: "Timeout"
  },
  title: "Abbinamento telefono cellulare"
}, passphrase = {
  considerations: {
    button: `Considerazioni sul backup
`,
    message: `La passphrase aggiunge un livello di protezione al backup del portafoglio (scheda microSD o parole di recupero). Se qualcuno ha accesso al vostro backup, avr bisogno anche della passphrase per accedere al vostro portafoglio.

Tuttavia, questo significa che saranno necessari <strong>sia la passphrase che il backup del portafoglio</strong> per ripristinare il portafoglio abilitato alla passphrase, nel caso in cui il BitBox02 venga perso o rotto. Se si dimentica o si perde la passphrase, si perde l'accesso a tutte le valute del portafoglio.

Quando si memorizza la passphrase, si consiglia di conservarla in un luogo separato rispetto al backup. In questo modo, se qualcuno trova il backup, non trover anche la passphrase.`,
    title: "Considerazioni sul backup"
  },
  disable: "Disabilita la passphrase",
  disableInfo: {
    button: "Disabilita",
    message: `Una volta disabilitata la passphrase, non verr pi richiesto di inserire una passphrase dopo aver sbloccato il BitBox02. Pertanto, si acceder al proprio portafoglio predefinito.

Tutte le valute presenti nel portafoglio con la passphrase saranno ancora presenti in quel portafoglio, ma non sar possibile accedervi perch, dopo aver sbloccato il BitBox02, si aprir il portafoglio predefinito.

Per accedere nuovamente ai portafogli di passphrase,  sufficiente riattivare la funzione passphrase e inserire la relativa passphrase dopo aver sbloccato il BitBox02.

<strong>Suggerimento:</strong>  ancora possibile accedere al portafoglio originale lasciando la passphrase vuota.`
  },
  enable: "Abilita la passphrase",
  error: {
    e104: "La modifica dell'impostazione della passphrase  stata interrotta."
  },
  how: {
    button: "Come si presenta",
    message: `Una passphrase non funziona come una password a cui si  abituati. Se si sbaglia a digitare la passphrase, non si riceve alcuna notifica. Questo perch <strong>ogni passphrase crea un portafoglio diverso, ma valido</strong>. Ci significa che  possibile utilizzare diverse passphrase per tanti portafogli quanti se ne desiderano. Ma si pu accedere a ciascun portafoglio solo digitando la passphrase corrispondente.

Quando si collega il BitBox02, viene richiesta la password del dispositivo come di consueto. Successivamente, verr richiesto di inserire una passphrase sul dispositivo.

Dopo aver inserito la passphrase, vi verr mostrata la passphrase inserita. In questo modo si pu confermare di averla inserita correttamente.`,
    title: "Come funziona"
  },
  intro: {
    message: `Una passphrase fornisce un ulteriore livello di sicurezza oltre al portafoglio.
Scopriamo come funziona.`,
    title: "Impostare la passphrase"
  },
  progressDisable: {
    message: "Confermare sul BitBox che si desidera <strong>disabilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  progressEnable: {
    message: "Confermare su BitBox che si desidera <strong>abilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  successDisabled: {
    message: `Passphrase opzionale <strong>attivata con successo</strong>!
D'ora in poi verr richiesto di fornire una passphrase.`,
    messageEnd: `Ricollegare ora il BitBox02.
`,
    title: "Passphrase abilitata"
  },
  successEnabled: {
    message: `Passphrase opzionale <strong>disabilitata con successo</strong>!

Non verr pi richiesto di fornire una passphrase.`,
    messageEnd: `Ricollegare ora il BitBox02.
`,
    tips: "Suggerimenti",
    tipsList: [
      "Si consiglia di inviare prima un piccolo importo al portafoglio con passphrase. Quindi scollegare e ricollegare il BitBox02 e inserire la password e la passphrase. Se la passphrase  stata inserita correttamente, si dovrebbero vedere i fondi nel portafoglio.",
      "Se si desidera accedere al portafoglio originale senza passphrase,  ancora possibile farlo non inserendo nulla quando viene richiesto di inserire la passphrase. Oppure puoi disattivare la funzione passphrase."
    ],
    title: "Passphrase disabilitata"
  },
  summary: {
    button: "Passphrase disabilitata",
    title: "Riepilogo",
    understand: `Ho capito come funziona la passphrase e i rischi ad essa associati.
`,
    understandList: [
      `La passphrase  un ulteriore livello di sicurezza oltre al backup.
`,
      `L'inserimento di una passphrase diversa generer sempre un portafoglio diverso.
`,
      "Per ripristinare il portafoglio sono necessari <strong>sia la passphrase che il backup</strong>.",
      `Se si dimentica la passphrase, <strong>non  pi possibile accedere ai propri fondi</strong>.
`
    ]
  },
  what: {
    button: "Scopri come funziona",
    message: `Un portafoglio viene creato (derivato) da un numero casuale molto grande, noto anche come seed. Questo seed viene creato quando si configura per la prima volta il BitBox02 e viene salvato nella scheda microSD o in una lista di parole di recupero. Chiunque abbia accesso al seed ha il pieno controllo sui fondi di quel portafoglio.

Una passphrase  un <strong>segreto opzionale</strong>, aggiunto al seed. Quando si usa una passphrase, ogni passphrase crea un nuovo portafoglio basato sul seed + passphrase (segreto opzionale). Una passphrase pu essere qualsiasi cosa: lettere, parole, caratteri speciali o pu anche essere vuota. Il portafoglio predefinito deriva infatti dal seed + passphrase vuota.

La passphrase fa parte dello standard BIP39, il che significa che  compatibile con tutti i portafogli che supportano lo stesso standard.`,
    title: "Cos' una passphrase?"
  },
  why: {
    button: "Perch usare una passphrase",
    message: `BitBox02 protegge il seed dall'estrazione dal dispositivo stesso, ma il backup (scheda microSD o parole di recupero) d pieno accesso al portafoglio. Per questo motivo deve essere conservato in un luogo sicuro!

Poich una passphrase crea un nuovo portafoglio utilizzando il seed esistente, il portafoglio con l apassphrase richiede sia il <strong>backup che la passphrase per il ripristino</strong>. Il vantaggio  che se qualcuno trova il vostro backup, ha comunque bisogno della passphrase per accedere al portafoglio con la passphrase.

Inoltre, la funzione passphrase consente di creare pi portafogli sullo stesso dispositivo, o "portafogli nascosti", oltre a quello predefinito.`,
    title: "Perch usare una passphrase?"
  }
}, password = {
  show: "Mostra {{label}}",
  warning: {
    caps: 'per incollare il testo, attivare "MOSTRA {{etichetta}}"',
    paste: 'per incollare il testo, attivare "MOSTRA {{label}}"'
  }
}, random$1 = {
  button: "Genera un numero casuale",
  description: "Il tuo BitBox ha generato il seguente numero casuale {{bits}}-bit:"
}, receive$2 = {
  changeScriptType: "Cambia il tipo di indirizzo",
  label: "Il tuo indirizzo",
  onlyThisCoin: {
    description: "Per ricevere altri token, abilitali nelle impostazioni. Se depositi altri token, potrebbero non essere accessibili.",
    warning: "Assicurati di ricevere solo {{coinName}} su questo indirizzo."
  },
  scriptType: {
    p2tr: "Taproot (formato pi recente)",
    p2wpkh: "Native Segwit (predefinito)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatibile)"
  },
  selectAccount: "Scegli un account",
  showFull: "Mostra e verifica l'indirizzo completo sul dispositivo",
  taprootWarning: "Nota: Taproot  una nuova funzione di Bitcoin e non  ancora ampiamente adottata. I fondi ricevuti sugli indirizzi Taproot potrebbero non essere visibili nei portafogli di terze parti. Molti portafogli e exchange non sono ancora in grado di inviare ad indirizzi Taproot.",
  title: "Ricevi {{accountName}}",
  verify: "Verificare l'indirizzo in modo sicuro",
  verifyBitBox01: "Verificare l'indirizzo sull'applicazione mobile",
  verifyBitBox02: "Verificare l'indirizzo sul BitBox02",
  verifyInstruction: "Verifica che il seguente indirizzo corrisponda a quello visualizzato sul tuo dispositivo.",
  warning: {
    secureOutput: "Si prega di associare il tuo BitBox con il tuo dispositivo mobile per abilitare la verifica sicura dell'indirizzo. Vai su 'Gestisci dispositivo' nella barra laterale."
  }
}, reset = {
  description: "Tutti i dati saranno cancellati dal dispositivo. Inclusa la tua chiave privata!",
  notReset: "Dispositivo NON resettato.",
  title: "Ripristino di fabbrica del dispositivo",
  understand: "Ho un backup e conosco la mia password di recupero",
  understandBB02: "Ho un backup valido"
}, securityInformation = {
  create: {
    description1: "Ti consigliamo di impostare il tuo dispositivo in un ambiente sicuro, cio lontano da altre persone che potrebbero vedere la password che hai scelto.",
    description2: "Ti verr chiesto di creare due password.",
    description3: "La prima  la <strong>password del dispositivo</strong> che sblocca il tuo dispositivo BitBox e pu essere cambiata in seguito.",
    description4: "La seconda  la <strong>password di recupero</strong> che sblocca il tuo portafoglio. Questa password non pu essere cambiata in seguito.",
    description5: "Il portafoglio creato sar salvato in un file sulla scheda microSD fornita. Questo pu essere utilizzato in caso di emergenza per recuperare i tuoi fondi utilizzando la tua <strong>password di recupero</strong>.",
    title: "Informazioni di sicurezza"
  },
  restore: {
    description1: "Ti verr chiesto di inserire la scheda microSD che hai usato per memorizzare il tuo backup.",
    description2: "Per ripristinare il tuo dispositivo avrai bisogno della tua password di recupero. ",
    description3: "Fai attenzione quando inserisci la password di recupero. Qualsiasi password inserita creer un portafoglio valido. Se inserisci la password sbagliata, potrebbe esserti mostrato un saldo del portafoglio che non ti aspetti.",
    title: "Informazioni di sicurezza"
  }
}, seed = {
  agreements: {
    "funds-access": "NON potr accedere ai miei fondi se dimentico la mia password di recupero",
    "password-change": "NON posso cambiare la password di recupero in futuro.",
    "password-required": "La password di recupero  necessaria per ripristinare un portafoglio da un backup"
  },
  create: "Crea un portafoglio",
  creating: "Creazione del portafoglio",
  description: "Capisco che:",
  error: {
    e102: "La password deve essere composta da almeno 4 caratteri.",
    e200: " necessario inserire una scheda microSD nel tuo BitBox per creare un portafoglio, cos un backup pu essere creato automaticamente."
  },
  info: {
    button: `Imposta ora la password di recupero
`,
    description1: "Inserire la scheda microSD nel BitBox",
    description2: 'Scegli una password di recupero per il portafoglio e seleziona "Imposta password di recupero ora".',
    description3: "Il backup su scheda microSD e la password di recupero sono l'unico metodo per recuperare i tuoi fondi in caso di perdita o furto del dispositivo BitBox.",
    description4: "Non  possibile cambiare la password di recupero in futuro senza dover trasferire i tuoi fondi.",
    title: "Crea un nuovo portafoglio"
  },
  password: {
    label: "Password di recupero",
    repeatPlaceholder: "Ripeti la password di recupero"
  },
  walletName: {
    label: "Nome del portafoglio"
  }
}, seedRestore = {
  error: {
    e200: "Il ripristino di un portafoglio da un backup richiede la scheda microSD."
  },
  info: {
    description1: 'Inserire la scheda microSD nel BitBox e cliccare su "Continua".',
    description2: 'Scegliete un backup e cliccate su "Ripristina".',
    description3: "Inserisci la password di recupero",
    description4: "Confermo di aver capito che una password errata creer un portafoglio diverso.",
    title: "Come ripristinare un portafoglio da un backup"
  }
}, send$2 = {
  abort: "La transazione  stata annullata",
  address: {
    label: "Indirizzo del destinatario",
    placeholder: "Inserisci indirizzo"
  },
  amount: {
    label: "Importo",
    placeholder: "Inserisci importo"
  },
  availableBalance: "Saldo disponibile",
  button: "Controlla",
  coincontrol: {
    address: "Indirizzo",
    outpoint: "Outpoint",
    title: "Invia da un output"
  },
  confirm: {
    "selected-coins": "Seleziona valute",
    title: "Conferma ed invia transazione",
    total: "Totale"
  },
  error: {
    erc20InsufficientGasFunds: "Sembra che tu non abbia abbastanza Ether per pagare questa transazione ERC20. Per favore, assicurati di avere abbastanza Ether nel tuo portafoglio.",
    feeTooLow: "commissione troppo bassa",
    feesNotAvailable: `Impossibile stimare le commissioni
`,
    insufficientFunds: "fondi insufficienti.",
    invalidAddress: "indirizzo non valido",
    invalidAmount: "importo non valido",
    invalidData: "dati non validi"
  },
  fee: {
    customPlaceholder: "Inserisci importo",
    label: "Commissioni di rete",
    placeholder: "Non disponibile"
  },
  feeTarget: {
    customLabel: "Tariffa",
    customLabel_eth: "Gas",
    description: {
      economy: "4 ore (24 blocchi)",
      economy_eth: "30 minuti al massimo",
      economy_ltc: "1 ora (24 blocchi)",
      high: "20 minuti (2 blocchi)",
      high_eth: "30 secondi al massimo",
      high_ltc: "5 minuti (2 blocchi)",
      low: "2 ore (12 blocchi)",
      low_eth: "5 minuti al massimo",
      low_ltc: "30 minuti (12 blocchi)",
      normal: "6 blocchi (circa 1 ora per Bitcoin, 15 minuti per Litecoin)",
      normal_eth: "2 minuti al massimo",
      normal_ltc: "15 minuti (6 blocchi)"
    },
    estimate: "Tempo di conferma stimato:",
    label: {
      custom: "Personalizzata",
      economy: "Economica",
      high: "Alta",
      low: "Bassa",
      normal: "Normale"
    },
    placeholder: "Calcolo delle commissioni..."
  },
  maximum: "Invia tutto",
  maximumSelectedCoins: `Invia le valute selezionate
`,
  noFeeTargets: "La stima delle fee al momento non  disponibile. Inserisci una fee a tua discrezione o riprova pi tardi.",
  priority: "Priorit",
  scanQR: "Leggi il QR code",
  signprogress: {
    description: "Questa  una transazione che contiene molti dati. Per firmare la transazione, ti verr chiesto di confermare {{steps}} volte.",
    label: "Progresso"
  },
  success: "La transazione  stata firmata ed inviata.",
  title: "Invia {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Dettagli della transazione"
}, settings$1 = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Impostazioni avanzate",
  appearance: "Aspetto",
  electrum: {
    add: "Aggiungi un server",
    "add-server": "Aggiungi",
    check: "Verifica",
    checkFailed: "Fallito",
    checkSuccess: "Connessione stabilita con {{host}}",
    checking: "Verifico",
    "download-cert": "Scarica certificato remoto",
    "remove-server": "Rimuovi",
    removeConfirm: "Rimuovere {{server}}?",
    reset: "Ripristina le impostazioni predefinite",
    resetConfirm: "Vuoi rimuovere tutti i server e installare quelli di default?",
    servers: "Server",
    step1: "1",
    "step1-text": "Inserisci l'endpoint.",
    step2: "2",
    "step2-text": "Inserisci un certificato della catena dei certificati del server. In alternativa, scarica il certificato remoto e confrontalo visivamente.",
    "step2-text-tcp": "Puoi saltare questo passo se non vuoi usare TLS.",
    step3: "3",
    "step3-text": "Controlla la connessione e aggiungi il server.",
    step4: "4",
    "step4-text": "Riavvia il portafoglio. Se non rimuovi i server di default, il tuo nodo sar aggiunto come ridondanza.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: 'Abilita "coin control"',
    electrum: {
      description: "Puoi connetterti al tuo full node Electrum",
      title: "Connetti il tuo full node"
    },
    fee: "Abilitare commissioni personalizzate",
    setProxyAddress: "Imposta indirizzo proxy",
    title: "Impostazioni avanzate",
    useProxy: "Abilita il proxy per tor",
    useSats: "Mostra i valori BTC in Satoshi"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nuovo aggiornamento disponibile",
    title: "Informazioni",
    "up-to-date": "La tua app  aggiornata",
    version: "Versione App"
  },
  restart: "Si prega di riavviare la BitBoxApp affinch le modifiche abbiano effetto.",
  services: {
    title: "Servizi"
  },
  success: "Si prega di scollegare e ricollegare il BitBox affinch le modifiche abbiano effetto.",
  title: "Impostazioni"
}, setup = "Imposta il dispositivo", sidebar$1 = {
  buy: "Acquista criptovalute",
  device: "Gestisci il dispositivo",
  leave: "Esci",
  settings: "Impostazioni"
}, success$7 = {
  create: {
    info1: "Il tuo portafoglio  stato salvato in modo sicuro sulla scheda microSD. Rimuovila e tienila al sicuro.",
    info2: "Hai creato una password sicura del dispositivo che sblocca il BitBox.",
    info3: "Hai creato una password di recupero sicura per il tuo portafoglio che sblocca i tuoi fondi e ripristina i tuoi backup.",
    summary: "Ecco un riassunto di quello che hai fatto",
    title: "Successo"
  },
  getstarted: "Inizia",
  restore: {
    summary: "Hai ripristinato con successo un portafoglio dal tuo backup.",
    title: "Successo"
  }
}, transaction$1 = {
  confirmation: "Conferme",
  details: {
    activity: "Attivit",
    address: "Indirizzo",
    amount: "Importo",
    date: "Data",
    fiat: "Fiat",
    fiatAmount: "Importo fiat",
    fiatAtTime: "Fiat al tempo della transazione",
    status: "Status",
    type: "Tipo"
  },
  explorer: "ID della transazione",
  explorerTitle: "Apri in un esploratore di blocchi esterno",
  fee: "Commissione",
  fiatHistorical: "Storico",
  gas: "Gas",
  note: {
    edit: "Modifica nota",
    save: "Salva nota"
  },
  pending: "Transazione in sospeso",
  size: "Dimensione",
  status: {
    complete: "Completata",
    failed: "Fallita",
    pending: "In sospeso"
  },
  tx: {
    received: "Ricevuta a",
    sent: "Inviata a"
  },
  vsize: "Dimensione virtuale",
  weight: "Peso"
}, transactions = {
  errorLoadTransactions: "Si  verificato un errore nel carimento delle transazioni",
  placeholder: "Nessuna transazione."
}, unknownError = "Si  verificato un errore sconosciuto: {{errorMessage}}", unlock = {
  description: "Inserisci la password del tuo dispositivo per sbloccarlo.",
  error: {
    e109_normal: "Password del dispositivo errata. Restano ancora {{remainingAttempts}} tentativi prima che il dispositivo venga resettato.",
    e109_touch: "$t(unlock.error.e109_normal) Il prossimo login richiede di tenere premuto il pulsante touch.",
    e113: "A causa di molti tentativi di login, il login successivo richiede di tenere premuto il pulsante a sfioramento per 4 secondi."
  },
  input: {
    label: "Password del dispositivo",
    placeholder: "Inserisci la password del tuo dispositivo per sbloccare il dispositivo"
  },
  unlocking: "Sblocco..."
}, upgradeFirmware$1 = {
  button: "Aggiorna il firmware",
  description: "Vuoi aggiornare il firmware dalla versione {{currentVersion}} alla {{newVersion}}?",
  label: "Il tuo BitBox richiede un aggiornamento del firmware.",
  locked: "Per aggiornare da {{currentVersion}} a {{newVersion}}, fai un tocco lungo.",
  title: "Aggiorna il firmware",
  unlocked: "Il bootloader  sbloccato. Per continuare, per favore:",
  unlocked1: "Scollegare e ricollegare il vostro Bitbox",
  unlocked2: "Il LED si accende quando il tuo BitBox  ricollegato",
  unlocked3: "Tocca il pulsante a sfioramento quando il LED si accende"
}, walletConnect$2 = {
  connect: {
    button: "Conneti",
    dappLabel: "Inserire indirizzo URI della DApp",
    invalidPairingUri: "URI di connessione non valido"
  },
  dashboard: {
    allSessions: "Tutte le sessioni",
    disclaimer: "WalletConnect  un protocollo per connettersi a Dapp basate su Ethereum. Queste DApp sono gestite da servizi di terze parti, per cui connettiti solo a DApp di cui ti fidi e accertati di sapere sempre cosa stai firmando quando crei una transazione.",
    newConnection: "Nuova Connessione",
    noConnectedSessions: "Nessun account  connesso a DApp al momento."
  },
  invalidPairingChain: "Errore nell'approvazione della connessione. Assicurati di utilizare una delle chain supportate: {{chains}}",
  pairingRequest: {
    approve: "Approva Connessione",
    reject: "Rifiuta",
    title: "Nuova richista di connessione da"
  },
  pairingSuccess: "DApp connessa. Puoi continuare sul sito della DApp.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Dati",
    dataParsingError: "Parse dei dati fallto.",
    decodeError: "Decodifica del messaggio fallita",
    method: {
      sendTransaction: "Firma ed invia transazione",
      signMessage: "Firma messaggio",
      signTransaction: "Firma transazione",
      signTypedData: "Firma typed data"
    },
    successfullySigned: "Richiesta firmata con successo",
    walletConnectRequest: "Richiesta WalletConnect"
  },
  useNewUri: "Questo URI  gi stato utilizzato per provare a connettersi. Per favore, utilizzare un nuovo URI.",
  walletConnect: "WalletConnect"
}, warning$6 = {
  receivePairing: `Si prega di associare il BitBox per abilitare la verifica sicura dell'indirizzo. Vai su "Gestisci dispositivo" nella barra laterale.`,
  sdcard: "Tenere la scheda microSD separata dal BitBox, a meno che non si vogliano gestire i backup.",
  sendPairing: "Si prega di abbinare il BitBox per verificare in modo sicuro i dettagli della transazione. Vai su 'Gestisci dispositivo' nella barra laterale."
}, welcome = {
  connect: "Connetti BitBox02",
  getStarted: "Iniziamo con l'installazione del firmware sul BitBox02.",
  insertBitBox02: "Se hai collegato un BitBox02, tocca il dispositivo per continuare.",
  insertDevice: "Collega il tuo dispositivo per cominciare",
  title: "Benvenuto"
}, appTranslationsIT = {
  account,
  accountInfo,
  accountSummary,
  addAccount: addAccount$1,
  aopp,
  app,
  auth: auth$1,
  backup,
  bb02Bootloader,
  bitbox,
  bitbox02Interact,
  bitbox02Settings,
  bitbox02Wizard,
  blink,
  bootloader,
  button: button$4,
  buy: buy$1,
  changePin,
  chart: chart$1,
  checkSDcard,
  clickHere,
  confirm: confirm$2,
  confirmOnDevice,
  connectKeystore: connectKeystore$1,
  darkmode: darkmode$1,
  device,
  deviceLock,
  deviceSettings,
  deviceTampered,
  dialog: dialog$1,
  error: error$2,
  fiat: fiat$2,
  footer: footer$2,
  generic: generic$1,
  genericError,
  goal,
  guide: guide$1,
  headerssync,
  hiddenWallet,
  initialize,
  invalidFormat,
  language: language$1,
  legacyhiddenwallet,
  loading,
  manageAccounts,
  mobile,
  newSettings,
  note: note$1,
  notification,
  pairing,
  passphrase,
  password,
  random: random$1,
  receive: receive$2,
  reset,
  securityInformation,
  seed,
  seedRestore,
  send: send$2,
  settings: settings$1,
  setup,
  sidebar: sidebar$1,
  success: success$7,
  transaction: transaction$1,
  transactions,
  unknownError,
  unlock,
  upgradeFirmware: upgradeFirmware$1,
  walletConnect: walletConnect$2,
  warning: warning$6,
  welcome
};
function i18nextFormat(locale) {
  return locale.replace("_", "-");
}
__name(i18nextFormat, "i18nextFormat");
const localeMainLanguage = /* @__PURE__ */ __name((locale) => i18nextFormat(locale).split("-")[0], "localeMainLanguage"), getRegionNameFromLocale = /* @__PURE__ */ __name((nativeLocale) => {
  try {
    const formattedLocale = i18nextFormat(nativeLocale);
    return new Intl.Locale(formattedLocale).region || "";
  } catch {
    return "";
  }
}, "getRegionNameFromLocale"), defaultUserLanguage = "en", languageFromConfig = {
  type: "languageDetector",
  async: !0,
  detect: (cb2) => {
    apiGet("config").then(({ backend }) => {
      if (backend && backend.userLanguage) {
        cb2(backend.userLanguage);
        return;
      }
      apiGet("native-locale").then((locale) => {
        if (typeof locale == "string" && locale) {
          try {
            (/* @__PURE__ */ new Date()).toLocaleString(i18nextFormat(locale));
          } catch {
            cb2(defaultUserLanguage);
            return;
          }
          cb2(i18nextFormat(locale));
          return;
        }
        cb2(defaultUserLanguage);
      });
    });
  },
  init: () => {
  },
  cacheUserLanguage: () => {
  }
};
let pendingConfig = {};
const getConfig = /* @__PURE__ */ __name(() => apiGet("config"), "getConfig"), setConfig = /* @__PURE__ */ __name((object) => getConfig().then((currentConfig = {}) => {
  const nextConfig = Object.assign(currentConfig, {
    backend: Object.assign({}, currentConfig.backend, pendingConfig.backend, object.backend),
    frontend: Object.assign({}, currentConfig.frontend, pendingConfig.frontend, object.frontend)
  });
  return pendingConfig = nextConfig, apiPost("config", nextConfig).then(() => (pendingConfig = {}, nextConfig));
}), "setConfig"), locizeProjectID = "fe4e5a24-e4a2-4903-96fc-3d62c11fc502";
let i18Init = instance.use(languageFromConfig);
i18Init.init({
  fallbackLng: "en",
  // have a common namespace used around the full app
  ns: ["app", "wallet"],
  defaultNS: "app",
  debug: !1,
  returnObjects: !0,
  interpolation: {
    escapeValue: !1
    // not needed for react
  },
  react: {
    useSuspense: !0
    // Not using Suspense you will need to handle the not ready state yourself
  },
  backend: {
    projectId: locizeProjectID,
    referenceLng: "en"
  }
});
instance.addResourceBundle("ar", "app", appTranslationsAR);
instance.addResourceBundle("cs", "app", appTranslationsCS);
instance.addResourceBundle("de", "app", appTranslationsDE);
instance.addResourceBundle("en", "app", appTranslationsEN);
instance.addResourceBundle("fr", "app", appTranslationsFR);
instance.addResourceBundle("ja", "app", appTranslationsJA);
instance.addResourceBundle("ms", "app", appTranslationsMS);
instance.addResourceBundle("nl", "app", appTranslationsNL);
instance.addResourceBundle("ru", "app", appTranslationsRU);
instance.addResourceBundle("pt", "app", appTranslationsPT);
instance.addResourceBundle("hi", "app", appTranslationsHI);
instance.addResourceBundle("bg", "app", appTranslationsBG);
instance.addResourceBundle("tr", "app", appTranslationsTR);
instance.addResourceBundle("zh", "app", appTranslationsZH);
instance.addResourceBundle("fa", "app", appTranslationsFA);
instance.addResourceBundle("es", "app", appTranslationsES);
instance.addResourceBundle("sl", "app", appTranslationsSL);
instance.addResourceBundle("he", "app", appTranslationsHE);
instance.addResourceBundle("it", "app", appTranslationsIT);
instance.on("languageChanged", (lng) => getNativeLocale().then((nativeLocale) => {
  let match2 = lng === nativeLocale;
  if (!match2) {
    const lngLang = localeMainLanguage(lng), localeLang = localeMainLanguage(nativeLocale);
    match2 = lngLang === localeLang;
  }
  return setConfig({ backend: { userLanguage: match2 ? null : lng } });
}));
const captureStrongElement = /^(.*)<strong>(.*)<\/strong>(.*)$/;
function SimpleMarkup({ tagName, markup, ...props }) {
  if (typeof markup != "string")
    return null;
  const simpleMarkupChunks = captureStrongElement.exec(markup);
  return simpleMarkupChunks === null || simpleMarkupChunks.length !== 4 ? reactExports.createElement(tagName, props, markup) : reactExports.createElement(tagName, props, simpleMarkupChunks[1], reactExports.createElement("strong", null, simpleMarkupChunks[2]), simpleMarkupChunks[3]);
}
__name(SimpleMarkup, "SimpleMarkup");
const MultilineMarkup = /* @__PURE__ */ __name(({ tagName, markup, withBreaks, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: markup.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName, markup: line2, ...props }),
  withBreaks && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
] }, `${line2}-${i}`)) }), "MultilineMarkup"), DarkModeContext = reactExports.createContext({}), useDarkmode = /* @__PURE__ */ __name(() => {
  const { isDarkMode, toggleDarkmode } = reactExports.useContext(DarkModeContext);
  return { isDarkMode, toggleDarkmode };
}, "useDarkmode"), alert = "" + new URL("alert-triangle.svg", import.meta.url).href, BB02StylizedDark = "" + new URL("bitbox02-stylized-reflection-dark.png", import.meta.url).href, BB02StylizedLight = "" + new URL("bitbox02-stylized-reflection-light.png", import.meta.url).href, info$5 = "" + new URL("info2.svg", import.meta.url).href, arrowCircleLeftSVG = "" + new URL("arrow-circle-left.svg", import.meta.url).href, arrowCircleLeftActiveSVG = "" + new URL("arrow-circle-left-active.svg", import.meta.url).href, arrowCircleRightSVG = "" + new URL("arrow-circle-right.svg", import.meta.url).href, arrowCircleRightActiveSVG = "" + new URL("arrow-circle-right-active.svg", import.meta.url).href, bankDarkSVG = "" + new URL("bank.svg", import.meta.url).href, bankLightSVG = "" + new URL("bank-light.svg", import.meta.url).href, buyInfoSVG = "" + new URL("buy-info.svg", import.meta.url).href, checkedSmallSVG = "" + new URL("checked-small.svg", import.meta.url).href, checkSVG = "" + new URL("check.svg", import.meta.url).href, chevronRightDark = "" + new URL("chevron-right-dark.svg", import.meta.url).href, chevronLeftDark = "" + new URL("chevron-left-dark.svg", import.meta.url).href, cancelSVG = "" + new URL("cancel.svg", import.meta.url).href, creditCardDarkSVG = "" + new URL("credit-card.svg", import.meta.url).href, creditCardLightSVG = "" + new URL("credit-card-light.svg", import.meta.url).href, editSVG = "" + new URL("edit.svg", import.meta.url).href, editLightSVG = "" + new URL("edit-light.svg", import.meta.url).href, editActiveSVG = "" + new URL("edit-active.svg", import.meta.url).href, ETH = "" + new URL("eth-color.svg", import.meta.url).href, redDotSVG = "" + new URL("red-dot.svg", import.meta.url).href, copySVG = "" + new URL("copy.svg", import.meta.url).href, closeSVG = "" + new URL("close.svg", import.meta.url).href, closeXWhiteSVG = "" + new URL("close-x-white.svg", import.meta.url).href, closeXDarkSVG = "" + new URL("close-x-dark.svg", import.meta.url).href, externalLink = "" + new URL("external-link.svg", import.meta.url).href, eyeClosedSVG = "" + new URL("eye-closed.svg", import.meta.url).href, eyeOpenedSVG = "" + new URL("eye-opened.svg", import.meta.url).href, eyeOpenedDarkSVG = "" + new URL("eye-opened-dark.svg", import.meta.url).href, globeDarkSVG = "" + new URL("globe-dark.svg", import.meta.url).href, globeLightSVG = "" + new URL("globe-light.svg", import.meta.url).href, guideSVG = "" + new URL("guide.svg", import.meta.url).href, menuDarkSVG = "" + new URL("menu-dark.svg", import.meta.url).href, menuLightSVG = "" + new URL("menu-light.svg", import.meta.url).href, walletConnectDarkSVG = "" + new URL("wallet-connect-dark.svg", import.meta.url).href, walletConnectLightSVG = "" + new URL("wallet-connect-light.svg", import.meta.url).href, walletConnectDefaultSVG = "" + new URL("wallet-connect-default.svg", import.meta.url).href, warningPNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACowAAAqMBZNxfiQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOMSURBVGiB7ZjPS5RBGMe/877vrluJmLqR4KEfICJ46CB0CNwOGS5sLf0FYq63grqWseipJOzaD6N7lyBSUohAgkDpkgcREiI96Wp00d33dZ4Ou67uvvP6zjvvLFvg97bzzjzP892Z+bwzL3CsY4USq1Xg3FCqnwx+v5iEnra+mp6rRZ6aGNgaSV3hnH8GYJaaHIN4omVq5ovuXIbugJRNWJz4cxwUDwAWN4wXlE1YuvNpN5BbO5UBodv1gNC9ud44rDuf1iW0PZhu3rPsFQBxjy4bphPpPP3m3W9dObXOgGMWRuFdPADEuWU/1JlT2wxsZJKdjNgSgIhP1wIx6om/nF7RkVfbDDDOJuBfPABEGbEn2vLqCFJi/sdAiblxvfX1+9mwuUPPAGUTFpl8MvA4k0/qwGpoA57Y9JMmrIZaQhLY9FNorIaagRISVYsHgDiP2A/C1KA8AyVsfgcQrX4WSyQR679V0bYz8xb5eeE+D4VV5U3EOJsAcxcPAIhEYcbPVva3PAm7j9W0Sh1KSyg3lOoHww3PDoW8q4lsd9sh3cwNpfpVaglsQAabZBfcjQVB2+ExilgNbGBzvXHYD5skKNZnBopY/XXydtB6AhnYHkw3M6Ix346CYkWmqsUYG98eTDcHqSmQAVlsCosVLSu3AmNV2sBGJtlJwB2ZvqI9INwXorGEuxuZZKdsXdIGSqdNMTarJaKQxBIqKdBpVcqALzarJPy3/TZxpaSx6mtA5bQppJD8DBT7S2LV14AMNl0SUUhyDxwMkMPqkQaksVmd27bdjYJ94ScZrB5pQPW06XppEYEcgSl/+WLV00AQbLrkOADn5Z/k2ACRUig/rHpukiNPmxJyVpeBSHE45XdVwwA+p1XhfUDlkl5reX0EcC0h1Ut6reWFVZcBJWyKxBjMM+0w4+0A0/D1xgOrFZE1XNKLQWMn0HRvHNaFLgCA82MZf56NgnZ3woQFBB8BKmZAwyUdABDrGygXDwDWxS7E+gbChgUEWC0bCIXNKrHGJqk2FVVjtWyghCplbB5WYWG+4sVFjo3CwryO0AAQZcDj/R8MqA02zY5zaLh8FSAg//UT9tZ/6gxfxiqjbNbIrS0uAnRJa4ba61trR28v+xdfWtJiuGZwttdW7zpURUCb0WCaswC26l2MgnIN+egcA4CtkWQP5+wRgPN1LkpODKsGx1jL1IelepdyrP9efwF60oqTW0b3mgAAAABJRU5ErkJggg==", warningOutlinedSVG = "" + new URL("warning-outlined.svg", import.meta.url).href, qrCodeDarkSVG = "" + new URL("qr-dark.svg", import.meta.url).href, qrCodeLightSVG = "" + new URL("qr-light.svg", import.meta.url).href, saveSVG = "" + new URL("save.svg", import.meta.url).href, saveLightSVG = "" + new URL("save-light.svg", import.meta.url).href, selectedCheckLightSVG = "" + new URL("selected-check-light.svg", import.meta.url).href, usbSuccessSVG = "" + new URL("usb-success.svg", import.meta.url).href, expandIcon = "_expandIcon_j17uw_1", style$13 = {
  expandIcon
}, ExpandOpen = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$13.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "11", y1: "8", x2: "11", y2: "14" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
), "ExpandOpen"), ExpandClose = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$13.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
), "ExpandClose"), AnimatedChecked = /* @__PURE__ */ __name(({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: `checked ${className || ""}`, viewBox: "0 0 52 52", ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "checked-circle", cx: "26", cy: "26", r: "25", fill: "none" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "checked-check", fill: "none", d: "M14.1 27.2l7.1 7.2 16.7-16.8" })
] }), "AnimatedChecked"), CaretDown = /* @__PURE__ */ __name(({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `caretDown ${className || ""}`, viewBox: "0 0 1024 1024", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }) }), "CaretDown"), ExpandIcon = /* @__PURE__ */ __name(({
  expand = !0
}) => expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandOpen, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandClose, {}), "ExpandIcon"), Info$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: info$5, draggable: !1, ...props }), "Info$1"), BitBox02StylizedDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedDark, draggable: !1, ...props }), "BitBox02StylizedDark"), BitBox02StylizedLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedLight, draggable: !1, ...props }), "BitBox02StylizedLight"), ArrowCirlceLeft = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftSVG, draggable: !1, ...props }), "ArrowCirlceLeft"), ArrowCirlceLeftActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftActiveSVG, draggable: !1, ...props }), "ArrowCirlceLeftActive"), ArrowCirlceRight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightSVG, draggable: !1, ...props }), "ArrowCirlceRight"), ArrowCirlceRightActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightActiveSVG, draggable: !1, ...props }), "ArrowCirlceRightActive"), BankDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankDarkSVG, draggable: !1, ...props }), "BankDark"), Bank = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankLightSVG, draggable: !1, ...props }), "Bank"), BuyInfo$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: buyInfoSVG, draggable: !1, ...props }), "BuyInfo$1"), Checked = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkedSmallSVG, draggable: !1, ...props }), "Checked"), Check$3 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkSVG, draggable: !1, ...props }), "Check$3"), ChevronLeftDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronLeftDark, draggable: !1, ...props }), "ChevronLeftDark"), ChevronRightDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronRightDark, draggable: !1, ...props }), "ChevronRightDark"), Cancel = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cancelSVG, draggable: !1, ...props }), "Cancel"), CreditCardDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardDarkSVG, draggable: !1, ...props }), "CreditCardDark"), CreditCard = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardLightSVG, draggable: !1, ...props }), "CreditCard"), RedDot = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: redDotSVG, draggable: !1, ...props }), "RedDot"), Copy = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: copySVG, draggable: !1, ...props }), "Copy"), Close = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeSVG, draggable: !1, ...props }), "Close"), CloseXWhite = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXWhiteSVG, draggable: !1, ...props }), "CloseXWhite"), CloseXDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXDarkSVG, draggable: !1, ...props }), "CloseXDark"), Edit = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editSVG, draggable: !1, ...props }), "Edit"), EditLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editLightSVG, draggable: !1, ...props }), "EditLight"), EditActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editActiveSVG, draggable: !1, ...props }), "EditActive"), ETHLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ETH, draggable: !1, ...props }), "ETHLogo"), ExternalLink = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: externalLink, draggable: !1, ...props }), "ExternalLink"), EyeClosed = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeClosedSVG, draggable: !1, ...props }), "EyeClosed"), EyeOpened = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedSVG, draggable: !1, ...props }), "EyeOpened"), EyeOpenedDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedDarkSVG, draggable: !1, ...props }), "EyeOpenedDark"), GlobeDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeDarkSVG, draggable: !1, ...props }), "GlobeDark"), GlobeLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeLightSVG, draggable: !1, ...props }), "GlobeLight"), GuideActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: guideSVG, draggable: !1, ...props }), "GuideActive"), MenuDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuDarkSVG, draggable: !1, ...props }), "MenuDark"), MenuLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuLightSVG, draggable: !1, ...props }), "MenuLight"), WalletConnectDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDarkSVG, draggable: !1, ...props }), "WalletConnectDark"), WalletConnectLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectLightSVG, draggable: !1, ...props }), "WalletConnectLight"), WalletConnectDefaultLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDefaultSVG, draggable: !1, ...props }), "WalletConnectDefaultLogo"), Warning = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningPNG, draggable: !1, ...props }), "Warning"), WarningOutlined = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningOutlinedSVG, draggable: !1, ...props }), "WarningOutlined"), QRCodeDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeDarkSVG, draggable: !1, ...props }), "QRCodeDark"), QRCodeLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeLightSVG, draggable: !1, ...props }), "QRCodeLight"), Save = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveSVG, draggable: !1, ...props }), "Save"), SaveLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveLightSVG, draggable: !1, ...props }), "SaveLight"), SelectedCheckLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedCheckLightSVG, draggable: !1, ...props }), "SelectedCheckLight"), USBSuccess = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: usbSuccessSVG, draggable: !1, ...props }), "USBSuccess"), Alert$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: alert, draggable: !1, ...props }), "Alert$1"), AppLogoInvertedImg = "" + new URL("app-logo-inverted.svg", import.meta.url).href, AppLogoImg = "" + new URL("app-logo.svg", import.meta.url).href, BitBoxLogo = "" + new URL("bitbox-logo.svg", import.meta.url).href, BitBox02Logo = "" + new URL("bitbox02-logo.svg", import.meta.url).href, BitBox02InvertedLogo = "" + new URL("bitbox02inverted-logo.svg", import.meta.url).href, BTC = "" + new URL("btc-color.svg", import.meta.url).href, BTC_GREY = "" + new URL("btc-white.svg", import.meta.url).href, ETH_GREY = "" + new URL("eth-white.svg", import.meta.url).href, LTC = "" + new URL("ltc-color.svg", import.meta.url).href, LTC_GREY = "" + new URL("ltc-white.svg", import.meta.url).href, SwissOpenSourceLight = "" + new URL("swiss-made-open-source-light.svg", import.meta.url).href, SwissOpenSourceDark = "" + new URL("swiss-made-open-source-dark.svg", import.meta.url).href, BAT = "" + new URL("bat-color.svg", import.meta.url).href, BAT_GREY = "" + new URL("bat-white.svg", import.meta.url).href, DAI = "" + new URL("dai-color.svg", import.meta.url).href, DAI_GREY = "" + new URL("dai-white.svg", import.meta.url).href, LINK = "" + new URL("link-color.svg", import.meta.url).href, LINK_GREY = "" + new URL("link-white.svg", import.meta.url).href, MKR = "" + new URL("mkr-color.svg", import.meta.url).href, MKR_GREY = "" + new URL("mkr-white.svg", import.meta.url).href, USDC = "" + new URL("usdc-color.svg", import.meta.url).href, USDC_GREY = "" + new URL("usdc-white.svg", import.meta.url).href, USDT = "" + new URL("usdt-color.svg", import.meta.url).href, USDT_GREY = "" + new URL("usdt-white.svg", import.meta.url).href, ZRX = "" + new URL("zrx-color.svg", import.meta.url).href, ZRX_GREY = "" + new URL("zrx-white.svg", import.meta.url).href, WBTC = "" + new URL("wbtc-color.svg", import.meta.url).href, WBTC_GREY = "" + new URL("wbtc-white.svg", import.meta.url).href, PAXG = "" + new URL("paxg-color.svg", import.meta.url).href, PAXG_GREY = "" + new URL("paxg-white.svg", import.meta.url).href, logo$1 = "_logo_gbled_1", swissOpenSource = "_swissOpenSource_gbled_7", large$2 = "_large_gbled_12", style$12 = {
  logo: logo$1,
  swissOpenSource,
  large: large$2
}, BitBox = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBoxLogo, alt: "BitBox", className: style$12.logo }), "BitBox"), BitBox02$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBox02Logo, alt: "BitBox02", className: style$12.logo }), "BitBox02$1"), BitBox02Inverted = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBox02InvertedLogo, alt: "BitBox02", className: style$12.logo }), "BitBox02Inverted"), AppLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: AppLogoImg, alt: "BitBox", className: style$12.logo }), "AppLogo"), AppLogoInverted = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: AppLogoInvertedImg, alt: "BitBox", className: style$12.logo }), "AppLogoInverted"), SwissMadeOpenSource = /* @__PURE__ */ __name(({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: SwissOpenSourceLight, alt: "Swiss Made Open Source", className: `${style$12.swissOpenSource} ${props.large ? style$12.large : ""} ${className || ""}` }), "SwissMadeOpenSource"), SwissMadeOpenSourceDark = /* @__PURE__ */ __name(({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: SwissOpenSourceDark, alt: "Swiss Made Open Source", className: `${style$12.swissOpenSource} ${props.large ? style$12.large : ""} ${className || ""}` }), "SwissMadeOpenSourceDark"), logoMap = {
  btc: [BTC, BTC_GREY],
  tbtc: [BTC, BTC_GREY],
  rbtc: [BTC, BTC_GREY],
  ltc: [LTC, LTC_GREY],
  tltc: [LTC, LTC_GREY],
  eth: [ETH, ETH_GREY],
  goeth: [ETH, ETH_GREY],
  sepeth: [ETH, ETH_GREY],
  erc20Test: [ETH, ETH_GREY],
  "eth-erc20-usdt": [USDT, USDT_GREY],
  "eth-erc20-usdc": [USDC, USDC_GREY],
  "eth-erc20-dai0x6b17": [DAI, DAI_GREY],
  "eth-erc20-link": [LINK, LINK_GREY],
  "eth-erc20-bat": [BAT, BAT_GREY],
  "eth-erc20-mkr": [MKR, MKR_GREY],
  "eth-erc20-zrx": [ZRX, ZRX_GREY],
  "eth-erc20-wbtc": [WBTC, WBTC_GREY],
  "eth-erc20-paxg": [PAXG, PAXG_GREY]
};
function Logo({ coinCode, active: active2, stacked, ...rest }) {
  return logoMap[coinCode] ? stacked ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: active2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][1], ...rest }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest })
  ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest }) : (console.error("logo undefined for ", coinCode), null);
}
__name(Logo, "Logo");
const point2bitbox02 = "_point2bitbox02_1vb0x_1", caret$1 = "_caret_1vb0x_5", bitbox02 = "_bitbox02_1vb0x_10", style$11 = {
  point2bitbox02,
  caret: caret$1,
  bitbox02
}, PointToBitBox02 = /* @__PURE__ */ __name(() => {
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$11.point2bitbox02, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { className: style$11.caret }),
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: style$11.bitbox02 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: style$11.bitbox02 })
  ] });
}, "PointToBitBox02"), overlay$3 = "_overlay_1u8gr_1", activeOverlay$1 = "_activeOverlay_1u8gr_15", modal$1 = "_modal_1u8gr_19", header$8 = "_header_1u8gr_31", title$9 = "_title_1u8gr_31", contentContainer$2 = "_contentContainer_1u8gr_37", small$2 = "_small_1u8gr_42", medium$1 = "_medium_1u8gr_47", large$1 = "_large_1u8gr_53", centered$1 = "_centered_1u8gr_68", closeButton$3 = "_closeButton_1u8gr_78", slim$1 = "_slim_1u8gr_105", padded$1 = "_padded_1u8gr_109", content$5 = "_content_1u8gr_37", actions$1 = "_actions_1u8gr_117", confirmationLabel$1 = "_confirmationLabel_1u8gr_135", confirmationLabelNumber$1 = "_confirmationLabelNumber_1u8gr_144", disabledLabel$1 = "_disabledLabel_1u8gr_150", noStep$1 = "_noStep_1u8gr_155", confirmationInstructions$1 = "_confirmationInstructions_1u8gr_159", confirm$1 = "_confirm_1u8gr_135", image$1 = "_image_1u8gr_179", modalContent$1 = "_modalContent_1u8gr_184", detail$2 = "_detail_1u8gr_193", description$1 = "_description_1u8gr_217", buttons$4 = "_buttons_1u8gr_221", dialogButtons$1 = "_dialogButtons_1u8gr_233", closingOverlay = "_closingOverlay_1u8gr_244", open$1 = "_open_1u8gr_268", style$10 = {
  overlay: overlay$3,
  activeOverlay: activeOverlay$1,
  modal: modal$1,
  header: header$8,
  title: title$9,
  contentContainer: contentContainer$2,
  small: small$2,
  medium: medium$1,
  large: large$1,
  centered: centered$1,
  closeButton: closeButton$3,
  slim: slim$1,
  padded: padded$1,
  content: content$5,
  actions: actions$1,
  confirmationLabel: confirmationLabel$1,
  confirmationLabelNumber: confirmationLabelNumber$1,
  disabledLabel: disabledLabel$1,
  noStep: noStep$1,
  confirmationInstructions: confirmationInstructions$1,
  confirm: confirm$1,
  image: image$1,
  modalContent: modalContent$1,
  detail: detail$2,
  description: description$1,
  buttons: buttons$4,
  dialogButtons: dialogButtons$1,
  closingOverlay,
  open: open$1
}, _Dialog = class _Dialog extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.modalContent = reactExports.createRef(), this.state = {
      currentTab: 0,
      renderDialog: !1
    }, this.handleFocus = (e2) => {
      const index = e2.target.getAttribute("index");
      this.setState({ currentTab: Number(index) });
    }, this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables)
          c2.classList.add("tabbable"), c2.setAttribute("index", focusables.indexOf(c2).toString()), c2.addEventListener("focus", this.handleFocus);
        document.addEventListener("keydown", this.handleKeyDown);
      }
    }, this.focusFirst = () => {
      const focusables = this.focusableChildren;
      focusables.length && focusables[0].getAttribute("autofocus") !== "false" && focusables[0].focus();
    }, this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    }, this.deactivateModal = (fireOnCloseProp) => {
      !this.modal.current || !this.overlay.current || (this.overlay.current.classList.remove(style$10.closingOverlay), this.setState({ currentTab: 0, renderDialog: !1 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown), this.props.onClose && fireOnCloseProp && this.props.onClose();
      }));
    }, this.handleKeyDown = (e2) => {
      const { disableEscape } = this.props, isEsc = e2.keyCode === 27, isTab = e2.keyCode === 9;
      !disableEscape && isEsc ? this.deactivate(!0) : isTab && e2.preventDefault(), isTab && e2.shiftKey ? this.updateIndex(!1) : isTab && this.updateIndex(!0);
    }, this.deactivate = (fireOnCloseProp) => {
      var _a46;
      if (!this.modal.current || !this.overlay.current)
        return;
      this.timerId && clearTimeout(this.timerId), this.overlay.current.classList.remove(style$10.activeOverlay), this.overlay.current.classList.add(style$10.closingOverlay), (_a46 = this.modal.current) == null || _a46.classList.remove(style$10.open);
      const onTransitionEnd = /* @__PURE__ */ __name((event2) => {
        var _a47;
        event2.target === this.modal.current && (this.deactivateModal(fireOnCloseProp), (_a47 = this.modal.current) == null || _a47.removeEventListener("transitionend", onTransitionEnd));
      }, "onTransitionEnd");
      parseFloat(window.getComputedStyle(this.modal.current).transitionDuration) > 0 ? (this.modal.current.addEventListener("transitionend", onTransitionEnd), this.timerId = setTimeout(() => this.deactivateModal(fireOnCloseProp), 400)) : this.deactivateModal(fireOnCloseProp);
    }, this.activate = () => {
      this.setState({ renderDialog: !0 }, () => {
        !this.modal.current || !this.overlay.current || (this.timerId && clearTimeout(this.timerId), this.overlay.current.classList.add(style$10.activeOverlay), this.timerId = setTimeout(() => {
          var _a46;
          (_a46 = this.modal.current) == null || _a46.classList.add(style$10.open);
        }, 10), this.focusWithin(), this.focusFirst());
      });
    };
  }
  componentDidMount() {
    this.props.open && this.activate();
  }
  componentDidUpdate(prevProps) {
    const { open: open2 } = this.props;
    if (open2 && !prevProps.open) {
      this.activate();
      return;
    }
    if (!open2 && prevProps.open) {
      this.deactivate(!1);
      return;
    }
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state, focusables = Array.from(this.focusableChildren), arr = isNext ? focusables : focusables.reverse(), current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    return next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled")), next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2, isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props, { renderDialog } = this.state, isSmall = small2 ? style$10.small : "", isMedium = medium2 ? style$10.medium : "", isLarge = large2 ? style$10.large : "", isSlim = slim2 ? style$10.slim : "", isCentered = centered2 && !onClose ? style$10.centered : "";
    return renderDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$10.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$10.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$10.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$10.closeButton, onClick: () => {
              this.deactivate(!0);
            }, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$10.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.content, children: children2 })
            }
          )
        ]
      }
    ) }) : null;
  }
};
__name(_Dialog, "Dialog");
let Dialog = _Dialog;
function DialogButtons$1({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.dialogButtons, children: children2 });
}
__name(DialogButtons$1, "DialogButtons$1");
const defaultLanguages = [
  { code: "ar", display: "" },
  { code: "bg", display: "" },
  { code: "cs", display: "etina" },
  { code: "de", display: "Deutsch" },
  { code: "en", display: "English" },
  { code: "es", display: "Espaol" },
  { code: "fa", display: "" },
  { code: "fr", display: "Franais" },
  { code: "he", display: "" },
  { code: "hi", display: " " },
  { code: "it", display: "Italiano" },
  { code: "ja", display: "" },
  { code: "ms", display: "Bahasa Melayu" },
  { code: "nl", display: "Nederlands" },
  { code: "pt", display: "Portugus" },
  { code: "ru", display: "" },
  { code: "sl", display: "Slovenina" },
  { code: "tr", display: "Trke" },
  { code: "zh", display: "" }
], link$4 = "_link_28asd_1", language = "_language_28asd_20", selected = "_selected_28asd_38", checked = "_checked_28asd_46", style$$ = {
  link: link$4,
  language,
  selected,
  checked
}, getSelectedIndex = /* @__PURE__ */ __name((languages, i18n) => {
  const lang = i18n.language;
  let index = languages.findIndex(({ code }) => code === lang);
  if (index === -1 && lang.indexOf("-") > 0) {
    const tag = lang.slice(0, lang.indexOf("-"));
    index = languages.findIndex(({ code }) => code === tag);
  }
  if (index === -1 && lang.indexOf("_") > 0) {
    const tag = lang.slice(0, lang.indexOf("_"));
    index = languages.findIndex(({ code }) => code === tag);
  }
  return index === -1 ? 0 : index;
}, "getSelectedIndex"), LanguageSwitch = /* @__PURE__ */ __name(({ languages }) => {
  const { t: t2, i18n } = useTranslation(), allLanguages = languages || defaultLanguages, [selectedIndex, setSelectedIndex] = reactExports.useState(getSelectedIndex(allLanguages, i18n)), [activeDialog, setActiveDialog] = reactExports.useState(!1), changeLanguage = /* @__PURE__ */ __name((langCode, index) => {
    setSelectedIndex(index), setActiveDialog(!1), i18n.changeLanguage(langCode);
  }, "changeLanguage");
  return allLanguages.length === 1 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type: "button",
        title: "Select Language",
        className: style$$.link,
        onClick: () => setActiveDialog(!0),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
              ]
            }
          ),
          allLanguages[selectedIndex].code === "en" ? "Other languages" : "English"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { small: !0, slim: !0, title: t2("language.title"), onClose: () => setActiveDialog(!1), open: activeDialog, children: allLanguages.map((language2, i) => {
      const selected2 = selectedIndex === i;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: [style$$.language, selected2 ? style$$.selected : ""].join(" "),
          onClick: () => changeLanguage(language2.code, i),
          "data-testid": `language-selection-${language2.code}`,
          children: [
            language2.display,
            selected2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: style$$.checked,
                xmlns: "http://www.w3.org/2000/svg",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" })
              }
            )
          ]
        },
        language2.code
      );
    }) })
  ] });
}, "LanguageSwitch"), useMountedRef = /* @__PURE__ */ __name(() => {
  const isMountedRef = reactExports.useRef(!1);
  return reactExports.useEffect(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), isMountedRef;
}, "useMountedRef"), useSubscribeReset = /* @__PURE__ */ __name((subscription) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), subscribe2 = /* @__PURE__ */ __name(() => subscription((data) => {
    mounted.current && setResponse(data);
  }), "subscribe");
  return reactExports.useEffect(
    () => subscribe2(),
    // empty dependencies because it's only subscribed once
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), [response, () => setResponse(void 0)];
}, "useSubscribeReset"), useSubscribe = /* @__PURE__ */ __name((subscription) => {
  const [response] = useSubscribeReset(subscription);
  return response;
}, "useSubscribe"), useLoad = /* @__PURE__ */ __name((apiCall, dependencies) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), load2 = /* @__PURE__ */ __name(() => {
    apiCall !== null && apiCall().then((data) => {
      mounted.current && setResponse(data);
    });
  }, "load");
  return reactExports.useEffect(
    () => load2(),
    // By default no dependencies are passed to only query once
    dependencies || []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), response;
}, "useLoad"), useSync = /* @__PURE__ */ __name((apiCall, subscription) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), onData = /* @__PURE__ */ __name((data) => {
    mounted.current && setResponse(data);
  }, "onData");
  return reactExports.useEffect(
    () => (apiCall().then(onData), subscription(onData)),
    // we pass no dependencies because it's only queried once
    []
  ), response;
}, "useSync"), getVersion$1 = /* @__PURE__ */ __name(() => apiGet("version"), "getVersion$1"), getUpdate = /* @__PURE__ */ __name(() => apiGet("update"), "getUpdate"), Version = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), version = useLoad(getVersion$1);
  return version ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
    t2("footer.appVersion"),
    " ",
    version
  ] }) : null;
}, "Version"), fullscreen = "_fullscreen_q1y08_1", dialog = "_dialog_q1y08_22", fill = "_fill_q1y08_28", inner = "_inner_q1y08_38", verticallyCentered = "_verticallyCentered_q1y08_46", fit = "_fit_q1y08_50", content$4 = "_content_q1y08_56", textCenter = "_textCenter_q1y08_61", header$7 = "_header_q1y08_109", smallHeader = "_smallHeader_q1y08_130", title$8 = "_title_q1y08_155", closeButton$2 = "_closeButton_q1y08_169", fullWidth = "_fullWidth_q1y08_197", largeIcon = "_largeIcon_q1y08_215", buttons$3 = "_buttons_q1y08_240", footer$1 = "_footer_q1y08_294", style$_ = {
  fullscreen,
  dialog,
  fill,
  inner,
  verticallyCentered,
  fit,
  content: content$4,
  textCenter,
  "text-center": "_text-center_q1y08_62",
  "text-left": "_text-left_q1y08_65",
  header: header$7,
  smallHeader,
  title: title$8,
  closeButton: closeButton$2,
  fullWidth,
  largeIcon,
  buttons: buttons$3,
  footer: footer$1
}, View = /* @__PURE__ */ __name(({
  dialog: dialog2 = !1,
  fitContent = !1,
  fullscreen: fullscreen2,
  children: children2,
  minHeight,
  onClose,
  textCenter: textCenter2,
  verticallyCentered: verticallyCentered2 = !1,
  width,
  withBottomBar
}) => {
  const { isDarkMode } = useDarkmode(), containerClasses = `${style$_[fullscreen2 ? "fullscreen" : "fill"]} ${verticallyCentered2 ? style$_.verticallyCentered : ""} ${dialog2 ? style$_.dialog : ""}`;
  let classNames2 = style$_.inner;
  fitContent && (classNames2 += ` ${style$_.fit}`), textCenter2 && (classNames2 += ` ${style$_.textCenter}`);
  const inlineStyles = {
    ...minHeight && { minHeight },
    ...width && { width }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames2,
        style: inlineStyles,
        children: children2
      }
    ),
    onClose && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$_.closeButton, onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {}) }),
    withBottomBar && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: style$_.footer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
    ] }) })
  ] });
}, "View"), ViewContent = /* @__PURE__ */ __name(({
  children: children2,
  fullWidth: fullWidth2,
  minHeight,
  textAlign,
  withIcon,
  ...props
}) => {
  const align = textAlign ? style$_[`text-${textAlign}`] : "", containerWidth = fullWidth2 ? style$_.fullWidth : "", classes = `${style$_.content} ${containerWidth} ${align}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classes,
      style: minHeight ? { minHeight } : {},
      ...props,
      children: [
        withIcon === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: style$_.largeIcon }),
        children2
      ]
    }
  );
}, "ViewContent"), ViewHeader = /* @__PURE__ */ __name(({
  children: children2,
  small: small2,
  title: title2,
  withAppLogo
}) => {
  const { isDarkMode } = useDarkmode(), headerStyles = small2 ? `${style$_.header} ${style$_.smallHeader}` : style$_.header;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: headerStyles, children: [
    withAppLogo && (isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {})),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$_.title, children: title2 }),
    children2
  ] });
}, "ViewHeader"), ViewButtons = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$_.buttons, children: children2 }), "ViewButtons"), button$3 = "_button_b8ew4_1", primary$1 = "_primary_b8ew4_38 _button_b8ew4_1", secondary = "_secondary_b8ew4_49 _button_b8ew4_1", danger$1 = "_danger_b8ew4_67 _button_b8ew4_1", transparent = "_transparent_b8ew4_84 _button_b8ew4_1", style$Z = {
  button: button$3,
  primary: primary$1,
  secondary,
  danger: danger$1,
  transparent
}, ButtonLink = /* @__PURE__ */ __name(({
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  disabled: disabled2,
  ...props
}) => {
  const classNames2 = [
    style$Z[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return disabled2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: classNames2,
      disabled: !0,
      children: children2
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Link,
    {
      className: classNames2,
      ...props,
      children: children2
    }
  );
}, "ButtonLink"), Button = /* @__PURE__ */ __name(({
  type: type2 = "button",
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  ...props
}) => {
  const classNames2 = [
    style$Z[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: type2,
      className: classNames2,
      ...props,
      children: children2
    }
  );
}, "Button"), checkbox = "_checkbox_1m6k1_1", success$6 = "_success_1m6k1_33", warning$5 = "_warning_1m6k1_37", info$4 = "_info_1m6k1_41", styles$s = {
  checkbox,
  success: success$6,
  warning: warning$5,
  info: info$4
}, Checkbox = /* @__PURE__ */ __name(({
  disabled: disabled2 = !1,
  label: label2,
  id: id2,
  className = "",
  children: children2,
  checkboxStyle = "default",
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$s.checkbox} ${className} ${styles$s[checkboxStyle] || ""}`, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      id: id2,
      disabled: disabled2,
      ...props
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
    label2,
    " ",
    children2
  ] })
] }), "Checkbox"), radio$1 = "_radio_198i3_1", style$Y = {
  radio: radio$1
};
function Radio({
  disabled: disabled2 = !1,
  label: label2,
  id: id2,
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$Y.radio, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "radio",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      children2
    ] })
  ] });
}
__name(Radio, "Radio");
const field = "_field_d2mb0_1", style$X = {
  field
};
function Field({
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$X.field, ...props, children: children2 });
}
__name(Field, "Field");
const input = "_input_1dgl0_1", isTransparent = "_isTransparent_1dgl0_58", errorText = "_errorText_1dgl0_64", styles$r = {
  input,
  "align-left": "_align-left_1dgl0_12",
  "align-right": "_align-right_1dgl0_16",
  isTransparent,
  errorText
}, Input$2 = reactExports.forwardRef(/* @__PURE__ */ __name(function({
  id: id2,
  label: label2 = "",
  error: error3,
  align = "left",
  className = "",
  children: children2,
  transparent: transparent2 = !1,
  type: type2 = "text",
  labelSection,
  ...props
}, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    styles$r.input,
    styles$r[`align-${align}`],
    className,
    transparent2 ? styles$r.isTransparent : ""
  ].join(" "), children: [
    label2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: error3 ? styles$r.errorText : "", children: [
        label2,
        error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          ":",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: error3.toString() })
        ] }) : null
      ] }),
      labelSection && labelSection
    ] }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: !1,
        type: type2,
        id: id2,
        ref,
        ...props
      }
    ),
    children2
  ] });
}, "Input")), label$6 = "_label_53nw1_1", style$W = {
  label: label$6
};
function Label({
  className,
  children: children2,
  id: id2,
  // TODO: change to htmlFor when mirgated away from preact@8.x
  ...props
}) {
  const classes = [style$W.label, className].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: classes, ...props, children: children2 });
}
__name(Label, "Label");
const select$5 = "_select_yd5xu_1", styles$q = {
  select: select$5
}, Select$1 = /* @__PURE__ */ __name(({
  id: id2,
  label: label2,
  options: options2 = [],
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$q.select, children: [
  label2 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, children: label2 }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("select", { id: id2, ...props, children: options2.map(({ value, text: text2, disabled: disabled2 = !1 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "option",
    {
      value,
      disabled: disabled2,
      children: text2
    },
    `${value}`
  )) })
] }), "Select$1");
let alertUser, callback;
const Alert = /* @__PURE__ */ __name(() => {
  const [active2, setActive] = reactExports.useState(!1), [asDialog, setAsDialog] = reactExports.useState(!0), [message2, setMessage] = reactExports.useState(), { t: t2 } = useTranslation();
  alertUser = /* @__PURE__ */ __name((message22, options2 = {}) => {
    const {
      asDialog: asDialog2 = !0
    } = options2;
    callback = options2.callback, setActive(!0), setAsDialog(asDialog2), setMessage(message22);
  }, "alertUser");
  const handleClose = /* @__PURE__ */ __name(() => {
    callback && callback(), setActive(!1);
  }, "handleClose");
  return active2 && message2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: () => setActive(!1), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      dialog: asDialog,
      fullscreen: !0,
      textCenter: !asDialog,
      verticallyCentered: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "span", markup: message2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: !0,
            primary: !0,
            onClick: handleClose,
            children: t2("button.ok")
          }
        ) })
      ]
    },
    "alert-overlay"
  ) }) : null;
}, "Alert");
var QWebChannelMessageTypes = {
  signal: 1,
  propertyUpdate: 2,
  init: 3,
  idle: 4,
  debug: 5,
  invokeMethod: 6,
  connectToSignal: 7,
  disconnectFromSignal: 8,
  setProperty: 9,
  response: 10
};
const QWebChannel = /* @__PURE__ */ __name(function(transport, initCallback) {
  if (typeof transport != "object" || typeof transport.send != "function") {
    console.error("The QWebChannel expects a transport object with a send function and onmessage callback property. Given is: transport: " + typeof transport + ", transport.send: " + typeof transport.send);
    return;
  }
  var channel = this;
  this.transport = transport, this.send = function(data) {
    typeof data != "string" && (data = JSON.stringify(data)), channel.transport.send(data);
  }, this.transport.onmessage = function(message2) {
    var data = message2.data;
    switch (typeof data == "string" && (data = JSON.parse(data)), data.type) {
      case QWebChannelMessageTypes.signal:
        channel.handleSignal(data);
        break;
      case QWebChannelMessageTypes.response:
        channel.handleResponse(data);
        break;
      case QWebChannelMessageTypes.propertyUpdate:
        channel.handlePropertyUpdate(data);
        break;
      default:
        console.error("invalid message received:", message2.data);
        break;
    }
  }, this.execCallbacks = {}, this.execId = 0, this.exec = function(data, callback2) {
    if (!callback2) {
      channel.send(data);
      return;
    }
    if (channel.execId === Number.MAX_VALUE && (channel.execId = Number.MIN_VALUE), data.hasOwnProperty("id")) {
      console.error("Cannot exec message with property id: " + JSON.stringify(data));
      return;
    }
    data.id = channel.execId++, channel.execCallbacks[data.id] = callback2, channel.send(data);
  }, this.objects = {}, this.handleSignal = function(message2) {
    var object = channel.objects[message2.object];
    object ? object.signalEmitted(message2.signal, message2.args) : console.warn("Unhandled signal: " + message2.object + "::" + message2.signal);
  }, this.handleResponse = function(message2) {
    if (!message2.hasOwnProperty("id")) {
      console.error("Invalid response message received: ", JSON.stringify(message2));
      return;
    }
    channel.execCallbacks[message2.id](message2.data), delete channel.execCallbacks[message2.id];
  }, this.handlePropertyUpdate = function(message2) {
    for (var i in message2.data) {
      var data = message2.data[i], object = channel.objects[data.object];
      object ? object.propertyUpdate(data.signals, data.properties) : console.warn("Unhandled property update: " + data.object + "::" + data.signal);
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  }, this.debug = function(message2) {
    channel.send({ type: QWebChannelMessageTypes.debug, data: message2 });
  }, channel.exec({ type: QWebChannelMessageTypes.init }, function(data) {
    for (var objectName in data)
      new QObject(objectName, data[objectName], channel);
    for (var objectName in channel.objects)
      channel.objects[objectName].unwrapProperties();
    initCallback && initCallback(channel), channel.exec({ type: QWebChannelMessageTypes.idle });
  });
}, "QWebChannel");
function QObject(name, data, webChannel2) {
  this.__id__ = name, webChannel2.objects[name] = this, this.__objectSignals__ = {}, this.__propertyCache__ = {};
  var object = this;
  this.unwrapQObject = function(response) {
    if (response instanceof Array) {
      for (var ret = new Array(response.length), i = 0; i < response.length; ++i)
        ret[i] = object.unwrapQObject(response[i]);
      return ret;
    }
    if (!response || !response["__QObject*__"] || response.id === void 0)
      return response;
    var objectId = response.id;
    if (webChannel2.objects[objectId])
      return webChannel2.objects[objectId];
    if (!response.data) {
      console.error("Cannot unwrap unknown QObject " + objectId + " without data.");
      return;
    }
    var qObject = new QObject(objectId, response.data, webChannel2);
    return qObject.destroyed.connect(function() {
      if (webChannel2.objects[objectId] === qObject) {
        delete webChannel2.objects[objectId];
        var propertyNames = [];
        for (var propertyName in qObject)
          propertyNames.push(propertyName);
        for (var idx in propertyNames)
          delete qObject[propertyNames[idx]];
      }
    }), qObject.unwrapProperties(), qObject;
  }, this.unwrapProperties = function() {
    for (var propertyIdx in object.__propertyCache__)
      object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);
  };
  function addSignal(signalData, isPropertyNotifySignal) {
    var signalName = signalData[0], signalIndex = signalData[1];
    object[signalName] = {
      connect: function(callback2) {
        if (typeof callback2 != "function") {
          console.error("Bad callback given to connect to signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [], object.__objectSignals__[signalIndex].push(callback2), !isPropertyNotifySignal && signalName !== "destroyed" && webChannel2.exec({
          type: QWebChannelMessageTypes.connectToSignal,
          object: object.__id__,
          signal: signalIndex
        });
      },
      disconnect: function(callback2) {
        if (typeof callback2 != "function") {
          console.error("Bad callback given to disconnect from signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        var idx = object.__objectSignals__[signalIndex].indexOf(callback2);
        if (idx === -1) {
          console.error("Cannot find connection of signal " + signalName + " to " + callback2.name);
          return;
        }
        object.__objectSignals__[signalIndex].splice(idx, 1), !isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0 && webChannel2.exec({
          type: QWebChannelMessageTypes.disconnectFromSignal,
          object: object.__id__,
          signal: signalIndex
        });
      }
    };
  }
  __name(addSignal, "addSignal");
  function invokeSignalCallbacks(signalName, signalArgs) {
    var connections = object.__objectSignals__[signalName];
    connections && connections.forEach(function(callback2) {
      callback2.apply(callback2, signalArgs);
    });
  }
  __name(invokeSignalCallbacks, "invokeSignalCallbacks"), this.propertyUpdate = function(signals, propertyMap) {
    for (var propertyIndex in propertyMap) {
      var propertyValue = propertyMap[propertyIndex];
      object.__propertyCache__[propertyIndex] = propertyValue;
    }
    for (var signalName in signals)
      invokeSignalCallbacks(signalName, signals[signalName]);
  }, this.signalEmitted = function(signalName, signalArgs) {
    invokeSignalCallbacks(signalName, this.unwrapQObject(signalArgs));
  };
  function addMethod(methodData) {
    var methodName = methodData[0], methodIdx = methodData[1];
    object[methodName] = function() {
      for (var args = [], callback2, i = 0; i < arguments.length; ++i) {
        var argument = arguments[i];
        typeof argument == "function" ? callback2 = argument : argument instanceof QObject && webChannel2.objects[argument.__id__] !== void 0 ? args.push({
          id: argument.__id__
        }) : args.push(argument);
      }
      webChannel2.exec({
        type: QWebChannelMessageTypes.invokeMethod,
        object: object.__id__,
        method: methodIdx,
        args
      }, function(response) {
        if (response !== void 0) {
          var result = object.unwrapQObject(response);
          callback2 && callback2(result);
        }
      });
    };
  }
  __name(addMethod, "addMethod");
  function bindGetterSetter(propertyInfo) {
    var propertyIndex = propertyInfo[0], propertyName = propertyInfo[1], notifySignalData = propertyInfo[2];
    object.__propertyCache__[propertyIndex] = propertyInfo[3], notifySignalData && (notifySignalData[0] === 1 && (notifySignalData[0] = propertyName + "Changed"), addSignal(notifySignalData, !0)), Object.defineProperty(object, propertyName, {
      configurable: !0,
      get: function() {
        var propertyValue = object.__propertyCache__[propertyIndex];
        return propertyValue === void 0 && console.warn('Undefined value in property cache for property "' + propertyName + '" in object ' + object.__id__), propertyValue;
      },
      set: function(value) {
        if (value === void 0) {
          console.warn("Property setter for " + propertyName + " called with undefined value!");
          return;
        }
        object.__propertyCache__[propertyIndex] = value;
        var valueToSend = value;
        valueToSend instanceof QObject && webChannel2.objects[valueToSend.__id__] !== void 0 && (valueToSend = { id: valueToSend.__id__ }), webChannel2.exec({
          type: QWebChannelMessageTypes.setProperty,
          object: object.__id__,
          property: propertyIndex,
          value: valueToSend
        });
      }
    });
  }
  __name(bindGetterSetter, "bindGetterSetter"), data.methods.forEach(addMethod), data.properties.forEach(bindGetterSetter), data.signals.forEach(function(signal) {
    addSignal(signal, !1);
  });
  for (var name in data.enums)
    object[name] = data.enums[name];
}
__name(QObject, "QObject");
const debug = !1;
function runningInQtWebEngine() {
  return typeof window.qt < "u";
}
__name(runningInQtWebEngine, "runningInQtWebEngine");
function runningInAndroid() {
  return typeof window.android < "u";
}
__name(runningInAndroid, "runningInAndroid");
let webChannel = null, queryID$1 = 0;
const queryPromises$1 = {}, currentListeners$2 = [];
async function initTransport() {
  if (!runningInQtWebEngine())
    throw new Error("Must be running in Qt");
  if (webChannel)
    return webChannel;
  const initWebChannel = /* @__PURE__ */ __name(function(channel) {
    channel.objects.backend.gotResponse.connect((queryID2, response) => {
      queryPromises$1[queryID2].resolve(JSON.parse(response)), delete queryPromises$1[queryID2];
    }), channel.objects.backend.pushNotify.connect((msg) => {
      currentListeners$2.forEach((listener) => listener(JSON.parse(msg)));
    }), webChannel = channel;
  }, "initWebChannel");
  for (new QWebChannel(window.qt.webChannelTransport, initWebChannel); !webChannel; )
    await new Promise((r2) => setTimeout(r2, 1));
  return webChannel;
}
__name(initTransport, "initTransport");
function call(query) {
  return new Promise((resolve, reject2) => {
    initTransport().then((channel) => {
      queryID$1++, queryPromises$1[queryID$1] = { resolve, reject: reject2 }, channel.objects.backend.call(queryID$1, query);
    });
  });
}
__name(call, "call");
function qtSubscribePushNotifications(msgCallback) {
  return currentListeners$2.push(msgCallback), () => {
    currentListeners$2.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners$2.indexOf(msgCallback);
    currentListeners$2.splice(index, 1), currentListeners$2.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(qtSubscribePushNotifications, "qtSubscribePushNotifications");
let queryID = 0;
const queryPromises = {}, currentListeners$1 = [];
function androidCall(query) {
  return new Promise((resolve, reject2) => {
    runningInAndroid() ? (typeof window.onAndroidCallResponse > "u" && (window.onAndroidCallResponse = (queryID2, response) => {
      queryPromises[queryID2].resolve(response), delete queryPromises[queryID2];
    }), queryID++, queryPromises[queryID] = { resolve, reject: reject2 }, window.android.call(queryID, query)) : reject2();
  });
}
__name(androidCall, "androidCall");
function androidSubscribePushNotifications(msgCallback) {
  return typeof window.onAndroidPushNotification > "u" && (window.onAndroidPushNotification = (msg) => {
    currentListeners$1.forEach((listener) => listener(msg));
  }), currentListeners$1.push(msgCallback), () => {
    currentListeners$1.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners$1.indexOf(msgCallback);
    currentListeners$1.splice(index, 1), currentListeners$1.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(androidSubscribePushNotifications, "androidSubscribePushNotifications");
function extConfig(key, defaultValue) {
  return key.startsWith("{{ ") && key.endsWith(" }}") ? defaultValue : key;
}
__name(extConfig, "extConfig");
const apiPort = extConfig("{{ API_PORT }}", "8082"), apiToken = extConfig("{{ API_TOKEN }}", "");
function isTLS() {
  return document.URL.startsWith("https://");
}
__name(isTLS, "isTLS");
function apiURL(endpoint) {
  return (isTLS() ? "https://" : "http://") + "localhost:" + apiPort + "/api/" + endpoint;
}
__name(apiURL, "apiURL");
function handleError(endpoint) {
  return function(json) {
    return new Promise((resolve, reject2) => {
      if (json && json.error) {
        if (json.error.indexOf("hidapi: unknown failure") !== -1)
          return;
        console.error("error from endpoint", endpoint, json), alertUser(instance.t("genericError")), reject2(json.error);
        return;
      }
      resolve(json);
    });
  };
}
__name(handleError, "handleError");
function apiGet(endpoint) {
  return runningInQtWebEngine() ? call(JSON.stringify({
    method: "GET",
    endpoint
  })) : runningInAndroid() ? androidCall(JSON.stringify({
    method: "GET",
    endpoint
  })) : fetch(apiURL(endpoint), {
    method: "GET"
  }).then((response) => response.json()).then(handleError(endpoint));
}
__name(apiGet, "apiGet");
function apiPost(endpoint, body) {
  return runningInQtWebEngine() ? call(JSON.stringify({
    method: "POST",
    endpoint,
    body: JSON.stringify(body)
  })) : runningInAndroid() ? androidCall(JSON.stringify({
    method: "POST",
    endpoint,
    body: JSON.stringify(body)
  })) : fetch(apiURL(endpoint), {
    method: "POST",
    body: JSON.stringify(body)
  }).then((response) => response.json()).then(handleError(endpoint));
}
__name(apiPost, "apiPost");
let socket;
const currentListeners = [];
function webSubscribePushNotifications(msgCallback) {
  return currentListeners.push(msgCallback), socket || (socket = new WebSocket((isTLS() ? "wss://" : "ws://") + "localhost:" + apiPort + "/api/events"), socket.onopen = function() {
    socket && socket.send("Authorization: Basic " + apiToken);
  }, socket.onerror = function(event2) {
    console.error("websocket error", event2);
  }, socket.onmessage = function(event2) {
    const payload = JSON.parse(event2.data);
    currentListeners.forEach((listener) => listener(payload));
  }, socket.onclose = function() {
    currentListeners.forEach((listener) => listener({ subject: "backend/connected", action: "replace", object: !1 }));
  }), () => {
    currentListeners.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners.indexOf(msgCallback);
    currentListeners.splice(index, 1), currentListeners.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(webSubscribePushNotifications, "webSubscribePushNotifications");
function apiWebsocket(msgCallback) {
  return runningInQtWebEngine() ? qtSubscribePushNotifications(msgCallback) : runningInAndroid() ? androidSubscribePushNotifications(msgCallback) : webSubscribePushNotifications(msgCallback);
}
__name(apiWebsocket, "apiWebsocket");
const subscriptions$1 = {};
function handleEvent(payload) {
  if ("subject" in payload && typeof payload.subject == "string" && subscriptions$1[payload.subject])
    for (const observer of subscriptions$1[payload.subject])
      observer(payload);
}
__name(handleEvent, "handleEvent");
let subscribed = null;
function apiSubscribe(subject, observer) {
  subscribed || (subscribed = apiWebsocket(handleEvent));
  let observers = subscriptions$1[subject];
  return observers === void 0 && (observers = [], subscriptions$1[subject] = observers), observers.push(observer), () => {
    observers.includes(observer) || console.warn("!observers.includes(observer)");
    const index = observers.indexOf(observer);
    observers.splice(index, 1), observers.includes(observer) && console.warn("observers.includes(observer)");
  };
}
__name(apiSubscribe, "apiSubscribe");
function subscribeEndpoint(endpoint, cb2) {
  return apiSubscribe(endpoint, (event2) => {
    switch (event2.action) {
      case "replace":
        cb2(event2.object);
        break;
      case "reload":
        apiGet(event2.subject).then((object) => cb2(object)).catch(console.error);
        break;
      default:
        throw new Error(`Event: ${event2} not supported`);
    }
  });
}
__name(subscribeEndpoint, "subscribeEndpoint");
const backendConnected = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("backend/connected", cb2), "backendConnected"), getSupportedCoins = /* @__PURE__ */ __name(() => apiGet("supported-coins"), "getSupportedCoins"), setAccountActive = /* @__PURE__ */ __name((accountCode, active2) => apiPost("set-account-active", { accountCode, active: active2 }), "setAccountActive"), setTokenActive = /* @__PURE__ */ __name((accountCode, tokenCode, active2) => apiPost("set-token-active", { accountCode, tokenCode, active: active2 }), "setTokenActive"), renameAccount = /* @__PURE__ */ __name((accountCode, name) => apiPost("rename-account", { accountCode, name }), "renameAccount"), reinitializeAccounts = /* @__PURE__ */ __name(() => apiPost("accounts/reinitialize"), "reinitializeAccounts"), getTesting = /* @__PURE__ */ __name(() => apiGet("testing"), "getTesting"), getQRCode = /* @__PURE__ */ __name((data) => () => apiGet(`qr?data=${encodeURIComponent(data)}`), "getQRCode"), getDefaultConfig = /* @__PURE__ */ __name(() => apiGet("config/default"), "getDefaultConfig"), socksProxyCheck = /* @__PURE__ */ __name((proxyAddress) => apiPost("socksproxy/check", proxyAddress), "socksProxyCheck"), syncConnectKeystore = /* @__PURE__ */ __name(() => (cb2) => subscribeEndpoint("connect-keystore", (obj) => {
  cb2(obj);
}), "syncConnectKeystore"), cancelConnectKeystore = /* @__PURE__ */ __name(() => apiPost("cancel-connect-keystore"), "cancelConnectKeystore"), setWatchonly = /* @__PURE__ */ __name((rootFingerprint, watchonly) => apiPost("set-watchonly", { rootFingerprint, watchonly }), "setWatchonly"), authenticate = /* @__PURE__ */ __name((force = !1) => apiPost("authenticate", force), "authenticate"), forceAuth = /* @__PURE__ */ __name(() => apiPost("force-auth"), "forceAuth"), subscribeAuth = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("auth", cb2), "subscribeAuth"), onAuthSettingChanged = /* @__PURE__ */ __name(() => apiPost("on-auth-setting-changed"), "onAuthSettingChanged"), subscribeKeystores = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("keystores", cb2), "subscribeKeystores"), getKeystores = /* @__PURE__ */ __name(() => apiGet("keystores"), "getKeystores"), message$1 = "_message_ncb43_1", small$1 = "_small_ncb43_15", success$5 = "_success_ncb43_28 _message_ncb43_1", info$3 = "_info_ncb43_34 _message_ncb43_1", warning$4 = "_warning_ncb43_40 _message_ncb43_1", error$1 = "_error_ncb43_46 _message_ncb43_1", styles$p = {
  message: message$1,
  small: small$1,
  success: success$5,
  info: info$3,
  warning: warning$4,
  error: error$1
};
function Message({
  hidden,
  small: small2,
  type: type2 = "message",
  children: children2
}) {
  return hidden ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$p[type2]} ${small2 ? styles$p.small : ""}`, children: children2 });
}
__name(Message, "Message");
function getDisplayName(component) {
  return component.displayName || component.name || "Component";
}
__name(getDisplayName, "getDisplayName");
function share(store) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      componentDidMount() {
        store.subscribe(this);
      }
      componentWillUnmount() {
        store.unsubscribe(this);
      }
      render() {
        const props = this.props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...store.state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Share(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(share, "share");
const coins = "" + new URL("coins.svg", import.meta.url).href, info$2 = "" + new URL("info.svg", import.meta.url).href, settings = "" + new URL("settings-alt.svg", import.meta.url).href, settingsGrey = "" + new URL("settings-alt_disabled.svg", import.meta.url).href;
function findAccount(accounts, accountCode) {
  return accounts.find(({ code }) => accountCode === code);
}
__name(findAccount, "findAccount");
function getCryptoName(cryptoLabel, account2) {
  return account2 && isBitcoinOnly(account2.coinCode) ? "Bitcoin" : cryptoLabel;
}
__name(getCryptoName, "getCryptoName");
function isBitcoinOnly(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return !0;
    default:
      return !1;
  }
}
__name(isBitcoinOnly, "isBitcoinOnly");
const isBitcoinCoin = /* @__PURE__ */ __name((coin) => coin === "BTC" || coin === "TBTC" || coin === "sat" || coin === "tsat", "isBitcoinCoin");
function isBitcoinBased(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
    case "ltc":
    case "tltc":
      return !0;
    default:
      return !1;
  }
}
__name(isBitcoinBased, "isBitcoinBased");
function isEthereumBased(coinCode) {
  return coinCode === "eth" || coinCode === "goeth" || coinCode === "sepeth" || coinCode.startsWith("eth-erc20-");
}
__name(isEthereumBased, "isEthereumBased");
function getCoinCode(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return "btc";
    case "ltc":
    case "tltc":
      return "ltc";
    case "eth":
    case "goeth":
    case "sepeth":
      return "eth";
  }
}
__name(getCoinCode, "getCoinCode");
function getScriptName(scriptType) {
  switch (scriptType) {
    case "p2pkh":
      return "Legacy (P2PKH)";
    case "p2wpkh-p2sh":
      return "Wrapped Segwit (P2WPKH-P2SH)";
    case "p2wpkh":
      return "Native segwit (bech32, P2WPKH)";
    case "p2tr":
      return "Taproot (bech32m, P2TR)";
  }
}
__name(getScriptName, "getScriptName");
function customFeeUnit$1(coinCode) {
  return isBitcoinBased(coinCode) ? "sat/vB" : isEthereumBased(coinCode) ? "Gwei" : "";
}
__name(customFeeUnit$1, "customFeeUnit$1");
function getAccountsByKeystore(accounts) {
  return Object.values(accounts.reduce((acc, account2) => {
    const key = account2.keystore.rootFingerprint;
    return acc[key] || (acc[key] = {
      keystore: account2.keystore,
      accounts: []
    }), acc[key].accounts.push(account2), acc;
  }, {})).sort((ac1, ac2) => ac1.keystore.name.localeCompare(ac2.keystore.name));
}
__name(getAccountsByKeystore, "getAccountsByKeystore");
function isAmbiguiousName(name, accounts) {
  return accounts.filter((keystore) => keystore.keystore.name === name).length > 1;
}
__name(isAmbiguiousName, "isAmbiguiousName");
const getAccounts = /* @__PURE__ */ __name(() => apiGet("accounts"), "getAccounts"), getAccountsTotalBalance = /* @__PURE__ */ __name(() => apiGet("accounts/total-balance"), "getAccountsTotalBalance"), getEthAccountCodeAndNameByAddress = /* @__PURE__ */ __name((address2) => apiPost("accounts/eth-account-code", { address: address2 }), "getEthAccountCodeAndNameByAddress"), getStatus$2 = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/status`), "getStatus$2"), allScriptTypes = ["p2pkh", "p2wpkh-p2sh", "p2wpkh", "p2tr"], getInfo = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/info`), "getInfo"), init = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/init`), "init"), getSummary = /* @__PURE__ */ __name(() => apiGet("account-summary"), "getSummary"), getBalance = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/balance`), "getBalance"), postNotesTx = /* @__PURE__ */ __name((code, {
  internalTxID,
  note: note2
}) => apiPost(`account/${code}/notes/tx`, { internalTxID, note: note2 }), "postNotesTx"), proposeTxNote = /* @__PURE__ */ __name((code, note2) => apiPost(`account/${code}/propose-tx-note`, note2), "proposeTxNote"), getTransactionList = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/transactions`), "getTransactionList"), getTransaction = /* @__PURE__ */ __name((code, id2) => apiGet(`account/${code}/transaction?id=${id2}`), "getTransaction"), exportAccount = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/export`), "exportAccount"), verifyXPub = /* @__PURE__ */ __name((code, signingConfigIndex) => apiPost(`account/${code}/verify-extended-public-key`, { signingConfigIndex }), "verifyXPub"), getReceiveAddressList = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/receive-addresses`), "getReceiveAddressList"), sendTx = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/sendtx`), "sendTx"), getFeeTargetList = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/fee-targets`), "getFeeTargetList"), verifyAddress$1 = /* @__PURE__ */ __name((code, addressID) => apiPost(`account/${code}/verify-address`, addressID), "verifyAddress$1"), getUTXOs = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/utxos`), "getUTXOs"), hasSecureOutput = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/has-secure-output`), "hasSecureOutput"), addAccount = /* @__PURE__ */ __name((coinCode, name) => apiPost("account-add", {
  coinCode,
  name
}), "addAccount"), testRegister = /* @__PURE__ */ __name((pin) => apiPost("test/register", { pin }), "testRegister"), connectKeystore = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/connect-keystore`), "connectKeystore"), ethSignMessage = /* @__PURE__ */ __name((code, message2) => apiPost(`account/${code}/eth-sign-msg`, message2), "ethSignMessage"), ethSignTypedMessage = /* @__PURE__ */ __name((code, chainId, data) => apiPost(`account/${code}/eth-sign-typed-msg`, { chainId, data }), "ethSignTypedMessage"), ethSignWalletConnectTx = /* @__PURE__ */ __name((code, send2, chainId, tx) => apiPost(`account/${code}/eth-sign-wallet-connect-tx`, { send: send2, chainId, tx }), "ethSignWalletConnectTx"), capsWarning = "_capsWarning_1xqma_1", style$V = {
  capsWarning
};
function PasswordInput(props) {
  const { seePlaintext, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: seePlaintext ? "text" : "password",
      ...rest
    }
  );
}
__name(PasswordInput, "PasswordInput");
const _PasswordSingleInputClass = class _PasswordSingleInputClass extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: "",
      seePlaintext: !1,
      capsLock: !1
    });
    __publicField(this, "password", reactExports.createRef());
    __publicField(this, "idPrefix", /* @__PURE__ */ __name(() => this.props.idPrefix || "", "idPrefix"));
    __publicField(this, "tryPaste", /* @__PURE__ */ __name((event2) => {
      event2.target.type === "password" && (event2.preventDefault(), alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      })));
    }, "tryPaste"));
    __publicField(this, "clear", /* @__PURE__ */ __name(() => {
      this.setState({
        password: "",
        seePlaintext: !1,
        capsLock: !1
      });
    }, "clear"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => {
      if (this.regex && this.password.current && !this.password.current.validity.valid)
        return this.props.onValidPassword(null);
      this.state.password ? this.props.onValidPassword(this.state.password) : this.props.onValidPassword(null);
    }, "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      let value = event2.target.value;
      event2.target.type === "checkbox" && (value = event2.target.checked);
      const stateKey = event2.target.id.slice(this.idPrefix().length);
      this.setState({ [stateKey]: value }, this.validate);
    }, "handleFormChange"));
    __publicField(this, "handleCheckCaps", /* @__PURE__ */ __name((event2) => {
      const capsLock = hasCaps(event2);
      capsLock !== null && this.setState({ capsLock });
    }, "handleCheckCaps"));
  }
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a46;
    this.props.pattern && (this.regex = new RegExp(this.props.pattern)), this.props.autoFocus && ((_a46 = this.password) != null && _a46.current) && this.password.current.focus();
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      showLabel
    } = this.props, {
      password: password2,
      seePlaintext,
      capsLock
    } = this.state, warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$V.capsWarning,
        title: t2("password.warning.caps"),
        children: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        autoFocus: !0,
        disabled: disabled2,
        type: seePlaintext ? "text" : "password",
        pattern,
        title: title2,
        id: this.idPrefix() + "password",
        label: label2,
        placeholder,
        onInput: this.handleFormChange,
        onPaste: this.tryPaste,
        ref: this.password,
        value: password2,
        labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: this.idPrefix() + "seePlaintext",
            onChange: this.handleFormChange,
            checked: seePlaintext,
            label: t2("password.show", {
              label: showLabel || label2
            })
          }
        ),
        children: warning2
      }
    );
  }
};
__name(_PasswordSingleInputClass, "PasswordSingleInputClass");
let PasswordSingleInputClass = _PasswordSingleInputClass;
const PasswordSingleInput = withTranslation(null, { withRef: !0 })(PasswordSingleInputClass), _PasswordRepeatInputClass = class _PasswordRepeatInputClass extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: "",
      passwordRepeat: "",
      seePlaintext: !1,
      capsLock: !1
    });
    __publicField(this, "password", reactExports.createRef());
    __publicField(this, "passwordRepeat", reactExports.createRef());
    __publicField(this, "idPrefix", /* @__PURE__ */ __name(() => this.props.idPrefix || "", "idPrefix"));
    __publicField(this, "tryPaste", /* @__PURE__ */ __name((event2) => {
      event2.target.type === "password" && (event2.preventDefault(), alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      })));
    }, "tryPaste"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => {
      if (this.regex && this.password.current && this.passwordRepeat.current && (!this.password.current.validity.valid || !this.passwordRepeat.current.validity.valid))
        return this.props.onValidPassword(null);
      this.state.password && this.state.password === this.state.passwordRepeat ? this.props.onValidPassword(this.state.password) : this.props.onValidPassword(null);
    }, "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      let value = event2.target.value;
      event2.target.type === "checkbox" && (value = event2.target.checked);
      const stateKey = event2.target.id.slice(this.idPrefix().length);
      this.setState({ [stateKey]: value }, this.validate);
    }, "handleFormChange"));
    __publicField(this, "handleCheckCaps", /* @__PURE__ */ __name((event2) => {
      const capsLock = hasCaps(event2);
      capsLock != null && this.setState({ capsLock });
    }, "handleCheckCaps"));
  }
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a46;
    this.props.pattern && (this.regex = new RegExp(this.props.pattern)), this.props.autoFocus && ((_a46 = this.password) != null && _a46.current) && this.password.current.focus();
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      repeatLabel,
      repeatPlaceholder,
      showLabel
    } = this.props, {
      password: password2,
      passwordRepeat,
      seePlaintext,
      capsLock
    } = this.state, warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$V.capsWarning,
        title: t2("password.warning.caps"),
        children: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          autoFocus: !0,
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "password",
          label: label2,
          placeholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: password2,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: password2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "passwordRepeat",
          label: repeatLabel,
          placeholder: repeatPlaceholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: passwordRepeat,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: passwordRepeat
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          id: this.idPrefix() + "seePlaintext",
          onChange: this.handleFormChange,
          checked: seePlaintext,
          label: t2("password.show", {
            label: showLabel || label2
          })
        }
      ) })
    ] });
  }
};
__name(_PasswordRepeatInputClass, "PasswordRepeatInputClass");
let PasswordRepeatInputClass = _PasswordRepeatInputClass;
const PasswordRepeatInput = withTranslation(null, { withRef: !0 })(PasswordRepeatInputClass);
function MatchesPattern({ regex, value = "", text: text2 }) {
  return !regex || !value.length || regex.test(value) ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--color-error)" }, children: text2 });
}
__name(MatchesPattern, "MatchesPattern");
const excludeKeys = /^(Shift|Alt|Backspace|CapsLock|Tab)$/i;
function hasCaps({ key }) {
  return key.length > 1 || key.toUpperCase() === key.toLowerCase() || excludeKeys.test(key) ? null : key.toUpperCase() === key && key.toLowerCase() !== key && !event.shiftKey;
}
__name(hasCaps, "hasCaps");
const SkipForTesting = /* @__PURE__ */ __name(() => {
  const [dialog2, setDialog] = reactExports.useState(!1), show2 = useLoad(() => Promise.resolve(!1)), [testPIN, setTestPIN] = reactExports.useState(""), registerTestingDevice = /* @__PURE__ */ __name(async (e2) => {
    e2.preventDefault(), await testRegister(testPIN), setDialog(!1);
  }, "registerTestingDevice");
  if (!show2)
    return null;
  const title2 = "Unlock software keystore";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setDialog(!0), children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: dialog2, title: title2, onClose: () => setDialog(!1), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: registerTestingDevice, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordSingleInput,
        {
          type: "password",
          autoFocus: !0,
          label: "Test Password",
          onValidPassword: setTestPIN,
          value: testPIN
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: "Unlock" }) })
    ] }) })
  ] });
}, "SkipForTesting"), _Store = class _Store {
  /**
     * Creates a new store with the given initial state.
     */
  /* eslint no-useless-constructor: "off" */
  constructor(state) {
    this.state = state, this.components = [];
  }
  /**
     * This method should only be called by the Share HOC.
     */
  subscribe(component) {
    this.components.push(component);
  }
  /**
     * This method should only be called by the Share HOC.
     */
  unsubscribe(component) {
    const index = this.components.indexOf(component);
    this.components.splice(index, 1);
  }
  updateComponents() {
    for (const component of this.components)
      component.forceUpdate();
  }
  /**
     * Sets the state of this store and updates the subscribed components.
     * Please note that you are allowed to pass a partial state just as in React.
     */
  setState(partialState) {
    Object.assign(this.state, partialState), this.updateComponents();
  }
};
__name(_Store, "Store");
let Store = _Store;
const badge$3 = "_badge_f2nw5_1", iconOnly = "_iconOnly_f2nw5_11", badgeIcon = "_badgeIcon_f2nw5_20", withChildren = "_withChildren_f2nw5_24", success$4 = "_success_f2nw5_34", warning$3 = "_warning_f2nw5_40", style$U = {
  badge: badge$3,
  iconOnly,
  badgeIcon,
  withChildren,
  success: success$4,
  warning: warning$3
}, Badge = /* @__PURE__ */ __name(({
  children: children2,
  className,
  icon: icon2,
  type: type2 = "success",
  ...props
}) => {
  const withChildrenStyle = children2 !== void 0 ? style$U.withChildren : "", iconOnlyStyle = children2 === void 0 && icon2 ? style$U.iconOnly : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$U.badge} ${style$U[type2]} ${withChildrenStyle} ${iconOnlyStyle} ${className || ""}`,
      ...props,
      children: [
        icon2 && icon2({ className: style$U.badgeIcon }),
        children2
      ]
    }
  );
}, "Badge"), closeButton$1 = "_closeButton_1xwfn_1", sidebarOverlay = "_sidebarOverlay_1xwfn_13", active$3 = "_active_1xwfn_26", sidebar = "_sidebar_1xwfn_13", end = "_end_1xwfn_47", forceShow = "_forceShow_1xwfn_52", sidebarLogoContainer = "_sidebarLogoContainer_1xwfn_56", sidebarHeaderContainer = "_sidebarHeaderContainer_1xwfn_75", sidebarPortfolio = "_sidebarPortfolio_1xwfn_85", sidebarHeader = "_sidebarHeader_1xwfn_75", sidebarIconVisible = "_sidebarIconVisible_1xwfn_95", sidebarIconHidden = "_sidebarIconHidden_1xwfn_99", sidebarItem = "_sidebarItem_1xwfn_103", sidebarArrow = "_sidebarArrow_1xwfn_121", sidebarActive = "_sidebarActive_1xwfn_125", activeGroup = "_activeGroup_1xwfn_130", single = "_single_1xwfn_136", sidebarLabel = "_sidebarLabel_1xwfn_141", sidebarSubmenu = "_sidebarSubmenu_1xwfn_197", sidebarContainer = "_sidebarContainer_1xwfn_216", forceHide = "_forceHide_1xwfn_216", style$T = {
  closeButton: closeButton$1,
  sidebarOverlay,
  active: active$3,
  sidebar,
  end,
  forceShow,
  sidebarLogoContainer,
  sidebarHeaderContainer,
  sidebarPortfolio,
  sidebarHeader,
  sidebarIconVisible,
  sidebarIconHidden,
  sidebarItem,
  sidebarArrow,
  sidebarActive,
  activeGroup,
  single,
  sidebarLabel,
  sidebarSubmenu,
  sidebarContainer,
  forceHide
}, panelStore = new Store({
  activeSidebar: !1,
  sidebarStatus: ""
}), toggleSidebar = /* @__PURE__ */ __name(() => {
  const toggled = !panelStore.state.activeSidebar;
  panelStore.setState({ activeSidebar: toggled });
}, "toggleSidebar"), setSidebarStatus = /* @__PURE__ */ __name((status2) => {
  panelStore.setState({ sidebarStatus: status2 });
}, "setSidebarStatus"), GetAccountLink = /* @__PURE__ */ __name(({
  coinCode,
  code,
  name,
  handleSidebarItemClick
}) => {
  const { pathname } = useLocation(), active2 = pathname === `/account/${code}` || pathname.startsWith(`/account/${code}/`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Link,
    {
      className: active2 ? style$T.sidebarActive : "",
      to: `/account/${code}`,
      onClick: handleSidebarItemClick,
      title: name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: !0, coinCode, alt: name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: name })
      ]
    }
  ) }, code);
}, "GetAccountLink"), Sidebar = /* @__PURE__ */ __name(({
  deviceIDs,
  accounts,
  activeSidebar,
  sidebarStatus
  // from share HOC
}) => {
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    const swipe = {
      active: !1,
      x: 0,
      y: 0
    }, handleTouchStart = /* @__PURE__ */ __name((event2) => {
      const touch = event2.touches[0];
      swipe.x = touch.clientX, swipe.y = touch.clientY;
    }, "handleTouchStart"), handleTouchMove = /* @__PURE__ */ __name((event2) => {
      sidebarStatus !== "forceHidden" && event2.changedTouches && event2.changedTouches.length && (swipe.active = !0);
    }, "handleTouchMove"), handleTouchEnd = /* @__PURE__ */ __name((event2) => {
      if (sidebarStatus !== "forceHidden") {
        const touch = event2.changedTouches[0], travelX = Math.abs(touch.clientX - swipe.x), travelY = Math.abs(touch.clientY - swipe.y), validSwipe = window.innerWidth <= 901 && swipe.active && travelY < 100 && travelX > 70;
        (!panelStore.state.activeSidebar && validSwipe && swipe.x < 60 || panelStore.state.activeSidebar && validSwipe && swipe.x > 230) && toggleSidebar(), swipe.x = 0, swipe.y = 0, swipe.active = !1;
      }
    }, "handleTouchEnd");
    return document.addEventListener("touchstart", handleTouchStart), document.addEventListener("touchmove", handleTouchMove), document.addEventListener("touchend", handleTouchEnd), () => {
      document.removeEventListener("touchstart", handleTouchStart), document.removeEventListener("touchmove", handleTouchMove), document.removeEventListener("touchend", handleTouchEnd);
    };
  }, [sidebarStatus]);
  const [keystores, setKeystores] = reactExports.useState();
  reactExports.useEffect(() => (getKeystores().then((keystores2) => {
    setKeystores(keystores2);
  }), subscribeKeystores(setKeystores)), []);
  const handleSidebarItemClick = /* @__PURE__ */ __name((event2) => {
    event2.target.closest("a").classList.contains("sidebarActive") && window.innerWidth <= 901 && toggleSidebar();
  }, "handleSidebarItemClick"), hidden = sidebarStatus === "forceHidden", hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode)), accountsByKeystore = getAccountsByKeystore(accounts);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$T.sidebarContainer, hidden ? style$T.forceHide : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$T.sidebarOverlay, activeSidebar ? style$T.active : ""].join(" "), onClick: toggleSidebar }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: [style$T.sidebar, activeSidebar ? style$T.forceShow : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$T.sidebarLogoContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: accounts.length ? "/account-summary" : "/",
            onClick: handleSidebarItemClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, { className: style$T.sidebarLogo })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$T.closeButton, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {}) })
      ] }),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$T.sidebarItem} ${style$T.sidebarPortfolio}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/account-summary",
          title: t2("accountSummary.title"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: info$2 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: t2("accountSummary.title") })
          ]
        }
      ) }) : null,
      accountsByKeystore.map((keystore) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarHeaderContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: style$T.sidebarHeader,
            hidden: !keystore.accounts.length,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                `${keystore.keystore.name} `,
                isAmbiguiousName(keystore.keystore.name, accountsByKeystore) ? (
                  // Disambiguate accounts group by adding the fingerprint.
                  // The most common case where this would happen is when adding accounts from the
                  // same seed using different passphrases.
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    " (",
                    keystore.keystore.rootFingerprint,
                    ")"
                  ] })
                ) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Badge,
                {
                  className: keystore.keystore.connected ? style$T.sidebarIconVisible : style$T.sidebarIconHidden,
                  icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                  type: "success",
                  title: t2("device.keystoreConnected")
                }
              )
            ]
          }
        ) }),
        keystore.accounts.map((acc) => /* @__PURE__ */ jsxRuntimeExports.jsx(GetAccountLink, { ...acc, handleSidebarItemClick }, acc.code))
      ] }, keystore.keystore.rootFingerprint)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$T.sidebarHeaderContainer, style$T.end].join(" ") }),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/buy/info",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: coins }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: hasOnlyBTCAccounts ? t2("accountInfo.buyCTA.buy", { unit: "Bitcoin" }) : t2("sidebar.buy") })
          ]
        }
      ) }, "buy") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/settings",
          title: t2("sidebar.settings"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: settingsGrey, alt: t2("sidebar.settings") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: settings, alt: t2("sidebar.settings") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: t2("sidebar.settings") })
          ]
        }
      ) }, "settings-new"),
      !keystores || keystores.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {}) : null,
      debug
    ] })
  ] });
}, "Sidebar"), guideShareHOC = share(panelStore)(Sidebar), AppContext = reactExports.createContext({}), children$1 = "_children_1y42x_1", container$n = "_container_1y42x_22", fixed = "_fixed_1y42x_26", disabled$2 = "_disabled_1y42x_34", forceHidden = "_forceHidden_1y42x_38", sidebarToggler = "_sidebarToggler_1y42x_38", guideIcon = "_guideIcon_1y42x_42", guideIconContainer = "_guideIconContainer_1y42x_57", header$6 = "_header_1y42x_62", narrow = "_narrow_1y42x_76", title$7 = "_title_1y42x_99", hideSidebarToggler = "_hideSidebarToggler_1y42x_120", style$S = {
  children: children$1,
  container: container$n,
  fixed,
  disabled: disabled$2,
  forceHidden,
  sidebarToggler,
  guideIcon,
  guideIconContainer,
  header: header$6,
  narrow,
  title: title$7,
  hideSidebarToggler
}, Header = /* @__PURE__ */ __name(({
  sidebarStatus,
  narrow: narrow2,
  title: title2,
  hideSidebarToggler: hideSidebarToggler2,
  children: children2
}) => {
  const { t: t2 } = useTranslation(), { guideShown, guideExists, toggleGuide } = reactExports.useContext(AppContext), toggle2 = /* @__PURE__ */ __name((e2) => (e2.preventDefault(), guideShown || toggleGuide(), !1), "toggle");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.container, sidebarStatus ? style$S[sidebarStatus] : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.header, narrow2 ? style$S.narrow : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$S.sidebarToggler} ${hideSidebarToggler2 ? style$S.hideSidebarToggler : ""}`, onClick: toggleSidebar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, { className: "show-in-lightmode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuLight, { className: "show-in-darkmode" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.title, children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.children, children: [
      children2,
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$S.guideIconContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", onClick: toggle2, className: [style$S.guideIcon, guideShown ? style$S.disabled : ""].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GuideActive, {}),
        t2("guide.toggle.open")
      ] }) })
    ] })
  ] }) });
}, "Header"), SharedHeader = share(panelStore)(Header), main$1 = "_main_1ntet_1", style$R = {
  main: main$1
}, Main = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: style$R.main, children: children2 }), "Main"), columnAsCard = "_columnAsCard_1rob5_1", column$2 = "_column_1rob5_1", columnButtons = "_columnButtons_1rob5_10", columnButtonsInline = "_columnButtonsInline_1rob5_10", left$1 = "_left_1rob5_29", center = "_center_1rob5_33", grid = "_grid_1rob5_47", style$Q = {
  columnAsCard,
  column: column$2,
  columnButtons,
  columnButtonsInline,
  left: left$1,
  center,
  grid,
  "grid-columns-1": "_grid-columns-1_1rob5_53",
  "grid-columns-2": "_grid-columns-2_1rob5_56"
}, Grid = /* @__PURE__ */ __name(({
  children: children2,
  col = "2",
  textAlign
}) => {
  const styles2 = `
    ${style$Q.grid}
    ${style$Q[`grid-columns-${col}`]}
    ${textAlign !== void 0 ? style$Q[textAlign] : ""}
  `;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: styles2, children: children2 });
}, "Grid"), Column = /* @__PURE__ */ __name(({
  asCard,
  children: children2,
  className
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$Q.column} ${asCard ? style$Q.columnAsCard : ""} ${className || ""}`, children: children2 }), "Column"), ColumnButtons = /* @__PURE__ */ __name(({
  children: children2,
  className = "",
  inline
}) => {
  const classNames2 = `${style$Q.columnButtons} ${inline ? style$Q.columnButtonsInline : ""} ${className}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
}, "ColumnButtons"), footer = "_footer_19w3c_1", style$P = {
  footer
};
function Footer({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: [style$P.footer, "flex flex-row flex-items-center flex-end"].join(" "), children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
  ] });
}
__name(Footer, "Footer");
const contentWithGuide = "_contentWithGuide_1gscs_1", container$m = "_container_1gscs_8", styles$o = {
  contentWithGuide,
  container: container$m
}, GuideWrapper = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.contentWithGuide, children: children2 }), "GuideWrapper"), GuidedContent = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.container, children: children2 }), "GuidedContent"), steps = "_steps_1l429_6", step = "_step_1l429_6", dot = "_dot_1l429_38", line$1 = "_line_1l429_72", finish = "_finish_1l429_76", wait = "_wait_1l429_81", process$1 = "_process_1l429_97", content$3 = "_content_1l429_110", style$O = {
  steps,
  step,
  dot,
  line: line$1,
  finish,
  wait,
  process: process$1,
  content: content$3
}, Steps = /* @__PURE__ */ __name(({
  current,
  children: children2
}) => {
  let childrens = React.Children.toArray(children2).filter(React.isValidElement);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.steps, children: childrens.filter((child) => !child.props.hidden).map((child, step2) => {
    if (!child)
      return null;
    const status2 = step2 === current ? "process" : step2 < current ? "finish" : "wait", line2 = step2 > 0;
    return reactExports.cloneElement(child, {
      step: step2 + 1,
      line: line2,
      status: status2
    });
  }) });
}, "Steps");
function Step({
  children: children2,
  hidden = !1,
  line: line2,
  status: status2 = "wait"
}) {
  return hidden ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$O.step} ${style$O[status2]} ${line2 ? style$O.line : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.dot }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.content, children: children2 })
  ] });
}
__name(Step, "Step");
const CoinDropDown = /* @__PURE__ */ __name(({
  onChange: onChange2,
  supportedCoins,
  value
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select$1,
    {
      autoFocus: !0,
      options: [
        {
          text: t2("buy.info.selectPlaceholder"),
          disabled: !0,
          value: "choose"
        },
        ...supportedCoins.map(({ coinCode, name, canAddAccount }) => ({
          value: coinCode,
          text: name,
          disabled: !canAddAccount
        }))
      ],
      onInput: (e2) => onChange2(supportedCoins.find((c2) => c2.coinCode === e2.target.value)),
      value,
      id: "coinCodeDropDown"
    }
  );
}, "CoinDropDown"), notifyUser = /* @__PURE__ */ __name((text2) => apiPost("notify-user", { text: text2 }), "notifyUser"), open = /* @__PURE__ */ __name((href) => apiPost("open", href), "open"), link$3 = "_link_1o1mh_1", style$N = {
  link: link$3
}, A$3 = /* @__PURE__ */ __name(({
  href,
  icon: icon2,
  className,
  children: children2,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "span",
  {
    className: `${style$N.link} ${className || ""}`,
    title: props.title || href,
    onClick: (e2) => {
      e2.preventDefault(), open(href).catch(console.error);
    },
    tabIndex: 0,
    ...props,
    children: [
      icon2 || null,
      children2
    ]
  }
), "A$3"), overlay$2 = "_overlay_14an4_1", close$2 = "_close_14an4_13", wrapper = "_wrapper_14an4_29", guide = "_guide_14an4_33", header$5 = "_header_14an4_44", content$2 = "_content_14an4_62", show = "_show_14an4_83", entry$1 = "_entry_14an4_87", entryTitle = "_entryTitle_14an4_91", entryToggle = "_entryToggle_14an4_99", entryTitleText = "_entryTitleText_14an4_109", entryContent = "_entryContent_14an4_113", expanded = "_expanded_14an4_121", link$2 = "_link_14an4_125", guideWrapper = "_guideWrapper_14an4_135", style$M = {
  overlay: overlay$2,
  close: close$2,
  wrapper,
  guide,
  header: header$5,
  content: content$2,
  show,
  entry: entry$1,
  entryTitle,
  entryToggle,
  entryTitleText,
  entryContent,
  expanded,
  link: link$2,
  guideWrapper
}, Entry = /* @__PURE__ */ __name((props) => {
  const [shown, setShown] = reactExports.useState(props.shown || !1), toggle2 = /* @__PURE__ */ __name(() => {
    setShown((shown2) => !shown2);
  }, "toggle"), entry2 = props.entry;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entry, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entryTitle, onClick: toggle2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$M.entryToggle, children: shown ? "" : "+" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$M.entryTitleText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: entry2.title }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$M.entryContent, shown ? style$M.expanded : ""].join(" "), children: shown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      entry2.text.trim().split(`
`).map((p2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: p2 }, idx)),
      entry2.link && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        A$3,
        {
          className: style$M.link,
          "data-testid": "link",
          href: entry2.link.url,
          children: entry2.link.text
        }
      ) }),
      props.children
    ] }) : null })
  ] });
}, "Entry"), Guide = /* @__PURE__ */ __name(({ children: children2 }) => {
  const { guideShown, toggleGuide, setGuideExists } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => (setGuideExists(!0), () => {
    setGuideExists(!1);
  }), [setGuideExists]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$M.overlay, guideShown && style$M.show].join(" "), onClick: toggleGuide }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$M.guide, guideShown && style$M.show].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$M.header, "flex flex-row flex-between flex-items-center"].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("guide.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: style$M.close, onClick: toggleGuide, children: [
          t2("guide.toggle.close"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.content, children: [
        children2,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entry, children: [
          t2("guide.appendix.text"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { className: style$M.link, href: "https://bitbox.swiss/support/", children: t2("guide.appendix.link") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
        ] })
      ] })
    ] })
  ] });
}, "Guide"), AddAccountGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
}, "AddAccountGuide");
let navigate;
const route = /* @__PURE__ */ __name((route2, replace2) => {
  navigate == null || navigate(route2, { replace: replace2 });
}, "route"), RouterWatcher = /* @__PURE__ */ __name(({ onChange: onChange2 }) => {
  navigate = useNavigate();
  const { pathname } = useLocation();
  return reactExports.useEffect(() => {
    onChange2();
  }, [onChange2, pathname]), null;
}, "RouterWatcher"), manageContainer = "_manageContainer_1n5md_1", title$6 = "_title_1n5md_9", successCheck = "_successCheck_1n5md_14", successMessage = "_successMessage_1n5md_20", styles$n = {
  manageContainer,
  title: title$6,
  successCheck,
  successMessage
}, AddAccount = /* @__PURE__ */ __name(() => {
  const [accountCode, setAccountCode] = reactExports.useState(), [accountName2, setAccountName] = reactExports.useState(""), [coinCode, setCoinCode] = reactExports.useState("choose"), [errorMessage, setErrorMessage] = reactExports.useState(), [step2, setStep] = reactExports.useState("select-coin"), [supportedCoins, setSupportedCoins] = reactExports.useState([]), [adding, setAdding] = reactExports.useState(!1), inputRef = reactExports.useRef(null), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    var _a46;
    step2 === "choose-name" && ((_a46 = inputRef.current) == null || _a46.focus());
  }, [step2]);
  const onlyOneSupportedCoin = /* @__PURE__ */ __name(() => supportedCoins.length === 1, "onlyOneSupportedCoin"), startProcess = reactExports.useCallback(async () => {
    var _a46;
    try {
      const coins2 = await getSupportedCoins(), onlyOneCoinIsSupported = coins2.length === 1;
      setCoinCode(onlyOneCoinIsSupported ? coins2[0].coinCode : "choose"), setStep(onlyOneCoinIsSupported ? "choose-name" : "select-coin"), setSupportedCoins(coins2), onlyOneCoinIsSupported && setAccountCode(coins2[0].suggestedAccountName), (_a46 = inputRef.current) == null || _a46.focus();
    } catch (err) {
      console.error(err);
    }
  }, []);
  reactExports.useEffect(() => (startProcess(), subscribeKeystores(() => {
    startProcess();
  })), [startProcess]);
  const back = /* @__PURE__ */ __name(() => {
    switch (step2) {
      case "select-coin":
        route("/settings/manage-accounts");
        break;
      case "choose-name":
        setStep("select-coin"), setErrorMessage(void 0);
        break;
      case "success":
        setStep("choose-name");
        break;
    }
  }, "back"), next2 = /* @__PURE__ */ __name(async (e2) => {
    switch (e2.preventDefault(), step2) {
      case "select-coin":
        setStep("choose-name");
        break;
      case "choose-name":
        setAdding(!0);
        const responseData = await addAccount(coinCode, accountName2);
        setAdding(!1), responseData.success ? (setAccountCode(responseData.accountCode), setErrorMessage(void 0), setStep("success")) : responseData.errorCode ? setErrorMessage(t2(`error.${responseData.errorCode}`)) : responseData.errorMessage && setErrorMessage(t2("unknownError", { errorMessage: responseData.errorMessage }));
        break;
      case "success":
        accountCode && route(`/account/${accountCode}`);
        break;
    }
  }, "next"), renderContent = /* @__PURE__ */ __name(() => {
    switch (step2) {
      case "select-coin":
        return supportedCoins.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("connectKeystore.promptNoName") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          CoinDropDown,
          {
            onChange: (coin) => {
              setCoinCode(coin.coinCode), setAccountName(coin.suggestedAccountName);
            },
            supportedCoins,
            value: coinCode
          }
        );
      case "choose-name":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            autoFocus: !0,
            ref: inputRef,
            id: "accountName",
            onInput: (e2) => setAccountName(e2.target.value),
            value: accountName2
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { className: styles$n.successCheck }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleMarkup,
            {
              className: styles$n.successMessage,
              markup: t2("addAccount.success.message", { accountName: accountName2 }),
              tagName: "p"
            }
          )
        ] });
    }
  }, "renderContent"), getTextFor = /* @__PURE__ */ __name((step22) => {
    switch (step22) {
      case "select-coin":
        return {
          titleText: t2("addAccount.selectCoin.title"),
          nextButtonText: t2("addAccount.selectCoin.nextButton")
        };
      case "choose-name":
        return {
          titleText: t2("addAccount.chooseName.title"),
          nextButtonText: t2("addAccount.chooseName.nextButton")
        };
      case "success":
        return {
          titleText: t2("addAccount.success.title"),
          nextButtonText: t2("addAccount.success.nextButton")
        };
    }
  }, "getTextFor"), handleAddAnotherAccount = /* @__PURE__ */ __name(async () => {
    setAccountCode(void 0), setAccountName(""), setCoinCode("choose"), setErrorMessage(void 0), setStep("select-coin"), await startProcess();
  }, "handleAddAnotherAccount"), currentStep = [
    ...onlyOneSupportedCoin() ? [] : ["select-coin"],
    "choose-name",
    "success"
  ].indexOf(step2), { titleText, nextButtonText } = getTextFor(step2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("manageAccounts.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content larger isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: `${styles$n.manageContainer} box larger flex flex-column flex-between`,
          onSubmit: next2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              t2("addAccount.title"),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$n.title, children: titleText })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", hidden: !errorMessage, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: errorMessage }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: renderContent() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Steps, { current: currentStep, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { hidden: onlyOneSupportedCoin(), children: t2("addAccount.selectCoin.step") }, "select-coin"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.chooseName.step") }, "choose-name"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.success.step") }, "success")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row flex flex-row flex-between m-bottom", style: { flexDirection: "row-reverse" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: step2 === "select-coin" && coinCode === "choose" || step2 === "choose-name" && (accountName2 === "" || adding),
                  primary: !0,
                  type: "submit",
                  children: nextButtonText
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: back,
                  hidden: step2 === "success",
                  secondary: !0,
                  children: t2("button.back")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleAddAnotherAccount,
                  hidden: step2 !== "success",
                  secondary: !0,
                  children: t2("addAccount.success.addAnotherAccount")
                }
              )
            ] })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccountGuide, {})
  ] });
}, "AddAccount"), getExchangesByRegion = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/by-region/${code}`), "getExchangesByRegion"), getExchangeDeals = /* @__PURE__ */ __name(() => apiGet("exchange/deals"), "getExchangeDeals"), getMoonpayBuyInfo = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/moonpay/buy-info/${code}`), "getMoonpayBuyInfo"), signAddress = /* @__PURE__ */ __name((format, msg, accountCode) => apiPost("exchange/pocket/sign-address", { format, msg, accountCode }), "signAddress"), verifyAddress = /* @__PURE__ */ __name((address2, accountCode) => apiPost("exchange/pocket/verify-address", { address: address2, accountCode }), "verifyAddress"), getPocketURL = /* @__PURE__ */ __name(() => apiGet("exchange/pocket/api-url"), "getPocketURL"), getExchangeBuySupported = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/buy-supported/${code}`), "getExchangeBuySupported");
function BuyGuide({ name, exchange }) {
  const { t: t2 } = useTranslation(), pocketLink = {
    text: t2("buy.pocket.data.link"),
    url: "https://pocketbitcoin.com/policy/privacy"
  }, moonpayLink = {
    text: t2("buy.info.disclaimer.privacyPolicy"),
    url: "https://www.moonpay.com/privacy_policy"
  }, privacyLink = exchange === "pocket" ? pocketLink : moonpayLink;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("buy.info.disclaimer.security.link"),
        url: "https://bitbox.swiss/bitbox02/threat-model/"
      },
      text: t2("buy.info.disclaimer.security.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.security.title")
    }, shown: !0 }, "guide.buy.security"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: exchange ? privacyLink : void 0,
      text: t2("buy.info.disclaimer.protection.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.protection.title")
    } }, "guide.buy.protection")
  ] });
}
__name(BuyGuide, "BuyGuide");
const spinnerContainer$2 = "_spinnerContainer_rthjr_1", spinner$2 = "_spinner_rthjr_1", spinnerText = "_spinnerText_rthjr_24", spinner1 = "_spinner1_rthjr_1", spinner2 = "_spinner2_rthjr_1", spinner3 = "_spinner3_rthjr_1", horizontallyCentered = "_horizontallyCentered_rthjr_59", overlay$1 = "_overlay_rthjr_81", fadein = "_fadein_rthjr_1", togglersContainer = "_togglersContainer_rthjr_98", guideToggler = "_guideToggler_rthjr_111", toggler = "_toggler_rthjr_98", togglerContainer = "_togglerContainer_rthjr_145", style$L = {
  spinnerContainer: spinnerContainer$2,
  spinner: spinner$2,
  spinnerText,
  spinner1,
  spinner2,
  spinner3,
  horizontallyCentered,
  overlay: overlay$1,
  fadein,
  togglersContainer,
  guideToggler,
  toggler,
  togglerContainer
}, SpinnerAnimation = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.spinner, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
] }), "SpinnerAnimation"), HorizontallyCenteredSpinner = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.horizontallyCentered, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }), "HorizontallyCenteredSpinner"), Spinner = /* @__PURE__ */ __name(({ text: text2, guideExists }) => {
  const { t: t2 } = useTranslation(), { toggleGuide } = reactExports.useContext(AppContext), handleKeyDown = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), document.activeElement.blur();
  }, "handleKeyDown");
  return reactExports.useEffect(() => (document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown)), []), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.spinnerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.togglersContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.togglerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.toggler, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, {}) }) }),
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.guideToggler, onClick: toggleGuide, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "4.93", x2: "9.17", y2: "9.17" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "14.83", x2: "19.07", y2: "19.07" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "19.07", y2: "4.93" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "18.36", y2: "5.64" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "19.07", x2: "9.17", y2: "14.83" })
            ]
          }
        ),
        t2("guide.toggle.open")
      ] })
    ] }),
    text2 && text2.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$L.spinnerText, children: line2 }, `${line2}-${i}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.overlay })
  ] });
}, "Spinner"), disclaimerContainer = "_disclaimerContainer_5gxwf_1", title$5 = "_title_5gxwf_15", disclaimer = "_disclaimer_5gxwf_1", table$1 = "_table_5gxwf_52", nowrap = "_nowrap_5gxwf_77", style$K = {
  disclaimerContainer,
  title: title$5,
  disclaimer,
  table: table$1,
  nowrap
}, MoonpayTerms = /* @__PURE__ */ __name(({ account: account2, onAgreedTerms }) => {
  const { t: t2 } = useTranslation(), name = getCryptoName(t2("buy.info.crypto"), account2), handleSkipDisclaimer = /* @__PURE__ */ __name((e2) => {
    setConfig({ frontend: { skipMoonpayDisclaimer: e2.target.checked } });
  }, "handleSkipDisclaimer");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.title", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.0", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.1", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.details", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$K.table, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "50px" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.method") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.fee") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$K.nowrap, children: "1.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_description") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$K.nowrap, children: "4.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_description") })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.footnote") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.security.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.info.disclaimer.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.protection.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.protection.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/privacy_policy", children: t2("buy.info.disclaimer.privacyPolicy") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
}, "MoonpayTerms"), container$l = "_container_yg57j_1", iframe = "_iframe_yg57j_12", header$4 = "_header_yg57j_18", style$J = {
  container: container$l,
  iframe,
  header: header$4
}, Moonpay = /* @__PURE__ */ __name(({ accounts, code }) => {
  const { t: t2 } = useTranslation(), [agreedTerms, setAgreedTerms] = reactExports.useState(!1), [iframeLoaded, setIframeLoaded] = reactExports.useState(!1), [height, setHeight] = reactExports.useState(0), { isDarkMode } = useDarkmode(), config = useLoad(getConfig), moonpay = useLoad(getMoonpayBuyInfo(code)), account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2), ref = reactExports.createRef();
  let resizeTimerID;
  reactExports.useEffect(() => {
    config && setAgreedTerms(config.frontend.skipMoonpayDisclaimer);
  }, [config]), reactExports.useEffect(() => (onResize(), window.addEventListener("resize", onResize), () => window.removeEventListener("resize", onResize)));
  const onResize = /* @__PURE__ */ __name(() => {
    resizeTimerID && clearTimeout(resizeTimerID), resizeTimerID = setTimeout(() => {
      ref.current && setHeight(ref.current.offsetHeight);
    }, 200);
  }, "onResize");
  return !account2 || !config ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$J.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$J.container, children: agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") }),
        moonpay && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(!0), onResize();
            },
            title: "Moonpay",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$J.iframe,
            allow: "camera; payment",
            src: `${moonpay.url}&colorCode=%235E94BF&theme=${isDarkMode ? "dark" : "light"}`
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        MoonpayTerms,
        {
          account: account2,
          onAgreedTerms: () => setAgreedTerms(!0)
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "moonpay" })
  ] });
}, "Moonpay");
function findLowestFee(providers) {
  let allFees = [];
  return providers.exchanges.forEach((provider) => {
    provider.deals.forEach((deal) => {
      provider.supported && (allFees = [...allFees, deal.fee]);
    });
  }), Math.min(...allFees);
}
__name(findLowestFee, "findLowestFee");
function findBestDeal(providers, lowestFee) {
  const hasMultipleSupportedExchanges = providers.exchanges.filter((p2) => p2.supported).length > 1;
  return { exchanges: providers.exchanges.map((exchange) => ({
    ...exchange,
    deals: exchange.deals.map((deal) => ({
      ...deal,
      isBestDeal: deal.fee === lowestFee && hasMultipleSupportedExchanges
    }))
  })) };
}
__name(findBestDeal, "findBestDeal");
function getFormattedName(name) {
  switch (name) {
    case "moonpay":
      return "MoonPay";
    case "pocket":
      return "Pocket";
  }
}
__name(getFormattedName, "getFormattedName");
async function getExchangeSupportedAccounts(accounts) {
  return (await Promise.all(
    accounts.map(async (account2) => (await getExchangeBuySupported(account2.code)()).exchanges.length ? account2 : !1)
  )).filter((result) => result);
}
__name(getExchangeSupportedAccounts, "getExchangeSupportedAccounts");
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread2, "_objectSpread2");
var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? !1 : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$6), _useState = reactExports.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1], _useState3 = reactExports.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1], _useState5 = reactExports.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1], onChange2 = reactExports.useCallback(function(value2, actionMeta) {
    typeof propsOnChange == "function" && propsOnChange(value2, actionMeta), setStateValue(value2);
  }, [propsOnChange]), onInputChange = reactExports.useCallback(function(value2, actionMeta) {
    var newValue;
    typeof propsOnInputChange == "function" && (newValue = propsOnInputChange(value2, actionMeta)), setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]), onMenuOpen = reactExports.useCallback(function() {
    typeof propsOnMenuOpen == "function" && propsOnMenuOpen(), setStateMenuIsOpen(!0);
  }, [propsOnMenuOpen]), onMenuClose = reactExports.useCallback(function() {
    typeof propsOnMenuClose == "function" && propsOnMenuClose(), setStateMenuIsOpen(!1);
  }, [propsOnMenuClose]), inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue, menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen, value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
__name(useStateManager, "useStateManager");
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper, "_createSuper");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function sheetForTag(tag) {
  if (tag.sheet)
    return tag.sheet;
  for (var i = 0; i < document.styleSheets.length; i++)
    if (document.styleSheets[i].ownerNode === tag)
      return document.styleSheets[i];
}
__name(sheetForTag, "sheetForTag");
function createStyleElement(options2) {
  var tag = document.createElement("style");
  return tag.setAttribute("data-emotion", options2.key), options2.nonce !== void 0 && tag.setAttribute("nonce", options2.nonce), tag.appendChild(document.createTextNode("")), tag.setAttribute("data-s", ""), tag;
}
__name(createStyleElement, "createStyleElement");
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      _this.tags.length === 0 ? _this.insertionPoint ? before = _this.insertionPoint.nextSibling : _this.prepend ? before = _this.container.firstChild : before = _this.before : before = _this.tags[_this.tags.length - 1].nextSibling, _this.container.insertBefore(tag, before), _this.tags.push(tag);
    }, this.isSpeedy = options2.speedy === void 0 ? !0 : options2.speedy, this.tags = [], this.ctr = 0, this.nonce = options2.nonce, this.key = options2.key, this.container = options2.container, this.prepend = options2.prepend, this.insertionPoint = options2.insertionPoint, this.before = null;
  }
  __name(StyleSheet2, "StyleSheet");
  var _proto = StyleSheet2.prototype;
  return _proto.hydrate = /* @__PURE__ */ __name(function(nodes) {
    nodes.forEach(this._insertTag);
  }, "hydrate"), _proto.insert = /* @__PURE__ */ __name(function(rule) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch {
      }
    } else
      tag.appendChild(document.createTextNode(rule));
    this.ctr++;
  }, "insert"), _proto.flush = /* @__PURE__ */ __name(function() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    }), this.tags = [], this.ctr = 0;
  }, "flush"), StyleSheet2;
}(), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from$1 = String.fromCharCode, assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
__name(hash$1, "hash$1");
function trim(value) {
  return value.trim();
}
__name(trim, "trim");
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
__name(match, "match");
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
__name(replace, "replace");
function indexof(value, search) {
  return value.indexOf(search);
}
__name(indexof, "indexof");
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
__name(charat, "charat");
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
__name(substr, "substr");
function strlen(value) {
  return value.length;
}
__name(strlen, "strlen");
function sizeof(value) {
  return value.length;
}
__name(sizeof, "sizeof");
function append(value, array) {
  return array.push(value), value;
}
__name(append, "append");
function combine(array, callback2) {
  return array.map(callback2).join("");
}
__name(combine, "combine");
var line = 1, column$1 = 1, length = 0, position = 0, character = 0, characters = "";
function node$1(value, root2, parent, type2, props, children2, length2) {
  return { value, root: root2, parent, type: type2, props, children: children2, line, column: column$1, length: length2, return: "" };
}
__name(node$1, "node$1");
function copy(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
__name(copy, "copy");
function char() {
  return character;
}
__name(char, "char");
function prev() {
  return character = position > 0 ? charat(characters, --position) : 0, column$1--, character === 10 && (column$1 = 1, line--), character;
}
__name(prev, "prev");
function next$1() {
  return character = position < length ? charat(characters, position++) : 0, column$1++, character === 10 && (column$1 = 1, line++), character;
}
__name(next$1, "next$1");
function peek() {
  return charat(characters, position);
}
__name(peek, "peek");
function caret() {
  return position;
}
__name(caret, "caret");
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
__name(slice, "slice");
function token$2(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
__name(token$2, "token$2");
function alloc(value) {
  return line = column$1 = 1, length = strlen(characters = value), position = 0, [];
}
__name(alloc, "alloc");
function dealloc(value) {
  return characters = "", value;
}
__name(dealloc, "dealloc");
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
__name(delimit, "delimit");
function whitespace(type2) {
  for (; (character = peek()) && character < 33; )
    next$1();
  return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
}
__name(whitespace, "whitespace");
function escaping(index, count) {
  for (; --count && next$1() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice(index, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
__name(escaping, "escaping");
function delimiter(type2) {
  for (; next$1(); )
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        type2 !== 34 && type2 !== 39 && delimiter(character);
        break;
      case 40:
        type2 === 41 && delimiter(type2);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
__name(delimiter, "delimiter");
function commenter(type2, index) {
  for (; next$1() && type2 + character !== 47 + 10; )
    if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from$1(type2 === 47 ? type2 : next$1());
}
__name(commenter, "commenter");
function identifier(index) {
  for (; !token$2(peek()); )
    next$1();
  return slice(index, position);
}
__name(identifier, "identifier");
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
__name(compile, "compile");
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  for (var index = 0, offset = 0, length2 = pseudo, atrule = 0, property = 0, previous2 = 0, variable = 1, scanning = 1, ampersand = 1, character2 = 0, type2 = "", props = rules, children2 = rulesets, reference = rule, characters2 = type2; scanning; )
    switch (previous2 = character2, character2 = next$1()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1 && (ampersand = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            ampersand == -1 && (characters2 = replace(characters2, /\f/g, "")), property > 0 && strlen(characters2) - length2 && append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            if (append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type2, props = [], children2 = [], length2), rulesets), character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            peek() === 45 && (characters2 += delimit(next$1())), atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            previous2 === 45 && strlen(characters2) == 2 && (variable = 0);
        }
    }
  return rulesets;
}
__name(parse, "parse");
function ruleset(value, root2, parent, index, offset, rules, points, type2, props, children2, length2) {
  for (var post = offset - 1, rule = offset === 0 ? rules : [""], size2 = sizeof(rule), i = 0, j2 = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size2; ++x2)
      (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2]))) && (props[k2++] = z2);
  return node$1(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
}
__name(ruleset, "ruleset");
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
__name(comment, "comment");
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
__name(declaration, "declaration");
function serialize(children2, callback2) {
  for (var output2 = "", length2 = sizeof(children2), i = 0; i < length2; i++)
    output2 += callback2(children2[i], i, children2, callback2) || "";
  return output2;
}
__name(serialize, "serialize");
function stringify(element, index, children2, callback2) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback2)) ? element.return = element.value + "{" + children2 + "}" : "";
}
__name(stringify, "stringify");
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children2, callback2) {
    for (var output2 = "", i = 0; i < length2; i++)
      output2 += collection[i](element, index, children2, callback2) || "";
    return output2;
  };
}
__name(middleware, "middleware");
function rulesheet(callback2) {
  return function(element) {
    element.root || (element = element.return) && callback2(element);
  };
}
__name(rulesheet, "rulesheet");
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    return cache[arg] === void 0 && (cache[arg] = fn2(arg)), cache[arg];
  };
}
__name(memoize, "memoize");
var identifierWithPointTracking = /* @__PURE__ */ __name(function(begin, points, index) {
  for (var previous2 = 0, character2 = 0; previous2 = character2, character2 = peek(), previous2 === 38 && character2 === 12 && (points[index] = 1), !token$2(character2); )
    next$1();
  return slice(begin, position);
}, "identifierWithPointTracking"), toRules = /* @__PURE__ */ __name(function(parsed, points) {
  var index = -1, character2 = 44;
  do
    switch (token$2(character2)) {
      case 0:
        character2 === 38 && peek() === 12 && (points[index] = 1), parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "", points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from$1(character2);
    }
  while (character2 = next$1());
  return parsed;
}, "toRules"), getRules = /* @__PURE__ */ __name(function(value, points) {
  return dealloc(toRules(alloc(value), points));
}, "getRules"), fixedElements = /* @__PURE__ */ new WeakMap(), compat = /* @__PURE__ */ __name(function(element) {
  if (!(element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1)) {
    for (var value = element.value, parent = element.parent, isImplicitRule = element.column === parent.column && element.line === parent.line; parent.type !== "rule"; )
      if (parent = parent.parent, !parent)
        return;
    if (!(element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) && !isImplicitRule) {
      fixedElements.set(element, !0);
      for (var points = [], rules = getRules(value, points), parentRules = parent.props, i = 0, k2 = 0; i < rules.length; i++)
        for (var j2 = 0; j2 < parentRules.length; j2++, k2++)
          element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
}, "compat"), removeLabel = /* @__PURE__ */ __name(function(element) {
  if (element.type === "decl") {
    var value = element.value;
    // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98 && (element.return = "", element.value = "");
  }
}, "removeLabel");
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
__name(prefix, "prefix");
var prefixer = /* @__PURE__ */ __name(function(element, index, children2, callback2) {
  if (element.length > -1 && !element.return)
    switch (element.type) {
      case DECLARATION:
        element.return = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback2);
      case RULESET:
        if (element.length)
          return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback2);
              case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback2);
            }
            return "";
          });
    }
}, "prefixer"), defaultStylisPlugins = [prefixer], createCache = /* @__PURE__ */ __name(function(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      dataEmotionAttribute.indexOf(" ") !== -1 && (document.head.appendChild(node2), node2.setAttribute("data-s", ""));
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins, inserted = {}, container2, nodesToHydrate = [];
  container2 = options2.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
    function(node2) {
      for (var attrib = node2.getAttribute("data-emotion").split(" "), i = 1; i < attrib.length; i++)
        inserted[attrib[i]] = !0;
      nodesToHydrate.push(node2);
    }
  );
  var _insert, omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet, finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })], serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins)), stylis = /* @__PURE__ */ __name(function(styles2) {
      return serialize(compile(styles2), serializer);
    }, "stylis");
    _insert = /* @__PURE__ */ __name(function(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet, stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles), shouldCache && (cache.inserted[serialized.name] = !0);
    }, "insert");
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  return cache.sheet.hydrate(nodesToHydrate), cache;
}, "createCache"), reactIs$1 = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol == "function" && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$2 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$3 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if (typeof a2 == "object" && a2 !== null) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$2:
          case e$2:
          case g$1:
          case f$1:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n:
              case t:
              case r$1:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
__name(z$1, "z$1");
function A$2(a2) {
  return z$1(a2) === m$2;
}
__name(A$2, "A$2");
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$2;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$2;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$2;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$2(a2) || z$1(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$2;
};
reactIs_production_min.isElement = function(a2) {
  return typeof a2 == "object" && a2 !== null && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$2;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return typeof a2 == "string" || typeof a2 == "function" || a2 === e$2 || a2 === m$2 || a2 === g$1 || a2 === f$1 || a2 === p$2 || a2 === q$1 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n || a2.$$typeof === w$3 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
reactIs$1.exports = reactIs_production_min;
var reactIsExports = reactIs$1.exports, reactIs = reactIsExports, FORWARD_REF_STATICS = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, MEMO_STATICS = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = !0;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  return classNames2.split(" ").forEach(function(className) {
    registered[className] !== void 0 ? registeredStyles.push(registered[className] + ";") : rawClassName += className + " ";
  }), rawClassName;
}
__name(getRegisteredStyles, "getRegisteredStyles");
var registerStyles = /* @__PURE__ */ __name(function(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === !1) && cache.registered[className] === void 0 && (cache.registered[className] = serialized.styles);
}, "registerStyles"), insertStyles = /* @__PURE__ */ __name(function(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, !0), current = current.next;
    while (current !== void 0);
  }
}, "insertStyles");
function murmur2(str) {
  for (var h2 = 0, k2, i = 0, len = str.length; len >= 4; ++i, len -= 4)
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24, k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16), k2 ^= /* k >>> r: */
    k2 >>> 24, h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255, h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  return h2 ^= h2 >>> 13, h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16), ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
__name(murmur2, "murmur2");
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = /* @__PURE__ */ __name(function(property) {
  return property.charCodeAt(1) === 45;
}, "isCustomProperty"), isProcessableValue = /* @__PURE__ */ __name(function(value) {
  return value != null && typeof value != "boolean";
}, "isProcessableValue"), processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
}), processStyleValue = /* @__PURE__ */ __name(function(key, value) {
  switch (key) {
    case "animation":
    case "animationName":
      if (typeof value == "string")
        return value.replace(animationRegex, function(match2, p1, p2) {
          return cursor = {
            name: p1,
            styles: p2,
            next: cursor
          }, p1;
        });
  }
  return unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value == "number" && value !== 0 ? value + "px" : value;
}, "processStyleValue");
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null)
    return "";
  if (interpolation.__emotion_styles !== void 0)
    return interpolation;
  switch (typeof interpolation) {
    case "boolean":
      return "";
    case "object": {
      if (interpolation.anim === 1)
        return cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        }, interpolation.name;
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0)
          for (; next2 !== void 0; )
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            }, next2 = next2.next;
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor, result = interpolation(mergedProps);
        return cursor = previousCursor, handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null)
    return interpolation;
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
__name(handleInterpolation, "handleInterpolation");
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj))
    for (var i = 0; i < obj.length; i++)
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
  else
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value != "object")
        registered != null && registered[value] !== void 0 ? string2 += _key + "{" + registered[value] + "}" : isProcessableValue(value) && (string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";");
      else if (Array.isArray(value) && typeof value[0] == "string" && (registered == null || registered[value[0]] === void 0))
        for (var _i2 = 0; _i2 < value.length; _i2++)
          isProcessableValue(value[_i2]) && (string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i2]) + ";");
      else {
        var interpolated = handleInterpolation(mergedProps, registered, value);
        switch (_key) {
          case "animation":
          case "animationName": {
            string2 += processStyleName(_key) + ":" + interpolated + ";";
            break;
          }
          default:
            string2 += _key + "{" + interpolated + "}";
        }
      }
    }
  return string2;
}
__name(createStringFromObject, "createStringFromObject");
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor, serializeStyles = /* @__PURE__ */ __name(function(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] == "object" && args[0] !== null && args[0].styles !== void 0)
    return args[0];
  var stringMode = !0, styles2 = "";
  cursor = void 0;
  var strings = args[0];
  strings == null || strings.raw === void 0 ? (stringMode = !1, styles2 += handleInterpolation(mergedProps, registered, strings)) : styles2 += strings[0];
  for (var i = 1; i < args.length; i++)
    styles2 += handleInterpolation(mergedProps, registered, args[i]), stringMode && (styles2 += strings[i]);
  labelPattern.lastIndex = 0;
  for (var identifierName = "", match2; (match2 = labelPattern.exec(styles2)) !== null; )
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}, "serializeStyles"), syncFallback = /* @__PURE__ */ __name(function(create) {
  return create();
}, "syncFallback"), useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback, hasOwnProperty = {}.hasOwnProperty, EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = /* @__PURE__ */ __name(function(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
}, "withEmotionCache"), ThemeContext = /* @__PURE__ */ reactExports.createContext({}), typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", createEmotionProps = /* @__PURE__ */ __name(function(type2, props) {
  var newProps = {};
  for (var key in props)
    hasOwnProperty.call(props, key) && (newProps[key] = props[key]);
  return newProps[typePropName] = type2, newProps;
}, "createEmotionProps"), Insertion = /* @__PURE__ */ __name(function(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  return registerStyles(cache, serialized, isStringTag), useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  }), null;
}, "Insertion"), Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  typeof cssProp == "string" && cache.registered[cssProp] !== void 0 && (cssProp = cache.registered[cssProp]);
  var WrappedComponent = props[typePropName], registeredStyles = [cssProp], className = "";
  typeof props.className == "string" ? className = getRegisteredStyles(cache.registered, registeredStyles, props.className) : props.className != null && (className = props.className + " ");
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props)
    hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && (newProps[key] = props[key]);
  return newProps.ref = ref, newProps.className = className, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent == "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
}), Emotion$1 = Emotion, jsx = /* @__PURE__ */ __name(function(type2, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css"))
    return reactExports.createElement.apply(void 0, args);
  var argsLength = args.length, createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1, createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++)
    createElementArgArray[i] = args[i];
  return reactExports.createElement.apply(null, createElementArgArray);
}, "jsx");
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return serializeStyles(args);
}
__name(css$2, "css$2");
var keyframes = /* @__PURE__ */ __name(function() {
  var insertable = css$2.apply(void 0, arguments), name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: /* @__PURE__ */ __name(function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }, "toString")
  };
}, "keyframes");
function _taggedTemplateLiteral(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
__name(_taggedTemplateLiteral, "_taggedTemplateLiteral");
const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = /* @__PURE__ */ __name((v2) => ({
  x: v2,
  y: v2
}), "createCoords");
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
__name(rectToClientRect, "rectToClientRect");
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
__name(getNodeName, "getNodeName");
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
__name(getWindow, "getWindow");
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
__name(getDocumentElement, "getDocumentElement");
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
__name(isNode, "isNode");
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
__name(isElement, "isElement");
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
__name(isHTMLElement, "isHTMLElement");
function isShadowRoot(value) {
  return typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
__name(isShadowRoot, "isShadowRoot");
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
__name(isOverflowElement, "isOverflowElement");
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
__name(isWebKit, "isWebKit");
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
__name(isLastTraversableNode, "isLastTraversableNode");
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
__name(getComputedStyle$1, "getComputedStyle$1");
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
__name(getParentNode, "getParentNode");
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
__name(getNearestOverflowAncestor, "getNearestOverflowAncestor");
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  return isBody ? list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []) : list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
__name(getOverflowAncestors, "getOverflowAncestors");
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0, height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
__name(getCssDimensions, "getCssDimensions");
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
__name(unwrapElement, "unwrapElement");
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width, y2 = ($2 ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
__name(getScale, "getScale");
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  return !isWebKit() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
__name(getVisualOffsets, "getVisualOffsets");
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
__name(shouldAddVisualOffsets, "shouldAddVisualOffsets");
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x, y2 = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    for (; currentIFrame && offsetParent && offsetWin !== win; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css4 = getComputedStyle$1(currentIFrame), left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left2, y2 += top, currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
__name(getBoundingClientRect, "getBoundingClientRect");
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId), io && io.disconnect(), io = null;
  }
  __name(cleanup, "cleanup");
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left2 + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left2), options2 = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 100);
      }
      isFirstUpdate = !1;
    }
    __name(handleObserve, "handleObserve");
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  return __name(refresh, "refresh"), refresh(!0), cleanup;
}
__name(observeMove, "observeMove");
function autoUpdate(reference, floating, update, options2) {
  options2 === void 0 && (options2 = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options2, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref3) => {
    let [firstEntry] = _ref3;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      resizeObserver && resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return __name(frameLoop, "frameLoop"), update(), () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo && cleanupIo(), resizeObserver && resizeObserver.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
__name(autoUpdate, "autoUpdate");
var index$1 = reactExports.useLayoutEffect, _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], noop = /* @__PURE__ */ __name(function() {
}, "noop");
function applyPrefixToName(prefix2, name) {
  return name ? name[0] === "-" ? prefix2 + name : prefix2 + "__" + name : prefix2;
}
__name(applyPrefixToName, "applyPrefixToName");
function classNames(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
    classNameList[_key - 2] = arguments[_key];
  var arr = [].concat(classNameList);
  if (state && prefix2)
    for (var key in state)
      state.hasOwnProperty(key) && state[key] && arr.push("".concat(applyPrefixToName(prefix2, key)));
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
__name(classNames, "classNames");
var cleanValue = /* @__PURE__ */ __name(function(value) {
  return isArray$1(value) ? value.filter(Boolean) : _typeof(value) === "object" && value !== null ? [value] : [];
}, "cleanValue"), cleanCommonProps = /* @__PURE__ */ __name(function(props) {
  props.className, props.clearValue, props.cx, props.getStyles, props.getClassNames, props.getValue, props.hasValue, props.isMulti, props.isRtl, props.options, props.selectOption, props.selectProps, props.setValue, props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
}, "cleanCommonProps"), getStyleProps = /* @__PURE__ */ __name(function(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState ?? {}, getClassNames(name, props), className)
  };
}, "getStyleProps");
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
__name(isDocumentElement, "isDocumentElement");
function normalizedHeight(el2) {
  return isDocumentElement(el2) ? window.innerHeight : el2.clientHeight;
}
__name(normalizedHeight, "normalizedHeight");
function getScrollTop(el2) {
  return isDocumentElement(el2) ? window.pageYOffset : el2.scrollTop;
}
__name(getScrollTop, "getScrollTop");
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
__name(scrollTo, "scrollTo");
function getScrollParent(element) {
  var style2 = getComputedStyle(element), excludeStaticParent = style2.position === "absolute", overflowRx = /(auto|scroll)/;
  if (style2.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; )
    if (style2 = getComputedStyle(parent), !(excludeStaticParent && style2.position === "static") && overflowRx.test(style2.overflow + style2.overflowY + style2.overflowX))
      return parent;
  return document.documentElement;
}
__name(getScrollParent, "getScrollParent");
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
__name(easeOutCubic, "easeOutCubic");
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, callback2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop, start = getScrollTop(element), change = to - start, increment = 10, currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val), currentTime < duration ? window.requestAnimationFrame(animateScroll) : callback2(element);
  }
  __name(animateScroll, "animateScroll"), animateScroll();
}
__name(animatedScrollTo, "animatedScrollTo");
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect(), focusedRect = focusedEl.getBoundingClientRect(), overScroll = focusedEl.offsetHeight / 3;
  focusedRect.bottom + overScroll > menuRect.bottom ? scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight)) : focusedRect.top - overScroll < menuRect.top && scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
}
__name(scrollIntoView, "scrollIntoView");
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
__name(getBoundingClientObj, "getBoundingClientObj");
function isTouchCapable() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
__name(isTouchCapable, "isTouchCapable");
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
__name(isMobileDevice, "isMobileDevice");
var passiveOptionAccessed = !1, options = {
  get passive() {
    return passiveOptionAccessed = !0;
  }
}, w$2 = typeof window < "u" ? window : {};
w$2.addEventListener && w$2.removeEventListener && (w$2.addEventListener("p", noop, options), w$2.removeEventListener("p", noop, !1));
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item2) {
  return item2 != null;
}
__name(notNullish, "notNullish");
function isArray$1(arg) {
  return Array.isArray(arg);
}
__name(isArray$1, "isArray$1");
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
__name(valueTernary, "valueTernary");
var removeProps = /* @__PURE__ */ __name(function(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
    properties[_key2 - 1] = arguments[_key2];
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key = _ref22[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    return newProps[key] = val, newProps;
  }, {});
}, "removeProps"), _excluded$3 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight, scrollParent = getScrollParent(menuEl), defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height, _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top, _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top, viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent), scrollTop = getScrollTop(scrollParent), marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10), marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10), viewSpaceAbove = containerTop - marginTop, viewSpaceBelow = viewHeight - menuTop, scrollSpaceAbove = viewSpaceAbove + scrollTop, scrollSpaceBelow = scrollHeight - scrollTop - menuTop, scrollDown = menuBottom - viewHeight + scrollTop + marginBottom, scrollUp = scrollTop + menuTop - marginTop, scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight)
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition)
        return shouldScroll && animatedScrollTo(scrollParent, scrollDown, scrollDuration), {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        shouldScroll && animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight, spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        return spaceAbove >= minHeight && (_constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight)), {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom")
        return shouldScroll && scrollTo(scrollParent, scrollDown), {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight)
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition)
        return shouldScroll && animatedScrollTo(scrollParent, scrollUp, scrollDuration), {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        return (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) && (_constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop), shouldScroll && animatedScrollTo(scrollParent, scrollUp, scrollDuration), {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
__name(getMenuPlacement, "getMenuPlacement");
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
__name(alignToControl, "alignToControl");
var coercePlacement = /* @__PURE__ */ __name(function(p2) {
  return p2 === "auto" ? "bottom" : p2;
}, "coercePlacement"), menuCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _objectSpread2$1, placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "width", "100%"), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
}, "menuCSS"), PortalPlacementContext = /* @__PURE__ */ reactExports.createContext(null), MenuPlacer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme, _ref3 = reactExports.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement, ref = reactExports.useRef(null), _useState = reactExports.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1], _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1], controlHeight2 = theme.spacing.controlHeight;
  return index$1(function() {
    var menuEl = ref.current;
    if (menuEl) {
      var isFixedPosition = menuPosition === "fixed", shouldScroll = menuShouldScrollIntoView && !isFixedPosition, state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll,
        isFixedPosition,
        controlHeight: controlHeight2
      });
      setMaxHeight(state.maxHeight), setPlacement(state.placement), setPortalPlacement == null || setPortalPlacement(state.placement);
    }
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]), children2({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
}, "MenuPlacer"), Menu = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: !0
  }), {
    ref: innerRef
  }, innerProps), children2);
}, "Menu"), Menu$1 = Menu, menuListCSS = /* @__PURE__ */ __name(function(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
}, "menuListCSS"), MenuList = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children2);
}, "MenuList"), noticeCSS = /* @__PURE__ */ __name(function(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
}, "noticeCSS"), noOptionsMessageCSS = noticeCSS, loadingMessageCSS = noticeCSS, NoOptionsMessage = /* @__PURE__ */ __name(function(_ref6) {
  var _ref6$children = _ref6.children, children2 = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), innerProps), children2);
}, "NoOptionsMessage"), LoadingMessage = /* @__PURE__ */ __name(function(_ref7) {
  var _ref7$children = _ref7.children, children2 = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), innerProps), children2);
}, "LoadingMessage"), menuPortalCSS = /* @__PURE__ */ __name(function(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
}, "menuPortalCSS"), MenuPortal = /* @__PURE__ */ __name(function(props) {
  var appendTo = props.appendTo, children2 = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuPortalRef = reactExports.useRef(null), cleanupRef = reactExports.useRef(null), _useState5 = reactExports.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1], portalPlacementContext = reactExports.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []), _useState7 = reactExports.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1], updateComputedPosition = reactExports.useCallback(function() {
    if (controlElement) {
      var rect = getBoundingClientObj(controlElement), scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset, offset = rect[placement] + scrollDistance;
      (offset !== (computedPosition == null ? void 0 : computedPosition.offset) || rect.left !== (computedPosition == null ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition == null ? void 0 : computedPosition.rect.width)) && setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition == null ? void 0 : computedPosition.offset, computedPosition == null ? void 0 : computedPosition.rect.left, computedPosition == null ? void 0 : computedPosition.rect.width]);
  index$1(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = reactExports.useCallback(function() {
    typeof cleanupRef.current == "function" && (cleanupRef.current(), cleanupRef.current = null), controlElement && menuPortalRef.current && (cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
      elementResize: "ResizeObserver" in window
    }));
  }, [controlElement, updateComputedPosition]);
  index$1(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = reactExports.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement, runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), innerProps), children2);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
}, "MenuPortal"), containerCSS = /* @__PURE__ */ __name(function(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, "containerCSS"), SelectContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children2);
}, "SelectContainer"), valueContainerCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
}, "valueContainerCSS"), ValueContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children2);
}, "ValueContainer"), indicatorsContainerCSS = /* @__PURE__ */ __name(function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, "indicatorsContainerCSS"), IndicatorsContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: !0
  }), innerProps), children2);
}, "IndicatorsContainer"), _templateObject, _excluded$2 = ["size"], _excluded2 = ["innerProps", "isRtl", "size"], _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, Svg = /* @__PURE__ */ __name(function(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
}, "Svg"), CrossIcon = /* @__PURE__ */ __name(function(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, "CrossIcon"), DownChevron = /* @__PURE__ */ __name(function(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, "DownChevron"), baseCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
}, "baseCSS"), dropdownIndicatorCSS = baseCSS, DropdownIndicator$3 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), innerProps), children2 || jsx(DownChevron, null));
}, "DropdownIndicator"), clearIndicatorCSS = baseCSS, ClearIndicator = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), innerProps), children2 || jsx(CrossIcon, null));
}, "ClearIndicator"), indicatorSeparatorCSS = /* @__PURE__ */ __name(function(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
}, "indicatorSeparatorCSS"), IndicatorSeparator = /* @__PURE__ */ __name(function(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, "IndicatorSeparator"), loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), loadingIndicatorCSS = /* @__PURE__ */ __name(function(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
}, "loadingIndicatorCSS"), LoadingDot = /* @__PURE__ */ __name(function(_ref6) {
  var delay2 = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, "LoadingDot"), LoadingIndicator = /* @__PURE__ */ __name(function(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: !0
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
}, "LoadingIndicator"), css$1 = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
}, "css"), Control = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: !0,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children2);
}, "Control"), Control$1 = Control, _excluded$1 = ["data"], groupCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
}, "groupCSS"), Group = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label2 = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: !0
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label2), jsx("div", null, children2));
}, "Group"), groupHeadingCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
}, "groupHeadingCSS"), GroupHeading = /* @__PURE__ */ __name(function(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": !0
  }), innerProps));
}, "GroupHeading"), Group$1 = Group, _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"], inputCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
}, "inputCSS"), spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
}, inputStyle = /* @__PURE__ */ __name(function(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
}, "inputStyle"), Input2 = /* @__PURE__ */ __name(function(props) {
  var cx = props.cx, value = props.value, _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": !0
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: !0
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
}, "Input"), Input$1 = Input2, multiValueCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
}, "multiValueCSS"), multiValueLabelCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, "multiValueLabelCSS"), multiValueRemoveCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
}, "multiValueRemoveCSS"), MultiValueGeneric = /* @__PURE__ */ __name(function(_ref4) {
  var children2 = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children2);
}, "MultiValueGeneric"), MultiValueContainer = MultiValueGeneric, MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children2 = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children2 || jsx(CrossIcon, {
    size: 14
  }));
}
__name(MultiValueRemove, "MultiValueRemove");
var MultiValue = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps, Container = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps
  }, children2), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(children2 || "option")
    }, removeProps3),
    selectProps
  }));
}, "MultiValue"), MultiValue$1 = MultiValue, optionCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: isDisabled ? void 0 : isSelected ? colors2.primary : colors2.primary50
    }
  });
}, "optionCSS"), Option$1 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: !0,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children2);
}, "Option"), Option$1$1 = Option$1, placeholderCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
}, "placeholderCSS"), Placeholder = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: !0
  }), innerProps), children2);
}, "Placeholder"), Placeholder$1 = Placeholder, css2 = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
}, "css"), SingleValue$1 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": isDisabled
  }), innerProps), children2);
}, "SingleValue"), SingleValue$1$1 = SingleValue$1, components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator: DropdownIndicator$3,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1$1,
  ValueContainer
}, defaultComponents = /* @__PURE__ */ __name(function(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
}, "defaultComponents"), safeIsNaN = Number.isNaN || /* @__PURE__ */ __name(function(value) {
  return typeof value == "number" && value !== value;
}, "ponyfill");
function isEqual(first2, second) {
  return !!(first2 === second || safeIsNaN(first2) && safeIsNaN(second));
}
__name(isEqual, "isEqual");
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length)
    return !1;
  for (var i = 0; i < newInputs.length; i++)
    if (!isEqual(newInputs[i], lastInputs[i]))
      return !1;
  return !0;
}
__name(areInputsEqual, "areInputsEqual");
function memoizeOne(resultFn, isEqual2) {
  isEqual2 === void 0 && (isEqual2 = areInputsEqual);
  var cache = null;
  function memoized() {
    for (var newArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
      newArgs[_i2] = arguments[_i2];
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs))
      return cache.lastResult;
    var lastResult = resultFn.apply(this, newArgs);
    return cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    }, lastResult;
  }
  return __name(memoized, "memoized"), memoized.clear = /* @__PURE__ */ __name(function() {
    cache = null;
  }, "clear"), memoized;
}
__name(memoizeOne, "memoizeOne");
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, A11yText = /* @__PURE__ */ __name(function(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
}, "A11yText"), A11yText$1 = A11yText, defaultAriaLiveMessages = {
  guidance: /* @__PURE__ */ __name(function(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  }, "guidance"),
  onChange: /* @__PURE__ */ __name(function(props) {
    var action2 = props.action, _props$label = props.label, label2 = _props$label === void 0 ? "" : _props$label, labels2 = props.labels, isDisabled = props.isDisabled;
    switch (action2) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label2, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels2.length > 1 ? "s" : "", " ").concat(labels2.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label2, " is disabled. Select another option.") : "option ".concat(label2, ", selected.");
      default:
        return "";
    }
  }, "onChange"),
  onFocus: /* @__PURE__ */ __name(function(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label2 = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected, getArrayIndex = /* @__PURE__ */ __name(function(arr, item2) {
      return arr && arr.length ? "".concat(arr.indexOf(item2) + 1, " of ").concat(arr.length) : "";
    }, "getArrayIndex");
    if (context === "value" && selectValue)
      return "value ".concat(label2, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    if (context === "menu") {
      var disabled2 = isDisabled ? " disabled" : "", status2 = "".concat(isSelected ? "selected" : "focused").concat(disabled2);
      return "option ".concat(label2, " ").concat(status2, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  }, "onFocus"),
  onFilter: /* @__PURE__ */ __name(function(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }, "onFilter")
}, LiveRegion = /* @__PURE__ */ __name(function(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id, ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue, ariaLabel = selectProps["aria-label"], ariaLive = selectProps["aria-live"], messages = reactExports.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]), ariaSelected = reactExports.useMemo(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value, asOption = /* @__PURE__ */ __name(function(val) {
        return Array.isArray(val) ? null : val;
      }, "asOption"), selected2 = removedValue || option || asOption(value), label2 = selected2 ? getOptionLabel4(selected2) : "", multiSelected = selectedOptions || removedValues || void 0, labels2 = multiSelected ? multiSelected.map(getOptionLabel4) : [], onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected2 && isOptionDisabled3(selected2, selectValue),
        label: label2,
        labels: labels2
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]), ariaFocused = reactExports.useMemo(function() {
    var focusMsg = "", focused = focusedOption || focusedValue, isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]), ariaResults = reactExports.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]), ariaGuidance = reactExports.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]), ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance), ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext)), isInitialFocus = (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
}, "LiveRegion"), LiveRegion$1 = LiveRegion, diacritics = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g"), diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++)
  for (var diacritic = diacritics[i], j$1 = 0; j$1 < diacritic.letters.length; j$1++)
    diacriticToBase[diacritic.letters[j$1]] = diacritic.base;
var stripDiacritics = /* @__PURE__ */ __name(function(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
}, "stripDiacritics"), memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics), trimString = /* @__PURE__ */ __name(function(str) {
  return str.replace(/^\s+|\s+$/g, "");
}, "trimString"), defaultStringify = /* @__PURE__ */ __name(function(option) {
  return "".concat(option.label, " ").concat(option.value);
}, "defaultStringify"), createFilter = /* @__PURE__ */ __name(function(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return !0;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: defaultStringify,
      trim: !0,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom, input2 = trim2 ? trimString(rawInput) : rawInput, candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    return ignoreCase && (input2 = input2.toLowerCase(), candidate = candidate.toLowerCase()), ignoreAccents && (input2 = memoizedStripDiacriticsForInput(input2), candidate = stripDiacritics(candidate)), matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
}, "createFilter"), _excluded = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded), filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$2({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
__name(DummyInput, "DummyInput");
var cancelScroll = /* @__PURE__ */ __name(function(event2) {
  event2.preventDefault(), event2.stopPropagation();
}, "cancelScroll");
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave, isBottom = reactExports.useRef(!1), isTop = reactExports.useRef(!1), touchStart = reactExports.useRef(0), scrollTarget = reactExports.useRef(null), handleEventDelta = reactExports.useCallback(function(event2, delta) {
    if (scrollTarget.current !== null) {
      var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight, target = scrollTarget.current, isDeltaPositive = delta > 0, availableScroll = scrollHeight - clientHeight - scrollTop, shouldCancelScroll = !1;
      availableScroll > delta && isBottom.current && (onBottomLeave && onBottomLeave(event2), isBottom.current = !1), isDeltaPositive && isTop.current && (onTopLeave && onTopLeave(event2), isTop.current = !1), isDeltaPositive && delta > availableScroll ? (onBottomArrive && !isBottom.current && onBottomArrive(event2), target.scrollTop = scrollHeight, shouldCancelScroll = !0, isBottom.current = !0) : !isDeltaPositive && -delta > scrollTop && (onTopArrive && !isTop.current && onTopArrive(event2), target.scrollTop = 0, shouldCancelScroll = !0, isTop.current = !0), shouldCancelScroll && cancelScroll(event2);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]), onWheel = reactExports.useCallback(function(event2) {
    handleEventDelta(event2, event2.deltaY);
  }, [handleEventDelta]), onTouchStart = reactExports.useCallback(function(event2) {
    touchStart.current = event2.changedTouches[0].clientY;
  }, []), onTouchMove = reactExports.useCallback(function(event2) {
    var deltaY = touchStart.current - event2.changedTouches[0].clientY;
    handleEventDelta(event2, deltaY);
  }, [handleEventDelta]), startListening = reactExports.useCallback(function(el2) {
    if (el2) {
      var notPassive = supportsPassiveEvents ? {
        passive: !1
      } : !1;
      el2.addEventListener("wheel", onWheel, notPassive), el2.addEventListener("touchstart", onTouchStart, notPassive), el2.addEventListener("touchmove", onTouchMove, notPassive);
    }
  }, [onTouchMove, onTouchStart, onWheel]), stopListening = reactExports.useCallback(function(el2) {
    el2 && (el2.removeEventListener("wheel", onWheel, !1), el2.removeEventListener("touchstart", onTouchStart, !1), el2.removeEventListener("touchmove", onTouchMove, !1));
  }, [onTouchMove, onTouchStart, onWheel]);
  return reactExports.useEffect(function() {
    if (isEnabled) {
      var element = scrollTarget.current;
      return startListening(element), function() {
        stopListening(element);
      };
    }
  }, [isEnabled, startListening, stopListening]), function(element) {
    scrollTarget.current = element;
  };
}
__name(useScrollCapture, "useScrollCapture");
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"], LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  e2.preventDefault();
}
__name(preventTouchMove, "preventTouchMove");
function allowTouchMove(e2) {
  e2.stopPropagation();
}
__name(allowTouchMove, "allowTouchMove");
function preventInertiaScroll() {
  var top = this.scrollTop, totalScroll = this.scrollHeight, currentScroll = top + this.offsetHeight;
  top === 0 ? this.scrollTop = 1 : currentScroll === totalScroll && (this.scrollTop = top - 1);
}
__name(preventInertiaScroll, "preventInertiaScroll");
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
__name(isTouchDevice, "isTouchDevice");
var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), activeScrollLocks = 0, listenerOptions = {
  capture: !1,
  passive: !1
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? !0 : _ref$accountForScroll, originalStyles = reactExports.useRef({}), scrollTarget = reactExports.useRef(null), addScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (canUseDOM) {
      var target = document.body, targetStyle = target && target.style;
      if (accountForScrollbars && STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      }), accountForScrollbars && activeScrollLocks < 1) {
        var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0, clientWidth = document.body ? document.body.clientWidth : 0, adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
        Object.keys(LOCK_STYLES).forEach(function(key) {
          var val = LOCK_STYLES[key];
          targetStyle && (targetStyle[key] = val);
        }), targetStyle && (targetStyle.paddingRight = "".concat(adjustedPadding, "px"));
      }
      target && isTouchDevice() && (target.addEventListener("touchmove", preventTouchMove, listenerOptions), touchScrollTarget && (touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions), touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions))), activeScrollLocks += 1;
    }
  }, [accountForScrollbars]), removeScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (canUseDOM) {
      var target = document.body, targetStyle = target && target.style;
      activeScrollLocks = Math.max(activeScrollLocks - 1, 0), accountForScrollbars && activeScrollLocks < 1 && STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        targetStyle && (targetStyle[key] = val);
      }), target && isTouchDevice() && (target.removeEventListener("touchmove", preventTouchMove, listenerOptions), touchScrollTarget && (touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions), touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions)));
    }
  }, [accountForScrollbars]);
  return reactExports.useEffect(function() {
    if (isEnabled) {
      var element = scrollTarget.current;
      return addScrollLock(element), function() {
        removeScrollLock(element);
      };
    }
  }, [isEnabled, addScrollLock, removeScrollLock]), function(element) {
    scrollTarget.current = element;
  };
}
__name(useScrollLock, "useScrollLock");
var blurSelectInput = /* @__PURE__ */ __name(function() {
  return document.activeElement && document.activeElement.blur();
}, "blurSelectInput"), _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function ScrollManager(_ref3) {
  var children2 = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? !0 : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave, setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  }), setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  }), targetRef = /* @__PURE__ */ __name(function(element) {
    setScrollCaptureTarget(element), setScrollLockTarget(element);
  }, "targetRef");
  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children2(targetRef));
}
__name(ScrollManager, "ScrollManager");
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, RequiredInput = /* @__PURE__ */ __name(function(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: !0,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref2,
    value: "",
    onChange: /* @__PURE__ */ __name(function() {
    }, "onChange")
  });
}, "RequiredInput"), RequiredInput$1 = RequiredInput, formatGroupLabel = /* @__PURE__ */ __name(function(group) {
  return group.label;
}, "formatGroupLabel"), getOptionLabel$1 = /* @__PURE__ */ __name(function(option) {
  return option.label;
}, "getOptionLabel"), getOptionValue$1 = /* @__PURE__ */ __name(function(option) {
  return option.value;
}, "getOptionValue"), isOptionDisabled = /* @__PURE__ */ __name(function(option) {
  return !!option.isDisabled;
}, "isOptionDisabled"), defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
}, colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, borderRadius = 4, baseUnit = 4, controlHeight = 38, menuGutter = baseUnit * 2, spacing = {
  baseUnit,
  controlHeight,
  menuGutter
}, defaultTheme = {
  borderRadius,
  colors,
  spacing
}, defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled,
  loadingMessage: /* @__PURE__ */ __name(function() {
    return "Loading...";
  }, "loadingMessage"),
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: /* @__PURE__ */ __name(function() {
    return "No options";
  }, "noOptionsMessage"),
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: /* @__PURE__ */ __name(function(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  }, "screenReaderStatus"),
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue), isSelected = _isOptionSelected(props, option, selectValue), label2 = getOptionLabel2(props, option), value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label: label2,
    value,
    index
  };
}
__name(toCategorizedOption, "toCategorizedOption");
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
__name(buildCategorizedOptions, "buildCategorizedOptions");
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    return categorizedOption.type === "group" ? optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
      return option.data;
    }))) : optionsAccumulator.push(categorizedOption.data), optionsAccumulator;
  }, []);
}
__name(buildFocusableOptionsFromCategorizedOptions, "buildFocusableOptionsFromCategorizedOptions");
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
__name(buildFocusableOptions, "buildFocusableOptions");
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue, data = categorizedOption.data, isSelected = categorizedOption.isSelected, label2 = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label2,
    value,
    data
  }, inputValue);
}
__name(isFocusable, "isFocusable");
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue, lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1)
      return focusedValue;
    if (lastFocusedIndex < nextSelectValue.length)
      return nextSelectValue[lastFocusedIndex];
  }
  return null;
}
__name(getNextFocusedValue, "getNextFocusedValue");
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
__name(getNextFocusedOption, "getNextFocusedOption");
var getOptionLabel2 = /* @__PURE__ */ __name(function(props, data) {
  return props.getOptionLabel(data);
}, "getOptionLabel"), getOptionValue2 = /* @__PURE__ */ __name(function(props, data) {
  return props.getOptionValue(data);
}, "getOptionValue");
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled == "function" ? props.isOptionDisabled(option, selectValue) : !1;
}
__name(_isOptionDisabled, "_isOptionDisabled");
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return !0;
  if (typeof props.isOptionSelected == "function")
    return props.isOptionSelected(option, selectValue);
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
__name(_isOptionSelected, "_isOptionSelected");
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : !0;
}
__name(_filterOption, "_filterOption");
var shouldHideSelectedOptions = /* @__PURE__ */ __name(function(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  return hideSelectedOptions === void 0 ? isMulti : hideSelectedOptions;
}, "shouldHideSelectedOptions"), instanceId = 1, Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    if (_classCallCheck(this, Select2), _this = _super.call(this, _props), _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    }, _this.blockOptionHover = !1, _this.isComposing = !1, _this.commonProps = void 0, _this.initialTouchX = 0, _this.initialTouchY = 0, _this.instancePrefix = "", _this.openAfterFocus = !1, _this.scrollToFocusedOptionOnUpdate = !1, _this.userIsDragging = void 0, _this.controlRef = null, _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    }, _this.focusedOptionRef = null, _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    }, _this.menuListRef = null, _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    }, _this.inputRef = null, _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    }, _this.focus = _this.focusInput, _this.blur = _this.blurInput, _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name, _this.ariaOnChange(newValue, actionMeta), onChange2(newValue, actionMeta);
    }, _this.setValue = function(newValue, action2, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      }), closeMenuOnSelect && (_this.setState({
        inputIsHiddenAfterUpdate: !isMulti
      }), _this.onMenuClose()), _this.setState({
        clearFocusValueOnUpdate: !0
      }), _this.onChange(newValue, {
        action: action2,
        option
      });
    }, _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name, selectValue = _this.state.selectValue, deselected = isMulti && _this.isOptionSelected(newValue, selectValue), isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        }), "deselect-option", newValue);
      } else if (!isDisabled)
        isMulti ? _this.setValue([].concat(_toConsumableArray(selectValue), [newValue]), "select-option", newValue) : _this.setValue(newValue, "select-option");
      else {
        _this.ariaOnChange(newValue, {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      blurInputOnSelect && _this.blurInput();
    }, _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti, selectValue = _this.state.selectValue, candidate = _this.getOptionValue(removedValue), newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      }), newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      }), _this.focusInput();
    }, _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    }, _this.popValue = function() {
      var isMulti = _this.props.isMulti, selectValue = _this.state.selectValue, lastSelectedValue = selectValue[selectValue.length - 1], newValueArray = selectValue.slice(0, selectValue.length - 1), newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    }, _this.getValue = function() {
      return _this.state.selectValue;
    }, _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    }, _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    }, _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    }, _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled, base3 = defaultStyles[key](props, unstyled);
      base3.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base3, props) : base3;
    }, _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    }, _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    }, _this.getComponents = function() {
      return defaultComponents(_this.props);
    }, _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    }, _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    }, _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    }, _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    }, _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    }, _this.onMenuMouseDown = function(event2) {
      event2.button === 0 && (event2.stopPropagation(), event2.preventDefault(), _this.focusInput());
    }, _this.onMenuMouseMove = function(event2) {
      _this.blockOptionHover = !1;
    }, _this.onControlMouseDown = function(event2) {
      if (!event2.defaultPrevented) {
        var openMenuOnClick = _this.props.openMenuOnClick;
        _this.state.isFocused ? _this.props.menuIsOpen ? event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA" && _this.onMenuClose() : openMenuOnClick && _this.openMenu("first") : (openMenuOnClick && (_this.openAfterFocus = !0), _this.focusInput()), event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA" && event2.preventDefault();
      }
    }, _this.onDropdownIndicatorMouseDown = function(event2) {
      if (!(event2 && event2.type === "mousedown" && event2.button !== 0) && !_this.props.isDisabled) {
        var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
        _this.focusInput(), menuIsOpen ? (_this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        }), _this.onMenuClose()) : _this.openMenu("first"), event2.preventDefault();
      }
    }, _this.onClearIndicatorMouseDown = function(event2) {
      event2 && event2.type === "mousedown" && event2.button !== 0 || (_this.clearValue(), event2.preventDefault(), _this.openAfterFocus = !1, event2.type === "touchend" ? _this.focusInput() : setTimeout(function() {
        return _this.focusInput();
      }));
    }, _this.onScroll = function(event2) {
      typeof _this.props.closeMenuOnScroll == "boolean" ? event2.target instanceof HTMLElement && isDocumentElement(event2.target) && _this.props.onMenuClose() : typeof _this.props.closeMenuOnScroll == "function" && _this.props.closeMenuOnScroll(event2) && _this.props.onMenuClose();
    }, _this.onCompositionStart = function() {
      _this.isComposing = !0;
    }, _this.onCompositionEnd = function() {
      _this.isComposing = !1;
    }, _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches, touch = touches && touches.item(0);
      touch && (_this.initialTouchX = touch.clientX, _this.initialTouchY = touch.clientY, _this.userIsDragging = !1);
    }, _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches, touch = touches && touches.item(0);
      if (touch) {
        var deltaX = Math.abs(touch.clientX - _this.initialTouchX), deltaY = Math.abs(touch.clientY - _this.initialTouchY), moveThreshold = 5;
        _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
      }
    }, _this.onTouchEnd = function(event2) {
      _this.userIsDragging || (_this.controlRef && !_this.controlRef.contains(event2.target) && _this.menuListRef && !_this.menuListRef.contains(event2.target) && _this.blurInput(), _this.initialTouchX = 0, _this.initialTouchY = 0);
    }, _this.onControlTouchEnd = function(event2) {
      _this.userIsDragging || _this.onControlMouseDown(event2);
    }, _this.onClearIndicatorTouchEnd = function(event2) {
      _this.userIsDragging || _this.onClearIndicatorMouseDown(event2);
    }, _this.onDropdownIndicatorTouchEnd = function(event2) {
      _this.userIsDragging || _this.onDropdownIndicatorMouseDown(event2);
    }, _this.handleInputChange = function(event2) {
      var prevInputValue = _this.props.inputValue, inputValue = event2.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: !1
      }), _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      }), _this.props.menuIsOpen || _this.onMenuOpen();
    }, _this.onInputFocus = function(event2) {
      _this.props.onFocus && _this.props.onFocus(event2), _this.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (_this.openAfterFocus || _this.props.openMenuOnFocus) && _this.openMenu("first"), _this.openAfterFocus = !1;
    }, _this.onInputBlur = function(event2) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      _this.props.onBlur && _this.props.onBlur(event2), _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      }), _this.onMenuClose(), _this.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, _this.onOptionHover = function(focusedOption) {
      _this.blockOptionHover || _this.state.focusedOption === focusedOption || _this.setState({
        focusedOption
      });
    }, _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    }, _this.onValueInputFocus = function(e2) {
      e2.preventDefault(), e2.stopPropagation(), _this.focus();
    }, _this.onKeyDown = function(event2) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus, _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (!isDisabled && !(typeof onKeyDown == "function" && (onKeyDown(event2), event2.defaultPrevented))) {
        switch (_this.blockOptionHover = !0, event2.key) {
          case "ArrowLeft":
            if (!isMulti || inputValue)
              return;
            _this.focusValue("previous");
            break;
          case "ArrowRight":
            if (!isMulti || inputValue)
              return;
            _this.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (inputValue)
              return;
            if (focusedValue)
              _this.removeValue(focusedValue);
            else {
              if (!backspaceRemovesValue)
                return;
              isMulti ? _this.popValue() : isClearable && _this.clearValue();
            }
            break;
          case "Tab":
            if (_this.isComposing || event2.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue))
              return;
            _this.selectOption(focusedOption);
            break;
          case "Enter":
            if (event2.keyCode === 229)
              break;
            if (menuIsOpen) {
              if (!focusedOption || _this.isComposing)
                return;
              _this.selectOption(focusedOption);
              break;
            }
            return;
          case "Escape":
            menuIsOpen ? (_this.setState({
              inputIsHiddenAfterUpdate: !1
            }), _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            }), _this.onMenuClose()) : isClearable && escapeClearsValue && _this.clearValue();
            break;
          case " ":
            if (inputValue)
              return;
            if (!menuIsOpen) {
              _this.openMenu("first");
              break;
            }
            if (!focusedOption)
              return;
            _this.selectOption(focusedOption);
            break;
          case "ArrowUp":
            menuIsOpen ? _this.focusOption("up") : _this.openMenu("last");
            break;
          case "ArrowDown":
            menuIsOpen ? _this.focusOption("down") : _this.openMenu("first");
            break;
          case "PageUp":
            if (!menuIsOpen)
              return;
            _this.focusOption("pageup");
            break;
          case "PageDown":
            if (!menuIsOpen)
              return;
            _this.focusOption("pagedown");
            break;
          case "Home":
            if (!menuIsOpen)
              return;
            _this.focusOption("first");
            break;
          case "End":
            if (!menuIsOpen)
              return;
            _this.focusOption("last");
            break;
          default:
            return;
        }
        event2.preventDefault();
      }
    }, _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId), _this.state.selectValue = cleanValue(_props.value), _props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions(), optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  return __name(Select2, "Select"), _createClass(Select2, [{
    key: "componentDidMount",
    value: /* @__PURE__ */ __name(function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && scrollIntoView(this.menuListRef, this.focusedOptionRef);
    }, "componentDidMount")
  }, {
    key: "componentDidUpdate",
    value: /* @__PURE__ */ __name(function(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen, isFocused = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) && this.focusInput(), isFocused && isDisabled && !prevProps.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (scrollIntoView(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }, "componentDidUpdate")
  }, {
    key: "componentWillUnmount",
    value: /* @__PURE__ */ __name(function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }, "componentWillUnmount")
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: /* @__PURE__ */ __name(function() {
      this.props.onMenuOpen();
    }, "onMenuOpen")
  }, {
    key: "onMenuClose",
    value: /* @__PURE__ */ __name(function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }, "onMenuClose")
  }, {
    key: "onInputChange",
    value: /* @__PURE__ */ __name(function(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }, "onInputChange")
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: /* @__PURE__ */ __name(function() {
      this.inputRef && this.inputRef.focus();
    }, "focusInput")
  }, {
    key: "blurInput",
    value: /* @__PURE__ */ __name(function() {
      this.inputRef && this.inputRef.blur();
    }, "blurInput")
    // aliased for consumers
  }, {
    key: "openMenu",
    value: /* @__PURE__ */ __name(function(focusOption) {
      var _this2 = this, _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused, focusableOptions = this.buildFocusableOptions(), openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        selectedIndex > -1 && (openAtIndex = selectedIndex);
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }, "openMenu")
  }, {
    key: "focusValue",
    value: /* @__PURE__ */ __name(function(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var focusedIndex = selectValue.indexOf(focusedValue);
        focusedValue || (focusedIndex = -1);
        var lastIndex = selectValue.length - 1, nextFocus = -1;
        if (selectValue.length) {
          switch (direction) {
            case "previous":
              focusedIndex === 0 ? nextFocus = 0 : focusedIndex === -1 ? nextFocus = lastIndex : nextFocus = focusedIndex - 1;
              break;
            case "next":
              focusedIndex > -1 && focusedIndex < lastIndex && (nextFocus = focusedIndex + 1);
              break;
          }
          this.setState({
            inputIsHidden: nextFocus !== -1,
            focusedValue: selectValue[nextFocus]
          });
        }
      }
    }, "focusValue")
  }, {
    key: "focusOption",
    value: /* @__PURE__ */ __name(function() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", pageSize = this.props.pageSize, focusedOption = this.state.focusedOption, options2 = this.getFocusableOptions();
      if (options2.length) {
        var nextFocus = 0, focusedIndex = options2.indexOf(focusedOption);
        focusedOption || (focusedIndex = -1), direction === "up" ? nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1 : direction === "down" ? nextFocus = (focusedIndex + 1) % options2.length : direction === "pageup" ? (nextFocus = focusedIndex - pageSize, nextFocus < 0 && (nextFocus = 0)) : direction === "pagedown" ? (nextFocus = focusedIndex + pageSize, nextFocus > options2.length - 1 && (nextFocus = options2.length - 1)) : direction === "last" && (nextFocus = options2.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: options2[nextFocus],
          focusedValue: null
        });
      }
    }, "focusOption")
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      /* @__PURE__ */ __name(function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(defaultTheme) : _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme) : defaultTheme;
      }, "getTheme")
    )
  }, {
    key: "getCommonProps",
    value: /* @__PURE__ */ __name(function() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props, isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options, hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }, "getCommonProps")
  }, {
    key: "hasValue",
    value: /* @__PURE__ */ __name(function() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }, "hasValue")
  }, {
    key: "hasOptions",
    value: /* @__PURE__ */ __name(function() {
      return !!this.getFocusableOptions().length;
    }, "hasOptions")
  }, {
    key: "isClearable",
    value: /* @__PURE__ */ __name(function() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      return isClearable2 === void 0 ? isMulti : isClearable2;
    }, "isClearable")
  }, {
    key: "isOptionDisabled",
    value: /* @__PURE__ */ __name(function(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }, "isOptionDisabled")
  }, {
    key: "isOptionSelected",
    value: /* @__PURE__ */ __name(function(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }, "isOptionSelected")
  }, {
    key: "filterOption",
    value: /* @__PURE__ */ __name(function(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }, "filterOption")
  }, {
    key: "formatOptionLabel",
    value: /* @__PURE__ */ __name(function(data, context) {
      if (typeof this.props.formatOptionLabel == "function") {
        var _inputValue = this.props.inputValue, _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else
        return this.getOptionLabel(data);
    }, "formatOptionLabel")
  }, {
    key: "formatGroupLabel",
    value: /* @__PURE__ */ __name(function(data) {
      return this.props.formatGroupLabel(data);
    }, "formatGroupLabel")
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      /* @__PURE__ */ __name(function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }, "startListeningComposition")
    )
  }, {
    key: "stopListeningComposition",
    value: /* @__PURE__ */ __name(function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }, "stopListeningComposition")
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      /* @__PURE__ */ __name(function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }, "startListeningToTouch")
    )
  }, {
    key: "stopListeningToTouch",
    value: /* @__PURE__ */ __name(function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }, "stopListeningToTouch")
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      /* @__PURE__ */ __name(function() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required, _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input, _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection, commonProps = this.commonProps, id2 = inputId || this.getElementId("input"), ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": !0
        }), this.hasValue() ? (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return isSearchable ? /* @__PURE__ */ reactExports.createElement(Input4, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes)) : /* @__PURE__ */ reactExports.createElement(DummyInput, _extends({
          id: id2,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          disabled: isDisabled,
          tabIndex,
          inputMode: "none",
          form,
          value: ""
        }, ariaAttributes));
      }, "renderInput")
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: /* @__PURE__ */ __name(function() {
      var _this3 = this, _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder, commonProps = this.commonProps, _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder, _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue)
        return inputValue ? null : /* @__PURE__ */ reactExports.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      if (isMulti)
        return selectValue.map(function(opt, index) {
          var isOptionFocused = opt === focusedValue, key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ reactExports.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index,
            removeProps: {
              onClick: /* @__PURE__ */ __name(function() {
                return _this3.removeValue(opt);
              }, "onClick"),
              onTouchEnd: /* @__PURE__ */ __name(function() {
                return _this3.removeValue(opt);
              }, "onTouchEnd"),
              onMouseDown: /* @__PURE__ */ __name(function(e2) {
                e2.preventDefault();
              }, "onMouseDown")
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      if (inputValue)
        return null;
      var singleValue = selectValue[0];
      return /* @__PURE__ */ reactExports.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }, "renderPlaceholderOrValue")
  }, {
    key: "renderClearIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator, commonProps = this.commonProps, _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading, isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading)
        return null;
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }, "renderClearIndicator")
  }, {
    key: "renderLoadingIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator, commonProps = this.commonProps, _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading, isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }, "renderLoadingIndicator")
  }, {
    key: "renderIndicatorSeparator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps, isDisabled = this.props.isDisabled, isFocused = this.state.isFocused;
      return /* @__PURE__ */ reactExports.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }, "renderIndicatorSeparator")
  }, {
    key: "renderDropdownIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps, isDisabled = this.props.isDisabled, isFocused = this.state.isFocused, innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }, "renderDropdownIndicator")
  }, {
    key: "renderMenu",
    value: /* @__PURE__ */ __name(function() {
      var _this4 = this, _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option, commonProps = this.commonProps, focusedOption = this.state.focusedOption, _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = /* @__PURE__ */ __name(function(props, id2) {
        var type2 = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label2 = props.label, value = props.value, isFocused = focusedOption === data, onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        }, onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        }, optionId = "".concat(_this4.getElementId("option"), "-").concat(id2), innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ reactExports.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label: label2,
          type: type2,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      }, "render"), menuUI;
      if (this.hasOptions())
        menuUI = this.getCategorizedOptions().map(function(item2) {
          if (item2.type === "group") {
            var _data = item2.data, options2 = item2.options, groupIndex = item2.index, groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex), headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ reactExports.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item2.data
              },
              label: _this4.formatGroupLabel(item2.data)
            }), item2.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item2.type === "option")
            return render(item2, "".concat(item2.index));
        });
      else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      }, menuElement = /* @__PURE__ */ reactExports.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ reactExports.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ reactExports.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ reactExports.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: /* @__PURE__ */ __name(function(instance2) {
              _this4.getMenuListRef(instance2), scrollTargetRef(instance2);
            }, "innerRef"),
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ reactExports.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }, "renderMenu")
  }, {
    key: "renderFormField",
    value: /* @__PURE__ */ __name(function() {
      var _this5 = this, _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required, selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled)
        return /* @__PURE__ */ reactExports.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      if (!(!name || isDisabled))
        if (isMulti)
          if (delimiter2) {
            var value = selectValue.map(function(opt) {
              return _this5.getOptionValue(opt);
            }).join(delimiter2);
            return /* @__PURE__ */ reactExports.createElement("input", {
              name,
              type: "hidden",
              value
            });
          } else {
            var input2 = selectValue.length > 0 ? selectValue.map(function(opt, i) {
              return /* @__PURE__ */ reactExports.createElement("input", {
                key: "i-".concat(i),
                name,
                type: "hidden",
                value: _this5.getOptionValue(opt)
              });
            }) : /* @__PURE__ */ reactExports.createElement("input", {
              name,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ reactExports.createElement("div", null, input2);
          }
        else {
          var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
          return /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value: _value
          });
        }
    }, "renderFormField")
  }, {
    key: "renderLiveRegion",
    value: /* @__PURE__ */ __name(function() {
      var commonProps = this.commonProps, _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue, focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ reactExports.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }, "renderLiveRegion")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer, _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen, isFocused = this.state.isFocused, commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ reactExports.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ reactExports.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ reactExports.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ reactExports.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }, "render")
  }], [{
    key: "getDerivedStateFromProps",
    value: /* @__PURE__ */ __name(function(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused, options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti, selectValue = cleanValue(value), newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [], focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null, focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: !1
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {}, newAriaSelection = ariaSelection, hasKeptFocus = isFocused && prevWasFocused;
      return isFocused && !hasKeptFocus && (newAriaSelection = {
        value: valueTernary(isMulti, selectValue, selectValue[0] || null),
        options: selectValue,
        action: "initial-input-focus"
      }, hasKeptFocus = !prevWasFocused), (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus" && (newAriaSelection = null), _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }, "getDerivedStateFromProps")
  }]), Select2;
}(reactExports.Component);
Select.defaultProps = defaultProps;
var StateManagedSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends({
    ref
  }, baseSelectProps));
}), StateManagedSelect$1 = StateManagedSelect;
const balance = "_balance_17xkv_1", balanceSingleValue = "_balanceSingleValue_17xkv_1", dropdown$2 = "_dropdown_17xkv_11", select$4 = "_select_17xkv_20", selectLabelText$1 = "_selectLabelText_17xkv_66", singleValueContainer$1 = "_singleValueContainer_17xkv_70", valueContainer = "_valueContainer_17xkv_78", styles$m = {
  balance,
  balanceSingleValue,
  dropdown: dropdown$2,
  select: select$4,
  selectLabelText: selectLabelText$1,
  singleValueContainer: singleValueContainer$1,
  valueContainer
}, SelectSingleValue$1 = /* @__PURE__ */ __name((props) => {
  const { hideAmounts } = reactExports.useContext(AppContext), { label: label2, coinCode, balance: balance2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$m.singleValueContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.selectLabelText, children: label2 }),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.balanceSingleValue, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) }) });
}, "SelectSingleValue$1"), SelectOption$1 = /* @__PURE__ */ __name((props) => {
  const { hideAmounts } = reactExports.useContext(AppContext), { label: label2, coinCode, balance: balance2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.selectLabelText, children: label2 }),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.balance, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) });
}, "SelectOption$1"), DropdownIndicator$2 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$m.dropdown }) }), "DropdownIndicator$2"), AccountSelector = /* @__PURE__ */ __name(({ title: title2, disabled: disabled2, options: options2, selected: selected2, onChange: onChange2, onProceed }) => {
  const { t: t2 } = useTranslation(), [selectedAccount, setSelectedAccount] = reactExports.useState();
  return reactExports.useEffect(() => {
    setSelectedAccount(options2.find((opt) => opt.value === selected2));
  }, [options2, selected2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title text-center", children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        className: styles$m.select,
        classNamePrefix: "react-select",
        components: { DropdownIndicator: DropdownIndicator$2, SingleValue: SelectSingleValue$1, Option: SelectOption$1, IndicatorSeparator: () => null },
        value: selected2 === "" ? {
          label: t2("buy.info.selectLabel"),
          value: "choose",
          disabled: !0
        } : selectedAccount,
        isSearchable: !1,
        onChange: (e2) => {
          const value = (e2 == null ? void 0 : e2.value) || "";
          onChange2(value);
        },
        isOptionDisabled: (option) => option.disabled,
        options: [
          {
            label: t2("buy.info.selectLabel") || "",
            value: "choose",
            disabled: !0
          },
          ...options2
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onProceed,
        disabled: !selected2 || disabled2,
        children: t2("buy.info.next")
      }
    ) })
  ] });
}, "AccountSelector"), button$2 = "_button_1riw8_1", styles$l = {
  button: button$2
}, HideAmountsButton = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { hideAmounts, toggleHideAmounts } = reactExports.useContext(AppContext), config = useLoad(getConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: config && config.frontend.allowHideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$l.button, onClick: toggleHideAmounts, transparent: !0, children: hideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeClosed, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.showAmounts") })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpened, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.hideAmounts") })
  ] }) }) : null });
}, "HideAmountsButton"), BuyInfo = /* @__PURE__ */ __name(({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code), [options2, setOptions] = reactExports.useState(), [disabled2, setDisabled] = reactExports.useState(!1), { t: t2 } = useTranslation(), checkSupportedCoins = reactExports.useCallback(async () => {
    try {
      const options22 = (await getExchangeSupportedAccounts(accounts)).map(({ name: name2, code: code2, coinCode }) => ({ label: `${name2}`, value: code2, coinCode, disabled: !1 }));
      setOptions(options22), getBalances(options22);
    } catch (e2) {
      console.error(e2);
    }
  }, [accounts]), maybeProceed = reactExports.useCallback(async () => {
    if (options2 !== void 0 && options2.length === 1) {
      const accountCode = options2[0].value;
      if (!(await connectKeystore(accountCode)).success)
        return;
      route(`/buy/exchange/${accountCode}`);
    }
  }, [options2]), handleChangeAccount = /* @__PURE__ */ __name((selected22) => {
    setSelected(selected22);
  }, "handleChangeAccount");
  reactExports.useEffect(() => {
    checkSupportedCoins();
  }, [checkSupportedCoins]), reactExports.useEffect(() => {
    maybeProceed();
  }, [maybeProceed, options2]);
  const getBalances = /* @__PURE__ */ __name((options22) => {
    Promise.all(options22.map((option) => getBalance(option.value).then((balance2) => ({ ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` })))).then((options3) => {
      setOptions(options3);
    });
  }, "getBalances"), handleProceed = /* @__PURE__ */ __name(async () => {
    setDisabled(!0);
    try {
      if (!(await connectKeystore(selected2)).success)
        return;
    } finally {
      setDisabled(!1);
    }
    route(`/buy/exchange/${selected2}`);
  }, "handleProceed");
  if (options2 === void 0)
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") });
  const account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: options2.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: t2("accountSummary.noAccount") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        AccountSelector,
        {
          title: t2("buy.title", { name }),
          disabled: disabled2,
          options: options2,
          selected: selected2,
          onChange: handleChangeAccount,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] }) });
}, "BuyInfo");
const button$1 = "_button_diw5d_1", style$I = {
  button: button$1
}, InfoButton = /* @__PURE__ */ __name(({ onClick, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick, ...props, className: style$I.button, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BuyInfo$1, {}) }), "InfoButton"), container$k = "_container_1ksto_17", paymentMethodContainer = "_paymentMethodContainer_1ksto_17", exchangeName = "_exchangeName_1ksto_21", infoButton = "_infoButton_1ksto_25", outerContainer$1 = "_outerContainer_1ksto_37", paymentMethodsContainer = "_paymentMethodsContainer_1ksto_41", paymentMethodName = "_paymentMethodName_1ksto_47", radio = "_radio_1ksto_67", radioLabel = "_radioLabel_1ksto_123", text$1 = "_text_1ksto_127", style$H = {
  container: container$k,
  paymentMethodContainer,
  exchangeName,
  infoButton,
  outerContainer: outerContainer$1,
  paymentMethodsContainer,
  paymentMethodName,
  radio,
  radioLabel,
  text: text$1
}, PaymentMethod = /* @__PURE__ */ __name(({ methodName }) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode();
  switch (methodName) {
    case "bank-transfer":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$H.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Bank, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BankDark, {}),
        t2("buy.exchange.bankTransfer")
      ] });
    case "card":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$H.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCardDark, {}),
        t2("buy.exchange.creditCard")
      ] });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: methodName });
  }
}, "PaymentMethod"), Deal = /* @__PURE__ */ __name(({ deal }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.paymentMethodContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, { methodName: deal.payment }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      deal.isBestDeal && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "success", children: t2("buy.exchange.bestDeal") }),
      deal.isFast && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "warning", children: t2("buy.exchange.fast") })
    ] })
  ] });
}, "Deal");
function ExchangeSelectionRadio({
  disabled: disabled2 = !1,
  id: id2,
  children: children2,
  checked: checked2,
  deals,
  onChange: onChange2,
  exchangeName: exchangeName2,
  onClickInfoButton,
  ...props
}) {
  const handleClick = /* @__PURE__ */ __name(() => {
    disabled2 || onChange2();
  }, "handleClick"), handleKeyDown = /* @__PURE__ */ __name((e2) => {
    !disabled2 && e2.key === "Enter" && onChange2();
  }, "handleKeyDown");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.outerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "aria-checked": checked2, onKeyDown: handleKeyDown, "aria-disabled": disabled2, role: "radio", tabIndex: 0, onClick: handleClick, className: style$H.radio, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          checked: checked2,
          type: "radio",
          id: id2,
          disabled: disabled2,
          onChange: onChange2,
          ...props
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: style$H.radioLabel, htmlFor: id2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$H.text, style$H.exchangeName].join(" "), children: getFormattedName(exchangeName2) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$H.paymentMethodsContainer, children: deals.map((deal) => /* @__PURE__ */ jsxRuntimeExports.jsx(Deal, { deal }, deal.payment)) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => onClickInfoButton(exchangeName2) })
  ] });
}
__name(ExchangeSelectionRadio, "ExchangeSelectionRadio");
const container$j = "_container_h94uh_1", style$G = {
  container: container$j
}, MoonPayInfo = /* @__PURE__ */ __name(({ cardFee, bankTransferFee }) => {
  const { t: t2 } = useTranslation(), formattedCardFee = cardFee && cardFee * 100, formattedBankTransferFee = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$G.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-", children: t2("buy.exchange.infoContent.moonpay.fullCurrenciesList") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCard") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCardDetails.cards") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.pix") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: t2("buy.exchange.infoContent.moonpay.payment.asteriskText") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/4406210084113-What-payment-methods-do-you-support-", children: t2("buy.exchange.infoContent.moonpay.payment.learnMore") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.creditDebitCard", { fee: formattedCardFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.bankTransfer", { fee: formattedBankTransferFee }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/", children: t2("buy.exchange.infoContent.moonpay.fees.learnMore") }) })
  ] });
}, "MoonPayInfo"), PocketInfo = /* @__PURE__ */ __name(({ bankTransferFee }) => {
  const { t: t2 } = useTranslation(), fee2 = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$G.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sic") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/how-do-I-set-up-my-standing-order", children: t2("buy.exchange.infoContent.pocket.payment.bankTransferReccuring") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.verification.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.verification.info") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/are-there-any-limits-with-pocket", children: t2("buy.exchange.infoContent.pocket.verification.link") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.fees.info", { fee: fee2 }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/", children: t2("buy.exchange.infoContent.pocket.learnMore") }) })
  ] });
}, "PocketInfo"), RegionInfo = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.region.title") }) });
}, "RegionInfo"), InfoContent = /* @__PURE__ */ __name(({ info: info2, cardFee, bankTransferFee }) => {
  switch (info2) {
    case "moonpay":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MoonPayInfo, { cardFee, bankTransferFee });
    case "pocket":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PocketInfo, { bankTransferFee });
    case "region":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RegionInfo, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
}, "InfoContent"), buttonBack = "_buttonBack_62uya_17", buttonsContainer$1 = "_buttonsContainer_62uya_21", container$i = "_container_62uya_27", exchangeContainer = "_exchangeContainer_62uya_31", header$3 = "_header_62uya_44", selectContainer = "_selectContainer_62uya_49", label$5 = "_label_62uya_62", noExchangeText = "_noExchangeText_62uya_69", radioButtonsContainer = "_radioButtonsContainer_62uya_77", title$4 = "_title_62uya_81", style$F = {
  buttonBack,
  buttonsContainer: buttonsContainer$1,
  container: container$i,
  exchangeContainer,
  header: header$3,
  selectContainer,
  label: label$5,
  noExchangeText,
  radioButtonsContainer,
  title: title$4
}, dropdown$1 = "_dropdown_9chnx_1", flag = "_flag_9chnx_10", globe = "_globe_9chnx_14", optionsContainer = "_optionsContainer_9chnx_20", select$3 = "_select_9chnx_25", selectLabelText = "_selectLabelText_9chnx_59", singleValueContainer = "_singleValueContainer_9chnx_64", styles$k = {
  dropdown: dropdown$1,
  flag,
  globe,
  optionsContainer,
  select: select$3,
  selectLabelText,
  singleValueContainer
}, SelectedRegionIcon = /* @__PURE__ */ __name(({ regionCode }) => {
  const { isDarkMode } = useDarkmode(), globe2 = isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeLight, { className: styles$k.globe }) : /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeDark, { className: styles$k.globe });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: regionCode === "" ? globe2 : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `fi fi-${regionCode} ${styles$k.flag}` }) });
}, "SelectedRegionIcon"), SelectSingleValue = /* @__PURE__ */ __name((props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.singleValueContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }) })
  ] });
}, "SelectSingleValue"), SelectOption = /* @__PURE__ */ __name((props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.optionsContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 })
  ] }) });
}, "SelectOption"), DropdownIndicator$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.dropdown }) }), "DropdownIndicator$1"), CountrySelect = /* @__PURE__ */ __name(({ onChangeRegion, regions, selectedRegion }) => {
  const { t: t2 } = useTranslation(), formattedRegionName = new Intl.DisplayNames([instance.language], { type: "region" }).of(selectedRegion) || "", selectedRegionName = selectedRegion === "" ? t2("buy.exchange.selectRegion") : formattedRegionName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: styles$k.select,
      classNamePrefix: "react-select",
      components: { DropdownIndicator: DropdownIndicator$1, SingleValue: SelectSingleValue, Option: SelectOption, IndicatorSeparator: () => null },
      defaultValue: { label: selectedRegionName, value: selectedRegion },
      isSearchable: !0,
      onChange: (e2) => onChangeRegion(e2),
      options: [
        {
          label: t2("buy.exchange.selectRegion") || "",
          value: ""
        },
        ...regions
      ]
    }
  );
}, "CountrySelect"), Exchange = /* @__PURE__ */ __name(({ code, accounts }) => {
  var _a46, _b, _c;
  const { t: t2 } = useTranslation(), [showPocket, setShowPocket] = reactExports.useState(!1), [showMoonpay, setShowMoonpay] = reactExports.useState(!1), [selectedRegion, setSelectedRegion] = reactExports.useState(""), [selectedExchange, setSelectedExchange] = reactExports.useState(""), [regions, setRegions] = reactExports.useState([]), [allExchangeDeals, setAllExchanges] = reactExports.useState(), [info2, setInfo] = reactExports.useState(), [supportedAccounts, setSupportedAccounts] = reactExports.useState([]), regionList = useLoad(getExchangesByRegion(code)), exchangeDeals = useLoad(getExchangeDeals), nativeLocale = useLoad(getNativeLocale), supportedExchanges = useLoad(getExchangeBuySupported(code)), config = useLoad(getConfig), account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2), hasOnlyOneSupportedExchange = allExchangeDeals ? allExchangeDeals.exchanges.filter((exchange) => exchange.supported).length === 1 : !1;
  reactExports.useEffect(() => {
    getExchangeSupportedAccounts(accounts).then(setSupportedAccounts);
  }, [accounts]), reactExports.useEffect(() => {
    if (!regionList || !config)
      return;
    const regionNames = new Intl.DisplayNames([instance.language], { type: "region" }) || "", regions2 = regionList.regions.map((region) => ({ value: region.code, label: regionNames.of(region.code) }));
    if (regions2.sort((a2, b2) => a2.label.localeCompare(b2.label, instance.language)), setRegions(regions2), config.frontend.selectedExchangeRegion === "")
      return;
    if (config.frontend.selectedExchangeRegion) {
      setSelectedRegion(config.frontend.selectedExchangeRegion);
      return;
    }
    const userRegion = getRegionNameFromLocale(nativeLocale || ""), regionAvailable = !!regionList.regions.find((region) => region.code === userRegion);
    setSelectedRegion(regionAvailable ? userRegion : "");
  }, [regionList, config, nativeLocale]), reactExports.useEffect(() => {
    if (!exchangeDeals)
      return;
    const deals = { exchanges: exchangeDeals.exchanges.map((ex) => ({ ...ex, supported: ex.exchangeName === "pocket" ? showPocket : showMoonpay })) }, lowestFee = findLowestFee(deals), exchangesWithBestDeal = findBestDeal(deals, lowestFee);
    setAllExchanges(exchangesWithBestDeal);
  }, [selectedRegion, showMoonpay, showPocket, exchangeDeals]), reactExports.useEffect(() => {
    if (hasOnlyOneSupportedExchange && allExchangeDeals && selectedRegion !== "") {
      const exchange = allExchangeDeals.exchanges.filter((exchange2) => exchange2.supported);
      setSelectedExchange(exchange[0].exchangeName);
    }
  }, [hasOnlyOneSupportedExchange, allExchangeDeals, selectedRegion]), reactExports.useEffect(() => {
    if (setSelectedExchange(""), !supportedExchanges) {
      setShowPocket(!1), setShowMoonpay(!1);
      return;
    }
    if (selectedRegion === "") {
      setShowPocket(supportedExchanges.exchanges.includes("pocket")), setShowMoonpay(supportedExchanges.exchanges.includes("moonpay"));
      return;
    }
    regionList && (setShowPocket(!1), setShowMoonpay(!1), regionList.regions.forEach((region) => {
      if (region.code === selectedRegion) {
        setShowPocket(region.isPocketEnabled), setShowMoonpay(region.isMoonpayEnabled);
        return;
      }
    }));
  }, [selectedRegion, regionList, supportedExchanges]);
  const goToExchange = /* @__PURE__ */ __name(() => {
    selectedExchange && route(`/buy/${selectedExchange}/${code}`);
  }, "goToExchange"), handleChangeRegion = /* @__PURE__ */ __name((newValue) => {
    if (newValue) {
      const selectedRegion2 = newValue.value;
      setSelectedRegion(selectedRegion2), setConfig({ frontend: { selectedExchangeRegion: selectedRegion2 } });
    }
  }, "handleChangeRegion"), noExchangeAvailable = !showMoonpay && !showPocket, infoFeesDetail = (_a46 = exchangeDeals == null ? void 0 : exchangeDeals.exchanges.find((exchange) => exchange.exchangeName === info2)) == null ? void 0 : _a46.deals, cardFee = infoFeesDetail && ((_b = infoFeesDetail.find((feeDetail) => feeDetail.payment === "card")) == null ? void 0 : _b.fee), bankTransferFee = infoFeesDetail && ((_c = infoFeesDetail.find((feeDetail) => feeDetail.payment === "bank-transfer")) == null ? void 0 : _c.fee);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { medium: !0, title: info2 && info2 !== "region" ? getFormattedName(info2) : t2("buy.exchange.region"), onClose: () => setInfo(void 0), open: !!info2, children: info2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoContent, { info: info2, cardFee, bankTransferFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.exchange.title", { name }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$F.exchangeContainer, "content", "narrow", "isVerticallyCentered"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$F.title, children: t2("buy.title", { name }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$F.label, children: t2("buy.exchange.region") }),
          regions.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.selectContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CountrySelect,
                {
                  onChangeRegion: handleChangeRegion,
                  regions,
                  selectedRegion
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => setInfo("region") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.radioButtonsContainer, children: [
              noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$F.noExchangeText, children: t2("buy.exchange.noExchanges") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !noExchangeAvailable && allExchangeDeals && allExchangeDeals.exchanges.map((exchange) => exchange.supported && /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExchangeSelectionRadio,
                {
                  id: exchange.exchangeName,
                  exchangeName: exchange.exchangeName,
                  deals: exchange.deals,
                  checked: selectedExchange === exchange.exchangeName,
                  onChange: () => setSelectedExchange(exchange.exchangeName),
                  onClickInfoButton: setInfo
                },
                exchange.exchangeName
              )) }),
              !noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.buttonsContainer, children: [
                supportedAccounts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: style$F.buttonBack,
                    secondary: !0,
                    onClick: () => route("/buy/info"),
                    children: t2("button.back")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    primary: !0,
                    disabled: !selectedExchange,
                    onClick: goToExchange,
                    children: t2("button.next")
                  }
                )
              ] })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0 })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] });
}, "Exchange");
var dist = {}, utils$1 = {};
Object.defineProperty(utils$1, "__esModule", { value: !0 });
utils$1.isOneOf = utils$1.isLiteral = utils$1.isNullish = utils$1.isBoolean = utils$1.isString = utils$1.isObject = void 0;
function isObject(value) {
  return Object(value) === value;
}
__name(isObject, "isObject");
utils$1.isObject = isObject;
function isString(value) {
  return typeof value == "string";
}
__name(isString, "isString");
utils$1.isString = isString;
function isBoolean(value) {
  return typeof value == "boolean";
}
__name(isBoolean, "isBoolean");
utils$1.isBoolean = isBoolean;
function isNullish(value) {
  return value == null;
}
__name(isNullish, "isNullish");
utils$1.isNullish = isNullish;
function isLiteral(value, literal) {
  return value === literal;
}
__name(isLiteral, "isLiteral");
utils$1.isLiteral = isLiteral;
function isOneOf(value, ...literal) {
  return literal.some((l2) => l2 === value);
}
__name(isOneOf, "isOneOf");
utils$1.isOneOf = isOneOf;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.parseMessage = exports.serializeMessage = exports.V0MessageScriptType = exports.V0MessageType = exports.MessageVersion = void 0;
  const utils_1 = utils$1;
  var MessageVersion;
  (function(MessageVersion2) {
    MessageVersion2.V0 = "0";
  })(MessageVersion = exports.MessageVersion || (exports.MessageVersion = {}));
  var V0MessageType;
  (function(V0MessageType2) {
    V0MessageType2.RequestAddress = "requestAddress", V0MessageType2.RequestExtendedPublicKey = "requestExtendedPublicKey", V0MessageType2.VerifyAddress = "verifyAddress", V0MessageType2.Address = "address", V0MessageType2.ExtendedPublicKey = "extendedPublicKey";
  })(V0MessageType = exports.V0MessageType || (exports.V0MessageType = {}));
  var V0MessageScriptType;
  (function(V0MessageScriptType2) {
    V0MessageScriptType2.P2PKH = "p2pkh", V0MessageScriptType2.P2WPKH = "p2wpkh", V0MessageScriptType2.P2SH = "p2sh", V0MessageScriptType2.P2TR = "p2tr";
  })(V0MessageScriptType = exports.V0MessageScriptType || (exports.V0MessageScriptType = {}));
  function serializeMessage(message2) {
    return JSON.stringify(message2);
  }
  __name(serializeMessage, "serializeMessage"), exports.serializeMessage = serializeMessage;
  function parseMessage(value) {
    let object = value;
    if (typeof object == "string")
      try {
        object = JSON.parse(object);
      } catch {
        throw new Error("could not parse as json");
      }
    if (!(0, utils_1.isObject)(object))
      throw new Error("not an object");
    const { version } = object;
    if ((0, utils_1.isLiteral)(version, MessageVersion.V0)) {
      const { type: type2 } = object;
      if (!(0, utils_1.isOneOf)(type2, ...Object.values(V0MessageType)))
        throw new Error("invalid type");
      if (type2 === V0MessageType.RequestAddress) {
        const { withMessageSignature } = object;
        if (!(0, utils_1.isString)(withMessageSignature) && !(0, utils_1.isNullish)(withMessageSignature))
          throw new Error("message signature indicator invalid");
        const { withExtendedPublicKey } = object;
        if (!(0, utils_1.isBoolean)(withExtendedPublicKey) && !(0, utils_1.isNullish)(withExtendedPublicKey))
          throw new Error("extended public key indicator invalid");
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType))
          throw new Error("script type indicator invalid");
        return {
          version,
          type: type2,
          withMessageSignature,
          withExtendedPublicKey,
          withScriptType
        };
      } else if (type2 === V0MessageType.RequestExtendedPublicKey) {
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType))
          throw new Error("script type indicator invalid");
        return {
          version,
          type: type2,
          withScriptType
        };
      } else if (type2 === V0MessageType.VerifyAddress) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress))
          throw new Error("bitcoin address missing");
        return {
          version,
          type: type2,
          bitcoinAddress
        };
      } else if (type2 === V0MessageType.Address) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress))
          throw new Error("bitcoin address missing");
        const { signature } = object;
        if (!(0, utils_1.isString)(signature) && !(0, utils_1.isNullish)(signature))
          throw new Error("signature invalid");
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey) && !(0, utils_1.isNullish)(extendedPublicKey))
          throw new Error("extended public key invalid");
        return {
          version,
          type: type2,
          bitcoinAddress,
          signature,
          extendedPublicKey
        };
      } else if (type2 === V0MessageType.ExtendedPublicKey) {
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey))
          throw new Error("extended public key missing");
        return {
          version,
          type: type2,
          extendedPublicKey
        };
      } else
        throw new Error("unsupported type");
    }
    throw new Error("unsupported version");
  }
  __name(parseMessage, "parseMessage"), exports.parseMessage = parseMessage;
})(dist);
const overlay = "_overlay_12k4v_1", activeOverlay = "_activeOverlay_12k4v_16", modal = "_modal_12k4v_20", activeModal = "_activeModal_12k4v_32", active$2 = "_active_12k4v_16", small = "_small_12k4v_38", medium = "_medium_12k4v_43", large = "_large_12k4v_49", header$2 = "_header_12k4v_54", centered = "_centered_12k4v_64", title$3 = "_title_12k4v_68", closeButton = "_closeButton_12k4v_74", contentContainer$1 = "_contentContainer_12k4v_95", slim = "_slim_12k4v_101", padded = "_padded_12k4v_105", content$1 = "_content_12k4v_95", actions = "_actions_12k4v_113", confirmationLabel = "_confirmationLabel_12k4v_131", confirmationLabelNumber = "_confirmationLabelNumber_12k4v_140", disabledLabel = "_disabledLabel_12k4v_146", noStep = "_noStep_12k4v_151", confirmationInstructions = "_confirmationInstructions_12k4v_155", confirm = "_confirm_12k4v_131", image = "_image_12k4v_175", modalContent = "_modalContent_12k4v_180", detail$1 = "_detail_12k4v_189", description = "_description_12k4v_213", buttons$2 = "_buttons_12k4v_217", dialogButtons = "_dialogButtons_12k4v_229", style$E = {
  overlay,
  activeOverlay,
  modal,
  activeModal,
  active: active$2,
  small,
  medium,
  large,
  header: header$2,
  centered,
  title: title$3,
  closeButton,
  contentContainer: contentContainer$1,
  slim,
  padded,
  content: content$1,
  actions,
  confirmationLabel,
  confirmationLabelNumber,
  disabledLabel,
  noStep,
  confirmationInstructions,
  confirm,
  image,
  modalContent,
  detail: detail$1,
  description,
  buttons: buttons$2,
  dialogButtons
}, _DialogLegacy = class _DialogLegacy extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.modalContent = reactExports.createRef(), this.state = {
      active: !1,
      currentTab: 0
    }, this.handleFocus = (e2) => {
      const index = e2.target.getAttribute("index");
      this.setState({ currentTab: Number(index) });
    }, this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables)
          c2.classList.add("tabbable"), c2.setAttribute("index", focusables.indexOf(c2).toString()), c2.addEventListener("focus", this.handleFocus);
        document.addEventListener("keydown", this.handleKeyDown);
      }
    }, this.focusFirst = () => {
      const focusables = this.focusableChildren;
      focusables.length && focusables[0].getAttribute("autofocus") !== "false" && focusables[0].focus();
    }, this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    }, this.handleKeyDown = (e2) => {
      const { disableEscape } = this.props, isEsc = e2.keyCode === 27, isTab = e2.keyCode === 9;
      !disableEscape && isEsc ? this.deactivate() : isTab && e2.preventDefault(), isTab && e2.shiftKey ? this.updateIndex(!1) : isTab && this.updateIndex(!0);
    }, this.deactivate = () => {
      !this.modal.current || !this.overlay.current || (this.modal.current.classList.remove(style$E.activeModal), this.overlay.current.classList.remove(style$E.activeOverlay), this.setState({ active: !1, currentTab: 0 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown), this.props.onClose && this.props.onClose();
      }));
    }, this.activate = () => {
      this.setState({ active: !0 }, () => {
        !this.modal.current || !this.overlay.current || (this.overlay.current.classList.add(style$E.activeOverlay), this.modal.current.classList.add(style$E.activeModal), this.focusWithin(), this.focusFirst());
      });
    };
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state, focusables = Array.from(this.focusableChildren), arr = isNext ? focusables : focusables.reverse(), current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    return next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled")), next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2, isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props, isSmall = small2 ? style$E.small : "", isMedium = medium2 ? style$E.medium : "", isLarge = large2 ? style$E.large : "", isSlim = slim2 ? style$E.slim : "", isCentered = centered2 && !onClose ? style$E.centered : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$E.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$E.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$E.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$E.closeButton, onClick: this.deactivate, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$E.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
};
__name(_DialogLegacy, "DialogLegacy");
let DialogLegacy = _DialogLegacy;
function DialogButtons({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.dialogButtons, children: children2 });
}
__name(DialogButtons, "DialogButtons");
let confirmation;
const Confirm = /* @__PURE__ */ __name(() => {
  const [state, setState] = reactExports.useState({ active: !1 }), { t: t2 } = useTranslation(), callback2 = reactExports.useRef(() => {
  });
  confirmation = /* @__PURE__ */ __name((message22, cb2, customButtonText2) => {
    callback2.current = cb2, setState({
      active: !0,
      message: message22,
      customButtonText: customButtonText2
    });
  }, "confirmation");
  const respond = /* @__PURE__ */ __name((response) => {
    callback2.current(response), setState({
      active: !1
    });
  }, "respond"), { message: message2, active: active2, customButtonText } = state;
  return active2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("dialog.confirmTitle"), onClose: () => respond(!1), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: message2 ? message2.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: i === 0 ? "first" : "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: line2 })
      },
      i
    )) : null }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: () => respond(!0), children: customButtonText || t2("dialog.confirm") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => respond(!1), children: t2("dialog.cancel") })
    ] })
  ] }) : null;
}, "Confirm"), PocketTerms = /* @__PURE__ */ __name(({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation(), handleSkipDisclaimer = /* @__PURE__ */ __name((e2) => {
    setConfig({ frontend: { skipPocketDisclaimer: e2.target.checked } });
  }, "handleSkipDisclaimer");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.welcome.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.security.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.pocket.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.kyc.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.kyc.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq", children: t2("buy.pocket.kyc.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.data.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.data.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/policy/privacy", children: t2("buy.pocket.data.link") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
}, "PocketTerms"), Pocket = /* @__PURE__ */ __name(({ code }) => {
  const { t: t2 } = useTranslation(), [height, setHeight] = reactExports.useState(0), [iframeLoaded, setIframeLoaded] = reactExports.useState(!1), [agreedTerms, setAgreedTerms] = reactExports.useState(!1), [verifying, setVerifying] = reactExports.useState(!1), iframeURL = useLoad(getPocketURL), config = useLoad(getConfig), accountInfo2 = useLoad(getInfo(code)), ref = reactExports.createRef(), iframeRef = reactExports.createRef();
  let signing = !1, resizeTimerID;
  const name = "Bitcoin";
  reactExports.useEffect(() => {
    config && setAgreedTerms(config.frontend.skipPocketDisclaimer);
  }, [config]), reactExports.useEffect(() => (onResize(), window.addEventListener("resize", onResize), window.addEventListener("message", onMessage), () => {
    window.removeEventListener("resize", onResize), window.removeEventListener("message", onMessage);
  }));
  const onResize = /* @__PURE__ */ __name(() => {
    resizeTimerID && clearTimeout(resizeTimerID), resizeTimerID = setTimeout(() => {
      ref.current && setHeight(ref.current.offsetHeight);
    }, 200);
  }, "onResize"), sendAddress = /* @__PURE__ */ __name((address2, sig) => {
    var _a46;
    const { current } = iframeRef;
    if (!current)
      return;
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      signature: sig
    });
    (_a46 = current.contentWindow) == null || _a46.postMessage(message2, "*");
  }, "sendAddress"), handleRequestAddress = /* @__PURE__ */ __name((message2) => {
    signing = !0;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "", withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = !1, response.success ? sendAddress(response.address, response.signature) : response.errorCode !== "userAbort" && (alertUser(t2("unknownError", { errorMessage: response.errorMessage })), console.log("error: " + response.errorMessage));
    });
  }, "handleRequestAddress"), handleVerifyAddress = /* @__PURE__ */ __name((address2) => {
    setVerifying(!0), verifyAddress(address2, code).then((response) => {
      setVerifying(!1), response.success || (response.errorCode === "addressNotFound" ? alertUser(t2("buy.pocket.usedAddress", { address: address2 })) : (alertUser(t2("unknownError", { errorMessage: response.errorMessage })), console.log("error: " + response.errorMessage)));
    });
  }, "handleVerifyAddress"), sendXpub = /* @__PURE__ */ __name(() => {
    var _a46;
    if (accountInfo2) {
      const bitcoinSimple = accountInfo2.signingConfigurations[0].bitcoinSimple;
      if (bitcoinSimple) {
        const xpub = bitcoinSimple.keyInfo.xpub, { current } = iframeRef;
        if (!current)
          return;
        const message2 = dist.serializeMessage({
          version: dist.MessageVersion.V0,
          type: dist.V0MessageType.ExtendedPublicKey,
          extendedPublicKey: xpub
        });
        (_a46 = current.contentWindow) == null || _a46.postMessage(message2, "*");
      }
    }
  }, "sendXpub"), handleRequestXpub = /* @__PURE__ */ __name(() => {
    getTransactionList(code).then((txs) => {
      if (!txs.success) {
        alertUser(t2("transactions.errorLoadTransactions"));
        return;
      }
      txs.list.length > 0 ? confirmation(t2("buy.pocket.previousTransactions"), (result) => {
        result && sendXpub();
      }) : sendXpub();
    });
  }, "handleRequestXpub"), onMessage = /* @__PURE__ */ __name((m2) => {
    if (!(!iframeURL || !code) && m2.origin === new URL(iframeURL).origin)
      try {
        const message2 = dist.parseMessage(m2.data);
        switch (message2.type) {
          case dist.V0MessageType.RequestAddress:
            signing || handleRequestAddress(message2);
            break;
          case dist.V0MessageType.VerifyAddress:
            verifying || handleVerifyAddress(message2.bitcoinAddress);
            break;
          case dist.V0MessageType.RequestExtendedPublicKey:
            handleRequestXpub();
        }
      } catch (e2) {
        console.log(e2);
      }
  }, "onMessage");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$J.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: style$J.container, children: [
        agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
          !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "iframe",
            {
              onLoad: () => {
                setIframeLoaded(!0);
              },
              ref: iframeRef,
              title: "Pocket",
              width: "100%",
              height,
              frameBorder: "0",
              className: style$J.iframe,
              allow: "camera; payment",
              src: iframeURL
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          PocketTerms,
          {
            onAgreedTerms: () => setAgreedTerms(!0)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: verifying,
            title: t2("receive.verifyBitBox02"),
            disableEscape: !0,
            medium: !0,
            centered: !0,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: t2("buy.pocket.verifyBitBox02") })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "pocket" })
  ] });
}, "Pocket"), useEsc = /* @__PURE__ */ __name((callback2) => {
  reactExports.useEffect(() => {
    const handleKeyDown = /* @__PURE__ */ __name((e2) => {
      e2.key === "Escape" && callback2();
    }, "handleKeyDown");
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [callback2]);
}, "useEsc"), button = "_button_1djzh_1", success$3 = "_success_1djzh_34", container$h = "_container_1djzh_38", inputField = "_inputField_1djzh_42", flexibleHeight = "_flexibleHeight_1djzh_72", alignLeft = "_alignLeft_1djzh_76", alignRight = "_alignRight_1djzh_80", borderLess = "_borderLess_1djzh_84", style$D = {
  button,
  success: success$3,
  container: container$h,
  inputField,
  flexibleHeight,
  alignLeft,
  alignRight,
  borderLess
}, CopyableInput = /* @__PURE__ */ __name(({ alignLeft: alignLeft2, alignRight: alignRight2, borderLess: borderLess2, value, className, disabled: disabled2, flexibleHeight: flexibleHeight2 }) => {
  const [success2, setSuccess] = reactExports.useState(!1), { t: t2 } = useTranslation(), textAreaRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setHeight();
  }, []), reactExports.useEffect(() => {
    success2 && setTimeout(() => setSuccess(!1), 1500);
  }, [success2]);
  const setHeight = /* @__PURE__ */ __name(() => {
    const textarea2 = textAreaRef.current;
    if (!textarea2)
      return;
    const fontSize = window.getComputedStyle(textarea2, null).getPropertyValue("font-size"), units = Number(fontSize.replace("px", "")) + 2;
    textarea2.setAttribute("rows", "1"), textarea2.setAttribute("rows", String(Math.round(textarea2.scrollHeight / units - 2)));
  }, "setHeight"), onFocus2 = /* @__PURE__ */ __name((e2) => {
    e2.currentTarget.focus();
  }, "onFocus"), copy2 = /* @__PURE__ */ __name(() => {
    var _a46;
    (_a46 = textAreaRef.current) == null || _a46.select(), document.execCommand("copy") && setSuccess(!0);
  }, "copy");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    "flex flex-row flex-start flex-items-start",
    style$D.container,
    className || ""
  ].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        disabled: disabled2,
        readOnly: !0,
        onFocus: onFocus2,
        value,
        ref: textAreaRef,
        rows: 1,
        className: [
          style$D.inputField,
          flexibleHeight2 && style$D.flexibleHeight,
          alignLeft2 && style$D.alignLeft,
          alignRight2 && style$D.alignRight,
          borderLess2 && style$D.borderLess
        ].join(" ")
      }
    ),
    disabled2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: copy2,
        className: [style$D.button, success2 && style$D.success, "ignore"].join(" "),
        title: t2("button.copy"),
        children: success2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, {})
      }
    )
  ] });
}, "CopyableInput"), empty$1 = "_empty_gzy3c_1", style$C = {
  empty: empty$1
}, QRCode = /* @__PURE__ */ __name(({
  data,
  size: size2 = 256
}) => {
  const qrCode2 = useLoad(data !== void 0 ? getQRCode(data) : null, [data]);
  return qrCode2 ? qrCode2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { width: size2, height: size2, src: qrCode2.data }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: qrCode2.message }) : data !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$C.empty }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: style$C.empty, style: { verticalAlign: "middle", fill: "currentColor", overflow: "hidden" }, viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M433.282171 47.939849 94.944396 47.939849c-23.327288 0-42.304502 18.975167-42.304502 42.300408l0 338.341868c0 23.324218 18.977213 42.300408 42.304502 42.300408L433.282171 470.882534c23.324218 0 42.300408-18.97619 42.300408-42.300408L475.582579 90.240257C475.581556 66.915016 456.606389 47.939849 433.282171 47.939849zM438.742533 428.582125c0 3.01159-2.449795 5.461385-5.461385 5.461385L94.944396 434.04351c-3.013637 0-5.465478-2.450818-5.465478-5.461385L89.478917 90.240257c0-3.01159 2.451842-5.461385 5.465478-5.461385L433.282171 84.778872c3.01159 0 5.461385 2.449795 5.461385 5.461385L438.743556 428.582125zM322.914504 173.887352l-117.608581 0c-14.733563 0-26.719548 11.985986-26.719548 26.719548l0 117.608581c0 14.735609 11.985986 26.724665 26.719548 26.724665l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581C349.640192 185.873338 337.651137 173.887352 322.914504 173.887352zM312.801169 308.101123l-97.374748 0 0-97.374748 97.374748 0L312.801169 308.101123zM322.914504 675.606195l-117.608581 0c-14.733563 0-26.719548 11.989055-26.719548 26.724665l0 117.608581c0 14.732539 11.985986 26.719548 26.719548 26.719548l117.608581 0c14.735609 0 26.724665-11.987009 26.724665-26.719548l0-117.608581C349.640192 687.59525 337.651137 675.606195 322.914504 675.606195zM312.801169 809.819966l-97.374748 0 0-97.374748 97.374748 0L312.801169 809.819966zM699.123818 344.940147l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581c0-14.733563-11.989055-26.719548-26.724665-26.719548l-117.608581 0c-14.732539 0-26.719548 11.985986-26.719548 26.719548l0 117.608581C672.40427 332.951091 684.391279 344.940147 699.123818 344.940147zM709.243293 210.726376l97.374748 0 0 97.374748-97.374748 0L709.243293 210.726376zM433.282171 546.435277 94.944396 546.435277c-23.327288 0-42.304502 18.97619-42.304502 42.300408L52.639894 927.077553c0 23.325241 18.977213 42.301432 42.304502 42.301432L433.282171 969.378985c23.324218 0 42.300408-18.97619 42.300408-42.301432L475.582579 588.735685C475.581556 565.411467 456.606389 546.435277 433.282171 546.435277zM438.742533 927.077553c0 3.01159-2.449795 5.462408-5.461385 5.462408L94.944396 932.539962c-3.013637 0-5.465478-2.450818-5.465478-5.462408L89.478917 588.735685c0-3.010567 2.451842-5.461385 5.465478-5.461385L433.282171 583.2743c3.01159 0 5.461385 2.450818 5.461385 5.461385L438.743556 927.077553zM590.849836 547.776831c-23.325241 0-42.301432 18.978237-42.301432 42.305525l0 194.649212c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L585.387427 590.082356c0-3.013637 2.450818-5.466502 5.462408-5.466502l204.825992 0c10.172687 0 18.419512-8.246825 18.419512-18.419512s-8.246825-18.419512-18.419512-18.419512L590.849836 547.776831zM588.757175 470.882534l338.341868 0c23.325241 0 42.301432-18.97619 42.301432-42.300408L969.400474 90.240257c0-23.324218-18.97619-42.300408-42.301432-42.300408L588.757175 47.939849c-23.324218 0-42.300408 18.975167-42.300408 42.300408l0 338.341868C546.456766 451.906343 565.432956 470.882534 588.757175 470.882534zM583.295789 90.240257c0-3.01159 2.450818-5.461385 5.461385-5.461385l338.341868 0c3.01159 0 5.462408 2.449795 5.462408 5.461385l0 338.341868c0 3.01159-2.450818 5.461385-5.462408 5.461385L588.757175 434.04351c-3.010567 0-5.461385-2.450818-5.461385-5.461385L583.295789 90.240257zM969.676767 566.196343c0-10.172687-8.246825-18.419512-18.419512-18.419512l-67.50444 0c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l49.084928 0 0 71.009264L779.708158 655.625118c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l171.549098 0c10.172687 0 18.419512-8.246825 18.419512-18.419512 0-0.076748-0.010233-0.151449-0.011256-0.228197 0.001023-0.076748 0.011256-0.150426 0.011256-0.228197L969.676767 566.196343zM630.202099 933.142689l-44.813648 0 0-51.2922c0-10.172687-8.246825-18.419512-18.419512-18.419512s-18.419512 8.246825-18.419512 18.419512l0 69.711711c0 10.172687 8.246825 18.419512 18.419512 18.419512l63.23316 0c10.172687 0 18.419512-8.246825 18.419512-18.419512S640.374786 933.142689 630.202099 933.142689zM834.04981 790.359752c0-10.172687-8.246825-18.419512-18.419512-18.419512L699.257871 771.940241c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 163.013701c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L717.677383 808.779264 815.630299 808.779264C825.802986 808.779264 834.04981 800.532439 834.04981 790.359752zM951.060781 723.425294c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 194.301288L765.943666 936.146093c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l185.117115 0c10.172687 0 18.419512-8.246825 18.419512-18.419512L969.480292 741.844805C969.480292 731.672118 961.234491 723.425294 951.060781 723.425294zM655.979182 623.620194c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 59.869552c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512l0-59.869552C674.398694 631.867018 666.151869 623.620194 655.979182 623.620194z" }) });
}, "QRCode"), title$2 = "_title_nnme6_1", nextButton = "_nextButton_nnme6_6", details = "_details_nnme6_17", qrCode = "_qrCode_nnme6_22", address$3 = "_address_nnme6_32", buttons$1 = "_buttons_nnme6_35", verifyButton = "_verifyButton_nnme6_42", entry = "_entry_nnme6_46", xPubInfo = "_xPubInfo_nnme6_55", infoContent = "_infoContent_nnme6_82", largeEntry = "_largeEntry_nnme6_86", addressField = "_addressField_nnme6_96", style$B = {
  title: title$2,
  nextButton,
  details,
  qrCode,
  address: address$3,
  buttons: buttons$1,
  verifyButton,
  entry,
  xPubInfo,
  infoContent,
  largeEntry,
  addressField
}, SigningConfiguration = /* @__PURE__ */ __name(({ account: account2, info: info2, code, signingConfigIndex, children: children2 }) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), config = (/* @__PURE__ */ __name(() => info2.bitcoinSimple !== void 0 ? info2.bitcoinSimple : info2.ethereumSimple, "getSimpleInfo"))(), bitcoinBased = isBitcoinBased(account2.coinCode);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.address, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$B.qrCode, children: bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      QRCode,
      {
        data: config.keyInfo.xpub
      }
    ) : null }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.details, children: [
      account2.isToken ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountSummary.name"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name })
      ] }, "accountname"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Keypath:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.keypath })
      ] }, "keypath"),
      "scriptType" in config ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountInfo.scriptType"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getScriptName(config.scriptType) })
      ] }, "scriptName") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Root fingerprint:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.rootFingerprint })
      ] }, "rootFingerprint"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          account2.isToken ? "Token" : "Coin",
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          account2.coinName,
          " (",
          account2.coinUnit,
          ")"
        ] })
      ] }, "coinName"),
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$B.entry} ${style$B.largeEntry}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { className: "m-right-half", children: [
          t2("accountInfo.extendedPublicKey"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyableInput,
          {
            className: "flex-grow",
            alignLeft: !0,
            flexibleHeight: !0,
            value: config.keyInfo.xpub
          }
        )
      ] }, "xpub") : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.buttons, children: [
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$B.verifyButton, primary: !0, disabled: verifying, onClick: async () => {
        setVerifying(!0);
        try {
          const result = await verifyXPub(code, signingConfigIndex);
          result.success || alertUser(result.errorMessage);
        } finally {
          setVerifying(!1);
        }
      }, children: t2("accountInfo.verify") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$B.verifyButton, primary: !0, onClick: () => route(`/account/${code}/receive`), children: t2("receive.verify") }),
      children2
    ] })
  ] });
}, "SigningConfiguration");
function BitcoinBasedAccountInfoGuide({
  coinName: coinName2
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.xpub"), shown: !0 }, "guide.accountInfo.xpub"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      text: t2("guide.accountInfo.multipleXPubs.text", { coinName: coinName2 }),
      title: t2("guide.accountInfo.multipleXPubs.title")
    } }, "guide.accountInfo.multipleXPubs"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.privacy") }, "guide.accountInfo.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.verify") }, "guide.accountInfo.verify")
  ] });
}
__name(BitcoinBasedAccountInfoGuide, "BitcoinBasedAccountInfoGuide");
const Info = /* @__PURE__ */ __name(({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation(), info2 = useLoad(getInfo(code)), [viewXPub, setViewXPub] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  if (useEsc(() => route(`/account/${code}`)), !account2 || !info2)
    return null;
  const config = info2.signingConfigurations[viewXPub], numberOfXPubs = info2.signingConfigurations.length, xpubTypes = info2.signingConfigurations.map((cfg) => {
    var _a46;
    return (_a46 = cfg.bitcoinSimple) == null ? void 0 : _a46.scriptType;
  }), showNextXPub = /* @__PURE__ */ __name(() => {
    if (!info2)
      return;
    const numberOfXPubs2 = info2.signingConfigurations.length;
    setViewXPub((viewXPub + 1) % numberOfXPubs2);
  }, "showNextXPub");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountInfo.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box larger", children: [
        isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$B.title, children: t2("accountInfo.extendedPublicKey") }) : null,
        config.bitcoinSimple !== void 0 && numberOfXPubs > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$B.xPubInfo, children: [
          t2("accountInfo.xpubTypeInfo", {
            current: `${viewXPub + 1}`,
            numberOfXPubs: numberOfXPubs.toString(),
            scriptType: config.bitcoinSimple.scriptType.toUpperCase()
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$B.nextButton, onClick: showNextXPub, children: t2(`accountInfo.xpubTypeChangeBtn.${xpubTypes[(viewXPub + 1) % numberOfXPubs]}`) })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SigningConfiguration,
          {
            account: account2,
            code,
            info: config,
            signingConfigIndex: viewXPub,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: !0,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          },
          viewXPub
        )
      ] }) })
    ] }) }),
    isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitcoinBasedAccountInfoGuide, { coinName: account2.coinName }) : null
  ] });
}, "Info");
function ReceiveGuide({
  hasMultipleAddresses,
  hasDifferentFormats
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.address") }, "guide.receive.address"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyVerify") }, "guide.receive.whyVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.howVerify") }, "guide.receive.howVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.plugout") }, "guide.receive.plugout"),
    hasMultipleAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyMany") }, "guide.receive.whyMany"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.why20") }, "guide.receive.why20"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressChange") }, "guide.receive.addressChange"),
      hasDifferentFormats && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressFormats") }, "guide.receive.addressFormats")
    ] })
  ] });
}
__name(ReceiveGuide, "ReceiveGuide");
const labels = "_labels_1m4jx_1", label$4 = "_label_1m4jx_1", qrCodeContainer = "_qrCodeContainer_1m4jx_17", arrowLeft = "_arrowLeft_1m4jx_22", arrowRight = "_arrowRight_1m4jx_23", previous = "_previous_1m4jx_37", next = "_next_1m4jx_38", hide = "_hide_1m4jx_49", changeType = "_changeType_1m4jx_58", style$A = {
  labels,
  label: label$4,
  qrCodeContainer,
  arrowLeft,
  arrowRight,
  previous,
  next,
  hide,
  changeType
}, scriptTypes$1 = ["p2wpkh", "p2tr", "p2wpkh-p2sh"], getIndexOfMatchingScriptType$1 = /* @__PURE__ */ __name((receiveAddresses, scriptType) => receiveAddresses ? receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType) : -1, "getIndexOfMatchingScriptType$1"), Receive$2 = /* @__PURE__ */ __name(({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), [activeIndex, setActiveIndex] = reactExports.useState(0), [addressType, setAddressType] = reactExports.useState(0), [addressDialog, setAddressDialog] = reactExports.useState(), [currentAddresses, setCurrentAddresses] = reactExports.useState(), [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code), receiveAddresses = useLoad(getReceiveAddressList(code)), availableScriptTypes = reactExports.useRef(), hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1, scriptTypeDialogOpened = !!(addressDialog && hasManyScriptTypes);
  useEsc(() => !scriptTypeDialogOpened && !verifying && route(`/account/${code}`)), reactExports.useEffect(() => {
    receiveAddresses && (availableScriptTypes.current = scriptTypes$1.filter((sc2) => getIndexOfMatchingScriptType$1(receiveAddresses, sc2) >= 0));
  }, [receiveAddresses]), reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType$1(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      addressIndex === -1 && (addressIndex = 0), setCurrentAddressIndex(addressIndex), setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const handleSubmit = /* @__PURE__ */ __name((e2) => {
    addressDialog && (e2.preventDefault(), setActiveIndex(0), setAddressType(addressDialog.addressType), setAddressDialog(void 0));
  }, "handleSubmit"), verifyAddress2 = /* @__PURE__ */ __name(async (addressesIndex) => {
    if (!receiveAddresses || code === void 0 || !(await connectKeystore(code)).success)
      return;
    if (!(await hasSecureOutput(code)()).hasSecureOutput) {
      setVerifying("insecure");
      return;
    }
    setVerifying("secure");
    try {
      await verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID);
    } finally {
      setVerifying(!1);
    }
  }, "verifyAddress"), previous2 = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), !verifying && activeIndex > 0 && setActiveIndex(activeIndex - 1);
  }, "previous"), next2 = /* @__PURE__ */ __name((e2, numAddresses) => {
    e2.preventDefault(), !verifying && activeIndex < numAddresses - 1 && setActiveIndex(activeIndex + 1);
  }, "next");
  let uriPrefix = "";
  account2 && (account2.coinCode === "btc" || account2.coinCode === "tbtc" ? uriPrefix = "bitcoin:" : (account2.coinCode === "ltc" || account2.coinCode === "tltc") && (uriPrefix = "litecoin:"));
  let address2 = "";
  return currentAddresses && (address2 = currentAddresses[activeIndex].address, verifying || (address2 = address2.substring(0, 8) + "...")), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: void 0 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$A.labels, children: [
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.previous,
              onClick: previous2,
              children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.label, children: [
            t2("receive.label"),
            " ",
            currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
          ] }),
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.next,
              onClick: (e2) => next2(e2, currentAddresses.length),
              children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !0, value: address2, flexibleHeight: !0 }),
        hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: style$A.changeType,
            onClick: () => setAddressDialog(addressDialog ? void 0 : { addressType }),
            children: t2("receive.changeScriptType")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: scriptTypeDialogOpened, onClose: () => setAddressDialog(void 0), medium: !0, title: t2("receive.changeScriptType"), children: [
          availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio,
              {
                checked: addressDialog.addressType === i,
                id: scriptType,
                name: "scriptType",
                onChange: () => setAddressDialog({ addressType: i }),
                title: getScriptName(scriptType),
                children: t2(`receive.scriptType.${scriptType}`)
              }
            ),
            scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
          ] }) }, scriptType)),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.done") }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              disabled: verifying !== !1,
              onClick: () => verifyAddress2(currentAddressIndex),
              primary: !0,
              children: t2("receive.verifyBitBox02")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonLink,
            {
              secondary: !0,
              to: `/account/${code}`,
              children: t2("button.back")
            }
          )
        ] }),
        verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.hide }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: !!(account2 && verifying),
            title: t2("receive.verifyBitBox02"),
            disableEscape: verifying === "secure",
            onClose: verifying === "insecure" ? () => {
              setVerifying(!1);
            } : void 0,
            medium: !0,
            centered: !0,
            children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                    coinName: account2.coinName
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  t2("receive.onlyThisCoin.description")
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: !0 }) })
            ] })
          }
        )
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : !1,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : !1
      }
    )
  ] });
}, "Receive$2"), getDeviceList = /* @__PURE__ */ __name(() => apiGet("devices/registered"), "getDeviceList"), hasMobileChannel = /* @__PURE__ */ __name((deviceID) => () => apiGet(`devices/${deviceID}/has-mobile-channel`), "hasMobileChannel"), container$g = "_container_1ooxc_1", withCloseBtn = "_withCloseBtn_1ooxc_7", status$2 = "_status_1ooxc_15", success$2 = "_success_1ooxc_21", warning$2 = "_warning_1ooxc_25", info$1 = "_info_1ooxc_29", close$1 = "_close_1ooxc_42", style$z = {
  container: container$g,
  withCloseBtn,
  status: status$2,
  success: success$2,
  warning: warning$2,
  info: info$1,
  "close-success": "_close-success_1ooxc_42",
  "close-warning": "_close-warning_1ooxc_46",
  "close-info": "_close-info_1ooxc_50",
  close: close$1
}, Status = /* @__PURE__ */ __name(({
  hidden,
  type: type2 = "warning",
  dismissible,
  className,
  children: children2
}) => {
  const [show2, setShow] = reactExports.useState(!dismissible), checkConfig = reactExports.useCallback(async () => {
    if (dismissible) {
      const config = await getConfig();
      setShow(config ? !config.frontend[dismissible] : !0);
    }
  }, [dismissible]);
  reactExports.useEffect(() => {
    checkConfig();
  }, [checkConfig]);
  const dismiss = /* @__PURE__ */ __name(async () => {
    dismissible && (setConfig({
      frontend: {
        [dismissible]: !0
      }
    }), setShow(!1));
  }, "dismiss");
  return hidden || !show2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$z.container, style$z[type2], className || "", dismissible ? style$z.withCloseBtn : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$z.status, children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        hidden: !dismissible,
        className: `${style$z.close} ${style$z[`close-${type2}`]}`,
        onClick: dismiss,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
      }
    )
  ] }) });
}, "Status"), PairedWarning = /* @__PURE__ */ __name(({
  deviceID
}) => {
  const { t: t2 } = useTranslation(), paired = useLoad(hasMobileChannel(deviceID));
  return paired ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== !1, children: t2("warning.receivePairing") });
}, "PairedWarning"), useVerifyLabel = /* @__PURE__ */ __name((device2) => {
  const { t: t2 } = useTranslation();
  return t2(device2 === "bitbox" ? "receive.verifyBitBox01" : device2 === "bitbox02" ? "receive.verifyBitBox02" : "receive.verify");
}, "useVerifyLabel"), VerifyButton = /* @__PURE__ */ __name(({
  device: device2,
  forceVerification,
  ...props
}) => {
  const { t: t2 } = useTranslation(), verifyLabel = useVerifyLabel(device2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, ...props, children: forceVerification ? t2("receive.showFull") : verifyLabel });
}, "VerifyButton"), scriptTypes = ["p2wpkh", "p2tr", "p2wpkh-p2sh"], getIndexOfMatchingScriptType = /* @__PURE__ */ __name((receiveAddresses, scriptType) => receiveAddresses ? receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType) : -1, "getIndexOfMatchingScriptType"), Receive$1 = /* @__PURE__ */ __name(({
  accounts,
  code,
  deviceID
}) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), [activeIndex, setActiveIndex] = reactExports.useState(0), [addressType, setAddressType] = reactExports.useState(0), [addressDialog, setAddressDialog] = reactExports.useState(), [currentAddresses, setCurrentAddresses] = reactExports.useState(), [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code), verifyLabel = useVerifyLabel("bitbox"), receiveAddresses = useLoad(getReceiveAddressList(code)), secureOutput = useLoad(hasSecureOutput(code));
  useEsc(() => !verifying && route(`/account/${code}`));
  const availableScriptTypes = reactExports.useRef();
  reactExports.useEffect(() => {
    receiveAddresses && (availableScriptTypes.current = scriptTypes.filter((sc2) => getIndexOfMatchingScriptType(receiveAddresses, sc2) >= 0));
  }, [receiveAddresses]), reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      addressIndex === -1 && (addressIndex = 0), setCurrentAddressIndex(addressIndex), setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const verifyAddress2 = /* @__PURE__ */ __name((addressesIndex) => {
    if (receiveAddresses && secureOutput) {
      if (code === void 0)
        return;
      if (!secureOutput.hasSecureOutput) {
        alertUser(t2("receive.warning.secureOutput"));
        return;
      }
      setVerifying(!0), verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID).then(() => setVerifying(!1));
    }
  }, "verifyAddress"), previous2 = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), !verifying && activeIndex > 0 && setActiveIndex(activeIndex - 1);
  }, "previous"), next2 = /* @__PURE__ */ __name((e2, numAddresses) => {
    e2.preventDefault(), !verifying && activeIndex < numAddresses - 1 && setActiveIndex(activeIndex + 1);
  }, "next"), forceVerification = secureOutput === void 0 ? !0 : secureOutput.hasSecureOutput && !secureOutput.optional, enableCopy = !forceVerification;
  let uriPrefix = "";
  account2 && (account2.coinCode === "btc" || account2.coinCode === "tbtc" ? uriPrefix = "bitcoin:" : (account2.coinCode === "ltc" || account2.coinCode === "tltc") && (uriPrefix = "litecoin:"));
  let address2 = "";
  currentAddresses && (address2 = currentAddresses[activeIndex].address, !enableCopy && !verifying && (address2 = address2.substring(0, 8) + "..."));
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PairedWarning, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: enableCopy ? uriPrefix + address2 : void 0 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$A.labels, children: [
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$A.previous,
                onClick: previous2,
                children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.label, children: [
              t2("receive.label"),
              " ",
              currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
            ] }),
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$A.next,
                onClick: (e2) => next2(e2, currentAddresses.length),
                children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !enableCopy, value: address2, flexibleHeight: !0 }),
          hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.changeType,
              onClick: () => setAddressDialog(addressDialog ? void 0 : { addressType }),
              children: t2("receive.changeScriptType")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: (e2) => {
            e2.preventDefault(), setActiveIndex(0), setAddressType(addressDialog ? addressDialog == null ? void 0 : addressDialog.addressType : addressType), setAddressDialog(void 0);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !!addressDialog, medium: !0, title: t2("receive.changeScriptType"), children: [
            availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Radio,
                {
                  checked: addressDialog.addressType === i,
                  id: scriptType,
                  name: "scriptType",
                  onChange: () => setAddressDialog({ addressType: i }),
                  title: getScriptName(scriptType),
                  children: t2(`receive.scriptType.${scriptType}`)
                }
              ),
              scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
            ] }) }, scriptType)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.done") }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              VerifyButton,
              {
                device: "bitbox",
                disabled: verifying || secureOutput === void 0,
                forceVerification,
                onClick: () => verifyAddress2(currentAddressIndex)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: !0,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          ] }),
          forceVerification && verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.hide }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dialog,
            {
              open: !!account2 && forceVerification && verifying,
              title: verifyLabel,
              disableEscape: !0,
              medium: !0,
              centered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                      coinName: account2.coinName
                    }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                    t2("receive.onlyThisCoin.description")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: !0 }) })
              ]
            }
          )
        ] }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : !1,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : !1
      }
    )
  ] });
}, "Receive$1"), Receive = /* @__PURE__ */ __name((props) => {
  const {
    devices,
    deviceIDs
  } = props, deviceID = deviceIDs[0];
  switch (deviceIDs.length ? devices[deviceID] : void 0) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$1,
        {
          deviceID,
          ...props
        }
      );
    case "bitbox02":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$2,
        {
          ...props
        }
      );
  }
}, "Receive"), RatesContext = reactExports.createContext({}), subscriptions = {};
function handleMessages(payload) {
  if ("type" in payload && payload.data && typeof payload.data == "string" && payload.data in subscriptions && subscriptions[payload.data].length)
    for (const observer of subscriptions[payload.data])
      observer(payload);
}
__name(handleMessages, "handleMessages");
function subscribe$1(subject, observer) {
  subscriptions[subject] || (subscriptions[subject] = []);
  const observers = subscriptions[subject];
  return observers.includes(observer) && console.error(`observer already registered for ${subject}`), observers.push(observer), () => {
    observers.includes(observer) || console.error("!observers.includes(observer)");
    const index = observers.indexOf(observer);
    observers.splice(index, 1);
  };
}
__name(subscribe$1, "subscribe$1");
apiWebsocket(handleMessages);
const syncAccountsList = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("accounts", cb2), "syncAccountsList"), syncAddressesCount = /* @__PURE__ */ __name((code) => (cb2) => subscribeEndpoint(`account/${code}/synced-addresses-count`, (count) => {
  cb2(count);
}), "syncAddressesCount"), statusChanged$1 = /* @__PURE__ */ __name((cb2) => subscribe$1("statusChanged", (event2) => {
  event2.type === "account" && event2.code && cb2(event2.code);
}), "statusChanged$1"), syncdone = /* @__PURE__ */ __name((cb2) => subscribe$1("syncdone", (event2) => {
  event2.type === "account" && event2.code && cb2(event2.code);
}), "syncdone"), subscribeCoinHeaders = /* @__PURE__ */ __name((coinCode) => (cb2) => subscribeEndpoint(`coins/${coinCode}/headers/status`, cb2), "subscribeCoinHeaders"), setBtcUnit = /* @__PURE__ */ __name((unit2) => apiPost("coins/btc/set-unit", { unit: unit2 }), "setBtcUnit"), parseExternalBtcAmount = /* @__PURE__ */ __name((amount2) => apiGet(`coins/btc/parse-external-amount?amount=${amount2}`), "parseExternalBtcAmount"), getDeviceInfo$1 = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/${deviceID}/info`), "getDeviceInfo$1"), space = "_space_tpxrt_1", style$y = {
  space
}, Amount = /* @__PURE__ */ __name(({ amount: amount2, unit: unit2, removeBtcTrailingZeroes, alwaysShowAmounts = !1 }) => {
  const { hideAmounts } = reactExports.useContext(AppContext), formatSats = /* @__PURE__ */ __name((amount22) => {
    const blocks = [];
    for (let i = amount22.length; i > 0; i -= 3) {
      const start = Math.max(0, i - 3);
      blocks.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: start === 0 ? "" : style$y.space, children: amount22.slice(start, i) }, "block_" + blocks.length)
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "amountBlocks", children: blocks.reverse() });
  }, "formatSats"), formatBtc = /* @__PURE__ */ __name((amount22) => {
    const dot2 = amount22.indexOf(".");
    return dot2 === -1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount22 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "amountBlocks", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: amount22.slice(0, dot2 + 3) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$y.space, children: amount22.slice(dot2 + 3, dot2 + 6) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$y.space, children: amount22.slice(dot2 + 6, dot2 + 9) })
    ] });
  }, "formatBtc");
  if (hideAmounts && !alwaysShowAmounts)
    return "***";
  switch (unit2) {
    case "BTC":
    case "TBTC":
    case "LTC":
    case "TLTC":
      return removeBtcTrailingZeroes && amount2.includes(".") ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2.replace(/\.?0+$/, "") }) : formatBtc(amount2);
    case "sat":
    case "tsat":
      return formatSats(amount2);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2 });
}, "Amount"), rates = "_rates_19qqe_1", unit$1 = "_unit_19qqe_8", unitAction = "_unitAction_19qqe_13", fiatRow = "_fiatRow_19qqe_20", availableFiatAmount = "_availableFiatAmount_19qqe_24", availableFiatUnitNoAction = "_availableFiatUnitNoAction_19qqe_29", availableFiatUnit = "_availableFiatUnit_19qqe_29", notAvailable = "_notAvailable_19qqe_46", style$x = {
  rates,
  unit: unit$1,
  unitAction,
  fiatRow,
  availableFiatAmount,
  availableFiatUnitNoAction,
  availableFiatUnit,
  notAvailable
}, currenciesWithDisplayName = [
  { currency: "AUD", displayName: "Australian Dollar" },
  { currency: "BRL", displayName: "Brazilian Real" },
  { currency: "CAD", displayName: "Canadian Dollar" },
  { currency: "CHF", displayName: "Swiss franc" },
  { currency: "CNY", displayName: "Chinese Yuan" },
  { currency: "CZK", displayName: "Czech Koruna" },
  { currency: "EUR", displayName: "Euro" },
  { currency: "GBP", displayName: "British Pound" },
  { currency: "HKD", displayName: "Hong Kong Dollar" },
  { currency: "ILS", displayName: "Israeli New Shekel" },
  { currency: "JPY", displayName: "Japanese Yen" },
  { currency: "KRW", displayName: "South Korean Won" },
  { currency: "NOK", displayName: "Norwegian Krone" },
  { currency: "PLN", displayName: "Polish Zloty" },
  { currency: "RUB", displayName: "Russian ruble" },
  { currency: "SEK", displayName: "Swedish Krona" },
  { currency: "SGD", displayName: "Singapore Dollar" },
  { currency: "USD", displayName: "United States Dollar" },
  { currency: "BTC", displayName: "Bitcoin" }
];
function formatNumber(amount2, maxDigits) {
  let formatted = amount2.toFixed(maxDigits), position2 = formatted.indexOf(".") - 3;
  for (; position2 > 0; )
    formatted = formatted.slice(0, position2) + "'" + formatted.slice(position2), position2 = position2 - 3;
  return formatted;
}
__name(formatNumber, "formatNumber");
function Conversion({
  amount: amount2,
  tableRow,
  unstyled,
  skipUnit,
  noAction,
  sign,
  noBtcZeroes,
  alwaysShowAmounts = !1
}) {
  const { rotateFiat, defaultCurrency: defaultCurrency2, btcUnit } = reactExports.useContext(RatesContext);
  let formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "---" }), isAvailable = !1, activeUnit = defaultCurrency2;
  return defaultCurrency2 === "BTC" && btcUnit === "sat" && (activeUnit = "sat"), amount2 && amount2.conversions && amount2.conversions[defaultCurrency2] && amount2.conversions[defaultCurrency2] !== "" && (isAvailable = !0, formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts, amount: amount2.conversions[defaultCurrency2], unit: activeUnit, removeBtcTrailingZeroes: !!noBtcZeroes })), tableRow ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: unstyled ? "" : style$x.fiatRow, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatAmount, children: formattedAmount }),
    !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatUnit, onClick: rotateFiat, children: activeUnit }),
    noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatUnitNoAction, children: activeUnit })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${style$x.rates} ${isAvailable ? "" : style$x.notAvailable}`, children: [
    isAvailable ? sign : "",
    formattedAmount,
    " ",
    !skipUnit && !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$x.unitAction, onClick: rotateFiat, children: activeUnit }),
    !skipUnit && noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$x.unit, children: activeUnit })
  ] });
}
__name(Conversion, "Conversion");
const formattedCurrencies = currenciesWithDisplayName.map((fiat2) => ({ label: `${fiat2.displayName} (${fiat2.currency})`, value: fiat2.currency })), FiatConversion = Conversion, balanceTable$1 = "_balanceTable_m2hui_1", availableAmount = "_availableAmount_m2hui_27", availableUnit = "_availableUnit_m2hui_32", pendingBalance = "_pendingBalance_m2hui_37", style$w = {
  balanceTable: balanceTable$1,
  availableAmount,
  availableUnit,
  pendingBalance
}, Balance = /* @__PURE__ */ __name(({
  balance: balance2,
  noRotateFiat
}) => {
  const { t: t2 } = useTranslation();
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: style$w.balance, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: style$w.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { "data-testid": "availableBalance", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$w.availableAmount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.available.amount,
            unit: balance2.available.unit,
            removeBtcTrailingZeroes: !0
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$w.availableUnit, children: balance2.available.unit })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FiatConversion,
        {
          amount: balance2.available,
          tableRow: !0,
          noAction: noRotateFiat,
          noBtcZeroes: !0
        }
      )
    ] }) }),
    balance2.hasIncoming && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$w.pendingBalance, children: [
      t2("account.incoming"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "incomingBalance", children: [
        "+",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.incoming.amount,
            unit: balance2.incoming.unit,
            removeBtcTrailingZeroes: !0
          }
        ),
        " ",
        balance2.incoming.unit,
        " /",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$w.incomingConversion, children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.incoming, noBtcZeroes: !0 })
        ] })
      ] })
    ] })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: style$w.balance });
}, "Balance"), translate = withTranslation;
function load(endpointsObjectOrFunction, renderOnlyOnceLoaded = !0) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      constructor() {
        super(...arguments), this.state = {};
      }
      determineEndpoints() {
        return typeof endpointsObjectOrFunction == "function" ? endpointsObjectOrFunction(this.props) : endpointsObjectOrFunction;
      }
      loadEndpoint(key, endpoint) {
        apiGet(endpoint).then((object) => {
          this.setState({ [key]: object });
        });
      }
      loadEndpoints() {
        const oldEndpoints = this.endpoints, newEndpoints = this.determineEndpoints();
        for (const key of Object.keys(newEndpoints))
          (oldEndpoints === void 0 || newEndpoints[key] !== oldEndpoints[key]) && this.loadEndpoint(key, newEndpoints[key]);
        if (oldEndpoints === void 0)
          renderOnlyOnceLoaded && Object.keys(newEndpoints).length === 0 && this.setState({});
        else
          for (const key of Object.keys(oldEndpoints))
            newEndpoints[key] === void 0 && this.setState({ [key]: void 0 });
        this.endpoints = newEndpoints;
      }
      componentDidMount() {
        this.loadEndpoints();
      }
      componentDidUpdate() {
        this.loadEndpoints();
      }
      allEndpointsLoaded() {
        if (this.endpoints === void 0)
          return !1;
        for (const key of Object.keys(this.endpoints))
          if (this.state[key] === void 0)
            return !1;
        return !0;
      }
      render() {
        const props = this.props, state = this.state;
        return renderOnlyOnceLoaded && !this.allEndpointsLoaded() ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Load(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(load, "load");
const row$1 = "_row_1qpuo_1", rowCustomFee = "_rowCustomFee_1qpuo_6", column = "_column_1qpuo_12", priority = "_priority_1qpuo_38", fee$1 = "_fee_1qpuo_42", feeCustom = "_feeCustom_1qpuo_91", feeDescription = "_feeDescription_1qpuo_95", feeProposed = "_feeProposed_1qpuo_96", customFeeUnit = "_customFeeUnit_1qpuo_112", style$v = {
  row: row$1,
  rowCustomFee,
  column,
  priority,
  fee: fee$1,
  feeCustom,
  feeDescription,
  feeProposed,
  customFeeUnit
}, _FeeTargets = class _FeeTargets extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      feeTarget: "",
      options: null,
      noFeeTargets: !1
    }, this.input = reactExports.createRef(), this.updateFeeTargets = (accountCode) => {
      getFeeTargetList(accountCode).then(({ feeTargets, defaultFeeTarget }) => {
        const expert = this.props.config.frontend.expertFee || feeTargets.length === 0, options2 = feeTargets.map(({ code, feeRateInfo }) => ({
          value: code,
          text: this.props.t(`send.feeTarget.label.${code}`) + (expert && feeRateInfo ? ` (${feeRateInfo})` : "")
        }));
        expert && options2.push({
          value: "custom",
          text: this.props.t("send.feeTarget.label.custom")
        }), this.setState({ options: options2 }), this.setFeeTarget(defaultFeeTarget), feeTargets.length === 0 && this.setState({ noFeeTargets: !0 });
      }).catch(console.error);
    }, this.handleFeeTargetChange = (event2) => {
      const target = event2.target;
      this.setFeeTarget(target.options[target.selectedIndex].value);
    }, this.handleCustomFee = (event2) => {
      const target = event2.target;
      this.props.onCustomFee(target.value);
    }, this.setFeeTarget = (feeTarget) => {
      this.setState({ feeTarget }), this.props.onFeeTargetChange(feeTarget);
    }, this.getProposeFeeText = () => {
      if (!this.props.proposedFee)
        return "";
      const { amount: amount2, unit: unit2, conversions } = this.props.proposedFee, fiatUnit = this.props.fiatUnit;
      return `${amount2} ${unit2} ${conversions ? ` = ${conversions[fiatUnit === "sat" ? "BTC" : fiatUnit]} ${fiatUnit}` : ""}`;
    }, this.focusInput = () => {
      !this.props.disabled && this.input.current && this.input.current.autofocus && this.input.current.focus();
    };
  }
  componentDidMount() {
    this.updateFeeTargets(this.props.accountCode), this.focusInput();
  }
  UNSAFE_componentWillReceiveProps({ accountCode }) {
    this.props.accountCode !== accountCode && this.updateFeeTargets(accountCode);
  }
  render() {
    const {
      t: t2,
      coinCode,
      disabled: disabled2,
      error: error3,
      showCalculatingFeeLabel = !1,
      customFee
    } = this.props, {
      feeTarget,
      options: options2,
      noFeeTargets
    } = this.state;
    if (options2 === null)
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          label: t2("send.priority"),
          id: "feetarget",
          placeholder: t2("send.feeTarget.placeholder"),
          disabled: !0,
          value: "",
          transparent: !0
        }
      );
    const isCustom = feeTarget === "custom", hasOptions = options2.length > 0, proposeFeeText = this.getProposeFeeText(), preventFocus = document.activeElement && document.activeElement.nodeName === "INPUT";
    return hasOptions ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      isCustom ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$v.rowCustomFee, children: [
        noFeeTargets ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { small: !0, type: "warning", children: t2("send.noFeeTargets") }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$v.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Select$1,
          {
            className: style$v.priority,
            label: t2("send.priority"),
            id: "feeTarget",
            disabled: disabled2,
            onChange: this.handleFeeTargetChange,
            value: feeTarget,
            options: options2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$v.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            type: disabled2 ? "text" : "number",
            min: "0",
            step: "any",
            autoFocus: !preventFocus,
            align: "right",
            className: `${style$v.fee} ${style$v.feeCustom}`,
            disabled: disabled2,
            label: t2("send.feeTarget.customLabel", {
              context: isEthereumBased(coinCode) ? "eth" : ""
            }),
            id: "proposedFee",
            placeholder: t2("send.fee.customPlaceholder"),
            error: error3,
            transparent: !0,
            onInput: this.handleCustomFee,
            ref: this.input,
            value: customFee,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$v.customFeeUnit, children: customFeeUnit$1(this.props.coinCode) })
          }
        ) })
      ] }) : showCalculatingFeeLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: !0,
          label: t2("send.priority"),
          placeholder: t2("send.feeTarget.placeholder"),
          value: "",
          transparent: !0
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select$1,
        {
          className: style$v.priority,
          label: t2("send.priority"),
          id: "feeTarget",
          disabled: disabled2,
          onChange: this.handleFeeTargetChange,
          value: feeTarget,
          options: options2
        }
      ),
      feeTarget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        showCalculatingFeeLabel || proposeFeeText ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$v.feeProposed, children: [
          t2("send.fee.label"),
          ":",
          " ",
          showCalculatingFeeLabel ? t2("send.feeTarget.placeholder") : proposeFeeText
        ] }) : null,
        isCustom ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$v.feeDescription, children: [
          t2("send.feeTarget.estimate"),
          " ",
          t2(`send.feeTarget.description.${feeTarget}`, {
            context: getCoinCode(coinCode) || ""
          })
        ] })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        disabled: !0,
        label: t2("send.fee.label"),
        id: "proposedFee",
        placeholder: t2("send.fee.placeholder"),
        error: error3,
        transparent: !0,
        value: proposeFeeText
      }
    );
  }
};
__name(_FeeTargets, "FeeTargets");
let FeeTargets = _FeeTargets;
const loadedHOC = load(
  { config: "config" }
)(FeeTargets), TranslatedFeeTargets = translate()(loadedHOC), utxosList = "_utxosList_8ra1q_1", utxo = "_utxo_8ra1q_1", utxoContent = "_utxoContent_8ra1q_17", note = "_note_8ra1q_25", utxoData = "_utxoData_8ra1q_33", utxoExplorer = "_utxoExplorer_8ra1q_41", amounts = "_amounts_8ra1q_51", amount$1 = "_amount_8ra1q_51", label$3 = "_label_8ra1q_59", unit = "_unit_8ra1q_60", address$2 = "_address_8ra1q_73", transaction = "_transaction_8ra1q_74", shrink = "_shrink_8ra1q_81", style$u = {
  utxosList,
  utxo,
  utxoContent,
  note,
  utxoData,
  utxoExplorer,
  amounts,
  amount: amount$1,
  label: label$3,
  unit,
  address: address$2,
  transaction,
  shrink
}, UTXOs = /* @__PURE__ */ __name(({
  accountCode,
  active: active2,
  explorerURL,
  onChange: onChange2,
  onClose
}) => {
  const { t: t2 } = useTranslation(), [utxos, setUtxos] = reactExports.useState([]), [selectedUTXOs, setSelectedUTXOs] = reactExports.useState({});
  reactExports.useEffect(() => (getUTXOs(accountCode).then(setUtxos), () => setUtxos([])), [accountCode]), reactExports.useEffect(() => {
    const unsubscribe2 = syncdone((code) => {
      accountCode === code && getUTXOs(accountCode).then(setUtxos);
    });
    return () => unsubscribe2();
  }, [accountCode]);
  const handleUTXOChange = /* @__PURE__ */ __name((event2) => {
    const target = event2.target, outPoint = target.dataset.outpoint, proposedUTXOs = Object.assign({}, selectedUTXOs);
    target.checked ? proposedUTXOs[outPoint] = !0 : delete proposedUTXOs[outPoint], setSelectedUTXOs(proposedUTXOs), onChange2(proposedUTXOs);
  }, "handleUTXOChange"), renderUTXOs = /* @__PURE__ */ __name((scriptType) => {
    const filteredUTXOs = utxos.filter((utxo2) => utxo2.scriptType === scriptType);
    return filteredUTXOs.length === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "subTitle", children: getScriptName(scriptType) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$u.utxosList, children: filteredUTXOs.map((utxo2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: style$u.utxo, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Checkbox,
        {
          checked: !!selectedUTXOs[utxo2.outPoint],
          id: "utxo-" + utxo2.outPoint,
          "data-outpoint": utxo2.outPoint,
          onChange: handleUTXOChange,
          children: [
            utxo2.note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$u.note, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              utxo2.note,
              " "
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.utxoContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.utxoData, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.amounts, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.amount, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: utxo2.amount.amount, unit: utxo2.amount.unit }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.unit, children: utxo2.amount.unit })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { alwaysShowAmounts: !0, amount: utxo2.amount, unstyled: !0, noAction: !0 })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.address, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.label, children: [
                    t2("send.coincontrol.address"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.shrink, children: utxo2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.transaction, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.label, children: [
                    t2("send.coincontrol.outpoint"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.shrink, children: utxo2.txId }),
                  ":",
                  utxo2.txOutput
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: style$u.utxoExplorer,
                  href: explorerURL + utxo2.txId,
                  title: t2("transaction.explorerTitle"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, {})
                }
              )
            ] })
          ]
        }
      ) }, "utxo-" + utxo2.outPoint)) })
    ] }, "utxos-" + scriptType);
  }, "renderUTXOs");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      open: active2,
      title: t2("send.coincontrol.title"),
      large: !0,
      onClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        allScriptTypes.map(renderUTXOs),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-top-none m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onClose, children: t2("button.continue") }) })
      ] })
    }
  );
}, "UTXOs");
function unsubscribe(unsubscribeList) {
  for (const unsubscribeCallback of unsubscribeList)
    unsubscribeCallback();
  unsubscribeList.splice(0, unsubscribeList.length);
}
__name(unsubscribe, "unsubscribe");
const approve$1 = "" + new URL("hold.png", import.meta.url).href, reject = "" + new URL("tap.png", import.meta.url).href, _WaitDialog = class _WaitDialog extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.state = {
      active: !1
    }, this.handleKeyDown = (e2) => {
      const activeElement = document.activeElement;
      activeElement && activeElement instanceof HTMLElement && activeElement.blur(), e2.preventDefault(), e2.stopPropagation();
    }, this.activate = () => {
      this.setState({ active: !0 }, () => {
        !this.overlay.current || !this.modal.current || (this.overlay.current.classList.add(style$10.activeOverlay), this.modal.current.classList.add(style$10.activeModal));
      });
    };
  }
  UNSAFE_componentWillMount() {
    document.body.addEventListener("keydown", this.handleKeyDown);
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.body.removeEventListener("keydown", this.handleKeyDown);
  }
  render() {
    const {
      t: t2,
      includeDefault,
      prequel,
      title: title2,
      paired = !1,
      touchConfirm = !0,
      children: children2
    } = this.props, defaultContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      prequel && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: prequel }),
      paired ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$10.confirmationLabel, touchConfirm && paired ? style$10.disabledLabel : "", "m-top-none"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$10.confirmationLabelNumber, children: "1." }),
          t2("confirm.infoWhenPaired")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$10.confirmationLabel, !touchConfirm && paired ? style$10.disabledLabel : ""].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$10.confirmationLabelNumber, children: "2." }),
          t2("confirm.info")
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$10.confirmationLabel, style$10.noStep, "m-top-none"].join(" "), children: t2("confirm.info") }),
      touchConfirm && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-between flex-items-stretch", style$10.confirmationInstructions].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$10.image, src: reject, alt: "Reject" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.abortInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red", children: t2("confirm.abortInfoRedText") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$10.image, src: approve$1, alt: "Approve" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.approveInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green", children: t2("confirm.approveInfoGreenText") })
          ] })
        ] })
      ] })
    ] }), hasChildren = React.Children.toArray(children2).length > 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: style$10.overlay,
        ref: this.overlay,
        style: { zIndex: 10001 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$10.modal, style$10.open].join(" "), ref: this.modal, children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$10.title, children: title2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.contentContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.content, children: [
            hasChildren && includeDefault ? defaultContent : null,
            hasChildren ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-start", children: children2 }) : defaultContent
          ] }) })
        ] })
      }
    );
  }
};
__name(_WaitDialog, "WaitDialog");
let WaitDialog = _WaitDialog;
const TranslatedWaitDialog = translate()(WaitDialog), confirmItem = "_confirmItem_1e5e5_1", confirmationValue = "_confirmationValue_1e5e5_6", total = "_total_1e5e5_15", style$t = {
  confirmItem,
  confirmationValue,
  total
}, ConfirmingWaitDialog = /* @__PURE__ */ __name(({
  paired,
  baseCurrencyUnit,
  note: note2,
  hasSelectedUTXOs,
  selectedUTXOs,
  coinCode,
  transactionStatus,
  transactionDetails
}) => {
  const { t: t2 } = useTranslation(), { isConfirming, signConfirm, signProgress } = transactionStatus, {
    proposedFee,
    proposedAmount,
    proposedTotal,
    customFee,
    feeTarget,
    recipientAddress,
    fiatUnit
  } = transactionDetails;
  if (!isConfirming)
    return null;
  const confirmPrequel = signProgress && signProgress.steps > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    t2("send.signprogress.description", {
      steps: signProgress.steps.toString()
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    t2("send.signprogress.label"),
    ": ",
    signProgress.step,
    "/",
    signProgress.steps
  ] }) : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TranslatedWaitDialog,
    {
      title: t2("send.confirm.title"),
      prequel: confirmPrequel,
      paired,
      touchConfirm: signConfirm,
      includeDefault: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.address.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: recipientAddress || "N/A" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.amount.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedAmount && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedAmount.amount, unit: proposedAmount.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedAmount && proposedAmount.unit || "N/A" })
            ] }, "proposedAmount"),
            proposedAmount && proposedAmount.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedAmount.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: note2 })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            t2("send.fee.label"),
            feeTarget ? " (" + t2(`send.feeTarget.label.${feeTarget}`) + ")" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedFee && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedFee.amount, unit: proposedFee.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedFee && proposedFee.unit || "N/A" })
            ] }, "amount"),
            proposedFee && proposedFee.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedFee.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] }, "conversation"),
            customFee ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "(",
                customFee,
                " ",
                customFeeUnit$1(coinCode),
                ")"
              ] })
            ] }, "customFee") : null
          ] })
        ] }),
        hasSelectedUTXOs && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$t.confirmItem].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.selected-coins") }),
          selectedUTXOs.map((uxto, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$t.confirmationValue, children: uxto }, `selectedCoin-${i}`))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$t.confirmItem, style$t.total].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.total") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: proposedTotal && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedTotal.amount, unit: proposedTotal.unit }) || "N/A" }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedTotal && proposedTotal.unit || "N/A" })
            ] }),
            proposedTotal && proposedTotal.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedTotal.conversions[fiatUnit], unit: baseCurrencyUnit }) }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] })
      ]
    }
  );
}, "ConfirmingWaitDialog"), SendGuide = /* @__PURE__ */ __name(({ coinCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.whyFee") }, "guide.send.whyFee"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.priority") }, "guide.send.priority"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.fee") }, "guide.send.fee"),
    isBitcoinOnly(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.change") }, "guide.send.change"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.revert") }, "guide.send.revert"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.plugout") }, "guide.send.plugout")
  ] });
}, "SendGuide"), txProposalErrorHandling = /* @__PURE__ */ __name((registerEvents, unregisterEvents, errorCode) => {
  const { t: t2 } = instance;
  switch (errorCode) {
    case "invalidAddress":
      return { addressError: t2("send.error.invalidAddress") };
    case "invalidAmount":
    case "insufficientFunds":
      return { amountError: t2(`send.error.${errorCode}`), proposedFee: void 0 };
    case "feeTooLow":
    case "feesNotAvailable":
      return { feeError: t2(`send.error.${errorCode}`) };
    default:
      return errorCode && (unregisterEvents(), alertUser(errorCode, { callback: registerEvents })), { proposedFee: void 0 };
  }
}, "txProposalErrorHandling"), MessageWaitDialog = /* @__PURE__ */ __name(({ isShown, messageType }) => isShown ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-center flex-items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconAndMessage, { messageType }) }) }) : null, "MessageWaitDialog"), IconAndMessage = /* @__PURE__ */ __name(({ messageType }) => {
  const { t: t2 } = useTranslation();
  switch (messageType) {
    case "sent":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, { style: { height: 18, marginRight: "1rem" } }),
        t2("send.success")
      ] });
    case "abort":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { alt: "Abort", style: { height: 18, marginRight: "1rem" } }),
        t2("send.abort")
      ] });
    default:
      return null;
  }
}, "IconAndMessage"), scriptRel = (/* @__PURE__ */ __name(function() {
  const relList = typeof document < "u" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}, "detectScriptRel"))(), assetsURL = /* @__PURE__ */ __name(function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
}, "assetsURL"), seen = {}, __vitePreload = /* @__PURE__ */ __name(function(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0)
    return baseModule();
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    if (dep = assetsURL(dep, importerUrl), dep in seen)
      return;
    seen[dep] = !0;
    const isCss = dep.endsWith(".css"), cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (!!importerUrl)
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet"))
          return;
      }
    else if (document.querySelector(`link[href="${dep}"]${cssSelector}`))
      return;
    const link2 = document.createElement("link");
    if (link2.rel = isCss ? "stylesheet" : scriptRel, isCss || (link2.as = "script", link2.crossOrigin = ""), link2.href = dep, document.head.appendChild(link2), isCss)
      return new Promise((res, rej) => {
        link2.addEventListener("load", res), link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: !0 });
    if (e2.payload = err, window.dispatchEvent(e2), !e2.defaultPrevented)
      throw err;
  });
}, "preload");
var _a;
let e$1 = (_a = class {
  constructor(a2, b2, c2, d2, f2) {
    this._legacyCanvasSize = _a.DEFAULT_CANVAS_SIZE, this._preferredCamera = "environment", this._maxScansPerSecond = 25, this._lastScanTimestamp = -1, this._destroyed = this._flashOn = this._paused = this._active = !1, this.$video = a2, this.$canvas = document.createElement("canvas"), c2 && typeof c2 == "object" ? this._onDecode = b2 : (console.warn(c2 || d2 || f2 ? "You're using a deprecated version of the QrScanner constructor which will be removed in the future" : "Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), this._legacyOnDecode = b2), b2 = typeof c2 == "object" ? c2 : {}, this._onDecodeError = b2.onDecodeError || (typeof c2 == "function" ? c2 : this._onDecodeError), this._calculateScanRegion = b2.calculateScanRegion || (typeof d2 == "function" ? d2 : this._calculateScanRegion), this._preferredCamera = b2.preferredCamera || f2 || this._preferredCamera, this._legacyCanvasSize = typeof c2 == "number" ? c2 : typeof d2 == "number" ? d2 : this._legacyCanvasSize, this._maxScansPerSecond = b2.maxScansPerSecond || this._maxScansPerSecond, this._onPlay = this._onPlay.bind(this), this._onLoadedMetaData = this._onLoadedMetaData.bind(this), this._onVisibilityChange = this._onVisibilityChange.bind(this), this._updateOverlay = this._updateOverlay.bind(this), a2.disablePictureInPicture = !0, a2.playsInline = !0, a2.muted = !0;
    let h2 = !1;
    if (a2.hidden && (a2.hidden = !1, h2 = !0), document.body.contains(a2) || (document.body.appendChild(a2), h2 = !0), c2 = a2.parentElement, b2.highlightScanRegion || b2.highlightCodeOutline) {
      if (d2 = !!b2.overlay, this.$overlay = b2.overlay || document.createElement("div"), f2 = this.$overlay.style, f2.position = "absolute", f2.display = "none", f2.pointerEvents = "none", this.$overlay.classList.add("scan-region-highlight"), !d2 && b2.highlightScanRegion) {
        this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
        try {
          this.$overlay.firstElementChild.animate({ transform: [
            "scale(.98)",
            "scale(1.01)"
          ] }, { duration: 400, iterations: 1 / 0, direction: "alternate", easing: "ease-in-out" });
        } catch {
        }
        c2.insertBefore(this.$overlay, this.$video.nextSibling);
      }
      b2.highlightCodeOutline && (this.$overlay.insertAdjacentHTML("beforeend", '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);
    }
    this._scanRegion = this._calculateScanRegion(a2), requestAnimationFrame(() => {
      let m2 = window.getComputedStyle(a2);
      m2.display === "none" && (a2.style.setProperty("display", "block", "important"), h2 = !0), m2.visibility !== "visible" && (a2.style.setProperty("visibility", "visible", "important"), h2 = !0), h2 && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), a2.style.opacity = "0", a2.style.width = "0", a2.style.height = "0", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight), this.$overlay && this._updateOverlay();
    }), a2.addEventListener("play", this._onPlay), a2.addEventListener("loadedmetadata", this._onLoadedMetaData), document.addEventListener("visibilitychange", this._onVisibilityChange), window.addEventListener("resize", this._updateOverlay), this._qrEnginePromise = _a.createQrEngine();
  }
  static set WORKER_PATH(a2) {
    console.warn("Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.");
  }
  static async hasCamera() {
    try {
      return !!(await _a.listCameras(!1)).length;
    } catch {
      return !1;
    }
  }
  static async listCameras(a2 = !1) {
    if (!navigator.mediaDevices)
      return [];
    let b2 = /* @__PURE__ */ __name(async () => (await navigator.mediaDevices.enumerateDevices()).filter((d2) => d2.kind === "videoinput"), "b"), c2;
    try {
      a2 && (await b2()).every((d2) => !d2.label) && (c2 = await navigator.mediaDevices.getUserMedia({ audio: !1, video: !0 }));
    } catch {
    }
    try {
      return (await b2()).map((d2, f2) => ({ id: d2.deviceId, label: d2.label || (f2 === 0 ? "Default Camera" : `Camera ${f2 + 1}`) }));
    } finally {
      c2 && (console.warn("Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"), _a._stopVideoStream(c2));
    }
  }
  async hasFlash() {
    let a2;
    try {
      if (this.$video.srcObject) {
        if (!(this.$video.srcObject instanceof MediaStream))
          return !1;
        a2 = this.$video.srcObject;
      } else
        a2 = (await this._getCameraStream()).stream;
      return "torch" in a2.getVideoTracks()[0].getSettings();
    } catch {
      return !1;
    } finally {
      a2 && a2 !== this.$video.srcObject && (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), _a._stopVideoStream(a2));
    }
  }
  isFlashOn() {
    return this._flashOn;
  }
  async toggleFlash() {
    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();
  }
  async turnFlashOn() {
    if (!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused))
      try {
        if (!await this.hasFlash())
          throw "No flash available";
        await this.$video.srcObject.getVideoTracks()[0].applyConstraints({ advanced: [{ torch: !0 }] });
      } catch (a2) {
        throw this._flashOn = !1, a2;
      }
  }
  async turnFlashOff() {
    this._flashOn && (this._flashOn = !1, await this._restartVideoStream());
  }
  destroy() {
    this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData), this.$video.removeEventListener("play", this._onPlay), document.removeEventListener(
      "visibilitychange",
      this._onVisibilityChange
    ), window.removeEventListener("resize", this._updateOverlay), this._destroyed = !0, this._flashOn = !1, this.stop(), _a._postWorkerMessage(this._qrEnginePromise, "close");
  }
  async start() {
    if (this._destroyed)
      throw Error("The QR scanner can not be started as it had been destroyed.");
    if ((!this._active || this._paused) && (window.location.protocol !== "https:" && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = !0, !document.hidden))
      if (this._paused = !1, this.$video.srcObject)
        await this.$video.play();
      else
        try {
          let { stream: a2, facingMode: b2 } = await this._getCameraStream();
          !this._active || this._paused ? _a._stopVideoStream(a2) : (this._setVideoMirror(b2), this.$video.srcObject = a2, await this.$video.play(), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(() => {
          })));
        } catch (a2) {
          if (!this._paused)
            throw this._active = !1, a2;
        }
  }
  stop() {
    this.pause(), this._active = !1;
  }
  async pause(a2 = !1) {
    if (this._paused = !0, !this._active)
      return !0;
    this.$video.pause(), this.$overlay && (this.$overlay.style.display = "none");
    let b2 = /* @__PURE__ */ __name(() => {
      this.$video.srcObject instanceof MediaStream && (_a._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);
    }, "b");
    return a2 ? (b2(), !0) : (await new Promise((c2) => setTimeout(c2, 300)), this._paused ? (b2(), !0) : !1);
  }
  async setCamera(a2) {
    a2 !== this._preferredCamera && (this._preferredCamera = a2, await this._restartVideoStream());
  }
  static async scanImage(a2, b2, c2, d2, f2 = !1, h2 = !1) {
    let m2, n2 = !1;
    b2 && ("scanRegion" in b2 || "qrEngine" in b2 || "canvas" in b2 || "disallowCanvasResizing" in b2 || "alsoTryWithoutScanRegion" in b2 || "returnDetailedScanResult" in b2) ? (m2 = b2.scanRegion, c2 = b2.qrEngine, d2 = b2.canvas, f2 = b2.disallowCanvasResizing || !1, h2 = b2.alsoTryWithoutScanRegion || !1, n2 = !0) : console.warn(b2 || c2 || d2 || f2 || h2 ? "You're using a deprecated api for scanImage which will be removed in the future." : "Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), b2 = !!c2;
    try {
      let p2, k2;
      [c2, p2] = await Promise.all([c2 || _a.createQrEngine(), _a._loadImage(a2)]), [d2, k2] = _a._drawToCanvas(p2, m2, d2, f2);
      let q2;
      if (c2 instanceof Worker) {
        let g2 = c2;
        b2 || _a._postWorkerMessageSync(g2, "inversionMode", "both"), q2 = await new Promise((l2, v2) => {
          let w2, u2, r2, y2 = -1;
          u2 = /* @__PURE__ */ __name((t2) => {
            t2.data.id === y2 && (g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), t2.data.data !== null ? l2({ data: t2.data.data, cornerPoints: _a._convertPoints(t2.data.cornerPoints, m2) }) : v2(_a.NO_QR_CODE_FOUND));
          }, "u"), r2 = /* @__PURE__ */ __name((t2) => {
            g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), v2("Scanner error: " + (t2 ? t2.message || t2 : "Unknown Error"));
          }, "r"), g2.addEventListener("message", u2), g2.addEventListener("error", r2), w2 = setTimeout(() => r2("timeout"), 1e4);
          let x2 = k2.getImageData(0, 0, d2.width, d2.height);
          y2 = _a._postWorkerMessageSync(g2, "decode", x2, [x2.data.buffer]);
        });
      } else
        q2 = await Promise.race([new Promise((g2, l2) => window.setTimeout(() => l2("Scanner error: timeout"), 1e4)), (async () => {
          try {
            var [g2] = await c2.detect(d2);
            if (!g2)
              throw _a.NO_QR_CODE_FOUND;
            return { data: g2.rawValue, cornerPoints: _a._convertPoints(g2.cornerPoints, m2) };
          } catch (l2) {
            if (g2 = l2.message || l2, /not implemented|service unavailable/.test(g2))
              return _a._disableBarcodeDetector = !0, _a.scanImage(a2, { scanRegion: m2, canvas: d2, disallowCanvasResizing: f2, alsoTryWithoutScanRegion: h2 });
            throw `Scanner error: ${g2}`;
          }
        })()]);
      return n2 ? q2 : q2.data;
    } catch (p2) {
      if (!m2 || !h2)
        throw p2;
      let k2 = await _a.scanImage(a2, { qrEngine: c2, canvas: d2, disallowCanvasResizing: f2 });
      return n2 ? k2 : k2.data;
    } finally {
      b2 || _a._postWorkerMessage(c2, "close");
    }
  }
  setGrayscaleWeights(a2, b2, c2, d2 = !0) {
    _a._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
      red: a2,
      green: b2,
      blue: c2,
      useIntegerApproximation: d2
    });
  }
  setInversionMode(a2) {
    _a._postWorkerMessage(this._qrEnginePromise, "inversionMode", a2);
  }
  static async createQrEngine(a2) {
    if (a2 && console.warn("Specifying a worker path is not required and not supported anymore."), a2 = /* @__PURE__ */ __name(() => __vitePreload(() => import("./qr-scanner-worker.min.js"), [], import.meta.url).then((c2) => c2.createWorker()), "a"), !(!_a._disableBarcodeDetector && "BarcodeDetector" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes("qr_code")))
      return a2();
    let b2 = navigator.userAgentData;
    return b2 && b2.brands.some(({ brand: c2 }) => /Chromium/i.test(c2)) && /mac ?OS/i.test(b2.platform) && await b2.getHighEntropyValues(["architecture", "platformVersion"]).then(({ architecture: c2, platformVersion: d2 }) => /arm/i.test(c2 || "arm") && 13 <= parseInt(d2 || "13")).catch(() => !0) ? a2() : new BarcodeDetector({ formats: ["qr_code"] });
  }
  _onPlay() {
    this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay(), this.$overlay && (this.$overlay.style.display = ""), this._scanFrame();
  }
  _onLoadedMetaData() {
    this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay();
  }
  _onVisibilityChange() {
    document.hidden ? this.pause() : this._active && this.start();
  }
  _calculateScanRegion(a2) {
    let b2 = Math.round(0.6666666666666666 * Math.min(a2.videoWidth, a2.videoHeight));
    return { x: Math.round((a2.videoWidth - b2) / 2), y: Math.round((a2.videoHeight - b2) / 2), width: b2, height: b2, downScaledWidth: this._legacyCanvasSize, downScaledHeight: this._legacyCanvasSize };
  }
  _updateOverlay() {
    requestAnimationFrame(() => {
      if (this.$overlay) {
        var a2 = this.$video, b2 = a2.videoWidth, c2 = a2.videoHeight, d2 = a2.offsetWidth, f2 = a2.offsetHeight, h2 = a2.offsetLeft, m2 = a2.offsetTop, n2 = window.getComputedStyle(a2), p2 = n2.objectFit, k2 = b2 / c2, q2 = d2 / f2;
        switch (p2) {
          case "none":
            var g2 = b2, l2 = c2;
            break;
          case "fill":
            g2 = d2, l2 = f2;
            break;
          default:
            (p2 === "cover" ? k2 > q2 : k2 < q2) ? (l2 = f2, g2 = l2 * k2) : (g2 = d2, l2 = g2 / k2), p2 === "scale-down" && (g2 = Math.min(g2, b2), l2 = Math.min(l2, c2));
        }
        var [v2, w2] = n2.objectPosition.split(" ").map((r2, y2) => {
          const x2 = parseFloat(r2);
          return r2.endsWith("%") ? (y2 ? f2 - l2 : d2 - g2) * x2 / 100 : x2;
        });
        n2 = this._scanRegion.width || b2, q2 = this._scanRegion.height || c2, p2 = this._scanRegion.x || 0;
        var u2 = this._scanRegion.y || 0;
        k2 = this.$overlay.style, k2.width = `${n2 / b2 * g2}px`, k2.height = `${q2 / c2 * l2}px`, k2.top = `${m2 + w2 + u2 / c2 * l2}px`, c2 = /scaleX\(-1\)/.test(a2.style.transform), k2.left = `${h2 + (c2 ? d2 - v2 - g2 : v2) + (c2 ? b2 - p2 - n2 : p2) / b2 * g2}px`, k2.transform = a2.style.transform;
      }
    });
  }
  static _convertPoints(a2, b2) {
    if (!b2)
      return a2;
    let c2 = b2.x || 0, d2 = b2.y || 0, f2 = b2.width && b2.downScaledWidth ? b2.width / b2.downScaledWidth : 1;
    b2 = b2.height && b2.downScaledHeight ? b2.height / b2.downScaledHeight : 1;
    for (let h2 of a2)
      h2.x = h2.x * f2 + c2, h2.y = h2.y * b2 + d2;
    return a2;
  }
  _scanFrame() {
    !this._active || this.$video.paused || this.$video.ended || ("requestVideoFrameCallback" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {
      if (!(1 >= this.$video.readyState)) {
        var a2 = Date.now() - this._lastScanTimestamp, b2 = 1e3 / this._maxScansPerSecond;
        a2 < b2 && await new Promise((d2) => setTimeout(d2, b2 - a2)), this._lastScanTimestamp = Date.now();
        try {
          var c2 = await _a.scanImage(this.$video, { scanRegion: this._scanRegion, qrEngine: this._qrEnginePromise, canvas: this.$canvas });
        } catch (d2) {
          if (!this._active)
            return;
          this._onDecodeError(d2);
        }
        !_a._disableBarcodeDetector || await this._qrEnginePromise instanceof Worker || (this._qrEnginePromise = _a.createQrEngine()), c2 ? (this._onDecode ? this._onDecode(c2) : this._legacyOnDecode && this._legacyOnDecode(c2.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute("viewBox", `${this._scanRegion.x || 0} ${this._scanRegion.y || 0} ${this._scanRegion.width || this.$video.videoWidth} ${this._scanRegion.height || this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute(
          "points",
          c2.cornerPoints.map(({ x: d2, y: f2 }) => `${d2},${f2}`).join(" ")
        ), this.$codeOutlineHighlight.style.display = "")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = "none", 100));
      }
      this._scanFrame();
    });
  }
  _onDecodeError(a2) {
    a2 !== _a.NO_QR_CODE_FOUND && console.log(a2);
  }
  async _getCameraStream() {
    if (!navigator.mediaDevices)
      throw "Camera not found.";
    let a2 = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId", b2 = [{ width: { min: 1024 } }, { width: { min: 768 } }, {}], c2 = b2.map((d2) => Object.assign({}, d2, { [a2]: { exact: this._preferredCamera } }));
    for (let d2 of [...c2, ...b2])
      try {
        let f2 = await navigator.mediaDevices.getUserMedia({ video: d2, audio: !1 }), h2 = this._getFacingMode(f2) || (d2.facingMode ? this._preferredCamera : this._preferredCamera === "environment" ? "user" : "environment");
        return { stream: f2, facingMode: h2 };
      } catch {
      }
    throw "Camera not found.";
  }
  async _restartVideoStream() {
    let a2 = this._paused;
    await this.pause(!0) && !a2 && this._active && await this.start();
  }
  static _stopVideoStream(a2) {
    for (let b2 of a2.getTracks())
      b2.stop(), a2.removeTrack(b2);
  }
  _setVideoMirror(a2) {
    this.$video.style.transform = "scaleX(" + (a2 === "user" ? -1 : 1) + ")";
  }
  _getFacingMode(a2) {
    return (a2 = a2.getVideoTracks()[0]) ? /rear|back|environment/i.test(a2.label) ? "environment" : /front|user|face/i.test(a2.label) ? "user" : null : null;
  }
  static _drawToCanvas(a2, b2, c2, d2 = !1) {
    c2 = c2 || document.createElement("canvas");
    let f2 = b2 && b2.x ? b2.x : 0, h2 = b2 && b2.y ? b2.y : 0, m2 = b2 && b2.width ? b2.width : a2.videoWidth || a2.width, n2 = b2 && b2.height ? b2.height : a2.videoHeight || a2.height;
    return d2 || (d2 = b2 && b2.downScaledWidth ? b2.downScaledWidth : m2, b2 = b2 && b2.downScaledHeight ? b2.downScaledHeight : n2, c2.width !== d2 && (c2.width = d2), c2.height !== b2 && (c2.height = b2)), b2 = c2.getContext("2d", { alpha: !1 }), b2.imageSmoothingEnabled = !1, b2.drawImage(a2, f2, h2, m2, n2, 0, 0, c2.width, c2.height), [c2, b2];
  }
  static async _loadImage(a2) {
    if (a2 instanceof Image)
      return await _a._awaitImageLoad(a2), a2;
    if (a2 instanceof HTMLVideoElement || a2 instanceof HTMLCanvasElement || a2 instanceof SVGImageElement || "OffscreenCanvas" in window && a2 instanceof OffscreenCanvas || "ImageBitmap" in window && a2 instanceof ImageBitmap)
      return a2;
    if (a2 instanceof File || a2 instanceof Blob || a2 instanceof URL || typeof a2 == "string") {
      let b2 = new Image();
      b2.src = a2 instanceof File || a2 instanceof Blob ? URL.createObjectURL(a2) : a2.toString();
      try {
        return await _a._awaitImageLoad(b2), b2;
      } finally {
        (a2 instanceof File || a2 instanceof Blob) && URL.revokeObjectURL(b2.src);
      }
    } else
      throw "Unsupported image type.";
  }
  static async _awaitImageLoad(a2) {
    a2.complete && a2.naturalWidth !== 0 || await new Promise((b2, c2) => {
      let d2 = /* @__PURE__ */ __name((f2) => {
        a2.removeEventListener("load", d2), a2.removeEventListener("error", d2), f2 instanceof ErrorEvent ? c2("Image load error") : b2();
      }, "d");
      a2.addEventListener("load", d2), a2.addEventListener("error", d2);
    });
  }
  static async _postWorkerMessage(a2, b2, c2, d2) {
    return _a._postWorkerMessageSync(await a2, b2, c2, d2);
  }
  static _postWorkerMessageSync(a2, b2, c2, d2) {
    if (!(a2 instanceof Worker))
      return -1;
    let f2 = _a._workerMessageId++;
    return a2.postMessage({ id: f2, type: b2, data: c2 }, d2), f2;
  }
}, __name(_a, "e"), _a);
e$1.DEFAULT_CANVAS_SIZE = 400;
e$1.NO_QR_CODE_FOUND = "No QR code found";
e$1._disableBarcodeDetector = !1;
e$1._workerMessageId = 0;
const useQRScanner = /* @__PURE__ */ __name((videoRef, {
  onStart,
  onResult,
  onError
}) => {
  reactExports.useEffect(() => {
    const scannerPromise = (/* @__PURE__ */ __name(async () => {
      const scanner = videoRef.current && new e$1(
        videoRef.current,
        (result) => {
          scanner == null || scanner.stop(), onResult(result);
        },
        {
          onDecodeError: onError,
          highlightScanRegion: !0,
          highlightCodeOutline: !0
        }
      );
      try {
        await (scanner == null ? void 0 : scanner.start()), onStart && onStart();
      } catch (error3) {
        console.error(error3);
      }
      return () => {
        scanner == null || scanner.stop(), scanner == null || scanner.destroy();
      };
    }, "startScanner"))();
    return () => {
      scannerPromise.then((cleanupFunc) => cleanupFunc());
    };
  }, [videoRef, onStart, onResult, onError]);
}, "useQRScanner"), spinnerAnimationContainer = "_spinnerAnimationContainer_18sha_1", qrVideo = "_qrVideo_18sha_10", style$s = {
  spinnerAnimationContainer,
  qrVideo
}, ScanQRVideo = /* @__PURE__ */ __name(({
  onResult
}) => {
  const videoRef = reactExports.useRef(null);
  return useQRScanner(videoRef, {
    onResult: (result) => onResult(result.data),
    onError: console.error
  }), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$s.spinnerAnimationContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        className: style$s.qrVideo,
        ref: videoRef,
        poster: "%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2264%22%20height=%2248%22%3E%3C/svg%3E"
      }
    )
  ] });
}, "ScanQRVideo"), ScanQRDialog = /* @__PURE__ */ __name(({ parseQRResult, activeScanQR, toggleScanQR, onChangeActiveScanQR }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      large: !0,
      open: activeScanQR,
      title: t2("send.scanQR"),
      onClose: toggleScanQR,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ScanQRVideo,
          {
            onResult: (result) => {
              parseQRResult(result), onChangeActiveScanQR(!1);
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: toggleScanQR,
            children: t2("button.back")
          }
        ) })
      ]
    }
  );
}, "ScanQRDialog"), inputWithIcon$1 = "_inputWithIcon_drrz7_1", action$2 = "_action_drrz7_9", qrButton = "_qrButton_drrz7_18", style$r = {
  inputWithIcon: inputWithIcon$1,
  action: action$2,
  qrButton
}, ScanQRButton = /* @__PURE__ */ __name(({ onClick }) => {
  const { isDarkMode } = reactExports.useContext(DarkModeContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick, className: style$r.qrButton, children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeDark, {}) });
}, "ScanQRButton"), ReceiverAddressInput = /* @__PURE__ */ __name(({
  accountCode,
  addressError,
  onInputChange,
  recipientAddress,
  activeScanQR,
  parseQRResult,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation(), toggleScanQR = /* @__PURE__ */ __name(() => {
    if (activeScanQR) {
      onChangeActiveScanQR(!1);
      return;
    }
    onChangeActiveScanQR(!0);
  }, "toggleScanQR");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScanQRDialog,
      {
        activeScanQR,
        toggleScanQR,
        onChangeActiveScanQR,
        parseQRResult
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.address.label"),
        placeholder: t2("send.address.placeholder"),
        id: "recipientAddress",
        error: addressError,
        onInput: (e2) => onInputChange(e2.target.value),
        value: recipientAddress,
        className: style$r.inputWithIcon,
        labelSection: void 0,
        autoFocus: !0,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
      }
    )
  ] });
}, "ReceiverAddressInput"), maxAmount = "_maxAmount_1t5n0_1", style$q = {
  maxAmount
}, CoinInput = /* @__PURE__ */ __name(({
  balance: balance2,
  onAmountChange,
  onSendAllChange,
  sendAll,
  amountError,
  proposedAmount,
  amount: amount2,
  hasSelectedUTXOs
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: balance2 ? balance2.available.unit : t2("send.amount.label"),
      id: "amount",
      onInput: (e2) => onAmountChange(e2.target.value),
      disabled: sendAll,
      error: amountError,
      value: sendAll ? proposedAmount ? proposedAmount.amount : "" : amount2,
      placeholder: t2("send.amount.placeholder"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          label: t2(hasSelectedUTXOs ? "send.maximumSelectedCoins" : "send.maximum"),
          id: "sendAll",
          onChange: (e2) => onSendAllChange(e2.target.checked),
          checked: sendAll,
          className: style$q.maxAmount
        }
      )
    }
  );
}, "CoinInput"), FiatInput = /* @__PURE__ */ __name(({ label: label2, onFiatChange, disabled: disabled2, error: error3, fiatAmount }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: label2,
      id: "fiatAmount",
      onInput: onFiatChange,
      disabled: disabled2,
      error: error3,
      value: fiatAmount,
      placeholder: t2("send.amount.placeholder")
    }
  );
}, "FiatInput"), labelDescription = "_labelDescription_5etm5_1", style$p = {
  labelDescription
}, NoteInput = /* @__PURE__ */ __name(({ onNoteChange, note: note2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      label: t2("note.title"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.labelDescription, children: t2("note.input.description") }),
      id: "note",
      onInput: onNoteChange,
      value: note2,
      placeholder: t2("note.input.placeholder")
    }
  );
}, "NoteInput"), container$f = "_container_8f83b_1", style$o = {
  container: container$f
}, _Send = class _Send extends reactExports.Component {
  constructor() {
    super(...arguments), this.selectedUTXOs = {}, this.unsubscribeList = [], this.pendingProposals = [], this.proposeTimeout = null, this.state = {
      recipientAddress: "",
      amount: "",
      fiatAmount: "",
      valid: !1,
      sendAll: !1,
      isConfirming: !1,
      signConfirm: !1,
      isSent: !1,
      isAborted: !1,
      isUpdatingProposal: !1,
      noMobileChannelError: !1,
      fiatUnit: this.props.activeCurrency,
      coinControl: !1,
      btcUnit: "default",
      activeCoinControl: !1,
      activeScanQR: !1,
      note: "",
      customFee: ""
    }, this.isBitcoinBased = () => {
      const account2 = this.getAccount();
      return account2 ? isBitcoinBased(account2.coinCode) : !1;
    }, this.registerEvents = () => {
      document.addEventListener("keydown", this.handleKeyDown);
    }, this.unregisterEvents = () => {
      document.removeEventListener("keydown", this.handleKeyDown);
    }, this.handleKeyDown = (e2) => {
      e2.keyCode === 27 && !this.state.activeCoinControl && !this.state.activeScanQR && route(`/account/${this.props.code}`);
    }, this.send = async () => {
      if (this.state.noMobileChannelError) {
        alertUser(this.props.t("warning.sendPairing"));
        return;
      }
      const code = this.getAccount().code;
      if ((await connectKeystore(code)).success) {
        this.setState({ signProgress: void 0, isConfirming: !0 });
        try {
          const result = await sendTx(code);
          if (result.success)
            this.setState({
              sendAll: !1,
              isConfirming: !1,
              isSent: !0,
              recipientAddress: "",
              proposedAmount: void 0,
              proposedFee: void 0,
              proposedTotal: void 0,
              fiatAmount: "",
              amount: "",
              note: "",
              customFee: ""
            }), this.selectedUTXOs = {}, setTimeout(() => this.setState({
              isSent: !1,
              isConfirming: !1
            }), 5e3);
          else if (result.aborted)
            this.setState({ isAborted: !0 }), setTimeout(() => this.setState({ isAborted: !1 }), 5e3);
          else
            switch (result.errorCode) {
              case "erc20InsufficientGasFunds":
                alertUser(this.props.t(`send.error.${result.errorCode}`));
                break;
              default:
                const { errorMessage } = result;
                alertUser(this.props.t("unknownError", errorMessage && { errorMessage }));
            }
        } catch (err) {
          console.error(err);
        } finally {
          this.setState({ isConfirming: !1, signProgress: void 0, signConfirm: !1 });
        }
      }
    }, this.txInput = () => ({
      address: this.state.recipientAddress,
      amount: this.state.amount,
      feeTarget: this.state.feeTarget || "",
      customFee: this.state.customFee,
      sendAll: this.state.sendAll ? "yes" : "no",
      selectedUTXOs: Object.keys(this.selectedUTXOs)
    }), this.sendDisabled = () => {
      const txInput = this.txInput();
      return !txInput.address || this.state.feeTarget === void 0 || txInput.sendAll === "no" && !txInput.amount || this.state.feeTarget === "custom" && !this.state.customFee;
    }, this.validateAndDisplayFee = (updateFiat = !0) => {
      if (this.setState({
        proposedTotal: void 0,
        addressError: void 0,
        amountError: void 0,
        feeError: void 0
      }), this.sendDisabled())
        return;
      const txInput = this.txInput();
      this.proposeTimeout && (clearTimeout(this.proposeTimeout), this.proposeTimeout = null), this.setState({ isUpdatingProposal: !0 }), this.proposeTimeout = setTimeout(() => {
        const propose = apiPost("account/" + this.getAccount().code + "/tx-proposal", txInput).then((result) => {
          const pos = this.pendingProposals.indexOf(propose);
          this.pendingProposals.length - 1 === pos && this.txProposal(updateFiat, result), this.pendingProposals.splice(pos, 1);
        }).catch(() => {
          this.setState({ valid: !1 }), this.pendingProposals.splice(this.pendingProposals.indexOf(propose), 1);
        });
        this.pendingProposals.push(propose);
      }, 400);
    }, this.handleNoteInput = (event2) => {
      const target = event2.target;
      this.setState({
        note: target.value
      }, () => {
        proposeTxNote(this.getAccount().code, this.state.note);
      });
    }, this.txProposal = (updateFiat, result) => {
      if (this.setState({ valid: result.success }), result.success)
        this.setState({
          addressError: void 0,
          amountError: void 0,
          feeError: void 0,
          proposedFee: result.fee,
          proposedAmount: result.amount,
          proposedTotal: result.total,
          isUpdatingProposal: !1
        }), updateFiat && this.convertToFiat(result.amount.amount);
      else {
        const errorHandling = txProposalErrorHandling(this.registerEvents, this.unregisterEvents, result.errorCode);
        this.setState({ ...errorHandling, isUpdatingProposal: !1 });
      }
    }, this.handleFiatInput = (event2) => {
      const value = event2.target.value;
      this.setState({ fiatAmount: value }), this.convertFromFiat(value);
    }, this.convertToFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-to-plain-fiat?from=${coinCode}&to=${this.state.fiatUnit}&amount=${value}`).then((data) => {
          data.success ? this.setState({ fiatAmount: data.fiatAmount }) : this.setState({ amountError: this.props.t("send.error.invalidAmount") });
        });
      } else
        this.setState({ fiatAmount: "" });
    }, this.convertFromFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-from-fiat?from=${this.state.fiatUnit}&to=${coinCode}&amount=${value}`).then((data) => {
          data.success ? this.setState({ amount: data.amount }, () => this.validateAndDisplayFee(!1)) : this.setState({ amountError: this.props.t("send.error.invalidAmount") });
        });
      } else
        this.setState({ amount: "" });
    }, this.feeTargetChange = (feeTarget) => {
      this.setState(
        { feeTarget, customFee: "" },
        () => this.validateAndDisplayFee(this.state.sendAll)
      );
    }, this.onSelectedUTXOsChange = (selectedUTXOs) => {
      this.selectedUTXOs = selectedUTXOs, this.validateAndDisplayFee(!0);
    }, this.hasSelectedUTXOs = () => Object.keys(this.selectedUTXOs).length !== 0, this.getAccount = () => {
      if (this.props.code)
        return findAccount(this.props.accounts, this.props.code);
    }, this.toggleCoinControl = () => {
      this.setState(({ activeCoinControl }) => (activeCoinControl && (this.selectedUTXOs = {}), { activeCoinControl: !activeCoinControl }));
    }, this.setActiveScanQR = (activeScanQR) => {
      this.setState({ activeScanQR });
    }, this.parseQRResult = async (uri) => {
      let address2, amount2 = "";
      try {
        const url = new URL(uri);
        if (url.protocol !== "bitcoin:" && url.protocol !== "litecoin:" && url.protocol !== "ethereum:") {
          alertUser(this.props.t("invalidFormat"));
          return;
        }
        address2 = url.pathname, this.isBitcoinBased() && (amount2 = url.searchParams.get("amount") || "");
      } catch {
        address2 = uri;
      }
      let updateState = {
        recipientAddress: address2,
        sendAll: !1,
        fiatAmount: ""
      };
      const coinCode = this.getAccount().coinCode;
      if (amount2)
        if (coinCode === "btc" || coinCode === "tbtc") {
          const result = await parseExternalBtcAmount(amount2);
          if (result.success)
            updateState.amount = result.amount;
          else {
            updateState.amountError = this.props.t("send.error.invalidAmount"), this.setState(updateState);
            return;
          }
        } else
          updateState.amount = amount2;
      this.setState(updateState, () => {
        this.convertToFiat(this.state.amount), this.validateAndDisplayFee(!0);
      });
    }, this.deactivateCoinControl = () => {
      this.setState({ activeCoinControl: !1 });
    }, this.onReceiverAddressInputChange = (recipientAddress) => {
      this.setState({ recipientAddress }, () => {
        this.validateAndDisplayFee(!0);
      });
    }, this.onCoinAmountChange = (amount2) => {
      this.convertToFiat(amount2), this.setState({ amount: amount2 }, () => {
        this.validateAndDisplayFee(!0);
      });
    }, this.onSendAllChange = (sendAll) => {
      sendAll || this.convertToFiat(this.state.amount), this.setState({ sendAll }, () => {
        this.validateAndDisplayFee(!0);
      });
    };
  }
  componentDidMount() {
    this.props.code && getBalance(this.props.code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error), this.props.deviceIDs.length > 0 && this.props.devices[this.props.deviceIDs[0]] === "bitbox" && apiGet("devices/" + this.props.deviceIDs[0] + "/has-mobile-channel").then((mobileChannel) => {
      getDeviceInfo$1(this.props.deviceIDs[0]).then(({ pairing: pairing2 }) => {
        const account2 = this.getAccount(), paired = mobileChannel && pairing2, noMobileChannelError = pairing2 && !mobileChannel && account2 && isBitcoinBased(account2.coinCode);
        this.setState((prevState) => ({ ...prevState, paired, noMobileChannelError }));
      });
    }), apiGet("config").then((config) => {
      this.setState({ btcUnit: config.backend.btcUnit }), this.isBitcoinBased() && this.setState({ coinControl: !!(config.frontend || {}).coinControl });
    }), this.unsubscribeList = [
      apiWebsocket((payload) => {
        if ("type" in payload) {
          const { data, meta, type: type2 } = payload;
          switch (type2) {
            case "device":
              switch (data) {
                case "signProgress":
                  this.setState({ signProgress: meta, signConfirm: !1 });
                  break;
                case "signConfirm":
                  this.setState({ signConfirm: !0 });
                  break;
              }
              break;
          }
        }
      }),
      syncdone((code) => {
        this.props.code === code && getBalance(code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error);
      })
    ];
  }
  UNSAFE_componentWillMount() {
    this.registerEvents();
  }
  componentWillUnmount() {
    this.unregisterEvents(), unsubscribe(this.unsubscribeList);
  }
  render() {
    var _a46;
    const { t: t2, code } = this.props, {
      balance: balance2,
      proposedFee,
      proposedTotal,
      recipientAddress,
      proposedAmount,
      valid,
      amount: amount2,
      /* data, */
      fiatAmount,
      fiatUnit,
      sendAll,
      feeTarget,
      customFee,
      isConfirming,
      isSent,
      isAborted,
      isUpdatingProposal,
      addressError,
      amountError,
      feeError,
      paired,
      signProgress,
      signConfirm,
      coinControl,
      btcUnit,
      activeCoinControl,
      activeScanQR,
      note: note2
    } = this.state, waitDialogTransactionDetails = {
      proposedFee,
      proposedAmount,
      proposedTotal,
      customFee,
      feeTarget,
      recipientAddress,
      fiatUnit
    }, waitDialogTransactionStatus = {
      isConfirming,
      signProgress,
      signConfirm
    }, account2 = this.getAccount();
    if (!account2)
      return null;
    const baseCurrencyUnit = fiatUnit === "BTC" && btcUnit === "sat" ? "sat" : fiatUnit;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== !1, children: t2("warning.sendPairing") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SharedHeader,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("send.title", { accountName: account2.coinName }) }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.availableBalance") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2, noRotateFiat: !0 }),
            coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              UTXOs,
              {
                accountCode: account2.code,
                active: activeCoinControl,
                explorerURL: account2.blockExplorerTxPrefix,
                onClose: this.deactivateCoinControl,
                onChange: this.onSelectedUTXOsChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-row flex-between ${style$o.container}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.transactionDetails") }),
              coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: "m-bottom-quarter p-right-none",
                  transparent: !0,
                  onClick: this.toggleCoinControl,
                  children: t2("send.toggleCoinControl")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ReceiverAddressInput,
              {
                accountCode: (_a46 = this.getAccount()) == null ? void 0 : _a46.code,
                addressError,
                onInputChange: this.onReceiverAddressInputChange,
                recipientAddress,
                parseQRResult: this.parseQRResult,
                activeScanQR,
                onChangeActiveScanQR: this.setActiveScanQR
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CoinInput,
                {
                  balance: balance2,
                  onAmountChange: this.onCoinAmountChange,
                  onSendAllChange: this.onSendAllChange,
                  sendAll,
                  amountError,
                  proposedAmount,
                  amount: amount2,
                  hasSelectedUTXOs: this.hasSelectedUTXOs()
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FiatInput,
                {
                  onFiatChange: this.handleFiatInput,
                  disabled: sendAll,
                  error: amountError,
                  fiatAmount,
                  label: baseCurrencyUnit
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TranslatedFeeTargets,
                {
                  accountCode: account2.code,
                  coinCode: account2.coinCode,
                  disabled: !amount2 && !sendAll,
                  fiatUnit: baseCurrencyUnit,
                  proposedFee,
                  customFee,
                  showCalculatingFeeLabel: isUpdatingProposal,
                  onFeeTargetChange: this.feeTargetChange,
                  onCustomFee: (customFee2) => this.setState({ customFee: customFee2 }, this.validateAndDisplayFee),
                  error: feeError
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NoteInput,
                  {
                    note: note2,
                    onNoteChange: this.handleNoteInput
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  ColumnButtons,
                  {
                    className: "m-top-default m-bottom-xlarge",
                    inline: !0,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          primary: !0,
                          onClick: this.send,
                          disabled: this.sendDisabled() || !valid || isUpdatingProposal,
                          children: t2("send.button")
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ButtonLink,
                        {
                          secondary: !0,
                          to: `/account/${code}`,
                          children: t2("button.back")
                        }
                      )
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConfirmingWaitDialog,
            {
              paired,
              baseCurrencyUnit,
              note: note2,
              hasSelectedUTXOs: this.hasSelectedUTXOs(),
              selectedUTXOs: Object.keys(this.selectedUTXOs),
              coinCode: account2.coinCode,
              transactionDetails: waitDialogTransactionDetails,
              transactionStatus: waitDialogTransactionStatus
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isSent, messageType: "sent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isAborted, messageType: "abort" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SendGuide, { coinCode: account2.coinCode })
    ] });
  }
};
__name(_Send, "Send");
let Send = _Send;
const TranslatedSend = translate()(Send), SendWrapper = /* @__PURE__ */ __name(({ accounts, code, deviceIDs, devices }) => {
  const { defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedSend,
    {
      accounts,
      code,
      devices,
      deviceIDs,
      activeCurrency: defaultCurrency2
    }
  );
}, "SendWrapper"), errUserAbort = 104, resetDevice = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/reset`), "resetDevice"), getDeviceInfo = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/info`), "getDeviceInfo"), checkSDCard = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/check-sdcard`), "checkSDCard"), insertSDCard = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/insert-sdcard`), "insertSDCard"), setDeviceName = /* @__PURE__ */ __name((deviceID, newDeviceName) => apiPost(`devices/bitbox02/${deviceID}/set-device-name`, {
  name: newDeviceName
}), "setDeviceName"), getVersion = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/version`), "getVersion"), setMnemonicPassphraseEnabled = /* @__PURE__ */ __name((deviceID, enabled) => apiPost(`devices/bitbox02/${deviceID}/set-mnemonic-passphrase-enabled`, enabled), "setMnemonicPassphraseEnabled"), verifyAttestation = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/attestation`), "verifyAttestation"), checkBackup = /* @__PURE__ */ __name((deviceID, silent) => apiPost(`devices/bitbox02/${deviceID}/backups/check`, { silent }), "checkBackup"), createBackup = /* @__PURE__ */ __name((deviceID, method) => apiPost(`devices/bitbox02/${deviceID}/backups/create`, method), "createBackup"), restoreBackup = /* @__PURE__ */ __name((deviceID, selectedBackup) => apiPost(`devices/bitbox02/${deviceID}/backups/restore`, selectedBackup), "restoreBackup"), upgradeDeviceFirmware = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/upgrade-firmware`), "upgradeDeviceFirmware"), showMnemonic = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/show-mnemonic`), "showMnemonic"), restoreFromMnemonic = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/restore-from-mnemonic`), "restoreFromMnemonic"), getStatus$1 = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/status`), "getStatus$1"), getChannelHash = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/channel-hash`), "getChannelHash"), verifyChannelHash = /* @__PURE__ */ __name((deviceID, ok2) => apiPost(`devices/bitbox02/${deviceID}/channel-hash-verify`, ok2), "verifyChannelHash"), setPassword = /* @__PURE__ */ __name((deviceID, seedLen) => apiPost(`devices/bitbox02/${deviceID}/set-password`, seedLen), "setPassword"), getRootFingerprint = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/root-fingerprint`), "getRootFingerprint"), useSDCard = /* @__PURE__ */ __name((devices, dependencies) => {
  const [sdcard, setSDCard] = reactExports.useState(!1), mounted = useMountedRef();
  return reactExports.useEffect(() => {
    const deviceIDs = Object.keys(devices);
    Promise.all(deviceIDs.map((deviceID) => {
      switch (devices[deviceID]) {
        case "bitbox":
          return getDeviceInfo$1(deviceID).then(({ sdcard: sdcard2 }) => sdcard2);
        case "bitbox02":
          return checkSDCard(deviceID);
        default:
          return !1;
      }
    })).then((sdcards) => sdcards.some((sdcard2) => sdcard2)).then((result) => {
      mounted.current && setSDCard(result);
    }).catch(console.error);
  }, [devices, ...dependencies || []]), sdcard;
}, "useSDCard");
function size(_a46) {
  var width = _a46.width, height = _a46.height;
  if (width < 0)
    throw new Error("Negative width is not allowed for Size");
  if (height < 0)
    throw new Error("Negative height is not allowed for Size");
  return {
    width,
    height
  };
}
__name(size, "size");
function equalSizes(first2, second) {
  return first2.width === second.width && first2.height === second.height;
}
__name(equalSizes, "equalSizes");
var Observable = (
  /** @class */
  function() {
    function Observable2(win) {
      var _this = this;
      this._resolutionListener = function() {
        return _this._onResolutionChanged();
      }, this._resolutionMediaQueryList = null, this._observers = [], this._window = win, this._installResolutionListener();
    }
    return __name(Observable2, "Observable"), Observable2.prototype.dispose = function() {
      this._uninstallResolutionListener(), this._window = null;
    }, Object.defineProperty(Observable2.prototype, "value", {
      get: function() {
        return this._window.devicePixelRatio;
      },
      enumerable: !1,
      configurable: !0
    }), Observable2.prototype.subscribe = function(next2) {
      var _this = this, observer = { next: next2 };
      return this._observers.push(observer), {
        unsubscribe: function() {
          _this._observers = _this._observers.filter(function(o2) {
            return o2 !== observer;
          });
        }
      };
    }, Observable2.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null)
        throw new Error("Resolution listener is already installed");
      var dppx = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(dppx, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener);
    }, Observable2.prototype._uninstallResolutionListener = function() {
      this._resolutionMediaQueryList !== null && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null);
    }, Observable2.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener(), this._installResolutionListener();
    }, Observable2.prototype._onResolutionChanged = function() {
      var _this = this;
      this._observers.forEach(function(observer) {
        return observer.next(_this._window.devicePixelRatio);
      }), this._reinstallResolutionListener();
    }, Observable2;
  }()
);
function createObservable(win) {
  return new Observable(win);
}
__name(createObservable, "createObservable");
var DevicePixelContentBoxBinding = (
  /** @class */
  function() {
    function DevicePixelContentBoxBinding2(canvasElement, transformBitmapSize, options2) {
      var _a46;
      this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = canvasElement, this._canvasElementClientSize = size({
        width: this._canvasElement.clientWidth,
        height: this._canvasElement.clientHeight
      }), this._transformBitmapSize = transformBitmapSize ?? function(size2) {
        return size2;
      }, this._allowResizeObserver = (_a46 = options2 == null ? void 0 : options2.allowResizeObserver) !== null && _a46 !== void 0 ? _a46 : !0, this._chooseAndInitObserver();
    }
    return __name(DevicePixelContentBoxBinding2, "DevicePixelContentBoxBinding"), DevicePixelContentBoxBinding2.prototype.dispose = function() {
      var _a46, _b;
      if (this._canvasElement === null)
        throw new Error("Object is disposed");
      (_a46 = this._canvasElementResizeObserver) === null || _a46 === void 0 || _a46.disconnect(), this._canvasElementResizeObserver = null, (_b = this._devicePixelRatioObservable) === null || _b === void 0 || _b.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null;
    }, Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElement", {
      get: function() {
        if (this._canvasElement === null)
          throw new Error("Object is disposed");
        return this._canvasElement;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElementClientSize", {
      get: function() {
        return this._canvasElementClientSize;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "bitmapSize", {
      get: function() {
        return size({
          width: this.canvasElement.width,
          height: this.canvasElement.height
        });
      },
      enumerable: !1,
      configurable: !0
    }), DevicePixelContentBoxBinding2.prototype.resizeCanvasElement = function(clientSize) {
      this._canvasElementClientSize = size(clientSize), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize();
    }, DevicePixelContentBoxBinding2.prototype.subscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners.push(listener);
    }, DevicePixelContentBoxBinding2.prototype.unsubscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    }, Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "suggestedBitmapSize", {
      get: function() {
        return this._suggestedBitmapSize;
      },
      enumerable: !1,
      configurable: !0
    }), DevicePixelContentBoxBinding2.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners.push(listener);
    }, DevicePixelContentBoxBinding2.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    }, DevicePixelContentBoxBinding2.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize !== null) {
        var oldSuggestedSize = this._suggestedBitmapSize;
        this._suggestedBitmapSize = null, this._resizeBitmap(oldSuggestedSize), this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);
      }
    }, DevicePixelContentBoxBinding2.prototype._resizeBitmap = function(newSize) {
      var oldSize = this.bitmapSize;
      equalSizes(oldSize, newSize) || (this.canvasElement.width = newSize.width, this.canvasElement.height = newSize.height, this._emitBitmapSizeChanged(oldSize, newSize));
    }, DevicePixelContentBoxBinding2.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._bitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    }, DevicePixelContentBoxBinding2.prototype._suggestNewBitmapSize = function(newSize) {
      var oldSuggestedSize = this._suggestedBitmapSize, finalNewSize = size(this._transformBitmapSize(newSize, this._canvasElementClientSize)), newSuggestedSize = equalSizes(this.bitmapSize, finalNewSize) ? null : finalNewSize;
      oldSuggestedSize === null && newSuggestedSize === null || oldSuggestedSize !== null && newSuggestedSize !== null && equalSizes(oldSuggestedSize, newSuggestedSize) || (this._suggestedBitmapSize = newSuggestedSize, this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize));
    }, DevicePixelContentBoxBinding2.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    }, DevicePixelContentBoxBinding2.prototype._chooseAndInitObserver = function() {
      var _this = this;
      if (!this._allowResizeObserver) {
        this._initDevicePixelRatioObservable();
        return;
      }
      isDevicePixelContentBoxSupported().then(function(isSupported) {
        return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();
      });
    }, DevicePixelContentBoxBinding2.prototype._initDevicePixelRatioObservable = function() {
      var _this = this;
      if (this._canvasElement !== null) {
        var win = canvasElementWindow(this._canvasElement);
        if (win === null)
          throw new Error("No window is associated with the canvas");
        this._devicePixelRatioObservable = createObservable(win), this._devicePixelRatioObservable.subscribe(function() {
          return _this._invalidateBitmapSize();
        }), this._invalidateBitmapSize();
      }
    }, DevicePixelContentBoxBinding2.prototype._invalidateBitmapSize = function() {
      var _a46, _b;
      if (this._canvasElement !== null) {
        var win = canvasElementWindow(this._canvasElement);
        if (win !== null) {
          var ratio = (_b = (_a46 = this._devicePixelRatioObservable) === null || _a46 === void 0 ? void 0 : _a46.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio, canvasRects = this._canvasElement.getClientRects(), newSize = (
            // eslint-disable-next-line no-negated-condition
            canvasRects[0] !== void 0 ? predictedBitmapSize(canvasRects[0], ratio) : size({
              width: this._canvasElementClientSize.width * ratio,
              height: this._canvasElementClientSize.height * ratio
            })
          );
          this._suggestNewBitmapSize(newSize);
        }
      }
    }, DevicePixelContentBoxBinding2.prototype._initResizeObserver = function() {
      var _this = this;
      this._canvasElement !== null && (this._canvasElementResizeObserver = new ResizeObserver(function(entries) {
        var entry2 = entries.find(function(entry3) {
          return entry3.target === _this._canvasElement;
        });
        if (!(!entry2 || !entry2.devicePixelContentBoxSize || !entry2.devicePixelContentBoxSize[0])) {
          var entrySize = entry2.devicePixelContentBoxSize[0], newSize = size({
            width: entrySize.inlineSize,
            height: entrySize.blockSize
          });
          _this._suggestNewBitmapSize(newSize);
        }
      }), this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" }));
    }, DevicePixelContentBoxBinding2;
  }()
);
function bindTo(canvasElement, target) {
  if (target.type === "device-pixel-content-box")
    return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);
  throw new Error("Unsupported binding target");
}
__name(bindTo, "bindTo");
function canvasElementWindow(canvasElement) {
  return canvasElement.ownerDocument.defaultView;
}
__name(canvasElementWindow, "canvasElementWindow");
function isDevicePixelContentBoxSupported() {
  return new Promise(function(resolve) {
    var ro = new ResizeObserver(function(entries) {
      resolve(entries.every(function(entry2) {
        return "devicePixelContentBoxSize" in entry2;
      })), ro.disconnect();
    });
    ro.observe(document.body, { box: "device-pixel-content-box" });
  }).catch(function() {
    return !1;
  });
}
__name(isDevicePixelContentBoxSupported, "isDevicePixelContentBoxSupported");
function predictedBitmapSize(canvasRect, ratio) {
  return size({
    width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),
    height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)
  });
}
__name(predictedBitmapSize, "predictedBitmapSize");
var CanvasRenderingTarget2D = (
  /** @class */
  function() {
    function CanvasRenderingTarget2D2(context, mediaSize, bitmapSize) {
      if (mediaSize.width === 0 || mediaSize.height === 0)
        throw new TypeError("Rendering target could only be created on a media with positive width and height");
      if (this._mediaSize = mediaSize, bitmapSize.width === 0 || bitmapSize.height === 0)
        throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      this._bitmapSize = bitmapSize, this._context = context;
    }
    return __name(CanvasRenderingTarget2D2, "CanvasRenderingTarget2D"), CanvasRenderingTarget2D2.prototype.useMediaCoordinateSpace = function(f2) {
      try {
        return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), f2({
          context: this._context,
          mediaSize: this._mediaSize
        });
      } finally {
        this._context.restore();
      }
    }, CanvasRenderingTarget2D2.prototype.useBitmapCoordinateSpace = function(f2) {
      try {
        return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), f2({
          context: this._context,
          mediaSize: this._mediaSize,
          bitmapSize: this._bitmapSize,
          horizontalPixelRatio: this._horizontalPixelRatio,
          verticalPixelRatio: this._verticalPixelRatio
        });
      } finally {
        this._context.restore();
      }
    }, Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_horizontalPixelRatio", {
      get: function() {
        return this._bitmapSize.width / this._mediaSize.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_verticalPixelRatio", {
      get: function() {
        return this._bitmapSize.height / this._mediaSize.height;
      },
      enumerable: !1,
      configurable: !0
    }), CanvasRenderingTarget2D2;
  }()
);
function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {
  var mediaSize = binding.canvasElementClientSize;
  if (mediaSize.width === 0 || mediaSize.height === 0)
    return null;
  var bitmapSize = binding.bitmapSize;
  if (bitmapSize.width === 0 || bitmapSize.height === 0)
    return null;
  var context = binding.canvasElement.getContext("2d", contextOptions);
  return context === null ? null : new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);
}
__name(tryCreateCanvasRenderingTarget2D, "tryCreateCanvasRenderingTarget2D");
/*!
 * @license
 * TradingView Lightweight Charts v4.1.1
 * Copyright (c) 2023 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
const e = { upColor: "#26a69a", downColor: "#ef5350", wickVisible: !0, borderVisible: !0, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, r = { upColor: "#26a69a", downColor: "#ef5350", openVisible: !0, thinBars: !0 }, h$1 = { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, l = { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: !1, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, a = { baseValue: { type: "price", price: 0 }, topFillColor1: "rgba(38, 166, 154, 0.28)", topFillColor2: "rgba(38, 166, 154, 0.05)", topLineColor: "rgba(38, 166, 154, 1)", bottomFillColor1: "rgba(239, 83, 80, 0.05)", bottomFillColor2: "rgba(239, 83, 80, 0.28)", bottomLineColor: "rgba(239, 83, 80, 1)", lineWidth: 3, lineStyle: 0, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, o = { color: "#26a69a", base: 0 }, _$1 = { color: "#2196f3" }, u = { title: "", visible: !0, lastValueVisible: !0, priceLineVisible: !0, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: !0, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: 0.01 } };
var c, d;
function f(t2, i) {
  const n2 = { 0: [], 1: [t2.lineWidth, t2.lineWidth], 2: [2 * t2.lineWidth, 2 * t2.lineWidth], 3: [6 * t2.lineWidth, 6 * t2.lineWidth], 4: [t2.lineWidth, 4 * t2.lineWidth] }[i];
  t2.setLineDash(n2);
}
__name(f, "f");
function v(t2, i, n2, s) {
  t2.beginPath();
  const e2 = t2.lineWidth % 2 ? 0.5 : 0;
  t2.moveTo(n2, i + e2), t2.lineTo(s, i + e2), t2.stroke();
}
__name(v, "v");
function p$1(t2, i) {
  if (!t2)
    throw new Error("Assertion failed" + (i ? ": " + i : ""));
}
__name(p$1, "p$1");
function m$1(t2) {
  if (t2 === void 0)
    throw new Error("Value is undefined");
  return t2;
}
__name(m$1, "m$1");
function b(t2) {
  if (t2 === null)
    throw new Error("Value is null");
  return t2;
}
__name(b, "b");
function w$1(t2) {
  return b(m$1(t2));
}
__name(w$1, "w$1");
(function(t2) {
  t2[t2.Simple = 0] = "Simple", t2[t2.WithSteps = 1] = "WithSteps", t2[t2.Curved = 2] = "Curved";
})(c || (c = {})), function(t2) {
  t2[t2.Solid = 0] = "Solid", t2[t2.Dotted = 1] = "Dotted", t2[t2.Dashed = 2] = "Dashed", t2[t2.LargeDashed = 3] = "LargeDashed", t2[t2.SparseDotted = 4] = "SparseDotted";
}(d || (d = {}));
const g = { khaki: "#f0e68c", azure: "#f0ffff", aliceblue: "#f0f8ff", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", gray: "#808080", green: "#008000", honeydew: "#f0fff0", floralwhite: "#fffaf0", lightblue: "#add8e6", lightcoral: "#f08080", lemonchiffon: "#fffacd", hotpink: "#ff69b4", lightyellow: "#ffffe0", greenyellow: "#adff2f", lightgoldenrodyellow: "#fafad2", limegreen: "#32cd32", linen: "#faf0e6", lightcyan: "#e0ffff", magenta: "#f0f", maroon: "#800000", olive: "#808000", orange: "#ffa500", oldlace: "#fdf5e6", mediumblue: "#0000cd", transparent: "#0000", lime: "#0f0", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", midnightblue: "#191970", orchid: "#da70d6", mediumorchid: "#ba55d3", mediumturquoise: "#48d1cc", orangered: "#ff4500", royalblue: "#4169e1", powderblue: "#b0e0e6", red: "#f00", coral: "#ff7f50", turquoise: "#40e0d0", white: "#fff", whitesmoke: "#f5f5f5", wheat: "#f5deb3", teal: "#008080", steelblue: "#4682b4", bisque: "#ffe4c4", aquamarine: "#7fffd4", aqua: "#0ff", sienna: "#a0522d", silver: "#c0c0c0", springgreen: "#00ff7f", antiquewhite: "#faebd7", burlywood: "#deb887", brown: "#a52a2a", beige: "#f5f5dc", chocolate: "#d2691e", chartreuse: "#7fff00", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cadetblue: "#5f9ea0", tomato: "#ff6347", fuchsia: "#f0f", blue: "#00f", salmon: "#fa8072", blanchedalmond: "#ffebcd", slateblue: "#6a5acd", slategray: "#708090", thistle: "#d8bfd8", tan: "#d2b48c", cyan: "#0ff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", blueviolet: "#8a2be2", black: "#000", darkmagenta: "#8b008b", darkslateblue: "#483d8b", darkkhaki: "#bdb76b", darkorchid: "#9932cc", darkorange: "#ff8c00", darkgreen: "#006400", darkred: "#8b0000", dodgerblue: "#1e90ff", darkslategray: "#2f4f4f", dimgray: "#696969", deepskyblue: "#00bfff", firebrick: "#b22222", forestgreen: "#228b22", indigo: "#4b0082", ivory: "#fffff0", lavenderblush: "#fff0f5", feldspar: "#d19275", indianred: "#cd5c5c", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightskyblue: "#87cefa", lightslategray: "#789", lightslateblue: "#8470ff", snow: "#fffafa", lightseagreen: "#20b2aa", lightsalmon: "#ffa07a", darksalmon: "#e9967a", darkviolet: "#9400d3", mediumpurple: "#9370d8", mediumaquamarine: "#66cdaa", skyblue: "#87ceeb", lavender: "#e6e6fa", lightsteelblue: "#b0c4de", mediumvioletred: "#c71585", mintcream: "#f5fffa", navajowhite: "#ffdead", navy: "#000080", olivedrab: "#6b8e23", palevioletred: "#d87093", violetred: "#d02090", yellow: "#ff0", yellowgreen: "#9acd32", lawngreen: "#7cfc00", pink: "#ffc0cb", paleturquoise: "#afeeee", palegoldenrod: "#eee8aa", darkolivegreen: "#556b2f", darkseagreen: "#8fbc8f", darkturquoise: "#00ced1", peachpuff: "#ffdab9", deeppink: "#ff1493", violet: "#ee82ee", palegreen: "#98fb98", mediumseagreen: "#3cb371", peru: "#cd853f", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", purple: "#800080", seagreen: "#2e8b57", seashell: "#fff5ee", papayawhip: "#ffefd5", mediumslateblue: "#7b68ee", plum: "#dda0dd", mediumspringgreen: "#00fa9a" };
function M(t2) {
  return t2 < 0 ? 0 : t2 > 255 ? 255 : Math.round(t2) || 0;
}
__name(M, "M");
function x(t2) {
  return t2 <= 0 || t2 > 0 ? t2 < 0 ? 0 : t2 > 1 ? 1 : Math.round(1e4 * t2) / 1e4 : 0;
}
__name(x, "x");
const S$1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i, k$1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i, y = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/, C$1 = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
function T$1(t2) {
  (t2 = t2.toLowerCase()) in g && (t2 = g[t2]);
  {
    const i = C$1.exec(t2) || y.exec(t2);
    if (i)
      return [M(parseInt(i[1], 10)), M(parseInt(i[2], 10)), M(parseInt(i[3], 10)), x(i.length < 5 ? 1 : parseFloat(i[4]))];
  }
  {
    const i = k$1.exec(t2);
    if (i)
      return [M(parseInt(i[1], 16)), M(parseInt(i[2], 16)), M(parseInt(i[3], 16)), 1];
  }
  {
    const i = S$1.exec(t2);
    if (i)
      return [M(17 * parseInt(i[1], 16)), M(17 * parseInt(i[2], 16)), M(17 * parseInt(i[3], 16)), 1];
  }
  throw new Error(`Cannot parse color: ${t2}`);
}
__name(T$1, "T$1");
function P(t2) {
  const i = T$1(t2);
  return { t: `rgb(${i[0]}, ${i[1]}, ${i[2]})`, i: (n2 = i, 0.199 * n2[0] + 0.687 * n2[1] + 0.114 * n2[2] > 160 ? "black" : "white") };
  var n2;
}
__name(P, "P");
const _R = class _R {
  constructor() {
    this.h = [];
  }
  l(t2, i, n2) {
    const s = { o: t2, _: i, u: n2 === !0 };
    this.h.push(s);
  }
  v(t2) {
    const i = this.h.findIndex((i2) => t2 === i2.o);
    i > -1 && this.h.splice(i, 1);
  }
  p(t2) {
    this.h = this.h.filter((i) => i._ !== t2);
  }
  m(t2, i, n2) {
    const s = [...this.h];
    this.h = this.h.filter((t3) => !t3.u), s.forEach((s2) => s2.o(t2, i, n2));
  }
  M() {
    return this.h.length > 0;
  }
  S() {
    this.h = [];
  }
};
__name(_R, "R");
let R = _R;
function D$1(t2, ...i) {
  for (const n2 of i)
    for (const i2 in n2)
      n2[i2] !== void 0 && (typeof n2[i2] != "object" || t2[i2] === void 0 || Array.isArray(n2[i2]) ? t2[i2] = n2[i2] : D$1(t2[i2], n2[i2]));
  return t2;
}
__name(D$1, "D$1");
function O$1(t2) {
  return typeof t2 == "number" && isFinite(t2);
}
__name(O$1, "O$1");
function A$1(t2) {
  return typeof t2 == "number" && t2 % 1 == 0;
}
__name(A$1, "A$1");
function V$1(t2) {
  return typeof t2 == "string";
}
__name(V$1, "V$1");
function B$1(t2) {
  return typeof t2 == "boolean";
}
__name(B$1, "B$1");
function I(t2) {
  const i = t2;
  if (!i || typeof i != "object")
    return i;
  let n2, s, e2;
  for (s in n2 = Array.isArray(i) ? [] : {}, i)
    i.hasOwnProperty(s) && (e2 = i[s], n2[s] = e2 && typeof e2 == "object" ? I(e2) : e2);
  return n2;
}
__name(I, "I");
function z(t2) {
  return t2 !== null;
}
__name(z, "z");
function E(t2) {
  return t2 === null ? void 0 : t2;
}
__name(E, "E");
const L$1 = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
function N$1(t2, i, n2) {
  return i === void 0 && (i = L$1), `${n2 = n2 !== void 0 ? `${n2} ` : ""}${t2}px ${i}`;
}
__name(N$1, "N$1");
var _a2;
let F$1 = (_a2 = class {
  constructor(t2) {
    this.k = { C: 1, T: 5, P: NaN, R: "", D: "", O: "", A: "", V: 0, B: 0, I: 0, L: 0, N: 0 }, this.F = t2;
  }
  W() {
    const t2 = this.k, i = this.j(), n2 = this.H();
    return t2.P === i && t2.D === n2 || (t2.P = i, t2.D = n2, t2.R = N$1(i, n2), t2.L = 2.5 / 12 * i, t2.V = t2.L, t2.B = i / 12 * t2.T, t2.I = i / 12 * t2.T, t2.N = 0), t2.O = this.$(), t2.A = this.U(), this.k;
  }
  $() {
    return this.F.W().layout.textColor;
  }
  U() {
    return this.F.q();
  }
  j() {
    return this.F.W().layout.fontSize;
  }
  H() {
    return this.F.W().layout.fontFamily;
  }
}, __name(_a2, "F"), _a2);
const _W = class _W {
  constructor() {
    this.Y = [];
  }
  X(t2) {
    this.Y = t2;
  }
  K(t2, i, n2) {
    this.Y.forEach((s) => {
      s.K(t2, i, n2);
    });
  }
};
__name(_W, "W");
let W = _W;
const _j = class _j {
  K(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
  G(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.J(t3, i, n2));
  }
  J(t2, i, n2) {
  }
};
__name(_j, "j");
let j = _j;
var _a3;
let H$1 = (_a3 = class extends j {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z({ context: t2 }) {
    if (this.tt === null || this.tt.nt === null)
      return;
    const i = this.tt.nt, n2 = this.tt, s = /* @__PURE__ */ __name((s2) => {
      t2.beginPath();
      for (let e2 = i.to - 1; e2 >= i.from; --e2) {
        const i2 = n2.st[e2];
        t2.moveTo(i2.et, i2.rt), t2.arc(i2.et, i2.rt, s2, 0, 2 * Math.PI);
      }
      t2.fill();
    }, "s");
    n2.ht > 0 && (t2.fillStyle = n2.lt, s(n2.ot + n2.ht)), t2.fillStyle = n2._t, s(n2.ot);
  }
}, __name(_a3, "H"), _a3);
function $$1() {
  return { st: [{ et: 0, rt: 0, ut: 0, ct: 0 }], _t: "", lt: "", ot: 0, ht: 0, nt: null };
}
__name($$1, "$$1");
const U$1 = { from: 0, to: 1 }, _q = class _q {
  constructor(t2, i) {
    this.dt = new W(), this.ft = [], this.vt = [], this.bt = !0, this.F = t2, this.wt = i, this.dt.X(this.ft);
  }
  gt(t2) {
    const i = this.F.Mt();
    i.length !== this.ft.length && (this.vt = i.map($$1), this.ft = this.vt.map((t3) => {
      const i2 = new H$1();
      return i2.it(t3), i2;
    }), this.dt.X(this.ft)), this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.dt;
  }
  St() {
    const t2 = this.wt.W().mode === 2, i = this.F.Mt(), n2 = this.wt.kt(), s = this.F.yt();
    i.forEach((i2, e2) => {
      var r2;
      const h2 = this.vt[e2], l2 = i2.Ct(n2);
      if (t2 || l2 === null || !i2.Tt())
        return void (h2.nt = null);
      const a2 = b(i2.Pt());
      h2._t = l2.Rt, h2.ot = l2.ot, h2.ht = l2.Dt, h2.st[0].ct = l2.ct, h2.st[0].rt = i2.At().Ot(l2.ct, a2.Vt), h2.lt = (r2 = l2.Bt) !== null && r2 !== void 0 ? r2 : this.F.It(h2.st[0].rt / i2.At().zt()), h2.st[0].ut = n2, h2.st[0].et = s.Et(n2), h2.nt = U$1;
    });
  }
};
__name(_q, "q");
let q = _q;
const _Y = class _Y {
  K(t2, i, n2) {
    t2.useBitmapCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
};
__name(_Y, "Y");
let Y = _Y;
var _a4;
let X$1 = (_a4 = class extends Y {
  constructor(t2) {
    super(), this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null)
      return;
    const e2 = this.Lt.Nt.Tt, r2 = this.Lt.Ft.Tt;
    if (!e2 && !r2)
      return;
    const h2 = Math.round(this.Lt.et * n2), l2 = Math.round(this.Lt.rt * s);
    t2.lineCap = "butt", e2 && h2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Nt.ht * n2), t2.strokeStyle = this.Lt.Nt.O, t2.fillStyle = this.Lt.Nt.O, f(t2, this.Lt.Nt.Wt), function(t3, i2, n3, s2) {
      t3.beginPath();
      const e3 = t3.lineWidth % 2 ? 0.5 : 0;
      t3.moveTo(i2 + e3, n3), t3.lineTo(i2 + e3, s2), t3.stroke();
    }(t2, h2, 0, i.height)), r2 && l2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Ft.ht * s), t2.strokeStyle = this.Lt.Ft.O, t2.fillStyle = this.Lt.Ft.O, f(t2, this.Lt.Ft.Wt), v(t2, l2, 0, i.width));
  }
}, __name(_a4, "X"), _a4);
const _K = class _K {
  constructor(t2) {
    this.bt = !0, this.jt = { Nt: { ht: 1, Wt: 0, O: "", Tt: !1 }, Ft: { ht: 1, Wt: 0, O: "", Tt: !1 }, et: 0, rt: 0 }, this.Ht = new X$1(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht;
  }
  St() {
    const t2 = this.$t.Tt(), i = b(this.$t.Ut()), n2 = i.qt().W().crosshair, s = this.jt;
    if (n2.mode === 2)
      return s.Ft.Tt = !1, void (s.Nt.Tt = !1);
    s.Ft.Tt = t2 && this.$t.Yt(i), s.Nt.Tt = t2 && this.$t.Xt(), s.Ft.ht = n2.horzLine.width, s.Ft.Wt = n2.horzLine.style, s.Ft.O = n2.horzLine.color, s.Nt.ht = n2.vertLine.width, s.Nt.Wt = n2.vertLine.style, s.Nt.O = n2.vertLine.color, s.et = this.$t.Kt(), s.rt = this.$t.Zt();
  }
};
__name(_K, "K");
let K = _K;
function Z$1(t2, i, n2, s, e2, r2) {
  t2.fillRect(i + r2, n2, s - 2 * r2, r2), t2.fillRect(i + r2, n2 + e2 - r2, s - 2 * r2, r2), t2.fillRect(i, n2, r2, e2), t2.fillRect(i + s - r2, n2, r2, e2);
}
__name(Z$1, "Z$1");
function G$1(t2, i, n2, s, e2, r2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.fillStyle = r2, t2.fillRect(i, n2, s, e2), t2.restore();
}
__name(G$1, "G$1");
function J$1(t2, i) {
  return t2.map((t3) => t3 === 0 ? t3 : t3 + i);
}
__name(J$1, "J$1");
function Q$1(t2, i, n2, s, e2, r2) {
  t2.beginPath(), t2.lineTo(i + s - r2[1], n2), r2[1] !== 0 && t2.arcTo(i + s, n2, i + s, n2 + r2[1], r2[1]), t2.lineTo(i + s, n2 + e2 - r2[2]), r2[2] !== 0 && t2.arcTo(i + s, n2 + e2, i + s - r2[2], n2 + e2, r2[2]), t2.lineTo(i + r2[3], n2 + e2), r2[3] !== 0 && t2.arcTo(i, n2 + e2, i, n2 + e2 - r2[3], r2[3]), t2.lineTo(i, n2 + r2[0]), r2[0] !== 0 && t2.arcTo(i, n2, i + r2[0], n2, r2[0]);
}
__name(Q$1, "Q$1");
function tt(t2, i, n2, s, e2, r2, h2 = 0, l2 = [0, 0, 0, 0], a2 = "") {
  if (t2.save(), !h2 || !a2 || a2 === r2)
    return Q$1(t2, i, n2, s, e2, l2), t2.fillStyle = r2, t2.fill(), void t2.restore();
  const o2 = h2 / 2;
  r2 !== "transparent" && (Q$1(t2, i + h2, n2 + h2, s - 2 * h2, e2 - 2 * h2, J$1(l2, -h2)), t2.fillStyle = r2, t2.fill()), a2 !== "transparent" && (Q$1(t2, i + o2, n2 + o2, s - h2, e2 - h2, J$1(l2, -o2)), t2.lineWidth = h2, t2.strokeStyle = a2, t2.closePath(), t2.stroke()), t2.restore();
}
__name(tt, "tt");
function it(t2, i, n2, s, e2, r2, h2) {
  t2.save(), t2.globalCompositeOperation = "copy";
  const l2 = t2.createLinearGradient(0, 0, 0, e2);
  l2.addColorStop(0, r2), l2.addColorStop(1, h2), t2.fillStyle = l2, t2.fillRect(i, n2, s, e2), t2.restore();
}
__name(it, "it");
const _nt = class _nt {
  constructor(t2, i) {
    this.it(t2, i);
  }
  it(t2, i) {
    this.Lt = t2, this.Gt = i;
  }
  zt(t2, i) {
    return this.Lt.Tt ? t2.P + t2.L + t2.V : 0;
  }
  K(t2, i, n2, s) {
    if (!this.Lt.Tt || this.Lt.Jt.length === 0)
      return;
    const e2 = this.Lt.O, r2 = this.Gt.t, h2 = t2.useBitmapCoordinateSpace((t3) => {
      const h3 = t3.context;
      h3.font = i.R;
      const l2 = this.Qt(t3, i, n2, s), a2 = l2.ti, o2 = /* @__PURE__ */ __name((t4, i2) => {
        l2.ii ? tt(h3, a2.ni, a2.si, a2.ei, a2.ri, t4, a2.hi, [a2.ot, 0, 0, a2.ot], i2) : tt(h3, a2.li, a2.si, a2.ei, a2.ri, t4, a2.hi, [0, a2.ot, a2.ot, 0], i2);
      }, "o");
      return o2(r2, "transparent"), this.Lt.ai && (h3.fillStyle = e2, h3.fillRect(a2.li, a2.oi, a2._i - a2.li, a2.ui)), o2("transparent", r2), this.Lt.ci && (h3.fillStyle = i.A, h3.fillRect(l2.ii ? a2.di - a2.hi : 0, a2.si, a2.hi, a2.fi - a2.si)), l2;
    });
    t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = h2.vi;
      t3.font = i.R, t3.textAlign = h2.ii ? "right" : "left", t3.textBaseline = "middle", t3.fillStyle = e2, t3.fillText(this.Lt.Jt, n3.pi, (n3.si + n3.fi) / 2 + n3.mi);
    });
  }
  Qt(t2, i, n2, s) {
    var e2;
    const { context: r2, bitmapSize: h2, mediaSize: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = this.Lt.ai || !this.Lt.bi ? i.T : 0, u2 = this.Lt.wi ? i.C : 0, c2 = i.L + this.Gt.gi, d2 = i.V + this.Gt.Mi, f2 = i.B, v2 = i.I, p2 = this.Lt.Jt, m2 = i.P, b2 = n2.xi(r2, p2), w2 = Math.ceil(n2.Si(r2, p2)), g2 = m2 + c2 + d2, M2 = i.C + f2 + v2 + w2 + _24, x2 = Math.max(1, Math.floor(o2));
    let S2 = Math.round(g2 * o2);
    S2 % 2 != x2 % 2 && (S2 += 1);
    const k2 = u2 > 0 ? Math.max(1, Math.floor(u2 * a2)) : 0, y2 = Math.round(M2 * a2), C2 = Math.round(_24 * a2), T2 = (e2 = this.Gt.ki) !== null && e2 !== void 0 ? e2 : this.Gt.yi, P2 = Math.round(T2 * o2) - Math.floor(0.5 * o2), R2 = Math.floor(P2 + x2 / 2 - S2 / 2), D2 = R2 + S2, O2 = s === "right", A2 = O2 ? l2.width - u2 : u2, V2 = O2 ? h2.width - k2 : k2;
    let B2, I2, z2;
    return O2 ? (B2 = V2 - y2, I2 = V2 - C2, z2 = A2 - _24 - f2 - u2) : (B2 = V2 + y2, I2 = V2 + C2, z2 = A2 + _24 + f2), { ii: O2, ti: { si: R2, oi: P2, fi: D2, ei: y2, ri: S2, ot: 2 * a2, hi: k2, ni: B2, li: V2, _i: I2, ui: x2, di: h2.width }, vi: { si: R2 / o2, fi: D2 / o2, pi: z2, mi: b2 } };
  }
};
__name(_nt, "nt");
let nt = _nt;
const _st = class _st {
  constructor(t2) {
    this.Ci = { yi: 0, t: "#000", Mi: 0, gi: 0 }, this.Ti = { Jt: "", Tt: !1, ai: !0, bi: !1, Bt: "", O: "#FFF", ci: !1, wi: !1 }, this.Pi = { Jt: "", Tt: !1, ai: !1, bi: !0, Bt: "", O: "#FFF", ci: !0, wi: !0 }, this.bt = !0, this.Ri = new (t2 || nt)(this.Ti, this.Ci), this.Di = new (t2 || nt)(this.Pi, this.Ci);
  }
  Jt() {
    return this.Oi(), this.Ti.Jt;
  }
  yi() {
    return this.Oi(), this.Ci.yi;
  }
  gt() {
    this.bt = !0;
  }
  zt(t2, i = !1) {
    return Math.max(this.Ri.zt(t2, i), this.Di.zt(t2, i));
  }
  Ai() {
    return this.Ci.ki || 0;
  }
  Vi(t2) {
    this.Ci.ki = t2;
  }
  Bi() {
    return this.Oi(), this.Ti.Tt || this.Pi.Tt;
  }
  Ii() {
    return this.Oi(), this.Ti.Tt;
  }
  xt(t2) {
    return this.Oi(), this.Ti.ai = this.Ti.ai && t2.W().ticksVisible, this.Pi.ai = this.Pi.ai && t2.W().ticksVisible, this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Ri;
  }
  zi() {
    return this.Oi(), this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Di;
  }
  Oi() {
    this.bt && (this.Ti.ai = !0, this.Pi.ai = !1, this.Ei(this.Ti, this.Pi, this.Ci));
  }
};
__name(_st, "st");
let st = _st;
const _et = class _et extends st {
  constructor(t2, i, n2) {
    super(), this.$t = t2, this.Li = i, this.Ni = n2;
  }
  Ei(t2, i, n2) {
    if (t2.Tt = !1, this.$t.W().mode === 2)
      return;
    const s = this.$t.W().horzLine;
    if (!s.labelVisible)
      return;
    const e2 = this.Li.Pt();
    if (!this.$t.Tt() || this.Li.Fi() || e2 === null)
      return;
    const r2 = P(s.labelBackgroundColor);
    n2.t = r2.t, t2.O = r2.i;
    const h2 = 2 / 12 * this.Li.P();
    n2.gi = h2, n2.Mi = h2;
    const l2 = this.Ni(this.Li);
    n2.yi = l2.yi, t2.Jt = this.Li.Wi(l2.ct, e2), t2.Tt = !0;
  }
};
__name(_et, "et");
let et = _et;
const rt$1 = /[1-9]/g;
var _a5;
let ht$1 = (_a5 = class {
  constructor() {
    this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  K(t2, i) {
    if (this.Lt === null || this.Lt.Tt === !1 || this.Lt.Jt.length === 0)
      return;
    const n2 = t2.useMediaCoordinateSpace(({ context: t3 }) => (t3.font = i.R, Math.round(i.ji.Si(t3, b(this.Lt).Jt, rt$1))));
    if (n2 <= 0)
      return;
    const s = i.Hi, e2 = n2 + 2 * s, r2 = e2 / 2, h2 = this.Lt.$i;
    let l2 = this.Lt.yi, a2 = Math.floor(l2 - r2) + 0.5;
    a2 < 0 ? (l2 += Math.abs(0 - a2), a2 = Math.floor(l2 - r2) + 0.5) : a2 + e2 > h2 && (l2 -= Math.abs(h2 - (a2 + e2)), a2 = Math.floor(l2 - r2) + 0.5);
    const o2 = a2 + e2, _24 = Math.ceil(0 + i.C + i.T + i.L + i.P + i.V);
    t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: n3, verticalPixelRatio: s2 }) => {
      const e3 = b(this.Lt);
      t3.fillStyle = e3.t;
      const r3 = Math.round(a2 * n3), h3 = Math.round(0 * s2), l3 = Math.round(o2 * n3), u2 = Math.round(_24 * s2), c2 = Math.round(2 * n3);
      if (t3.beginPath(), t3.moveTo(r3, h3), t3.lineTo(r3, u2 - c2), t3.arcTo(r3, u2, r3 + c2, u2, c2), t3.lineTo(l3 - c2, u2), t3.arcTo(l3, u2, l3, u2 - c2, c2), t3.lineTo(l3, h3), t3.fill(), e3.ai) {
        const r4 = Math.round(e3.yi * n3), l4 = h3, a3 = Math.round((l4 + i.T) * s2);
        t3.fillStyle = e3.O;
        const o3 = Math.max(1, Math.floor(n3)), _25 = Math.floor(0.5 * n3);
        t3.fillRect(r4 - _25, l4, o3, a3 - l4);
      }
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = b(this.Lt), e3 = 0 + i.C + i.T + i.L + i.P / 2;
      t3.font = i.R, t3.textAlign = "left", t3.textBaseline = "middle", t3.fillStyle = n3.O;
      const r3 = i.ji.xi(t3, "Apr0");
      t3.translate(a2 + s, e3 + r3), t3.fillText(n3.Jt, 0, 0);
    });
  }
}, __name(_a5, "ht"), _a5);
var _a6;
let lt$1 = (_a6 = class {
  constructor(t2, i, n2) {
    this.bt = !0, this.Ht = new ht$1(), this.jt = { Tt: !1, t: "#4c525e", O: "white", Jt: "", $i: 0, yi: NaN, ai: !0 }, this.wt = t2, this.Ui = i, this.Ni = n2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht.it(this.jt), this.Ht;
  }
  St() {
    const t2 = this.jt;
    if (t2.Tt = !1, this.wt.W().mode === 2)
      return;
    const i = this.wt.W().vertLine;
    if (!i.labelVisible)
      return;
    const n2 = this.Ui.yt();
    if (n2.Fi())
      return;
    t2.$i = n2.$i();
    const s = this.Ni();
    if (s === null)
      return;
    t2.yi = s.yi;
    const e2 = n2.qi(this.wt.kt());
    t2.Jt = n2.Yi(b(e2)), t2.Tt = !0;
    const r2 = P(i.labelBackgroundColor);
    t2.t = r2.t, t2.O = r2.i, t2.ai = n2.W().ticksVisible;
  }
}, __name(_a6, "lt"), _a6);
var _a7;
let at$1 = (_a7 = class {
  constructor() {
    this.Xi = null, this.Ki = 0;
  }
  Zi() {
    return this.Ki;
  }
  Gi(t2) {
    this.Ki = t2;
  }
  At() {
    return this.Xi;
  }
  Ji(t2) {
    this.Xi = t2;
  }
  Qi(t2) {
    return [];
  }
  tn() {
    return [];
  }
  Tt() {
    return !0;
  }
}, __name(_a7, "at"), _a7);
var ot$1;
(function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Magnet = 1] = "Magnet", t2[t2.Hidden = 2] = "Hidden";
})(ot$1 || (ot$1 = {}));
var _a8;
let _t$1 = (_a8 = class extends at$1 {
  constructor(t2, i) {
    super(), this.nn = null, this.sn = NaN, this.en = 0, this.rn = !0, this.hn = /* @__PURE__ */ new Map(), this.ln = !1, this.an = NaN, this.on = NaN, this._n = NaN, this.un = NaN, this.Ui = t2, this.cn = i, this.dn = new q(t2, this), this.fn = ((t3, i2) => (n3) => {
      const s = i2(), e2 = t3();
      if (n3 === b(this.nn).vn())
        return { ct: e2, yi: s };
      {
        const t4 = b(n3.Pt());
        return { ct: n3.pn(s, t4), yi: s };
      }
    })(() => this.sn, () => this.on);
    const n2 = ((t3, i2) => () => {
      const n3 = this.Ui.yt().mn(t3()), s = i2();
      return n3 && Number.isFinite(s) ? { ut: n3, yi: s } : null;
    })(() => this.en, () => this.Kt());
    this.bn = new lt$1(this, t2, n2), this.wn = new K(this);
  }
  W() {
    return this.cn;
  }
  gn(t2, i) {
    this._n = t2, this.un = i;
  }
  Mn() {
    this._n = NaN, this.un = NaN;
  }
  xn() {
    return this._n;
  }
  Sn() {
    return this.un;
  }
  kn(t2, i, n2) {
    this.ln || (this.ln = !0), this.rn = !0, this.yn(t2, i, n2);
  }
  kt() {
    return this.en;
  }
  Kt() {
    return this.an;
  }
  Zt() {
    return this.on;
  }
  Tt() {
    return this.rn;
  }
  Cn() {
    this.rn = !1, this.Tn(), this.sn = NaN, this.an = NaN, this.on = NaN, this.nn = null, this.Mn();
  }
  Pn(t2) {
    return this.nn !== null ? [this.wn, this.dn] : [];
  }
  Yt(t2) {
    return t2 === this.nn && this.cn.horzLine.visible;
  }
  Xt() {
    return this.cn.vertLine.visible;
  }
  Rn(t2, i) {
    this.rn && this.nn === t2 || this.hn.clear();
    const n2 = [];
    return this.nn === t2 && n2.push(this.Dn(this.hn, i, this.fn)), n2;
  }
  tn() {
    return this.rn ? [this.bn] : [];
  }
  Ut() {
    return this.nn;
  }
  On() {
    this.wn.gt(), this.hn.forEach((t2) => t2.gt()), this.bn.gt(), this.dn.gt();
  }
  An(t2) {
    return t2 && !t2.vn().Fi() ? t2.vn() : null;
  }
  yn(t2, i, n2) {
    this.Vn(t2, i, n2) && this.On();
  }
  Vn(t2, i, n2) {
    const s = this.an, e2 = this.on, r2 = this.sn, h2 = this.en, l2 = this.nn, a2 = this.An(n2);
    this.en = t2, this.an = isNaN(t2) ? NaN : this.Ui.yt().Et(t2), this.nn = n2;
    const o2 = a2 !== null ? a2.Pt() : null;
    return a2 !== null && o2 !== null ? (this.sn = i, this.on = a2.Ot(i, o2)) : (this.sn = NaN, this.on = NaN), s !== this.an || e2 !== this.on || h2 !== this.en || r2 !== this.sn || l2 !== this.nn;
  }
  Tn() {
    const t2 = this.Ui.Mt().map((t3) => t3.In().Bn()).filter(z), i = t2.length === 0 ? null : Math.max(...t2);
    this.en = i !== null ? i : NaN;
  }
  Dn(t2, i, n2) {
    let s = t2.get(i);
    return s === void 0 && (s = new et(this, i, n2), t2.set(i, s)), s;
  }
}, __name(_a8, "_t"), _a8);
function ut$1(t2) {
  return t2 === "left" || t2 === "right";
}
__name(ut$1, "ut$1");
const _ct = class _ct {
  constructor(t2) {
    this.zn = /* @__PURE__ */ new Map(), this.En = [], this.Ln = t2;
  }
  Nn(t2, i) {
    const n2 = function(t3, i2) {
      return t3 === void 0 ? i2 : { Fn: Math.max(t3.Fn, i2.Fn), Wn: t3.Wn || i2.Wn };
    }(this.zn.get(t2), i);
    this.zn.set(t2, n2);
  }
  jn() {
    return this.Ln;
  }
  Hn(t2) {
    const i = this.zn.get(t2);
    return i === void 0 ? { Fn: this.Ln } : { Fn: Math.max(this.Ln, i.Fn), Wn: i.Wn };
  }
  $n() {
    this.Un(), this.En = [{ qn: 0 }];
  }
  Yn(t2) {
    this.Un(), this.En = [{ qn: 1, Vt: t2 }];
  }
  Xn(t2) {
    this.Kn(), this.En.push({ qn: 5, Vt: t2 });
  }
  Un() {
    this.Kn(), this.En.push({ qn: 6 });
  }
  Zn() {
    this.Un(), this.En = [{ qn: 4 }];
  }
  Gn(t2) {
    this.Un(), this.En.push({ qn: 2, Vt: t2 });
  }
  Jn(t2) {
    this.Un(), this.En.push({ qn: 3, Vt: t2 });
  }
  Qn() {
    return this.En;
  }
  ts(t2) {
    for (const i of t2.En)
      this.ns(i);
    this.Ln = Math.max(this.Ln, t2.Ln), t2.zn.forEach((t3, i) => {
      this.Nn(i, t3);
    });
  }
  static ss() {
    return new _ct(2);
  }
  static es() {
    return new _ct(3);
  }
  ns(t2) {
    switch (t2.qn) {
      case 0:
        this.$n();
        break;
      case 1:
        this.Yn(t2.Vt);
        break;
      case 2:
        this.Gn(t2.Vt);
        break;
      case 3:
        this.Jn(t2.Vt);
        break;
      case 4:
        this.Zn();
        break;
      case 5:
        this.Xn(t2.Vt);
        break;
      case 6:
        this.Kn();
    }
  }
  Kn() {
    const t2 = this.En.findIndex((t3) => t3.qn === 5);
    t2 !== -1 && this.En.splice(t2, 1);
  }
};
__name(_ct, "ct");
let ct = _ct;
const dt$1 = ".";
function ft$1(t2, i) {
  if (!O$1(t2))
    return "n/a";
  if (!A$1(i))
    throw new TypeError("invalid length");
  if (i < 0 || i > 16)
    throw new TypeError("invalid length");
  return i === 0 ? t2.toString() : ("0000000000000000" + t2.toString()).slice(-i);
}
__name(ft$1, "ft$1");
var _a9;
let vt$1 = (_a9 = class {
  constructor(t2, i) {
    if (i || (i = 1), O$1(t2) && A$1(t2) || (t2 = 100), t2 < 0)
      throw new TypeError("invalid base");
    this.Li = t2, this.rs = i, this.hs();
  }
  format(t2) {
    const i = t2 < 0 ? "" : "";
    return t2 = Math.abs(t2), i + this.ls(t2);
  }
  hs() {
    if (this.os = 0, this.Li > 0 && this.rs > 0) {
      let t2 = this.Li;
      for (; t2 > 1; )
        t2 /= 10, this.os++;
    }
  }
  ls(t2) {
    const i = this.Li / this.rs;
    let n2 = Math.floor(t2), s = "";
    const e2 = this.os !== void 0 ? this.os : NaN;
    if (i > 1) {
      let r2 = +(Math.round(t2 * i) - n2 * i).toFixed(this.os);
      r2 >= i && (r2 -= i, n2 += 1), s = dt$1 + ft$1(+r2.toFixed(this.os) * this.rs, e2);
    } else
      n2 = Math.round(n2 * i) / i, e2 > 0 && (s = dt$1 + ft$1(0, e2));
    return n2.toFixed(0) + s;
  }
}, __name(_a9, "vt"), _a9);
var _a10;
let pt$1 = (_a10 = class extends vt$1 {
  constructor(t2 = 100) {
    super(t2);
  }
  format(t2) {
    return `${super.format(t2)}%`;
  }
}, __name(_a10, "pt"), _a10);
var _a11;
let mt$1 = (_a11 = class {
  constructor(t2) {
    this._s = t2;
  }
  format(t2) {
    let i = "";
    return t2 < 0 && (i = "-", t2 = -t2), t2 < 995 ? i + this.us(t2) : t2 < 999995 ? i + this.us(t2 / 1e3) + "K" : t2 < 999999995 ? (t2 = 1e3 * Math.round(t2 / 1e3), i + this.us(t2 / 1e6) + "M") : (t2 = 1e6 * Math.round(t2 / 1e6), i + this.us(t2 / 1e9) + "B");
  }
  us(t2) {
    let i;
    const n2 = Math.pow(10, this._s);
    return i = (t2 = Math.round(t2 * n2) / n2) >= 1e-15 && t2 < 1 ? t2.toFixed(this._s).replace(/\.?0+$/, "") : String(t2), i.replace(/(\.[1-9]*)0+$/, (t3, i2) => i2);
  }
}, __name(_a11, "mt"), _a11);
function bt$1(t2, i, n2, s, e2, r2, h2) {
  if (i.length === 0 || s.from >= i.length || s.to <= 0)
    return;
  const { context: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = i[s.from];
  let u2 = r2(t2, _24), c2 = _24;
  if (s.to - s.from < 2) {
    const i2 = e2 / 2;
    l2.beginPath();
    const n3 = { et: _24.et - i2, rt: _24.rt }, s2 = { et: _24.et + i2, rt: _24.rt };
    l2.moveTo(n3.et * a2, n3.rt * o2), l2.lineTo(s2.et * a2, s2.rt * o2), h2(t2, u2, n3, s2);
  } else {
    const e3 = /* @__PURE__ */ __name((i2, n3) => {
      h2(t2, u2, c2, n3), l2.beginPath(), u2 = i2, c2 = n3;
    }, "e");
    let d2 = c2;
    l2.beginPath(), l2.moveTo(_24.et * a2, _24.rt * o2);
    for (let h3 = s.from + 1; h3 < s.to; ++h3) {
      d2 = i[h3];
      const s2 = r2(t2, d2);
      switch (n2) {
        case 0:
          l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 1:
          l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2), s2 !== u2 && (e3(s2, d2), l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2)), l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 2: {
          const [t3, n3] = xt$1(i, h3 - 1, h3);
          l2.bezierCurveTo(t3.et * a2, t3.rt * o2, n3.et * a2, n3.rt * o2, d2.et * a2, d2.rt * o2);
          break;
        }
      }
      n2 !== 1 && s2 !== u2 && (e3(s2, d2), l2.moveTo(d2.et * a2, d2.rt * o2));
    }
    (c2 !== d2 || c2 === d2 && n2 === 1) && h2(t2, u2, c2, d2);
  }
}
__name(bt$1, "bt$1");
const wt$1 = 6;
function gt$1(t2, i) {
  return { et: t2.et - i.et, rt: t2.rt - i.rt };
}
__name(gt$1, "gt$1");
function Mt(t2, i) {
  return { et: t2.et / i, rt: t2.rt / i };
}
__name(Mt, "Mt");
function xt$1(t2, i, n2) {
  const s = Math.max(0, i - 1), e2 = Math.min(t2.length - 1, n2 + 1);
  var r2, h2;
  return [(r2 = t2[i], h2 = Mt(gt$1(t2[n2], t2[s]), wt$1), { et: r2.et + h2.et, rt: r2.rt + h2.rt }), gt$1(t2[n2], Mt(gt$1(t2[e2], t2[i]), wt$1))];
}
__name(xt$1, "xt$1");
function St$1(t2, i, n2, s, e2) {
  const { context: r2, horizontalPixelRatio: h2, verticalPixelRatio: l2 } = i;
  r2.lineTo(e2.et * h2, t2 * l2), r2.lineTo(s.et * h2, t2 * l2), r2.closePath(), r2.fillStyle = n2, r2.fill();
}
__name(St$1, "St$1");
const _kt = class _kt extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    var i;
    if (this.tt === null)
      return;
    const { st: n2, nt: s, cs: e2, ht: r2, Wt: h2, ds: l2 } = this.tt, a2 = (i = this.tt.fs) !== null && i !== void 0 ? i : this.tt.vs ? 0 : t2.mediaSize.height;
    if (s === null)
      return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineJoin = "round", o2.lineWidth = r2, f(o2, h2), o2.lineWidth = 1, bt$1(t2, n2, l2, s, e2, this.ps.bind(this), St$1.bind(null, a2));
  }
};
__name(_kt, "kt");
let kt = _kt;
function yt$1(t2, i, n2) {
  return Math.min(Math.max(t2, i), n2);
}
__name(yt$1, "yt$1");
function Ct$1(t2, i, n2) {
  return i - t2 <= n2;
}
__name(Ct$1, "Ct$1");
function Tt$1(t2) {
  const i = Math.ceil(t2);
  return i % 2 == 0 ? i - 1 : i;
}
__name(Tt$1, "Tt$1");
var _a12;
let Pt$1 = (_a12 = class {
  bs(t2, i) {
    const n2 = this.ws, { gs: s, Ms: e2, xs: r2, Ss: h2, ks: l2, fs: a2 } = i;
    if (this.ys === void 0 || n2 === void 0 || n2.gs !== s || n2.Ms !== e2 || n2.xs !== r2 || n2.Ss !== h2 || n2.fs !== a2 || n2.ks !== l2) {
      const n3 = t2.context.createLinearGradient(0, 0, 0, l2);
      if (n3.addColorStop(0, s), a2 != null) {
        const i2 = yt$1(a2 * t2.verticalPixelRatio / l2, 0, 1);
        n3.addColorStop(i2, e2), n3.addColorStop(i2, r2);
      }
      n3.addColorStop(1, h2), this.ys = n3, this.ws = i;
    }
    return this.ys;
  }
}, __name(_a12, "Pt"), _a12);
var _a13;
let Rt$1 = (_a13 = class extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    return this.Cs.bs(t2, { gs: i.Ts, Ms: "", xs: "", Ss: i.Ps, ks: t2.bitmapSize.height });
  }
}, __name(_a13, "Rt"), _a13);
function Dt$1(t2, i) {
  const n2 = t2.context;
  n2.strokeStyle = i, n2.stroke();
}
__name(Dt$1, "Dt$1");
var _a14;
let Ot$1 = (_a14 = class extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    if (this.tt === null)
      return;
    const { st: i, nt: n2, cs: s, ds: e2, ht: r2, Wt: h2, Rs: l2 } = this.tt;
    if (n2 === null)
      return;
    const a2 = t2.context;
    a2.lineCap = "butt", a2.lineWidth = r2 * t2.verticalPixelRatio, f(a2, h2), a2.lineJoin = "round";
    const o2 = this.Ds.bind(this);
    e2 !== void 0 && bt$1(t2, i, e2, n2, s, o2, Dt$1), l2 && function(t3, i2, n3, s2, e3) {
      const { horizontalPixelRatio: r3, verticalPixelRatio: h3, context: l3 } = t3;
      let a3 = null;
      const o3 = Math.max(1, Math.floor(r3)) % 2 / 2, _24 = n3 * h3 + o3;
      for (let n4 = s2.to - 1; n4 >= s2.from; --n4) {
        const s3 = i2[n4];
        if (s3) {
          const i3 = e3(t3, s3);
          i3 !== a3 && (l3.beginPath(), a3 !== null && l3.fill(), l3.fillStyle = i3, a3 = i3);
          const n5 = Math.round(s3.et * r3) + o3, u2 = s3.rt * h3;
          l3.moveTo(n5, u2), l3.arc(n5, u2, _24, 0, 2 * Math.PI);
        }
      }
      l3.fill();
    }(t2, i, l2, n2, o2);
  }
}, __name(_a14, "Ot"), _a14);
var _a15;
let At$1 = (_a15 = class extends Ot$1 {
  Ds(t2, i) {
    return i._t;
  }
}, __name(_a15, "At"), _a15);
function Vt$1(t2, i, n2, s, e2 = 0, r2 = i.length) {
  let h2 = r2 - e2;
  for (; 0 < h2; ) {
    const r3 = h2 >> 1, l2 = e2 + r3;
    s(i[l2], n2) === t2 ? (e2 = l2 + 1, h2 -= r3 + 1) : h2 = r3;
  }
  return e2;
}
__name(Vt$1, "Vt$1");
const Bt$1 = Vt$1.bind(null, !0), It$1 = Vt$1.bind(null, !1);
function zt$1(t2, i) {
  return t2.ut < i;
}
__name(zt$1, "zt$1");
function Et$1(t2, i) {
  return i < t2.ut;
}
__name(Et$1, "Et$1");
function Lt$1(t2, i, n2) {
  const s = i.Os(), e2 = i.di(), r2 = Bt$1(t2, s, zt$1), h2 = It$1(t2, e2, Et$1);
  if (!n2)
    return { from: r2, to: h2 };
  let l2 = r2, a2 = h2;
  return r2 > 0 && r2 < t2.length && t2[r2].ut >= s && (l2 = r2 - 1), h2 > 0 && h2 < t2.length && t2[h2 - 1].ut <= e2 && (a2 = h2 + 1), { from: l2, to: a2 };
}
__name(Lt$1, "Lt$1");
var _a16;
let Nt$1 = (_a16 = class {
  constructor(t2, i, n2) {
    this.As = !0, this.Vs = !0, this.Bs = !0, this.Is = [], this.zs = null, this.Es = t2, this.Ls = i, this.Ns = n2;
  }
  gt(t2) {
    this.As = !0, t2 === "data" && (this.Vs = !0), t2 === "options" && (this.Bs = !0);
  }
  xt() {
    return this.Es.Tt() ? (this.Fs(), this.zs === null ? null : this.Ws) : null;
  }
  js() {
    this.Is = this.Is.map((t2) => Object.assign(Object.assign({}, t2), this.Es.$s().Hs(t2.ut)));
  }
  Us() {
    this.zs = null;
  }
  Fs() {
    this.Vs && (this.qs(), this.Vs = !1), this.Bs && (this.js(), this.Bs = !1), this.As && (this.Ys(), this.As = !1);
  }
  Ys() {
    const t2 = this.Es.At(), i = this.Ls.yt();
    if (this.Us(), i.Fi() || t2.Fi())
      return;
    const n2 = i.Xs();
    if (n2 === null || this.Es.In().Ks() === 0)
      return;
    const s = this.Es.Pt();
    s !== null && (this.zs = Lt$1(this.Is, n2, this.Ns), this.Zs(t2, i, s.Vt), this.Gs());
  }
}, __name(_a16, "Nt"), _a16);
var _a17;
let Ft$1 = (_a17 = class extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, !0);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.Qs(this.Is, n2, E(this.zs));
  }
  te(t2, i) {
    return { ut: t2, ct: i, et: NaN, rt: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => {
      const n2 = i.Vt[3];
      return this.ne(i.se, n2, t2);
    });
  }
}, __name(_a17, "Ft"), _a17);
var _a18;
let Wt$1 = (_a18 = class extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.ee = new Rt$1(), this.re = new At$1(), this.Ws.X([this.ee, this.re]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.ee.it({ ds: t2.lineType, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, fs: null, vs: t2.invertFilledArea, nt: this.zs, cs: this.Ls.yt().he() }), this.re.it({ ds: t2.lineVisible ? t2.lineType : void 0, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, nt: this.zs, cs: this.Ls.yt().he(), Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0 });
  }
}, __name(_a18, "Wt"), _a18);
var _a19;
let jt$1 = (_a19 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0, this.ae = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (this.Lt === null || this.Lt.In.length === 0 || this.Lt.nt === null)
      return;
    this.le = this.oe(i), this.le >= 2 && Math.max(1, Math.floor(i)) % 2 != this.le % 2 && this.le--, this.ae = this.Lt._e ? Math.min(this.le, Math.floor(i)) : this.le;
    let s = null;
    const e2 = this.ae <= this.le && this.Lt.he >= Math.floor(1.5 * i);
    for (let r2 = this.Lt.nt.from; r2 < this.Lt.nt.to; ++r2) {
      const h2 = this.Lt.In[r2];
      s !== h2.ue && (t2.fillStyle = h2.ue, s = h2.ue);
      const l2 = Math.floor(0.5 * this.ae), a2 = Math.round(h2.et * i), o2 = a2 - l2, _24 = this.ae, u2 = o2 + _24 - 1, c2 = Math.min(h2.ce, h2.de), d2 = Math.max(h2.ce, h2.de), f2 = Math.round(c2 * n2) - l2, v2 = Math.round(d2 * n2) + l2, p2 = Math.max(v2 - f2, this.ae);
      t2.fillRect(o2, f2, _24, p2);
      const m2 = Math.ceil(1.5 * this.le);
      if (e2) {
        if (this.Lt.fe) {
          const i3 = a2 - m2;
          let s3 = Math.max(f2, Math.round(h2.ve * n2) - l2), e4 = s3 + _24 - 1;
          e4 > f2 + p2 - 1 && (e4 = f2 + p2 - 1, s3 = e4 - _24 + 1), t2.fillRect(i3, s3, o2 - i3, e4 - s3 + 1);
        }
        const i2 = a2 + m2;
        let s2 = Math.max(f2, Math.round(h2.pe * n2) - l2), e3 = s2 + _24 - 1;
        e3 > f2 + p2 - 1 && (e3 = f2 + p2 - 1, s2 = e3 - _24 + 1), t2.fillRect(u2 + 1, s2, i2 - u2, e3 - s2 + 1);
      }
    }
  }
  oe(t2) {
    const i = Math.floor(t2);
    return Math.max(i, Math.floor(function(t3, i2) {
      return Math.floor(0.3 * t3 * i2);
    }(b(this.Lt).he, t2)));
  }
}, __name(_a19, "jt"), _a19);
var _a20;
let Ht$1 = (_a20 = class extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, !1);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.me(this.Is, n2, E(this.zs));
  }
  be(t2, i, n2) {
    return { ut: t2, we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3], et: NaN, ve: NaN, ce: NaN, de: NaN, pe: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => this.ne(i.se, i, t2));
  }
}, __name(_a20, "Ht"), _a20);
var _a21;
let $t$1 = (_a21 = class extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new jt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), fe: t2.openVisible, _e: t2.thinBars, nt: this.zs });
  }
}, __name(_a21, "$t"), _a21);
var _a22;
let Ut$1 = (_a22 = class extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    const n2 = this.tt;
    return this.Cs.bs(t2, { gs: i.Se, Ms: i.ke, xs: i.ye, Ss: i.Ce, ks: t2.bitmapSize.height, fs: n2.fs });
  }
}, __name(_a22, "Ut"), _a22);
var _a23;
let qt$1 = (_a23 = class extends Ot$1 {
  constructor() {
    super(...arguments), this.Te = new Pt$1();
  }
  Ds(t2, i) {
    const n2 = this.tt;
    return this.Te.bs(t2, { gs: i.Pe, Ms: i.Pe, xs: i.Re, Ss: i.Re, ks: t2.bitmapSize.height, fs: n2.fs });
  }
}, __name(_a23, "qt"), _a23);
var _a24;
let Yt$1 = (_a24 = class extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.De = new Ut$1(), this.Oe = new qt$1(), this.Ws.X([this.De, this.Oe]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.Pt();
    if (t2 === null)
      return;
    const i = this.Es.W(), n2 = this.Es.At().Ot(i.baseValue.price, t2.Vt), s = this.Ls.yt().he();
    this.De.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineType, fs: n2, vs: !1, nt: this.zs, cs: s }), this.Oe.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineVisible ? i.lineType : void 0, Rs: i.pointMarkersVisible ? i.pointMarkersRadius || i.lineWidth / 2 + 2 : void 0, fs: n2, nt: this.zs, cs: s });
  }
}, __name(_a24, "Yt"), _a24);
var _a25;
let Xt$1 = (_a25 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z(t2) {
    if (this.Lt === null || this.Lt.In.length === 0 || this.Lt.nt === null)
      return;
    const { horizontalPixelRatio: i } = t2;
    this.le = function(t3, i2) {
      if (t3 >= 2.5 && t3 <= 4)
        return Math.floor(3 * i2);
      const n3 = 1 - 0.2 * Math.atan(Math.max(4, t3) - 4) / (0.5 * Math.PI), s2 = Math.floor(t3 * n3 * i2), e2 = Math.floor(t3 * i2), r2 = Math.min(s2, e2);
      return Math.max(Math.floor(i2), r2);
    }(this.Lt.he, i), this.le >= 2 && Math.floor(i) % 2 != this.le % 2 && this.le--;
    const n2 = this.Lt.In;
    this.Lt.Ae && this.Ve(t2, n2, this.Lt.nt), this.Lt.ci && this.Be(t2, n2, this.Lt.nt);
    const s = this.Ie(i);
    (!this.Lt.ci || this.le > 2 * s) && this.ze(t2, n2, this.Lt.nt);
  }
  Ve(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "", l2 = Math.min(Math.floor(e2), Math.floor(this.Lt.he * e2));
    l2 = Math.max(Math.floor(e2), Math.min(l2, this.le));
    const a2 = Math.floor(0.5 * l2);
    let o2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Ee !== h2 && (s.fillStyle = n3.Ee, h2 = n3.Ee);
      const _24 = Math.round(Math.min(n3.ve, n3.pe) * r2), u2 = Math.round(Math.max(n3.ve, n3.pe) * r2), c2 = Math.round(n3.ce * r2), d2 = Math.round(n3.de * r2);
      let f2 = Math.round(e2 * n3.et) - a2;
      const v2 = f2 + l2 - 1;
      o2 !== null && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, v2));
      const p2 = v2 - f2 + 1;
      s.fillRect(f2, c2, p2, _24 - c2), s.fillRect(f2, u2 + 1, p2, d2 - u2), o2 = v2;
    }
  }
  Ie(t2) {
    let i = Math.floor(1 * t2);
    this.le <= 2 * i && (i = Math.floor(0.5 * (this.le - 1)));
    const n2 = Math.max(Math.floor(t2), i);
    return this.le <= 2 * n2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : n2;
  }
  Be(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e2);
    let a2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Le !== h2 && (s.fillStyle = n3.Le, h2 = n3.Le);
      let o2 = Math.round(n3.et * e2) - Math.floor(0.5 * this.le);
      const _24 = o2 + this.le - 1, u2 = Math.round(Math.min(n3.ve, n3.pe) * r2), c2 = Math.round(Math.max(n3.ve, n3.pe) * r2);
      if (a2 !== null && (o2 = Math.max(a2 + 1, o2), o2 = Math.min(o2, _24)), this.Lt.he * e2 > 2 * l2)
        Z$1(s, o2, u2, _24 - o2 + 1, c2 - u2 + 1, l2);
      else {
        const t4 = _24 - o2 + 1;
        s.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      a2 = _24;
    }
  }
  ze(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e2);
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      let a2 = Math.round(Math.min(n3.ve, n3.pe) * r2), o2 = Math.round(Math.max(n3.ve, n3.pe) * r2), _24 = Math.round(n3.et * e2) - Math.floor(0.5 * this.le), u2 = _24 + this.le - 1;
      if (n3.ue !== h2) {
        const t4 = n3.ue;
        s.fillStyle = t4, h2 = t4;
      }
      this.Lt.ci && (_24 += l2, a2 += l2, u2 -= l2, o2 -= l2), a2 > o2 || s.fillRect(_24, a2, u2 - _24 + 1, o2 - a2 + 1);
    }
  }
}, __name(_a25, "Xt"), _a25);
var _a26;
let Kt$1 = (_a26 = class extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new Xt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), Ae: t2.wickVisible, ci: t2.borderVisible, nt: this.zs });
  }
}, __name(_a26, "Kt"), _a26);
var _a27;
let Zt$1 = (_a27 = class {
  constructor(t2, i) {
    this.Ne = t2, this.Li = i;
  }
  K(t2, i, n2) {
    this.Ne.draw(t2, this.Li, i, n2);
  }
}, __name(_a27, "Zt"), _a27);
var _a28;
let Gt$1 = (_a28 = class extends Nt$1 {
  constructor(t2, i, n2) {
    super(t2, i, !1), this.wn = n2, this.Ws = new Zt$1(this.wn.renderer(), (i2) => {
      const n3 = t2.Pt();
      return n3 === null ? null : t2.At().Ot(i2, n3.Vt);
    });
  }
  Fe(t2) {
    return this.wn.priceValueBuilder(t2);
  }
  We(t2) {
    return this.wn.isWhitespace(t2);
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => Object.assign(Object.assign({ ut: i.se, et: NaN }, t2.Hs(i.se)), { je: i.He }));
  }
  Zs(t2, i) {
    i.Js(this.Is, E(this.zs));
  }
  Gs() {
    this.wn.update({ bars: this.Is.map(Jt$1), barSpacing: this.Ls.yt().he(), visibleRange: this.zs }, this.Es.W());
  }
}, __name(_a28, "Gt"), _a28);
function Jt$1(t2) {
  return { x: t2.et, time: t2.ut, originalData: t2.je, barColor: t2.ue };
}
__name(Jt$1, "Jt$1");
var _a29;
let Qt$1 = (_a29 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.$e = [];
  }
  it(t2) {
    this.Lt = t2, this.$e = [];
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (this.Lt === null || this.Lt.st.length === 0 || this.Lt.nt === null)
      return;
    this.$e.length || this.Ue(i);
    const s = Math.max(1, Math.floor(n2)), e2 = Math.round(this.Lt.qe * n2) - Math.floor(s / 2), r2 = e2 + s;
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const h2 = this.Lt.st[i2], l2 = this.$e[i2 - this.Lt.nt.from], a2 = Math.round(h2.rt * n2);
      let o2, _24;
      t2.fillStyle = h2.ue, a2 <= e2 ? (o2 = a2, _24 = r2) : (o2 = e2, _24 = a2 - Math.floor(s / 2) + s), t2.fillRect(l2.Os, o2, l2.di - l2.Os + 1, _24 - o2);
    }
  }
  Ue(t2) {
    if (this.Lt === null || this.Lt.st.length === 0 || this.Lt.nt === null)
      return void (this.$e = []);
    const i = Math.ceil(this.Lt.he * t2) <= 1 ? 0 : Math.max(1, Math.floor(t2)), n2 = Math.round(this.Lt.he * t2) - i;
    this.$e = new Array(this.Lt.nt.to - this.Lt.nt.from);
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const s2 = this.Lt.st[i2], e2 = Math.round(s2.et * t2);
      let r2, h2;
      if (n2 % 2) {
        const t3 = (n2 - 1) / 2;
        r2 = e2 - t3, h2 = e2 + t3;
      } else {
        const t3 = n2 / 2;
        r2 = e2 - t3, h2 = e2 + t3 - 1;
      }
      this.$e[i2 - this.Lt.nt.from] = { Os: r2, di: h2, Ye: e2, Xe: s2.et * t2, ut: s2.ut };
    }
    for (let t3 = this.Lt.nt.from + 1; t3 < this.Lt.nt.to; t3++) {
      const n3 = this.$e[t3 - this.Lt.nt.from], s2 = this.$e[t3 - this.Lt.nt.from - 1];
      n3.ut === s2.ut + 1 && n3.Os - s2.di !== i + 1 && (s2.Ye > s2.Xe ? s2.di = n3.Os - i - 1 : n3.Os = s2.di + i + 1);
    }
    let s = Math.ceil(this.Lt.he * t2);
    for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
      const i2 = this.$e[t3 - this.Lt.nt.from];
      i2.di < i2.Os && (i2.di = i2.Os);
      const n3 = i2.di - i2.Os + 1;
      s = Math.min(n3, s);
    }
    if (i > 0 && s < 4)
      for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
        const i2 = this.$e[t3 - this.Lt.nt.from];
        i2.di - i2.Os + 1 > s && (i2.Ye > i2.Xe ? i2.di -= 1 : i2.Os += 1);
      }
  }
}, __name(_a29, "Qt"), _a29);
const _ti = class _ti extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new Qt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = { st: this.Is, he: this.Ls.yt().he(), nt: this.zs, qe: this.Es.At().Ot(this.Es.W().base, b(this.Es.Pt()).Vt) };
    this.Ws.it(t2);
  }
};
__name(_ti, "ti");
let ti = _ti;
const _ii = class _ii extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new At$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W(), i = { st: this.Is, Wt: t2.lineStyle, ds: t2.lineVisible ? t2.lineType : void 0, ht: t2.lineWidth, Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0, nt: this.zs, cs: this.Ls.yt().he() };
    this.Ws.it(i);
  }
};
__name(_ii, "ii");
let ii = _ii;
const ni = /[2-9]/g, _si = class _si {
  constructor(t2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Je = {}, this.Qe = /* @__PURE__ */ new Map(), this.tr = t2;
  }
  ir() {
    this.Ke = 0, this.Qe.clear(), this.Ze = 1, this.Ge = 1, this.Je = {};
  }
  Si(t2, i, n2) {
    return this.nr(t2, i, n2).width;
  }
  xi(t2, i, n2) {
    const s = this.nr(t2, i, n2);
    return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2;
  }
  nr(t2, i, n2) {
    const s = n2 || ni, e2 = String(i).replace(s, "0");
    if (this.Qe.has(e2))
      return m$1(this.Qe.get(e2)).sr;
    if (this.Ke === this.tr) {
      const t3 = this.Je[this.Ge];
      delete this.Je[this.Ge], this.Qe.delete(t3), this.Ge++, this.Ke--;
    }
    t2.save(), t2.textBaseline = "middle";
    const r2 = t2.measureText(e2);
    return t2.restore(), r2.width === 0 && i.length || (this.Qe.set(e2, { sr: r2, er: this.Ze }), this.Je[this.Ze] = e2, this.Ke++, this.Ze++), r2;
  }
};
__name(_si, "si");
let si = _si;
const _ei = class _ei {
  constructor(t2) {
    this.rr = null, this.k = null, this.hr = "right", this.lr = t2;
  }
  ar(t2, i, n2) {
    this.rr = t2, this.k = i, this.hr = n2;
  }
  K(t2) {
    this.k !== null && this.rr !== null && this.rr.K(t2, this.k, this.lr, this.hr);
  }
};
__name(_ei, "ei");
let ei = _ei;
const _ri = class _ri {
  constructor(t2, i, n2) {
    this._r = t2, this.lr = new si(50), this.ur = i, this.F = n2, this.j = -1, this.Ht = new ei(this.lr);
  }
  xt() {
    const t2 = this.F.cr(this.ur);
    if (t2 === null)
      return null;
    const i = t2.dr(this.ur) ? t2.vr() : this.ur.At();
    if (i === null)
      return null;
    const n2 = t2.pr(i);
    if (n2 === "overlay")
      return null;
    const s = this.F.mr();
    return s.P !== this.j && (this.j = s.P, this.lr.ir()), this.Ht.ar(this._r.zi(), s, n2), this.Ht;
  }
};
__name(_ri, "ri");
let ri = _ri;
const _hi = class _hi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  br(t2, i) {
    var n2;
    if (!(!((n2 = this.Lt) === null || n2 === void 0) && n2.Tt))
      return null;
    const { rt: s, ht: e2, wr: r2 } = this.Lt;
    return i >= s - e2 - 7 && i <= s + e2 + 7 ? { gr: this.Lt, wr: r2 } : null;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null || this.Lt.Tt === !1)
      return;
    const e2 = Math.round(this.Lt.rt * s);
    e2 < 0 || e2 > i.height || (t2.lineCap = "butt", t2.strokeStyle = this.Lt.O, t2.lineWidth = Math.floor(this.Lt.ht * n2), f(t2, this.Lt.Wt), v(t2, e2, 0, i.width));
  }
};
__name(_hi, "hi");
let hi = _hi;
const _li = class _li {
  constructor(t2) {
    this.Mr = { rt: 0, O: "rgba(0, 0, 0, 0)", ht: 1, Wt: 0, Tt: !1 }, this.Sr = new hi(), this.bt = !0, this.Es = t2, this.Ls = t2.qt(), this.Sr.it(this.Mr);
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.Es.Tt() ? (this.bt && (this.kr(), this.bt = !1), this.Sr) : null;
  }
};
__name(_li, "li");
let li = _li;
const _ai = class _ai extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    this.Mr.Tt = !1;
    const t2 = this.Es.At(), i = t2.yr().yr;
    if (i !== 2 && i !== 3)
      return;
    const n2 = this.Es.W();
    if (!n2.baseLineVisible || !this.Es.Tt())
      return;
    const s = this.Es.Pt();
    s !== null && (this.Mr.Tt = !0, this.Mr.rt = t2.Ot(s.Vt, s.Vt), this.Mr.O = n2.baseLineColor, this.Mr.ht = n2.baseLineWidth, this.Mr.Wt = n2.baseLineStyle);
  }
};
__name(_ai, "ai");
let ai = _ai;
const _oi = class _oi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  He() {
    return this.Lt;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    const s = this.Lt;
    if (s === null)
      return;
    const e2 = Math.max(1, Math.floor(i)), r2 = e2 % 2 / 2, h2 = Math.round(s.Xe.x * i) + r2, l2 = s.Xe.y * n2;
    t2.fillStyle = s.Cr, t2.beginPath();
    const a2 = Math.max(2, 1.5 * s.Tr) * i;
    t2.arc(h2, l2, a2, 0, 2 * Math.PI, !1), t2.fill(), t2.fillStyle = s.Pr, t2.beginPath(), t2.arc(h2, l2, s.ot * i, 0, 2 * Math.PI, !1), t2.fill(), t2.lineWidth = e2, t2.strokeStyle = s.Rr, t2.beginPath(), t2.arc(h2, l2, s.ot * i + e2 / 2, 0, 2 * Math.PI, !1), t2.stroke();
  }
};
__name(_oi, "oi");
let oi = _oi;
const _i = [{ Dr: 0, Or: 0.25, Ar: 4, Vr: 10, Br: 0.25, Ir: 0, zr: 0.4, Er: 0.8 }, { Dr: 0.25, Or: 0.525, Ar: 10, Vr: 14, Br: 0, Ir: 0, zr: 0.8, Er: 0 }, { Dr: 0.525, Or: 1, Ar: 14, Vr: 14, Br: 0, Ir: 0, zr: 0, Er: 0 }];
function ui(t2, i, n2, s) {
  return function(t3, i2) {
    if (t3 === "transparent")
      return t3;
    const n3 = T$1(t3), s2 = n3[3];
    return `rgba(${n3[0]}, ${n3[1]}, ${n3[2]}, ${i2 * s2})`;
  }(t2, n2 + (s - n2) * i);
}
__name(ui, "ui");
function ci(t2, i) {
  const n2 = t2 % 2600 / 2600;
  let s;
  for (const t3 of _i)
    if (n2 >= t3.Dr && n2 <= t3.Or) {
      s = t3;
      break;
    }
  p$1(s !== void 0, "Last price animation internal logic error");
  const e2 = (n2 - s.Dr) / (s.Or - s.Dr);
  return { Pr: ui(i, e2, s.Br, s.Ir), Rr: ui(i, e2, s.zr, s.Er), ot: (r2 = e2, h2 = s.Ar, l2 = s.Vr, h2 + (l2 - h2) * r2) };
  var r2, h2, l2;
}
__name(ci, "ci");
const _di = class _di {
  constructor(t2) {
    this.Ht = new oi(), this.bt = !0, this.Lr = !0, this.Nr = performance.now(), this.Fr = this.Nr - 1, this.Wr = t2;
  }
  jr() {
    this.Fr = this.Nr - 1, this.gt();
  }
  Hr() {
    if (this.gt(), this.Wr.W().lastPriceAnimation === 2) {
      const t2 = performance.now(), i = this.Fr - t2;
      if (i > 0)
        return void (i < 650 && (this.Fr += 2600));
      this.Nr = t2, this.Fr = t2 + 2600;
    }
  }
  gt() {
    this.bt = !0;
  }
  $r() {
    this.Lr = !0;
  }
  Tt() {
    return this.Wr.W().lastPriceAnimation !== 0;
  }
  Ur() {
    switch (this.Wr.W().lastPriceAnimation) {
      case 0:
        return !1;
      case 1:
        return !0;
      case 2:
        return performance.now() <= this.Fr;
    }
  }
  xt() {
    return this.bt ? (this.St(), this.bt = !1, this.Lr = !1) : this.Lr && (this.qr(), this.Lr = !1), this.Ht;
  }
  St() {
    this.Ht.it(null);
    const t2 = this.Wr.qt().yt(), i = t2.Xs(), n2 = this.Wr.Pt();
    if (i === null || n2 === null)
      return;
    const s = this.Wr.Yr(!0);
    if (s.Xr || !i.Kr(s.se))
      return;
    const e2 = { x: t2.Et(s.se), y: this.Wr.At().Ot(s.ct, n2.Vt) }, r2 = s.O, h2 = this.Wr.W().lineWidth, l2 = ci(this.Zr(), r2);
    this.Ht.it({ Cr: r2, Tr: h2, Pr: l2.Pr, Rr: l2.Rr, ot: l2.ot, Xe: e2 });
  }
  qr() {
    const t2 = this.Ht.He();
    if (t2 !== null) {
      const i = ci(this.Zr(), t2.Cr);
      t2.Pr = i.Pr, t2.Rr = i.Rr, t2.ot = i.ot;
    }
  }
  Zr() {
    return this.Ur() ? performance.now() - this.Nr : 2599;
  }
};
__name(_di, "di");
let di = _di;
function fi(t2, i) {
  return Tt$1(Math.min(Math.max(t2, 12), 30) * i);
}
__name(fi, "fi");
function vi(t2, i) {
  switch (t2) {
    case "arrowDown":
    case "arrowUp":
      return fi(i, 1);
    case "circle":
      return fi(i, 0.8);
    case "square":
      return fi(i, 0.7);
  }
}
__name(vi, "vi");
function pi(t2) {
  return function(t3) {
    const i = Math.ceil(t3);
    return i % 2 != 0 ? i - 1 : i;
  }(fi(t2, 1));
}
__name(pi, "pi");
function mi(t2) {
  return Math.max(fi(t2, 0.1), 3);
}
__name(mi, "mi");
function bi(t2, i, n2, s, e2) {
  const r2 = vi("square", n2), h2 = (r2 - 1) / 2, l2 = t2 - h2, a2 = i - h2;
  return s >= l2 && s <= l2 + r2 && e2 >= a2 && e2 <= a2 + r2;
}
__name(bi, "bi");
function wi(t2, i, n2, s, e2) {
  const r2 = (vi("arrowUp", e2) - 1) / 2, h2 = (Tt$1(e2 / 2) - 1) / 2;
  i.beginPath(), t2 ? (i.moveTo(n2 - r2, s), i.lineTo(n2, s - r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s + r2), i.lineTo(n2 - h2, s + r2), i.lineTo(n2 - h2, s)) : (i.moveTo(n2 - r2, s), i.lineTo(n2, s + r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s - r2), i.lineTo(n2 - h2, s - r2), i.lineTo(n2 - h2, s)), i.fill();
}
__name(wi, "wi");
function gi(t2, i, n2, s, e2, r2) {
  return bi(i, n2, s, e2, r2);
}
__name(gi, "gi");
const _Mi = class _Mi extends j {
  constructor() {
    super(...arguments), this.Lt = null, this.lr = new si(), this.j = -1, this.H = "", this.Gr = "";
  }
  it(t2) {
    this.Lt = t2;
  }
  ar(t2, i) {
    this.j === t2 && this.H === i || (this.j = t2, this.H = i, this.Gr = N$1(t2, i), this.lr.ir());
  }
  br(t2, i) {
    if (this.Lt === null || this.Lt.nt === null)
      return null;
    for (let n2 = this.Lt.nt.from; n2 < this.Lt.nt.to; n2++) {
      const s = this.Lt.st[n2];
      if (Si(s, t2, i))
        return { gr: s.Jr, wr: s.wr };
    }
    return null;
  }
  Z({ context: t2 }, i, n2) {
    if (this.Lt !== null && this.Lt.nt !== null) {
      t2.textBaseline = "middle", t2.font = this.Gr;
      for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
        const n3 = this.Lt.st[i2];
        n3.Jt !== void 0 && (n3.Jt.$i = this.lr.Si(t2, n3.Jt.Qr), n3.Jt.zt = this.j, n3.Jt.et = n3.et - n3.Jt.$i / 2), xi(n3, t2);
      }
    }
  }
};
__name(_Mi, "Mi");
let Mi = _Mi;
function xi(t2, i) {
  i.fillStyle = t2.O, t2.Jt !== void 0 && function(t3, i2, n2, s) {
    t3.fillText(i2, n2, s);
  }(i, t2.Jt.Qr, t2.Jt.et, t2.Jt.rt), function(t3, i2) {
    if (t3.Ks !== 0) {
      switch (t3.th) {
        case "arrowDown":
          return void wi(!1, i2, t3.et, t3.rt, t3.Ks);
        case "arrowUp":
          return void wi(!0, i2, t3.et, t3.rt, t3.Ks);
        case "circle":
          return void function(t4, i3, n2, s) {
            const e2 = (vi("circle", s) - 1) / 2;
            t4.beginPath(), t4.arc(i3, n2, e2, 0, 2 * Math.PI, !1), t4.fill();
          }(i2, t3.et, t3.rt, t3.Ks);
        case "square":
          return void function(t4, i3, n2, s) {
            const e2 = vi("square", s), r2 = (e2 - 1) / 2, h2 = i3 - r2, l2 = n2 - r2;
            t4.fillRect(h2, l2, e2, e2);
          }(i2, t3.et, t3.rt, t3.Ks);
      }
      t3.th;
    }
  }(t2, i);
}
__name(xi, "xi");
function Si(t2, i, n2) {
  return !(t2.Jt === void 0 || !function(t3, i2, n3, s, e2, r2) {
    const h2 = s / 2;
    return e2 >= t3 && e2 <= t3 + n3 && r2 >= i2 - h2 && r2 <= i2 + h2;
  }(t2.Jt.et, t2.Jt.rt, t2.Jt.$i, t2.Jt.zt, i, n2)) || function(t3, i2, n3) {
    if (t3.Ks === 0)
      return !1;
    switch (t3.th) {
      case "arrowDown":
      case "arrowUp":
        return gi(0, t3.et, t3.rt, t3.Ks, i2, n3);
      case "circle":
        return function(t4, i3, n4, s, e2) {
          const r2 = 2 + vi("circle", n4) / 2, h2 = t4 - s, l2 = i3 - e2;
          return Math.sqrt(h2 * h2 + l2 * l2) <= r2;
        }(t3.et, t3.rt, t3.Ks, i2, n3);
      case "square":
        return bi(t3.et, t3.rt, t3.Ks, i2, n3);
    }
  }(t2, i, n2);
}
__name(Si, "Si");
function ki(t2, i, n2, s, e2, r2, h2, l2, a2) {
  const o2 = O$1(n2) ? n2 : n2.xe, _24 = O$1(n2) ? n2 : n2.ge, u2 = O$1(n2) ? n2 : n2.Me, c2 = O$1(i.size) ? Math.max(i.size, 0) : 1, d2 = pi(l2.he()) * c2, f2 = d2 / 2;
  switch (t2.Ks = d2, i.position) {
    case "inBar":
      return t2.rt = h2.Ot(o2, a2), void (t2.Jt !== void 0 && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e2));
    case "aboveBar":
      return t2.rt = h2.Ot(_24, a2) - f2 - s.ih, t2.Jt !== void 0 && (t2.Jt.rt = t2.rt - f2 - 0.6 * e2, s.ih += 1.2 * e2), void (s.ih += d2 + r2);
    case "belowBar":
      return t2.rt = h2.Ot(u2, a2) + f2 + s.nh, t2.Jt !== void 0 && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e2, s.nh += 1.2 * e2), void (s.nh += d2 + r2);
  }
  i.position;
}
__name(ki, "ki");
const _yi = class _yi {
  constructor(t2, i) {
    this.bt = !0, this.sh = !0, this.eh = !0, this.rh = null, this.Ht = new Mi(), this.Wr = t2, this.Ui = i, this.Lt = { st: [], nt: null };
  }
  gt(t2) {
    this.bt = !0, this.eh = !0, t2 === "data" && (this.sh = !0);
  }
  xt(t2) {
    if (!this.Wr.Tt())
      return null;
    this.bt && this.hh();
    const i = this.Ui.W().layout;
    return this.Ht.ar(i.fontSize, i.fontFamily), this.Ht.it(this.Lt), this.Ht;
  }
  lh() {
    if (this.eh) {
      if (this.Wr.ah().length > 0) {
        const t2 = this.Ui.yt().he(), i = mi(t2), n2 = 1.5 * pi(t2) + 2 * i;
        this.rh = { above: n2, below: n2 };
      } else
        this.rh = null;
      this.eh = !1;
    }
    return this.rh;
  }
  hh() {
    const t2 = this.Wr.At(), i = this.Ui.yt(), n2 = this.Wr.ah();
    this.sh && (this.Lt.st = n2.map((t3) => ({ ut: t3.time, et: 0, rt: 0, Ks: 0, th: t3.shape, O: t3.color, Jr: t3.Jr, wr: t3.id, Jt: void 0 })), this.sh = !1);
    const s = this.Ui.W().layout;
    this.Lt.nt = null;
    const e2 = i.Xs();
    if (e2 === null)
      return;
    const r2 = this.Wr.Pt();
    if (r2 === null || this.Lt.st.length === 0)
      return;
    let h2 = NaN;
    const l2 = mi(i.he()), a2 = { ih: l2, nh: l2 };
    this.Lt.nt = Lt$1(this.Lt.st, e2, !0);
    for (let e3 = this.Lt.nt.from; e3 < this.Lt.nt.to; e3++) {
      const o2 = n2[e3];
      o2.time !== h2 && (a2.ih = l2, a2.nh = l2, h2 = o2.time);
      const _24 = this.Lt.st[e3];
      _24.et = i.Et(o2.time), o2.text !== void 0 && o2.text.length > 0 && (_24.Jt = { Qr: o2.text, et: 0, rt: 0, $i: 0, zt: 0 });
      const u2 = this.Wr.oh(o2.time);
      u2 !== null && ki(_24, o2, u2, a2, s.fontSize, l2, t2, i, r2.Vt);
    }
    this.bt = !1;
  }
};
__name(_yi, "yi");
let yi = _yi;
const _Ci = class _Ci extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = !1;
    const i = this.Es.W();
    if (!i.priceLineVisible || !this.Es.Tt())
      return;
    const n2 = this.Es.Yr(i.priceLineSource === 0);
    n2.Xr || (t2.Tt = !0, t2.rt = n2.yi, t2.O = this.Es._h(n2.O), t2.ht = i.priceLineWidth, t2.Wt = i.priceLineStyle);
  }
};
__name(_Ci, "Ci");
let Ci = _Ci;
const _Ti = class _Ti extends st {
  constructor(t2) {
    super(), this.$t = t2;
  }
  Ei(t2, i, n2) {
    t2.Tt = !1, i.Tt = !1;
    const s = this.$t;
    if (!s.Tt())
      return;
    const e2 = s.W(), r2 = e2.lastValueVisible, h2 = s.uh() !== "", l2 = e2.seriesLastValueMode === 0, a2 = s.Yr(!1);
    if (a2.Xr)
      return;
    r2 && (t2.Jt = this.dh(a2, r2, l2), t2.Tt = t2.Jt.length !== 0), (h2 || l2) && (i.Jt = this.fh(a2, r2, h2, l2), i.Tt = i.Jt.length > 0);
    const o2 = s._h(a2.O), _24 = P(o2);
    n2.t = _24.t, n2.yi = a2.yi, i.Bt = s.qt().It(a2.yi / s.At().zt()), t2.Bt = o2, t2.O = _24.i, i.O = _24.i;
  }
  fh(t2, i, n2, s) {
    let e2 = "";
    const r2 = this.$t.uh();
    return n2 && r2.length !== 0 && (e2 += `${r2} `), i && s && (e2 += this.$t.At().ph() ? t2.mh : t2.bh), e2.trim();
  }
  dh(t2, i, n2) {
    return i ? n2 ? this.$t.At().ph() ? t2.bh : t2.mh : t2.Jt : "";
  }
};
__name(_Ti, "Ti");
let Ti = _Ti;
function Pi(t2, i, n2, s) {
  const e2 = Number.isFinite(i), r2 = Number.isFinite(n2);
  return e2 && r2 ? t2(i, n2) : e2 || r2 ? e2 ? i : n2 : s;
}
__name(Pi, "Pi");
const _Ri = class _Ri {
  constructor(t2, i) {
    this.wh = t2, this.gh = i;
  }
  Mh(t2) {
    return t2 !== null && this.wh === t2.wh && this.gh === t2.gh;
  }
  xh() {
    return new _Ri(this.wh, this.gh);
  }
  Sh() {
    return this.wh;
  }
  kh() {
    return this.gh;
  }
  yh() {
    return this.gh - this.wh;
  }
  Fi() {
    return this.gh === this.wh || Number.isNaN(this.gh) || Number.isNaN(this.wh);
  }
  ts(t2) {
    return t2 === null ? this : new _Ri(Pi(Math.min, this.Sh(), t2.Sh(), -1 / 0), Pi(Math.max, this.kh(), t2.kh(), 1 / 0));
  }
  Ch(t2) {
    if (!O$1(t2) || this.gh - this.wh === 0)
      return;
    const i = 0.5 * (this.gh + this.wh);
    let n2 = this.gh - i, s = this.wh - i;
    n2 *= t2, s *= t2, this.gh = i + n2, this.wh = i + s;
  }
  Th(t2) {
    O$1(t2) && (this.gh += t2, this.wh += t2);
  }
  Ph() {
    return { minValue: this.wh, maxValue: this.gh };
  }
  static Rh(t2) {
    return t2 === null ? null : new _Ri(t2.minValue, t2.maxValue);
  }
};
__name(_Ri, "Ri");
let Ri = _Ri;
const _Di = class _Di {
  constructor(t2, i) {
    this.Dh = t2, this.Oh = i || null;
  }
  Ah() {
    return this.Dh;
  }
  Vh() {
    return this.Oh;
  }
  Ph() {
    return this.Dh === null ? null : { priceRange: this.Dh.Ph(), margins: this.Oh || void 0 };
  }
  static Rh(t2) {
    return t2 === null ? null : new _Di(Ri.Rh(t2.priceRange), t2.margins);
  }
};
__name(_Di, "Di");
let Di = _Di;
const _Oi = class _Oi extends li {
  constructor(t2, i) {
    super(t2), this.Bh = i;
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = !1;
    const i = this.Bh.W();
    if (!this.Es.Tt() || !i.lineVisible)
      return;
    const n2 = this.Bh.Ih();
    n2 !== null && (t2.Tt = !0, t2.rt = n2, t2.O = i.color, t2.ht = i.lineWidth, t2.Wt = i.lineStyle, t2.wr = this.Bh.W().id);
  }
};
__name(_Oi, "Oi");
let Oi = _Oi;
const _Ai = class _Ai extends st {
  constructor(t2, i) {
    super(), this.Wr = t2, this.Bh = i;
  }
  Ei(t2, i, n2) {
    t2.Tt = !1, i.Tt = !1;
    const s = this.Bh.W(), e2 = s.axisLabelVisible, r2 = s.title !== "", h2 = this.Wr;
    if (!e2 || !h2.Tt())
      return;
    const l2 = this.Bh.Ih();
    if (l2 === null)
      return;
    r2 && (i.Jt = s.title, i.Tt = !0), i.Bt = h2.qt().It(l2 / h2.At().zt()), t2.Jt = this.zh(s.price), t2.Tt = !0;
    const a2 = P(s.axisLabelColor || s.color);
    n2.t = a2.t;
    const o2 = s.axisLabelTextColor || a2.i;
    t2.O = o2, i.O = o2, n2.yi = l2;
  }
  zh(t2) {
    const i = this.Wr.Pt();
    return i === null ? "" : this.Wr.At().Wi(t2, i.Vt);
  }
};
__name(_Ai, "Ai");
let Ai = _Ai;
const _Vi = class _Vi {
  constructor(t2, i) {
    this.Wr = t2, this.cn = i, this.Eh = new Oi(t2, this), this._r = new Ai(t2, this), this.Lh = new ri(this._r, t2, t2.qt());
  }
  Nh(t2) {
    D$1(this.cn, t2), this.gt(), this.Wr.qt().Fh();
  }
  W() {
    return this.cn;
  }
  Wh() {
    return this.Eh;
  }
  jh() {
    return this.Lh;
  }
  Hh() {
    return this._r;
  }
  gt() {
    this.Eh.gt(), this._r.gt();
  }
  Ih() {
    const t2 = this.Wr, i = t2.At();
    if (t2.qt().yt().Fi() || i.Fi())
      return null;
    const n2 = t2.Pt();
    return n2 === null ? null : i.Ot(this.cn.price, n2.Vt);
  }
};
__name(_Vi, "Vi");
let Vi = _Vi;
const _Bi = class _Bi extends at$1 {
  constructor(t2) {
    super(), this.Ui = t2;
  }
  qt() {
    return this.Ui;
  }
};
__name(_Bi, "Bi");
let Bi = _Bi;
const Ii = { Bar: (t2, i, n2, s) => {
  var e2;
  const r2 = i.upColor, h2 = i.downColor, l2 = b(t2(n2, s)), a2 = w$1(l2.Vt[0]) <= w$1(l2.Vt[3]);
  return { ue: (e2 = l2.O) !== null && e2 !== void 0 ? e2 : a2 ? r2 : h2 };
}, Candlestick: (t2, i, n2, s) => {
  var e2, r2, h2;
  const l2 = i.upColor, a2 = i.downColor, o2 = i.borderUpColor, _24 = i.borderDownColor, u2 = i.wickUpColor, c2 = i.wickDownColor, d2 = b(t2(n2, s)), f2 = w$1(d2.Vt[0]) <= w$1(d2.Vt[3]);
  return { ue: (e2 = d2.O) !== null && e2 !== void 0 ? e2 : f2 ? l2 : a2, Le: (r2 = d2.Bt) !== null && r2 !== void 0 ? r2 : f2 ? o2 : _24, Ee: (h2 = d2.$h) !== null && h2 !== void 0 ? h2 : f2 ? u2 : c2 };
}, Custom: (t2, i, n2, s) => {
  var e2;
  return { ue: (e2 = b(t2(n2, s)).O) !== null && e2 !== void 0 ? e2 : i.color };
}, Area: (t2, i, n2, s) => {
  var e2, r2, h2, l2;
  const a2 = b(t2(n2, s));
  return { ue: (e2 = a2._t) !== null && e2 !== void 0 ? e2 : i.lineColor, _t: (r2 = a2._t) !== null && r2 !== void 0 ? r2 : i.lineColor, Ts: (h2 = a2.Ts) !== null && h2 !== void 0 ? h2 : i.topColor, Ps: (l2 = a2.Ps) !== null && l2 !== void 0 ? l2 : i.bottomColor };
}, Baseline: (t2, i, n2, s) => {
  var e2, r2, h2, l2, a2, o2;
  const _24 = b(t2(n2, s));
  return { ue: _24.Vt[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor, Pe: (e2 = _24.Pe) !== null && e2 !== void 0 ? e2 : i.topLineColor, Re: (r2 = _24.Re) !== null && r2 !== void 0 ? r2 : i.bottomLineColor, Se: (h2 = _24.Se) !== null && h2 !== void 0 ? h2 : i.topFillColor1, ke: (l2 = _24.ke) !== null && l2 !== void 0 ? l2 : i.topFillColor2, ye: (a2 = _24.ye) !== null && a2 !== void 0 ? a2 : i.bottomFillColor1, Ce: (o2 = _24.Ce) !== null && o2 !== void 0 ? o2 : i.bottomFillColor2 };
}, Line: (t2, i, n2, s) => {
  var e2, r2;
  const h2 = b(t2(n2, s));
  return { ue: (e2 = h2.O) !== null && e2 !== void 0 ? e2 : i.color, _t: (r2 = h2.O) !== null && r2 !== void 0 ? r2 : i.color };
}, Histogram: (t2, i, n2, s) => {
  var e2;
  return { ue: (e2 = b(t2(n2, s)).O) !== null && e2 !== void 0 ? e2 : i.color };
} }, _zi = class _zi {
  constructor(t2) {
    this.Uh = (t3, i) => i !== void 0 ? i.Vt : this.Wr.In().qh(t3), this.Wr = t2, this.Yh = Ii[t2.Xh()];
  }
  Hs(t2, i) {
    return this.Yh(this.Uh, this.Wr.W(), t2, i);
  }
};
__name(_zi, "zi");
let zi = _zi;
var Ei;
(function(t2) {
  t2[t2.NearestLeft = -1] = "NearestLeft", t2[t2.None = 0] = "None", t2[t2.NearestRight = 1] = "NearestRight";
})(Ei || (Ei = {}));
const Li = 30, _Ni = class _Ni {
  constructor() {
    this.Kh = [], this.Zh = /* @__PURE__ */ new Map(), this.Gh = /* @__PURE__ */ new Map();
  }
  Jh() {
    return this.Ks() > 0 ? this.Kh[this.Kh.length - 1] : null;
  }
  Qh() {
    return this.Ks() > 0 ? this.tl(0) : null;
  }
  Bn() {
    return this.Ks() > 0 ? this.tl(this.Kh.length - 1) : null;
  }
  Ks() {
    return this.Kh.length;
  }
  Fi() {
    return this.Ks() === 0;
  }
  Kr(t2) {
    return this.il(t2, 0) !== null;
  }
  qh(t2) {
    return this.nl(t2);
  }
  nl(t2, i = 0) {
    const n2 = this.il(t2, i);
    return n2 === null ? null : Object.assign(Object.assign({}, this.sl(n2)), { se: this.tl(n2) });
  }
  ie() {
    return this.Kh;
  }
  el(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    for (const e2 of n2)
      s = Fi(s, this.rl(t2, i, e2));
    return s;
  }
  it(t2) {
    this.Gh.clear(), this.Zh.clear(), this.Kh = t2;
  }
  tl(t2) {
    return this.Kh[t2].se;
  }
  sl(t2) {
    return this.Kh[t2];
  }
  il(t2, i) {
    const n2 = this.hl(t2);
    if (n2 === null && i !== 0)
      switch (i) {
        case -1:
          return this.ll(t2);
        case 1:
          return this.al(t2);
        default:
          throw new TypeError("Unknown search mode");
      }
    return n2;
  }
  ll(t2) {
    let i = this.ol(t2);
    return i > 0 && (i -= 1), i !== this.Kh.length && this.tl(i) < t2 ? i : null;
  }
  al(t2) {
    const i = this._l(t2);
    return i !== this.Kh.length && t2 < this.tl(i) ? i : null;
  }
  hl(t2) {
    const i = this.ol(t2);
    return i === this.Kh.length || t2 < this.Kh[i].se ? null : i;
  }
  ol(t2) {
    return Bt$1(this.Kh, t2, (t3, i) => t3.se < i);
  }
  _l(t2) {
    return It$1(this.Kh, t2, (t3, i) => t3.se > i);
  }
  ul(t2, i, n2) {
    let s = null;
    for (let e2 = t2; e2 < i; e2++) {
      const t3 = this.Kh[e2].Vt[n2];
      Number.isNaN(t3) || (s === null ? s = { cl: t3, dl: t3 } : (t3 < s.cl && (s.cl = t3), t3 > s.dl && (s.dl = t3)));
    }
    return s;
  }
  rl(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    const e2 = b(this.Qh()), r2 = b(this.Bn()), h2 = Math.max(t2, e2), l2 = Math.min(i, r2), a2 = Math.ceil(h2 / Li) * Li, o2 = Math.max(a2, Math.floor(l2 / Li) * Li);
    {
      const t3 = this.ol(h2), e3 = this._l(Math.min(l2, a2, i));
      s = Fi(s, this.ul(t3, e3, n2));
    }
    let _24 = this.Zh.get(n2);
    _24 === void 0 && (_24 = /* @__PURE__ */ new Map(), this.Zh.set(n2, _24));
    for (let t3 = Math.max(a2 + 1, h2); t3 < o2; t3 += Li) {
      const i2 = Math.floor(t3 / Li);
      let e3 = _24.get(i2);
      if (e3 === void 0) {
        const t4 = this.ol(i2 * Li), s2 = this._l((i2 + 1) * Li - 1);
        e3 = this.ul(t4, s2, n2), _24.set(i2, e3);
      }
      s = Fi(s, e3);
    }
    {
      const t3 = this.ol(o2), i2 = this._l(l2);
      s = Fi(s, this.ul(t3, i2, n2));
    }
    return s;
  }
};
__name(_Ni, "Ni");
let Ni = _Ni;
function Fi(t2, i) {
  return t2 === null ? i : i === null ? t2 : { cl: Math.min(t2.cl, i.cl), dl: Math.max(t2.dl, i.dl) };
}
__name(Fi, "Fi");
const _Wi = class _Wi {
  constructor(t2) {
    this.fl = t2;
  }
  K(t2, i, n2) {
    this.fl.draw(t2);
  }
  G(t2, i, n2) {
    var s, e2;
    (e2 = (s = this.fl).drawBackground) === null || e2 === void 0 || e2.call(s, t2);
  }
};
__name(_Wi, "Wi");
let Wi = _Wi;
const _ji = class _ji {
  constructor(t2) {
    this.Qe = null, this.wn = t2;
  }
  xt() {
    var t2;
    const i = this.wn.renderer();
    if (i === null)
      return null;
    if (((t2 = this.Qe) === null || t2 === void 0 ? void 0 : t2.vl) === i)
      return this.Qe.pl;
    const n2 = new Wi(i);
    return this.Qe = { vl: i, pl: n2 }, n2;
  }
  ml() {
    var t2, i, n2;
    return (n2 = (i = (t2 = this.wn).zOrder) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : "normal";
  }
};
__name(_ji, "ji");
let ji = _ji;
function Hi(t2) {
  var i, n2, s, e2, r2;
  return { Jt: t2.text(), yi: t2.coordinate(), ki: (i = t2.fixedCoordinate) === null || i === void 0 ? void 0 : i.call(t2), O: t2.textColor(), t: t2.backColor(), Tt: (s = (n2 = t2.visible) === null || n2 === void 0 ? void 0 : n2.call(t2)) === null || s === void 0 || s, ai: (r2 = (e2 = t2.tickVisible) === null || e2 === void 0 ? void 0 : e2.call(t2)) === null || r2 === void 0 || r2 };
}
__name(Hi, "Hi");
const _$i = class _$i {
  constructor(t2, i) {
    this.Ht = new ht$1(), this.bl = t2, this.wl = i;
  }
  xt() {
    return this.Ht.it(Object.assign({ $i: this.wl.$i() }, Hi(this.bl))), this.Ht;
  }
};
__name(_$i, "$i");
let $i = _$i;
const _Ui = class _Ui extends st {
  constructor(t2, i) {
    super(), this.bl = t2, this.Li = i;
  }
  Ei(t2, i, n2) {
    const s = Hi(this.bl);
    n2.t = s.t, t2.O = s.O;
    const e2 = 2 / 12 * this.Li.P();
    n2.gi = e2, n2.Mi = e2, n2.yi = s.yi, n2.ki = s.ki, t2.Jt = s.Jt, t2.Tt = s.Tt, t2.ai = s.ai;
  }
};
__name(_Ui, "Ui");
let Ui = _Ui;
const _qi = class _qi {
  constructor(t2, i) {
    this.gl = null, this.Ml = null, this.xl = null, this.Sl = null, this.kl = null, this.yl = t2, this.Wr = i;
  }
  Cl() {
    return this.yl;
  }
  On() {
    var t2, i;
    (i = (t2 = this.yl).updateAllViews) === null || i === void 0 || i.call(t2);
  }
  Pn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).paneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.gl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.gl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.gl = { vl: e2, pl: r2 }, r2;
  }
  tn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).timeAxisViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.Ml) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.Ml.pl;
    const r2 = this.Wr.qt().yt(), h2 = e2.map((t3) => new $i(t3, r2));
    return this.Ml = { vl: e2, pl: h2 }, h2;
  }
  Rn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).priceAxisViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.xl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.xl.pl;
    const r2 = this.Wr.At(), h2 = e2.map((t3) => new Ui(t3, r2));
    return this.xl = { vl: e2, pl: h2 }, h2;
  }
  Tl() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).priceAxisPaneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.Sl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.Sl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.Sl = { vl: e2, pl: r2 }, r2;
  }
  Pl() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).timeAxisPaneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.kl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.kl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.kl = { vl: e2, pl: r2 }, r2;
  }
  Rl(t2, i) {
    var n2, s, e2;
    return (e2 = (s = (n2 = this.yl).autoscaleInfo) === null || s === void 0 ? void 0 : s.call(n2, t2, i)) !== null && e2 !== void 0 ? e2 : null;
  }
  br(t2, i) {
    var n2, s, e2;
    return (e2 = (s = (n2 = this.yl).hitTest) === null || s === void 0 ? void 0 : s.call(n2, t2, i)) !== null && e2 !== void 0 ? e2 : null;
  }
};
__name(_qi, "qi");
let qi = _qi;
function Yi(t2, i, n2, s) {
  t2.forEach((t3) => {
    i(t3).forEach((t4) => {
      t4.ml() === n2 && s.push(t4);
    });
  });
}
__name(Yi, "Yi");
function Xi(t2) {
  return t2.Pn();
}
__name(Xi, "Xi");
function Ki(t2) {
  return t2.Tl();
}
__name(Ki, "Ki");
function Zi(t2) {
  return t2.Pl();
}
__name(Zi, "Zi");
const _Gi = class _Gi extends Bi {
  constructor(t2, i, n2, s, e2) {
    super(t2), this.Lt = new Ni(), this.Eh = new Ci(this), this.Dl = [], this.Ol = new ai(this), this.Al = null, this.Vl = null, this.Bl = [], this.Il = [], this.zl = null, this.El = [], this.cn = i, this.Ll = n2;
    const r2 = new Ti(this);
    this.hn = [r2], this.Lh = new ri(r2, this, t2), n2 !== "Area" && n2 !== "Line" && n2 !== "Baseline" || (this.Al = new di(this)), this.Nl(), this.Fl(e2);
  }
  S() {
    this.zl !== null && clearTimeout(this.zl);
  }
  _h(t2) {
    return this.cn.priceLineColor || t2;
  }
  Yr(t2) {
    const i = { Xr: !0 }, n2 = this.At();
    if (this.qt().yt().Fi() || n2.Fi() || this.Lt.Fi())
      return i;
    const s = this.qt().yt().Xs(), e2 = this.Pt();
    if (s === null || e2 === null)
      return i;
    let r2, h2;
    if (t2) {
      const t3 = this.Lt.Jh();
      if (t3 === null)
        return i;
      r2 = t3, h2 = t3.se;
    } else {
      const t3 = this.Lt.nl(s.di(), -1);
      if (t3 === null || (r2 = this.Lt.qh(t3.se), r2 === null))
        return i;
      h2 = t3.se;
    }
    const l2 = r2.Vt[3], a2 = this.$s().Hs(h2, { Vt: r2 }), o2 = n2.Ot(l2, e2.Vt);
    return { Xr: !1, ct: l2, Jt: n2.Wi(l2, e2.Vt), mh: n2.Wl(l2), bh: n2.jl(l2, e2.Vt), O: a2.ue, yi: o2, se: h2 };
  }
  $s() {
    return this.Vl !== null || (this.Vl = new zi(this)), this.Vl;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    const i = t2.priceScaleId;
    i !== void 0 && i !== this.cn.priceScaleId && this.qt().Hl(this, i), D$1(this.cn, t2), t2.priceFormat !== void 0 && (this.Nl(), this.qt().$l()), this.qt().Ul(this), this.qt().ql(), this.wn.gt("options");
  }
  it(t2, i) {
    this.Lt.it(t2), this.Yl(), this.wn.gt("data"), this.dn.gt("data"), this.Al !== null && (i && i.Xl ? this.Al.Hr() : t2.length === 0 && this.Al.jr());
    const n2 = this.qt().cr(this);
    this.qt().Kl(n2), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Zl(t2) {
    this.Bl = t2, this.Yl();
    const i = this.qt().cr(this);
    this.dn.gt("data"), this.qt().Kl(i), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Gl() {
    return this.Bl;
  }
  ah() {
    return this.Il;
  }
  Jl(t2) {
    const i = new Vi(this, t2);
    return this.Dl.push(i), this.qt().Ul(this), i;
  }
  Ql(t2) {
    const i = this.Dl.indexOf(t2);
    i !== -1 && this.Dl.splice(i, 1), this.qt().Ul(this);
  }
  Xh() {
    return this.Ll;
  }
  Pt() {
    const t2 = this.ta();
    return t2 === null ? null : { Vt: t2.Vt[3], ia: t2.ut };
  }
  ta() {
    const t2 = this.qt().yt().Xs();
    if (t2 === null)
      return null;
    const i = t2.Os();
    return this.Lt.nl(i, 1);
  }
  In() {
    return this.Lt;
  }
  oh(t2) {
    const i = this.Lt.qh(t2);
    return i === null ? null : this.Ll === "Bar" || this.Ll === "Candlestick" || this.Ll === "Custom" ? { we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3] } : i.Vt[3];
  }
  na(t2) {
    const i = [];
    Yi(this.El, Xi, "top", i);
    const n2 = this.Al;
    return n2 !== null && n2.Tt() && (this.zl === null && n2.Ur() && (this.zl = setTimeout(() => {
      this.zl = null, this.qt().sa();
    }, 0)), n2.$r(), i.push(n2)), i;
  }
  Pn() {
    const t2 = [];
    this.ea() || t2.push(this.Ol), t2.push(this.wn, this.Eh, this.dn);
    const i = this.Dl.map((t3) => t3.Wh());
    return t2.push(...i), Yi(this.El, Xi, "normal", t2), t2;
  }
  ra() {
    return this.ha(Xi, "bottom");
  }
  la(t2) {
    return this.ha(Ki, t2);
  }
  aa(t2) {
    return this.ha(Zi, t2);
  }
  oa(t2, i) {
    return this.El.map((n2) => n2.br(t2, i)).filter((t3) => t3 !== null);
  }
  Qi(t2) {
    return [this.Lh, ...this.Dl.map((t3) => t3.jh())];
  }
  Rn(t2, i) {
    if (i !== this.Xi && !this.ea())
      return [];
    const n2 = [...this.hn];
    for (const t3 of this.Dl)
      n2.push(t3.Hh());
    return this.El.forEach((t3) => {
      n2.push(...t3.Rn());
    }), n2;
  }
  tn() {
    const t2 = [];
    return this.El.forEach((i) => {
      t2.push(...i.tn());
    }), t2;
  }
  Rl(t2, i) {
    if (this.cn.autoscaleInfoProvider !== void 0) {
      const n2 = this.cn.autoscaleInfoProvider(() => {
        const n3 = this._a(t2, i);
        return n3 === null ? null : n3.Ph();
      });
      return Di.Rh(n2);
    }
    return this._a(t2, i);
  }
  ua() {
    return this.cn.priceFormat.minMove;
  }
  ca() {
    return this.da;
  }
  On() {
    var t2;
    this.wn.gt(), this.dn.gt();
    for (const t3 of this.hn)
      t3.gt();
    for (const t3 of this.Dl)
      t3.gt();
    this.Eh.gt(), this.Ol.gt(), (t2 = this.Al) === null || t2 === void 0 || t2.gt(), this.El.forEach((t3) => t3.On());
  }
  At() {
    return b(super.At());
  }
  Ct(t2) {
    if (!((this.Ll === "Line" || this.Ll === "Area" || this.Ll === "Baseline") && this.cn.crosshairMarkerVisible))
      return null;
    const i = this.Lt.qh(t2);
    return i === null ? null : { ct: i.Vt[3], ot: this.fa(), Bt: this.va(), Dt: this.pa(), Rt: this.ma(t2) };
  }
  uh() {
    return this.cn.title;
  }
  Tt() {
    return this.cn.visible;
  }
  ba(t2) {
    this.El.push(new qi(t2, this));
  }
  wa(t2) {
    this.El = this.El.filter((i) => i.Cl() !== t2);
  }
  ga() {
    if (this.wn instanceof Gt$1)
      return (t2) => this.wn.Fe(t2);
  }
  Ma() {
    if (this.wn instanceof Gt$1)
      return (t2) => this.wn.We(t2);
  }
  ea() {
    return !ut$1(this.At().xa());
  }
  _a(t2, i) {
    if (!A$1(t2) || !A$1(i) || this.Lt.Fi())
      return null;
    const n2 = this.Ll === "Line" || this.Ll === "Area" || this.Ll === "Baseline" || this.Ll === "Histogram" ? [3] : [2, 1], s = this.Lt.el(t2, i, n2);
    let e2 = s !== null ? new Ri(s.cl, s.dl) : null;
    if (this.Xh() === "Histogram") {
      const t3 = this.cn.base, i2 = new Ri(t3, t3);
      e2 = e2 !== null ? e2.ts(i2) : i2;
    }
    let r2 = this.dn.lh();
    return this.El.forEach((n3) => {
      const s2 = n3.Rl(t2, i);
      if (s2 != null && s2.priceRange) {
        const t3 = new Ri(s2.priceRange.minValue, s2.priceRange.maxValue);
        e2 = e2 !== null ? e2.ts(t3) : t3;
      }
      var h2, l2, a2, o2;
      s2 != null && s2.margins && (h2 = r2, l2 = s2.margins, r2 = { above: Math.max((a2 = h2 == null ? void 0 : h2.above) !== null && a2 !== void 0 ? a2 : 0, l2.above), below: Math.max((o2 = h2 == null ? void 0 : h2.below) !== null && o2 !== void 0 ? o2 : 0, l2.below) });
    }), new Di(e2, r2);
  }
  fa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerRadius;
    }
    return 0;
  }
  va() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t2 = this.cn.crosshairMarkerBorderColor;
        if (t2.length !== 0)
          return t2;
      }
    }
    return null;
  }
  pa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerBorderWidth;
    }
    return 0;
  }
  ma(t2) {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t3 = this.cn.crosshairMarkerBackgroundColor;
        if (t3.length !== 0)
          return t3;
      }
    }
    return this.$s().Hs(t2).ue;
  }
  Nl() {
    switch (this.cn.priceFormat.type) {
      case "custom":
        this.da = { format: this.cn.priceFormat.formatter };
        break;
      case "volume":
        this.da = new mt$1(this.cn.priceFormat.precision);
        break;
      case "percent":
        this.da = new pt$1(this.cn.priceFormat.precision);
        break;
      default: {
        const t2 = Math.pow(10, this.cn.priceFormat.precision);
        this.da = new vt$1(t2, this.cn.priceFormat.minMove * t2);
      }
    }
    this.Xi !== null && this.Xi.Sa();
  }
  Yl() {
    const t2 = this.qt().yt();
    if (!t2.ka() || this.Lt.Fi())
      return void (this.Il = []);
    const i = b(this.Lt.Qh());
    this.Il = this.Bl.map((n2, s) => {
      const e2 = b(t2.ya(n2.time, !0)), r2 = e2 < i ? 1 : -1;
      return { time: b(this.Lt.nl(e2, r2)).se, position: n2.position, shape: n2.shape, color: n2.color, id: n2.id, Jr: s, text: n2.text, size: n2.size, originalTime: n2.originalTime };
    });
  }
  Fl(t2) {
    switch (this.dn = new yi(this, this.qt()), this.Ll) {
      case "Bar":
        this.wn = new $t$1(this, this.qt());
        break;
      case "Candlestick":
        this.wn = new Kt$1(this, this.qt());
        break;
      case "Line":
        this.wn = new ii(this, this.qt());
        break;
      case "Custom":
        this.wn = new Gt$1(this, this.qt(), m$1(t2));
        break;
      case "Area":
        this.wn = new Wt$1(this, this.qt());
        break;
      case "Baseline":
        this.wn = new Yt$1(this, this.qt());
        break;
      case "Histogram":
        this.wn = new ti(this, this.qt());
        break;
      default:
        throw Error("Unknown chart style assigned: " + this.Ll);
    }
  }
  ha(t2, i) {
    const n2 = [];
    return Yi(this.El, t2, i, n2), n2;
  }
};
__name(_Gi, "Gi");
let Gi = _Gi;
const _Ji = class _Ji {
  constructor(t2) {
    this.cn = t2;
  }
  Ca(t2, i, n2) {
    let s = t2;
    if (this.cn.mode === 0)
      return s;
    const e2 = n2.vn(), r2 = e2.Pt();
    if (r2 === null)
      return s;
    const h2 = e2.Ot(t2, r2), l2 = n2.Ta().filter((t3) => t3 instanceof Gi).reduce((t3, s2) => {
      if (n2.dr(s2) || !s2.Tt())
        return t3;
      const e3 = s2.At(), r3 = s2.In();
      if (e3.Fi() || !r3.Kr(i))
        return t3;
      const h3 = r3.qh(i);
      if (h3 === null)
        return t3;
      const l3 = w$1(s2.Pt());
      return t3.concat([e3.Ot(h3.Vt[3], l3.Vt)]);
    }, []);
    if (l2.length === 0)
      return s;
    l2.sort((t3, i2) => Math.abs(t3 - h2) - Math.abs(i2 - h2));
    const a2 = l2[0];
    return s = e2.pn(a2, r2), s;
  }
};
__name(_Ji, "Ji");
let Ji = _Ji;
const _Qi = class _Qi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null)
      return;
    const e2 = Math.max(1, Math.floor(n2));
    t2.lineWidth = e2, function(t3, i2) {
      t3.save(), t3.lineWidth % 2 && t3.translate(0.5, 0.5), i2(), t3.restore();
    }(t2, () => {
      const r2 = b(this.Lt);
      if (r2.Pa) {
        t2.strokeStyle = r2.Ra, f(t2, r2.Da), t2.beginPath();
        for (const s2 of r2.Oa) {
          const r3 = Math.round(s2.Aa * n2);
          t2.moveTo(r3, -e2), t2.lineTo(r3, i.height + e2);
        }
        t2.stroke();
      }
      if (r2.Va) {
        t2.strokeStyle = r2.Ba, f(t2, r2.Ia), t2.beginPath();
        for (const n3 of r2.za) {
          const r3 = Math.round(n3.Aa * s);
          t2.moveTo(-e2, r3), t2.lineTo(i.width + e2, r3);
        }
        t2.stroke();
      }
    });
  }
};
__name(_Qi, "Qi");
let Qi = _Qi;
var _a30;
let tn$1 = (_a30 = class {
  constructor(t2) {
    this.Ht = new Qi(), this.bt = !0, this.nn = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    if (this.bt) {
      const t2 = this.nn.qt().W().grid, i = { Va: t2.horzLines.visible, Pa: t2.vertLines.visible, Ba: t2.horzLines.color, Ra: t2.vertLines.color, Ia: t2.horzLines.style, Da: t2.vertLines.style, za: this.nn.vn().Ea(), Oa: (this.nn.qt().yt().Ea() || []).map((t3) => ({ Aa: t3.coord })) };
      this.Ht.it(i), this.bt = !1;
    }
    return this.Ht;
  }
}, __name(_a30, "tn"), _a30);
var _a31;
let nn$1 = (_a31 = class {
  constructor(t2) {
    this.wn = new tn$1(t2);
  }
  Wh() {
    return this.wn;
  }
}, __name(_a31, "nn"), _a31);
const sn$1 = { La: 4, Na: 1e-4 };
function en$1(t2, i) {
  const n2 = 100 * (t2 - i) / i;
  return i < 0 ? -n2 : n2;
}
__name(en$1, "en$1");
function rn$1(t2, i) {
  const n2 = en$1(t2.Sh(), i), s = en$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(rn$1, "rn$1");
function hn$1(t2, i) {
  const n2 = 100 * (t2 - i) / i + 100;
  return i < 0 ? -n2 : n2;
}
__name(hn$1, "hn$1");
function ln$1(t2, i) {
  const n2 = hn$1(t2.Sh(), i), s = hn$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(ln$1, "ln$1");
function an$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.log10(n2 + i.Na) + i.La;
  return t2 < 0 ? -s : s;
}
__name(an$1, "an$1");
function on$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.pow(10, n2 - i.La) - i.Na;
  return t2 < 0 ? -s : s;
}
__name(on$1, "on$1");
function _n(t2, i) {
  if (t2 === null)
    return null;
  const n2 = an$1(t2.Sh(), i), s = an$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(_n, "_n");
function un$1(t2, i) {
  if (t2 === null)
    return null;
  const n2 = on$1(t2.Sh(), i), s = on$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(un$1, "un$1");
function cn$1(t2) {
  if (t2 === null)
    return sn$1;
  const i = Math.abs(t2.kh() - t2.Sh());
  if (i >= 1 || i < 1e-15)
    return sn$1;
  const n2 = Math.ceil(Math.abs(Math.log10(i))), s = sn$1.La + n2;
  return { La: s, Na: 1 / Math.pow(10, s) };
}
__name(cn$1, "cn$1");
var _a32;
let dn$1 = (_a32 = class {
  constructor(t2, i) {
    if (this.Fa = t2, this.Wa = i, function(t3) {
      if (t3 < 0)
        return !1;
      for (let i2 = t3; i2 > 1; i2 /= 10)
        if (i2 % 10 != 0)
          return !1;
      return !0;
    }(this.Fa))
      this.ja = [2, 2.5, 2];
    else {
      this.ja = [];
      for (let t3 = this.Fa; t3 !== 1; ) {
        if (t3 % 2 == 0)
          this.ja.push(2), t3 /= 2;
        else {
          if (t3 % 5 != 0)
            throw new Error("unexpected base");
          this.ja.push(2, 2.5), t3 /= 5;
        }
        if (this.ja.length > 100)
          throw new Error("something wrong with base");
      }
    }
  }
  Ha(t2, i, n2) {
    const s = this.Fa === 0 ? 0 : 1 / this.Fa;
    let e2 = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t2 - i)))), r2 = 0, h2 = this.Wa[0];
    for (; ; ) {
      const t3 = Ct$1(e2, s, 1e-14) && e2 > s + 1e-14, i2 = Ct$1(e2, n2 * h2, 1e-14), l3 = Ct$1(e2, 1, 1e-14);
      if (!(t3 && i2 && l3))
        break;
      e2 /= h2, h2 = this.Wa[++r2 % this.Wa.length];
    }
    if (e2 <= s + 1e-14 && (e2 = s), e2 = Math.max(1, e2), this.ja.length > 0 && (l2 = e2, a2 = 1, o2 = 1e-14, Math.abs(l2 - a2) < o2))
      for (r2 = 0, h2 = this.ja[0]; Ct$1(e2, n2 * h2, 1e-14) && e2 > s + 1e-14; )
        e2 /= h2, h2 = this.ja[++r2 % this.ja.length];
    var l2, a2, o2;
    return e2;
  }
}, __name(_a32, "dn"), _a32);
var _a33;
let fn$1 = (_a33 = class {
  constructor(t2, i, n2, s) {
    this.$a = [], this.Li = t2, this.Fa = i, this.Ua = n2, this.qa = s;
  }
  Ha(t2, i) {
    if (t2 < i)
      throw new Error("high < low");
    const n2 = this.Li.zt(), s = (t2 - i) * this.Ya() / n2, e2 = new dn$1(this.Fa, [2, 2.5, 2]), r2 = new dn$1(this.Fa, [2, 2, 2.5]), h2 = new dn$1(this.Fa, [2.5, 2, 2]), l2 = [];
    return l2.push(e2.Ha(t2, i, s), r2.Ha(t2, i, s), h2.Ha(t2, i, s)), function(t3) {
      if (t3.length < 1)
        throw Error("array is empty");
      let i2 = t3[0];
      for (let n3 = 1; n3 < t3.length; ++n3)
        t3[n3] < i2 && (i2 = t3[n3]);
      return i2;
    }(l2);
  }
  Xa() {
    const t2 = this.Li, i = t2.Pt();
    if (i === null)
      return void (this.$a = []);
    const n2 = t2.zt(), s = this.Ua(n2 - 1, i), e2 = this.Ua(0, i), r2 = this.Li.W().entireTextOnly ? this.Ka() / 2 : 0, h2 = r2, l2 = n2 - 1 - r2, a2 = Math.max(s, e2), o2 = Math.min(s, e2);
    if (a2 === o2)
      return void (this.$a = []);
    let _24 = this.Ha(a2, o2), u2 = a2 % _24;
    u2 += u2 < 0 ? _24 : 0;
    const c2 = a2 >= o2 ? 1 : -1;
    let d2 = null, f2 = 0;
    for (let n3 = a2 - u2; n3 > o2; n3 -= _24) {
      const s2 = this.qa(n3, i, !0);
      d2 !== null && Math.abs(s2 - d2) < this.Ya() || s2 < h2 || s2 > l2 || (f2 < this.$a.length ? (this.$a[f2].Aa = s2, this.$a[f2].Za = t2.Ga(n3)) : this.$a.push({ Aa: s2, Za: t2.Ga(n3) }), f2++, d2 = s2, t2.Ja() && (_24 = this.Ha(n3 * c2, o2)));
    }
    this.$a.length = f2;
  }
  Ea() {
    return this.$a;
  }
  Ka() {
    return this.Li.P();
  }
  Ya() {
    return Math.ceil(2.5 * this.Ka());
  }
}, __name(_a33, "fn"), _a33);
function vn(t2) {
  return t2.slice().sort((t3, i) => b(t3.Zi()) - b(i.Zi()));
}
__name(vn, "vn");
var pn$1;
(function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Logarithmic = 1] = "Logarithmic", t2[t2.Percentage = 2] = "Percentage", t2[t2.IndexedTo100 = 3] = "IndexedTo100";
})(pn$1 || (pn$1 = {}));
const mn$1 = new pt$1(), bn = new vt$1(100, 1), _wn = class _wn {
  constructor(t2, i, n2, s) {
    this.Qa = 0, this.io = null, this.Dh = null, this.no = null, this.so = { eo: !1, ro: null }, this.ho = 0, this.lo = 0, this.ao = new R(), this.oo = new R(), this._o = [], this.uo = null, this.co = null, this.do = null, this.fo = null, this.da = bn, this.vo = cn$1(null), this.po = t2, this.cn = i, this.mo = n2, this.bo = s, this.wo = new fn$1(this, 100, this.Mo.bind(this), this.xo.bind(this));
  }
  xa() {
    return this.po;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    if (D$1(this.cn, t2), this.Sa(), t2.mode !== void 0 && this.So({ yr: t2.mode }), t2.scaleMargins !== void 0) {
      const i = m$1(t2.scaleMargins.top), n2 = m$1(t2.scaleMargins.bottom);
      if (i < 0 || i > 1)
        throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i}`);
      if (n2 < 0 || n2 > 1 || i + n2 > 1)
        throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n2}`);
      if (i + n2 > 1)
        throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i + n2}`);
      this.ko(), this.co = null;
    }
  }
  yo() {
    return this.cn.autoScale;
  }
  Ja() {
    return this.cn.mode === 1;
  }
  ph() {
    return this.cn.mode === 2;
  }
  Co() {
    return this.cn.mode === 3;
  }
  yr() {
    return { Wn: this.cn.autoScale, To: this.cn.invertScale, yr: this.cn.mode };
  }
  So(t2) {
    const i = this.yr();
    let n2 = null;
    t2.Wn !== void 0 && (this.cn.autoScale = t2.Wn), t2.yr !== void 0 && (this.cn.mode = t2.yr, t2.yr !== 2 && t2.yr !== 3 || (this.cn.autoScale = !0), this.so.eo = !1), i.yr === 1 && t2.yr !== i.yr && (function(t3, i2) {
      if (t3 === null)
        return !1;
      const n3 = on$1(t3.Sh(), i2), s2 = on$1(t3.kh(), i2);
      return isFinite(n3) && isFinite(s2);
    }(this.Dh, this.vo) ? (n2 = un$1(this.Dh, this.vo), n2 !== null && this.Po(n2)) : this.cn.autoScale = !0), t2.yr === 1 && t2.yr !== i.yr && (n2 = _n(this.Dh, this.vo), n2 !== null && this.Po(n2));
    const s = i.yr !== this.cn.mode;
    s && (i.yr === 2 || this.ph()) && this.Sa(), s && (i.yr === 3 || this.Co()) && this.Sa(), t2.To !== void 0 && i.To !== t2.To && (this.cn.invertScale = t2.To, this.Ro()), this.oo.m(i, this.yr());
  }
  Do() {
    return this.oo;
  }
  P() {
    return this.mo.fontSize;
  }
  zt() {
    return this.Qa;
  }
  Oo(t2) {
    this.Qa !== t2 && (this.Qa = t2, this.ko(), this.co = null);
  }
  Ao() {
    if (this.io)
      return this.io;
    const t2 = this.zt() - this.Vo() - this.Bo();
    return this.io = t2, t2;
  }
  Ah() {
    return this.Io(), this.Dh;
  }
  Po(t2, i) {
    const n2 = this.Dh;
    (i || n2 === null && t2 !== null || n2 !== null && !n2.Mh(t2)) && (this.co = null, this.Dh = t2);
  }
  Fi() {
    return this.Io(), this.Qa === 0 || !this.Dh || this.Dh.Fi();
  }
  zo(t2) {
    return this.To() ? t2 : this.zt() - 1 - t2;
  }
  Ot(t2, i) {
    return this.ph() ? t2 = en$1(t2, i) : this.Co() && (t2 = hn$1(t2, i)), this.xo(t2, i);
  }
  Qs(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e2 = b(this.Ah()), r2 = e2.Sh(), h2 = e2.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = n2 === void 0 ? 0 : n2.from, u2 = n2 === void 0 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e3 = t2[n3], h3 = e3.ct;
      if (isNaN(h3))
        continue;
      let l3 = h3;
      c2 !== null && (l3 = c2(e3.ct, i));
      const _25 = s + o2 * (l3 - r2), u3 = a2 ? _25 : this.Qa - 1 - _25;
      e3.rt = u3;
    }
  }
  me(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e2 = b(this.Ah()), r2 = e2.Sh(), h2 = e2.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = n2 === void 0 ? 0 : n2.from, u2 = n2 === void 0 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e3 = t2[n3];
      let h3 = e3.we, l3 = e3.ge, _25 = e3.Me, u3 = e3.xe;
      c2 !== null && (h3 = c2(e3.we, i), l3 = c2(e3.ge, i), _25 = c2(e3.Me, i), u3 = c2(e3.xe, i));
      let d2 = s + o2 * (h3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2;
      e3.ve = f2, d2 = s + o2 * (l3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.ce = f2, d2 = s + o2 * (_25 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.de = f2, d2 = s + o2 * (u3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.pe = f2;
    }
  }
  pn(t2, i) {
    const n2 = this.Mo(t2, i);
    return this.Lo(n2, i);
  }
  Lo(t2, i) {
    let n2 = t2;
    return this.ph() ? n2 = function(t3, i2) {
      return i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i) : this.Co() && (n2 = function(t3, i2) {
      return t3 -= 100, i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i)), n2;
  }
  Ta() {
    return this._o;
  }
  No() {
    if (this.uo)
      return this.uo;
    let t2 = [];
    for (let i = 0; i < this._o.length; i++) {
      const n2 = this._o[i];
      n2.Zi() === null && n2.Gi(i + 1), t2.push(n2);
    }
    return t2 = vn(t2), this.uo = t2, this.uo;
  }
  Fo(t2) {
    this._o.indexOf(t2) === -1 && (this._o.push(t2), this.Sa(), this.Wo());
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    if (i === -1)
      throw new Error("source is not attached to scale");
    this._o.splice(i, 1), this._o.length === 0 && (this.So({ Wn: !0 }), this.Po(null)), this.Sa(), this.Wo();
  }
  Pt() {
    let t2 = null;
    for (const i of this._o) {
      const n2 = i.Pt();
      n2 !== null && (t2 === null || n2.ia < t2.ia) && (t2 = n2);
    }
    return t2 === null ? null : t2.Vt;
  }
  To() {
    return this.cn.invertScale;
  }
  Ea() {
    const t2 = this.Pt() === null;
    if (this.co !== null && (t2 || this.co.Ho === t2))
      return this.co.Ea;
    this.wo.Xa();
    const i = this.wo.Ea();
    return this.co = { Ea: i, Ho: t2 }, this.ao.m(), i;
  }
  $o() {
    return this.ao;
  }
  Uo(t2) {
    this.ph() || this.Co() || this.do === null && this.no === null && (this.Fi() || (this.do = this.Qa - t2, this.no = b(this.Ah()).xh()));
  }
  qo(t2) {
    if (this.ph() || this.Co() || this.do === null)
      return;
    this.So({ Wn: !1 }), (t2 = this.Qa - t2) < 0 && (t2 = 0);
    let i = (this.do + 0.2 * (this.Qa - 1)) / (t2 + 0.2 * (this.Qa - 1));
    const n2 = b(this.no).xh();
    i = Math.max(i, 0.1), n2.Ch(i), this.Po(n2);
  }
  Yo() {
    this.ph() || this.Co() || (this.do = null, this.no = null);
  }
  Xo(t2) {
    this.yo() || this.fo === null && this.no === null && (this.Fi() || (this.fo = t2, this.no = b(this.Ah()).xh()));
  }
  Ko(t2) {
    if (this.yo() || this.fo === null)
      return;
    const i = b(this.Ah()).yh() / (this.Ao() - 1);
    let n2 = t2 - this.fo;
    this.To() && (n2 *= -1);
    const s = n2 * i, e2 = b(this.no).xh();
    e2.Th(s), this.Po(e2, !0), this.co = null;
  }
  Zo() {
    this.yo() || this.fo !== null && (this.fo = null, this.no = null);
  }
  ca() {
    return this.da || this.Sa(), this.da;
  }
  Wi(t2, i) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(en$1(t2, i));
      case 3:
        return this.ca().format(hn$1(t2, i));
      default:
        return this.zh(t2);
    }
  }
  Ga(t2) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(t2);
      case 3:
        return this.ca().format(t2);
      default:
        return this.zh(t2);
    }
  }
  Wl(t2) {
    return this.zh(t2, b(this.Jo()).ca());
  }
  jl(t2, i) {
    return t2 = en$1(t2, i), this.Go(t2, mn$1);
  }
  Qo() {
    return this._o;
  }
  t_(t2) {
    this.so = { ro: t2, eo: !1 };
  }
  On() {
    this._o.forEach((t2) => t2.On());
  }
  Sa() {
    this.co = null;
    const t2 = this.Jo();
    let i = 100;
    t2 !== null && (i = Math.round(1 / t2.ua())), this.da = bn, this.ph() ? (this.da = mn$1, i = 100) : this.Co() ? (this.da = new vt$1(100, 1), i = 100) : t2 !== null && (this.da = t2.ca()), this.wo = new fn$1(this, i, this.Mo.bind(this), this.xo.bind(this)), this.wo.Xa();
  }
  Wo() {
    this.uo = null;
  }
  Jo() {
    return this._o[0] || null;
  }
  Vo() {
    return this.To() ? this.cn.scaleMargins.bottom * this.zt() + this.lo : this.cn.scaleMargins.top * this.zt() + this.ho;
  }
  Bo() {
    return this.To() ? this.cn.scaleMargins.top * this.zt() + this.ho : this.cn.scaleMargins.bottom * this.zt() + this.lo;
  }
  Io() {
    this.so.eo || (this.so.eo = !0, this.i_());
  }
  ko() {
    this.io = null;
  }
  xo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    t2 = this.Ja() && t2 ? an$1(t2, this.vo) : t2;
    const n2 = b(this.Ah()), s = this.Bo() + (this.Ao() - 1) * (t2 - n2.Sh()) / n2.yh();
    return this.zo(s);
  }
  Mo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    const n2 = this.zo(t2), s = b(this.Ah()), e2 = s.Sh() + s.yh() * ((n2 - this.Bo()) / (this.Ao() - 1));
    return this.Ja() ? on$1(e2, this.vo) : e2;
  }
  Ro() {
    this.co = null, this.wo.Xa();
  }
  i_() {
    const t2 = this.so.ro;
    if (t2 === null)
      return;
    let i = null;
    const n2 = this.Qo();
    let s = 0, e2 = 0;
    for (const r3 of n2) {
      if (!r3.Tt())
        continue;
      const n3 = r3.Pt();
      if (n3 === null)
        continue;
      const h3 = r3.Rl(t2.Os(), t2.di());
      let l2 = h3 && h3.Ah();
      if (l2 !== null) {
        switch (this.cn.mode) {
          case 1:
            l2 = _n(l2, this.vo);
            break;
          case 2:
            l2 = rn$1(l2, n3.Vt);
            break;
          case 3:
            l2 = ln$1(l2, n3.Vt);
        }
        if (i = i === null ? l2 : i.ts(b(l2)), h3 !== null) {
          const t3 = h3.Vh();
          t3 !== null && (s = Math.max(s, t3.above), e2 = Math.max(s, t3.below));
        }
      }
    }
    if (s === this.ho && e2 === this.lo || (this.ho = s, this.lo = e2, this.co = null, this.ko()), i !== null) {
      if (i.Sh() === i.kh()) {
        const t3 = this.Jo(), n3 = 5 * (t3 === null || this.ph() || this.Co() ? 1 : t3.ua());
        this.Ja() && (i = un$1(i, this.vo)), i = new Ri(i.Sh() - n3, i.kh() + n3), this.Ja() && (i = _n(i, this.vo));
      }
      if (this.Ja()) {
        const t3 = un$1(i, this.vo), n3 = cn$1(t3);
        if (r2 = n3, h2 = this.vo, r2.La !== h2.La || r2.Na !== h2.Na) {
          const s2 = this.no !== null ? un$1(this.no, this.vo) : null;
          this.vo = n3, i = _n(t3, n3), s2 !== null && (this.no = _n(s2, n3));
        }
      }
      this.Po(i);
    } else
      this.Dh === null && (this.Po(new Ri(-0.5, 0.5)), this.vo = cn$1(null));
    var r2, h2;
    this.so.eo = !0;
  }
  Eo() {
    return this.ph() ? en$1 : this.Co() ? hn$1 : this.Ja() ? (t2) => an$1(t2, this.vo) : null;
  }
  n_(t2, i, n2) {
    return i === void 0 ? (n2 === void 0 && (n2 = this.ca()), n2.format(t2)) : i(t2);
  }
  zh(t2, i) {
    return this.n_(t2, this.bo.priceFormatter, i);
  }
  Go(t2, i) {
    return this.n_(t2, this.bo.percentageFormatter, i);
  }
};
__name(_wn, "wn");
let wn = _wn;
var _a34;
let gn$1 = (_a34 = class {
  constructor(t2, i) {
    this._o = [], this.s_ = /* @__PURE__ */ new Map(), this.Qa = 0, this.e_ = 0, this.r_ = 1e3, this.uo = null, this.h_ = new R(), this.wl = t2, this.Ui = i, this.l_ = new nn$1(this);
    const n2 = i.W();
    this.a_ = this.o_("left", n2.leftPriceScale), this.__ = this.o_("right", n2.rightPriceScale), this.a_.Do().l(this.u_.bind(this, this.a_), this), this.__.Do().l(this.u_.bind(this, this.__), this), this.c_(n2);
  }
  c_(t2) {
    if (t2.leftPriceScale && this.a_.Nh(t2.leftPriceScale), t2.rightPriceScale && this.__.Nh(t2.rightPriceScale), t2.localization && (this.a_.Sa(), this.__.Sa()), t2.overlayPriceScales) {
      const i = Array.from(this.s_.values());
      for (const n2 of i) {
        const i2 = b(n2[0].At());
        i2.Nh(t2.overlayPriceScales), t2.localization && i2.Sa();
      }
    }
  }
  d_(t2) {
    switch (t2) {
      case "left":
        return this.a_;
      case "right":
        return this.__;
    }
    return this.s_.has(t2) ? m$1(this.s_.get(t2))[0].At() : null;
  }
  S() {
    this.qt().f_().p(this), this.a_.Do().p(this), this.__.Do().p(this), this._o.forEach((t2) => {
      t2.S && t2.S();
    }), this.h_.m();
  }
  v_() {
    return this.r_;
  }
  p_(t2) {
    this.r_ = t2;
  }
  qt() {
    return this.Ui;
  }
  $i() {
    return this.e_;
  }
  zt() {
    return this.Qa;
  }
  m_(t2) {
    this.e_ = t2, this.b_();
  }
  Oo(t2) {
    this.Qa = t2, this.a_.Oo(t2), this.__.Oo(t2), this._o.forEach((i) => {
      if (this.dr(i)) {
        const n2 = i.At();
        n2 !== null && n2.Oo(t2);
      }
    }), this.b_();
  }
  Ta() {
    return this._o;
  }
  dr(t2) {
    const i = t2.At();
    return i === null || this.a_ !== i && this.__ !== i;
  }
  Fo(t2, i, n2) {
    const s = n2 !== void 0 ? n2 : this.g_().w_ + 1;
    this.M_(t2, i, s);
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    p$1(i !== -1, "removeDataSource: invalid data source"), this._o.splice(i, 1);
    const n2 = b(t2.At()).xa();
    if (this.s_.has(n2)) {
      const i2 = m$1(this.s_.get(n2)), s2 = i2.indexOf(t2);
      s2 !== -1 && (i2.splice(s2, 1), i2.length === 0 && this.s_.delete(n2));
    }
    const s = t2.At();
    s && s.Ta().indexOf(t2) >= 0 && s.jo(t2), s !== null && (s.Wo(), this.x_(s)), this.uo = null;
  }
  pr(t2) {
    return t2 === this.a_ ? "left" : t2 === this.__ ? "right" : "overlay";
  }
  S_() {
    return this.a_;
  }
  k_() {
    return this.__;
  }
  y_(t2, i) {
    t2.Uo(i);
  }
  C_(t2, i) {
    t2.qo(i), this.b_();
  }
  T_(t2) {
    t2.Yo();
  }
  P_(t2, i) {
    t2.Xo(i);
  }
  R_(t2, i) {
    t2.Ko(i), this.b_();
  }
  D_(t2) {
    t2.Zo();
  }
  b_() {
    this._o.forEach((t2) => {
      t2.On();
    });
  }
  vn() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible && this.__.Ta().length !== 0 ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && this.a_.Ta().length !== 0 ? t2 = this.a_ : this._o.length !== 0 && (t2 = this._o[0].At()), t2 === null && (t2 = this.__), t2;
  }
  vr() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && (t2 = this.a_), t2;
  }
  x_(t2) {
    t2 !== null && t2.yo() && this.O_(t2);
  }
  A_(t2) {
    const i = this.wl.Xs();
    t2.So({ Wn: !0 }), i !== null && t2.t_(i), this.b_();
  }
  V_() {
    this.O_(this.a_), this.O_(this.__);
  }
  B_() {
    this.x_(this.a_), this.x_(this.__), this._o.forEach((t2) => {
      this.dr(t2) && this.x_(t2.At());
    }), this.b_(), this.Ui.Fh();
  }
  No() {
    return this.uo === null && (this.uo = vn(this._o)), this.uo;
  }
  I_() {
    return this.h_;
  }
  z_() {
    return this.l_;
  }
  O_(t2) {
    const i = t2.Qo();
    if (i && i.length > 0 && !this.wl.Fi()) {
      const i2 = this.wl.Xs();
      i2 !== null && t2.t_(i2);
    }
    t2.On();
  }
  g_() {
    const t2 = this.No();
    if (t2.length === 0)
      return { E_: 0, w_: 0 };
    let i = 0, n2 = 0;
    for (let s = 0; s < t2.length; s++) {
      const e2 = t2[s].Zi();
      e2 !== null && (e2 < i && (i = e2), e2 > n2 && (n2 = e2));
    }
    return { E_: i, w_: n2 };
  }
  M_(t2, i, n2) {
    let s = this.d_(i);
    if (s === null && (s = this.o_(i, this.Ui.W().overlayPriceScales)), this._o.push(t2), !ut$1(i)) {
      const n3 = this.s_.get(i) || [];
      n3.push(t2), this.s_.set(i, n3);
    }
    s.Fo(t2), t2.Ji(s), t2.Gi(n2), this.x_(s), this.uo = null;
  }
  u_(t2, i, n2) {
    i.yr !== n2.yr && this.O_(t2);
  }
  o_(t2, i) {
    const n2 = Object.assign({ visible: !0, autoScale: !0 }, I(i)), s = new wn(t2, n2, this.Ui.W().layout, this.Ui.W().localization);
    return s.Oo(this.zt()), s;
  }
}, __name(_a34, "gn"), _a34);
var _a35;
let Mn$1 = (_a35 = class {
  constructor(t2, i, n2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Qe = /* @__PURE__ */ new Map(), this.Je = /* @__PURE__ */ new Map(), this.L_ = t2, this.N_ = i, this.tr = n2;
  }
  F_(t2) {
    const i = t2.time, n2 = this.N_.cacheKey(i), s = this.Qe.get(n2);
    if (s !== void 0)
      return s.W_;
    if (this.Ke === this.tr) {
      const t3 = this.Je.get(this.Ge);
      this.Je.delete(this.Ge), this.Qe.delete(m$1(t3)), this.Ge++, this.Ke--;
    }
    const e2 = this.L_(t2);
    return this.Qe.set(n2, { W_: e2, er: this.Ze }), this.Je.set(this.Ze, n2), this.Ke++, this.Ze++, e2;
  }
}, __name(_a35, "Mn"), _a35);
var _a36;
let xn$1 = (_a36 = class {
  constructor(t2, i) {
    p$1(t2 <= i, "right should be >= left"), this.j_ = t2, this.H_ = i;
  }
  Os() {
    return this.j_;
  }
  di() {
    return this.H_;
  }
  U_() {
    return this.H_ - this.j_ + 1;
  }
  Kr(t2) {
    return this.j_ <= t2 && t2 <= this.H_;
  }
  Mh(t2) {
    return this.j_ === t2.Os() && this.H_ === t2.di();
  }
}, __name(_a36, "xn"), _a36);
function Sn(t2, i) {
  return t2 === null || i === null ? t2 === i : t2.Mh(i);
}
__name(Sn, "Sn");
var _a37;
let kn$1 = (_a37 = class {
  constructor() {
    this.q_ = /* @__PURE__ */ new Map(), this.Qe = null, this.Y_ = !1;
  }
  X_(t2) {
    this.Y_ = t2, this.Qe = null;
  }
  K_(t2, i) {
    this.Z_(i), this.Qe = null;
    for (let n2 = i; n2 < t2.length; ++n2) {
      const i2 = t2[n2];
      let s = this.q_.get(i2.timeWeight);
      s === void 0 && (s = [], this.q_.set(i2.timeWeight, s)), s.push({ index: n2, time: i2.time, weight: i2.timeWeight, originalTime: i2.originalTime });
    }
  }
  G_(t2, i) {
    const n2 = Math.ceil(i / t2);
    return this.Qe !== null && this.Qe.J_ === n2 || (this.Qe = { Ea: this.Q_(n2), J_: n2 }), this.Qe.Ea;
  }
  Z_(t2) {
    if (t2 === 0)
      return void this.q_.clear();
    const i = [];
    this.q_.forEach((n2, s) => {
      t2 <= n2[0].index ? i.push(s) : n2.splice(Bt$1(n2, t2, (i2) => i2.index < t2), 1 / 0);
    });
    for (const t3 of i)
      this.q_.delete(t3);
  }
  Q_(t2) {
    let i = [];
    for (const n2 of Array.from(this.q_.keys()).sort((t3, i2) => i2 - t3)) {
      if (!this.q_.get(n2))
        continue;
      const s = i;
      i = [];
      const e2 = s.length;
      let r2 = 0;
      const h2 = m$1(this.q_.get(n2)), l2 = h2.length;
      let a2 = 1 / 0, o2 = -1 / 0;
      for (let n3 = 0; n3 < l2; n3++) {
        const l3 = h2[n3], _24 = l3.index;
        for (; r2 < e2; ) {
          const t3 = s[r2], n4 = t3.index;
          if (!(n4 < _24)) {
            a2 = n4;
            break;
          }
          r2++, i.push(t3), o2 = n4, a2 = 1 / 0;
        }
        if (a2 - _24 >= t2 && _24 - o2 >= t2)
          i.push(l3), o2 = _24;
        else if (this.Y_)
          return s;
      }
      for (; r2 < e2; r2++)
        i.push(s[r2]);
    }
    return i;
  }
}, __name(_a37, "kn"), _a37);
var _a38;
let yn$1 = (_a38 = class {
  constructor(t2) {
    this.tu = t2;
  }
  iu() {
    return this.tu === null ? null : new xn$1(Math.floor(this.tu.Os()), Math.ceil(this.tu.di()));
  }
  nu() {
    return this.tu;
  }
  static su() {
    return new _a38(null);
  }
}, __name(_a38, "yn"), _a38);
function Cn(t2, i) {
  return t2.weight > i.weight ? t2 : i;
}
__name(Cn, "Cn");
const _Tn = class _Tn {
  constructor(t2, i, n2, s) {
    this.e_ = 0, this.eu = null, this.ru = [], this.fo = null, this.do = null, this.hu = new kn$1(), this.lu = /* @__PURE__ */ new Map(), this.au = yn$1.su(), this.ou = !0, this._u = new R(), this.uu = new R(), this.cu = new R(), this.du = null, this.fu = null, this.vu = [], this.cn = i, this.bo = n2, this.pu = i.rightOffset, this.mu = i.barSpacing, this.Ui = t2, this.N_ = s, this.bu(), this.hu.X_(i.uniformDistribution);
  }
  W() {
    return this.cn;
  }
  wu(t2) {
    D$1(this.bo, t2), this.gu(), this.bu();
  }
  Nh(t2, i) {
    var n2;
    D$1(this.cn, t2), this.cn.fixLeftEdge && this.Mu(), this.cn.fixRightEdge && this.xu(), t2.barSpacing !== void 0 && this.Ui.Gn(t2.barSpacing), t2.rightOffset !== void 0 && this.Ui.Jn(t2.rightOffset), t2.minBarSpacing !== void 0 && this.Ui.Gn((n2 = t2.barSpacing) !== null && n2 !== void 0 ? n2 : this.mu), this.gu(), this.bu(), this.cu.m();
  }
  mn(t2) {
    var i, n2;
    return (n2 = (i = this.ru[t2]) === null || i === void 0 ? void 0 : i.time) !== null && n2 !== void 0 ? n2 : null;
  }
  qi(t2) {
    var i;
    return (i = this.ru[t2]) !== null && i !== void 0 ? i : null;
  }
  ya(t2, i) {
    if (this.ru.length < 1)
      return null;
    if (this.N_.key(t2) > this.N_.key(this.ru[this.ru.length - 1].time))
      return i ? this.ru.length - 1 : null;
    const n2 = Bt$1(this.ru, this.N_.key(t2), (t3, i2) => this.N_.key(t3.time) < i2);
    return this.N_.key(t2) < this.N_.key(this.ru[n2].time) ? i ? n2 : null : n2;
  }
  Fi() {
    return this.e_ === 0 || this.ru.length === 0 || this.eu === null;
  }
  ka() {
    return this.ru.length > 0;
  }
  Xs() {
    return this.Su(), this.au.iu();
  }
  ku() {
    return this.Su(), this.au.nu();
  }
  yu() {
    const t2 = this.Xs();
    if (t2 === null)
      return null;
    const i = { from: t2.Os(), to: t2.di() };
    return this.Cu(i);
  }
  Cu(t2) {
    const i = Math.round(t2.from), n2 = Math.round(t2.to), s = b(this.Tu()), e2 = b(this.Pu());
    return { from: b(this.qi(Math.max(s, i))), to: b(this.qi(Math.min(e2, n2))) };
  }
  Ru(t2) {
    return { from: b(this.ya(t2.from, !0)), to: b(this.ya(t2.to, !0)) };
  }
  $i() {
    return this.e_;
  }
  m_(t2) {
    if (!isFinite(t2) || t2 <= 0 || this.e_ === t2)
      return;
    const i = this.ku(), n2 = this.e_;
    if (this.e_ = t2, this.ou = !0, this.cn.lockVisibleTimeRangeOnResize && n2 !== 0) {
      const i2 = this.mu * t2 / n2;
      this.mu = i2;
    }
    if (this.cn.fixLeftEdge && i !== null && i.Os() <= 0) {
      const i2 = n2 - t2;
      this.pu -= Math.round(i2 / this.mu) + 1, this.ou = !0;
    }
    this.Du(), this.Ou();
  }
  Et(t2) {
    if (this.Fi() || !A$1(t2))
      return 0;
    const i = this.Au() + this.pu - t2;
    return this.e_ - (i + 0.5) * this.mu - 1;
  }
  Js(t2, i) {
    const n2 = this.Au(), s = i === void 0 ? 0 : i.from, e2 = i === void 0 ? t2.length : i.to;
    for (let i2 = s; i2 < e2; i2++) {
      const s2 = t2[i2].ut, e3 = n2 + this.pu - s2, r2 = this.e_ - (e3 + 0.5) * this.mu - 1;
      t2[i2].et = r2;
    }
  }
  Vu(t2) {
    return Math.ceil(this.Bu(t2));
  }
  Jn(t2) {
    this.ou = !0, this.pu = t2, this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  he() {
    return this.mu;
  }
  Gn(t2) {
    this.zu(t2), this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  Eu() {
    return this.pu;
  }
  Ea() {
    if (this.Fi())
      return null;
    if (this.fu !== null)
      return this.fu;
    const t2 = this.mu, i = 5 * (this.Ui.W().layout.fontSize + 4) / 8 * (this.cn.tickMarkMaxCharacterLength || 8), n2 = Math.round(i / t2), s = b(this.Xs()), e2 = Math.max(s.Os(), s.Os() - n2), r2 = Math.max(s.di(), s.di() - n2), h2 = this.hu.G_(t2, i), l2 = this.Tu() + n2, a2 = this.Pu() - n2, o2 = this.Lu(), _24 = this.cn.fixLeftEdge || o2, u2 = this.cn.fixRightEdge || o2;
    let c2 = 0;
    for (const t3 of h2) {
      if (!(e2 <= t3.index && t3.index <= r2))
        continue;
      let n3;
      c2 < this.vu.length ? (n3 = this.vu[c2], n3.coord = this.Et(t3.index), n3.label = this.Nu(t3), n3.weight = t3.weight) : (n3 = { needAlignCoordinate: !1, coord: this.Et(t3.index), label: this.Nu(t3), weight: t3.weight }, this.vu.push(n3)), this.mu > i / 2 && !o2 ? n3.needAlignCoordinate = !1 : n3.needAlignCoordinate = _24 && t3.index <= l2 || u2 && t3.index >= a2, c2++;
    }
    return this.vu.length = c2, this.fu = this.vu, this.vu;
  }
  Fu() {
    this.ou = !0, this.Gn(this.cn.barSpacing), this.Jn(this.cn.rightOffset);
  }
  Wu(t2) {
    this.ou = !0, this.eu = t2, this.Ou(), this.Mu();
  }
  ju(t2, i) {
    const n2 = this.Bu(t2), s = this.he(), e2 = s + i * (s / 10);
    this.Gn(e2), this.cn.rightBarStaysOnScroll || this.Jn(this.Eu() + (n2 - this.Bu(t2)));
  }
  Uo(t2) {
    this.fo && this.Zo(), this.do === null && this.du === null && (this.Fi() || (this.do = t2, this.Hu()));
  }
  qo(t2) {
    if (this.du === null)
      return;
    const i = yt$1(this.e_ - t2, 0, this.e_), n2 = yt$1(this.e_ - b(this.do), 0, this.e_);
    i !== 0 && n2 !== 0 && this.Gn(this.du.he * i / n2);
  }
  Yo() {
    this.do !== null && (this.do = null, this.$u());
  }
  Xo(t2) {
    this.fo === null && this.du === null && (this.Fi() || (this.fo = t2, this.Hu()));
  }
  Ko(t2) {
    if (this.fo === null)
      return;
    const i = (this.fo - t2) / this.he();
    this.pu = b(this.du).Eu + i, this.ou = !0, this.Ou();
  }
  Zo() {
    this.fo !== null && (this.fo = null, this.$u());
  }
  Uu() {
    this.qu(this.cn.rightOffset);
  }
  qu(t2, i = 400) {
    if (!isFinite(t2))
      throw new RangeError("offset is required and must be finite number");
    if (!isFinite(i) || i <= 0)
      throw new RangeError("animationDuration (optional) must be finite positive number");
    const n2 = this.pu, s = performance.now();
    this.Ui.Xn({ Yu: (t3) => (t3 - s) / i >= 1, Xu: (e2) => {
      const r2 = (e2 - s) / i;
      return r2 >= 1 ? t2 : n2 + (t2 - n2) * r2;
    } });
  }
  gt(t2, i) {
    this.ou = !0, this.ru = t2, this.hu.K_(t2, i), this.Ou();
  }
  Ku() {
    return this._u;
  }
  Zu() {
    return this.uu;
  }
  Gu() {
    return this.cu;
  }
  Au() {
    return this.eu || 0;
  }
  Ju(t2) {
    const i = t2.U_();
    this.zu(this.e_ / i), this.pu = t2.di() - this.Au(), this.Ou(), this.ou = !0, this.Ui.Iu(), this.Ui.Fh();
  }
  Qu() {
    const t2 = this.Tu(), i = this.Pu();
    t2 !== null && i !== null && this.Ju(new xn$1(t2, i + this.cn.rightOffset));
  }
  tc(t2) {
    const i = new xn$1(t2.from, t2.to);
    this.Ju(i);
  }
  Yi(t2) {
    return this.bo.timeFormatter !== void 0 ? this.bo.timeFormatter(t2.originalTime) : this.N_.formatHorzItem(t2.time);
  }
  Lu() {
    const { handleScroll: t2, handleScale: i } = this.Ui.W();
    return !(t2.horzTouchDrag || t2.mouseWheel || t2.pressedMouseMove || t2.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch);
  }
  Tu() {
    return this.ru.length === 0 ? null : 0;
  }
  Pu() {
    return this.ru.length === 0 ? null : this.ru.length - 1;
  }
  ic(t2) {
    return (this.e_ - 1 - t2) / this.mu;
  }
  Bu(t2) {
    const i = this.ic(t2), n2 = this.Au() + this.pu - i;
    return Math.round(1e6 * n2) / 1e6;
  }
  zu(t2) {
    const i = this.mu;
    this.mu = t2, this.Du(), i !== this.mu && (this.ou = !0, this.nc());
  }
  Su() {
    if (!this.ou)
      return;
    if (this.ou = !1, this.Fi())
      return void this.sc(yn$1.su());
    const t2 = this.Au(), i = this.e_ / this.mu, n2 = this.pu + t2, s = new xn$1(n2 - i + 1, n2);
    this.sc(new yn$1(s));
  }
  Du() {
    const t2 = this.ec();
    if (this.mu < t2 && (this.mu = t2, this.ou = !0), this.e_ !== 0) {
      const t3 = 0.5 * this.e_;
      this.mu > t3 && (this.mu = t3, this.ou = !0);
    }
  }
  ec() {
    return this.cn.fixLeftEdge && this.cn.fixRightEdge && this.ru.length !== 0 ? this.e_ / this.ru.length : this.cn.minBarSpacing;
  }
  Ou() {
    const t2 = this.rc();
    this.pu > t2 && (this.pu = t2, this.ou = !0);
    const i = this.hc();
    i !== null && this.pu < i && (this.pu = i, this.ou = !0);
  }
  hc() {
    const t2 = this.Tu(), i = this.eu;
    return t2 === null || i === null ? null : t2 - i - 1 + (this.cn.fixLeftEdge ? this.e_ / this.mu : Math.min(2, this.ru.length));
  }
  rc() {
    return this.cn.fixRightEdge ? 0 : this.e_ / this.mu - Math.min(2, this.ru.length);
  }
  Hu() {
    this.du = { he: this.he(), Eu: this.Eu() };
  }
  $u() {
    this.du = null;
  }
  Nu(t2) {
    let i = this.lu.get(t2.weight);
    return i === void 0 && (i = new Mn$1((t3) => this.lc(t3), this.N_), this.lu.set(t2.weight, i)), i.F_(t2);
  }
  lc(t2) {
    return this.N_.formatTickmark(t2, this.bo);
  }
  sc(t2) {
    const i = this.au;
    this.au = t2, Sn(i.iu(), this.au.iu()) || this._u.m(), Sn(i.nu(), this.au.nu()) || this.uu.m(), this.nc();
  }
  nc() {
    this.fu = null;
  }
  gu() {
    this.nc(), this.lu.clear();
  }
  bu() {
    this.N_.updateFormatter(this.bo);
  }
  Mu() {
    if (!this.cn.fixLeftEdge)
      return;
    const t2 = this.Tu();
    if (t2 === null)
      return;
    const i = this.Xs();
    if (i === null)
      return;
    const n2 = i.Os() - t2;
    if (n2 < 0) {
      const t3 = this.pu - n2 - 1;
      this.Jn(t3);
    }
    this.Du();
  }
  xu() {
    this.Ou(), this.Du();
  }
};
__name(_Tn, "Tn");
let Tn = _Tn;
const _Pn = class _Pn extends j {
  constructor(t2) {
    super(), this.ac = /* @__PURE__ */ new Map(), this.Lt = t2;
  }
  Z(t2) {
  }
  J(t2) {
    if (!this.Lt.Tt)
      return;
    const { context: i, mediaSize: n2 } = t2;
    let s = 0;
    for (const t3 of this.Lt.oc) {
      if (t3.Jt.length === 0)
        continue;
      i.font = t3.R;
      const e3 = this._c(i, t3.Jt);
      e3 > n2.width ? t3.ju = n2.width / e3 : t3.ju = 1, s += t3.uc * t3.ju;
    }
    let e2 = 0;
    switch (this.Lt.cc) {
      case "top":
        e2 = 0;
        break;
      case "center":
        e2 = Math.max((n2.height - s) / 2, 0);
        break;
      case "bottom":
        e2 = Math.max(n2.height - s, 0);
    }
    i.fillStyle = this.Lt.O;
    for (const t3 of this.Lt.oc) {
      i.save();
      let s2 = 0;
      switch (this.Lt.dc) {
        case "left":
          i.textAlign = "left", s2 = t3.uc / 2;
          break;
        case "center":
          i.textAlign = "center", s2 = n2.width / 2;
          break;
        case "right":
          i.textAlign = "right", s2 = n2.width - 1 - t3.uc / 2;
      }
      i.translate(s2, e2), i.textBaseline = "top", i.font = t3.R, i.scale(t3.ju, t3.ju), i.fillText(t3.Jt, 0, t3.fc), i.restore(), e2 += t3.uc * t3.ju;
    }
  }
  _c(t2, i) {
    const n2 = this.vc(t2.font);
    let s = n2.get(i);
    return s === void 0 && (s = t2.measureText(i).width, n2.set(i, s)), s;
  }
  vc(t2) {
    let i = this.ac.get(t2);
    return i === void 0 && (i = /* @__PURE__ */ new Map(), this.ac.set(t2, i)), i;
  }
};
__name(_Pn, "Pn");
let Pn = _Pn;
const _Rn = class _Rn {
  constructor(t2) {
    this.bt = !0, this.jt = { Tt: !1, O: "", oc: [], cc: "center", dc: "center" }, this.Ht = new Pn(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht;
  }
  St() {
    const t2 = this.$t.W(), i = this.jt;
    i.Tt = t2.visible, i.Tt && (i.O = t2.color, i.dc = t2.horzAlign, i.cc = t2.vertAlign, i.oc = [{ Jt: t2.text, R: N$1(t2.fontSize, t2.fontFamily, t2.fontStyle), uc: 1.2 * t2.fontSize, fc: 0, ju: 0 }]);
  }
};
__name(_Rn, "Rn");
let Rn = _Rn;
var _a39;
let Dn$1 = (_a39 = class extends at$1 {
  constructor(t2, i) {
    super(), this.cn = i, this.wn = new Rn(this);
  }
  Rn() {
    return [];
  }
  Pn() {
    return [this.wn];
  }
  W() {
    return this.cn;
  }
  On() {
    this.wn.gt();
  }
}, __name(_a39, "Dn"), _a39);
var On, An, Vn$1, Bn$1, In;
(function(t2) {
  t2[t2.OnTouchEnd = 0] = "OnTouchEnd", t2[t2.OnNextTap = 1] = "OnNextTap";
})(On || (On = {}));
const _zn = class _zn {
  constructor(t2, i, n2) {
    this.mc = [], this.bc = [], this.e_ = 0, this.wc = null, this.gc = new R(), this.Mc = new R(), this.xc = null, this.Sc = t2, this.cn = i, this.N_ = n2, this.kc = new F$1(this), this.wl = new Tn(this, i.timeScale, this.cn.localization, n2), this.wt = new _t$1(this, i.crosshair), this.yc = new Ji(i.crosshair), this.Cc = new Dn$1(this, i.watermark), this.Tc(), this.mc[0].p_(2e3), this.Pc = this.Rc(0), this.Dc = this.Rc(1);
  }
  $l() {
    this.Oc(ct.es());
  }
  Fh() {
    this.Oc(ct.ss());
  }
  sa() {
    this.Oc(new ct(1));
  }
  Ul(t2) {
    const i = this.Ac(t2);
    this.Oc(i);
  }
  Vc() {
    return this.wc;
  }
  Bc(t2) {
    const i = this.wc;
    this.wc = t2, i !== null && this.Ul(i.Ic), t2 !== null && this.Ul(t2.Ic);
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    D$1(this.cn, t2), this.mc.forEach((i) => i.c_(t2)), t2.timeScale !== void 0 && this.wl.Nh(t2.timeScale), t2.localization !== void 0 && this.wl.wu(t2.localization), (t2.leftPriceScale || t2.rightPriceScale) && this.gc.m(), this.Pc = this.Rc(0), this.Dc = this.Rc(1), this.$l();
  }
  zc(t2, i) {
    if (t2 === "left")
      return void this.Nh({ leftPriceScale: i });
    if (t2 === "right")
      return void this.Nh({ rightPriceScale: i });
    const n2 = this.Ec(t2);
    n2 !== null && (n2.At.Nh(i), this.gc.m());
  }
  Ec(t2) {
    for (const i of this.mc) {
      const n2 = i.d_(t2);
      if (n2 !== null)
        return { Ut: i, At: n2 };
    }
    return null;
  }
  yt() {
    return this.wl;
  }
  Lc() {
    return this.mc;
  }
  Nc() {
    return this.Cc;
  }
  Fc() {
    return this.wt;
  }
  Wc() {
    return this.Mc;
  }
  jc(t2, i) {
    t2.Oo(i), this.Iu();
  }
  m_(t2) {
    this.e_ = t2, this.wl.m_(this.e_), this.mc.forEach((i) => i.m_(t2)), this.Iu();
  }
  Tc(t2) {
    const i = new gn$1(this.wl, this);
    t2 !== void 0 ? this.mc.splice(t2, 0, i) : this.mc.push(i);
    const n2 = t2 === void 0 ? this.mc.length - 1 : t2, s = ct.es();
    return s.Nn(n2, { Fn: 0, Wn: !0 }), this.Oc(s), i;
  }
  y_(t2, i, n2) {
    t2.y_(i, n2);
  }
  C_(t2, i, n2) {
    t2.C_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2));
  }
  T_(t2, i) {
    t2.T_(i), this.Oc(this.Hc(t2, 2));
  }
  P_(t2, i, n2) {
    i.yo() || t2.P_(i, n2);
  }
  R_(t2, i, n2) {
    i.yo() || (t2.R_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2)));
  }
  D_(t2, i) {
    i.yo() || (t2.D_(i), this.Oc(this.Hc(t2, 2)));
  }
  A_(t2, i) {
    t2.A_(i), this.Oc(this.Hc(t2, 2));
  }
  $c(t2) {
    this.wl.Uo(t2);
  }
  Uc(t2, i) {
    const n2 = this.yt();
    if (n2.Fi() || i === 0)
      return;
    const s = n2.$i();
    t2 = Math.max(1, Math.min(t2, s)), n2.ju(t2, i), this.Iu();
  }
  qc(t2) {
    this.Yc(0), this.Xc(t2), this.Kc();
  }
  Zc(t2) {
    this.wl.qo(t2), this.Iu();
  }
  Gc() {
    this.wl.Yo(), this.Fh();
  }
  Yc(t2) {
    this.wl.Xo(t2);
  }
  Xc(t2) {
    this.wl.Ko(t2), this.Iu();
  }
  Kc() {
    this.wl.Zo(), this.Fh();
  }
  Mt() {
    return this.bc;
  }
  Jc(t2, i, n2, s, e2) {
    this.wt.gn(t2, i);
    let r2 = NaN, h2 = this.wl.Vu(t2);
    const l2 = this.wl.Xs();
    l2 !== null && (h2 = Math.min(Math.max(l2.Os(), h2), l2.di()));
    const a2 = s.vn(), o2 = a2.Pt();
    o2 !== null && (r2 = a2.pn(i, o2)), r2 = this.yc.Ca(r2, h2, s), this.wt.kn(h2, r2, s), this.sa(), e2 || this.Mc.m(this.wt.kt(), { x: t2, y: i }, n2);
  }
  Qc(t2, i, n2) {
    const s = n2.vn(), e2 = s.Pt(), r2 = s.Ot(t2, b(e2)), h2 = this.wl.ya(i, !0), l2 = this.wl.Et(b(h2));
    this.Jc(l2, r2, null, n2, !0);
  }
  td(t2) {
    this.Fc().Cn(), this.sa(), t2 || this.Mc.m(null, null, null);
  }
  ql() {
    const t2 = this.wt.Ut();
    if (t2 !== null) {
      const i = this.wt.xn(), n2 = this.wt.Sn();
      this.Jc(i, n2, null, t2);
    }
    this.wt.On();
  }
  nd(t2, i, n2) {
    const s = this.wl.mn(0);
    i !== void 0 && n2 !== void 0 && this.wl.gt(i, n2);
    const e2 = this.wl.mn(0), r2 = this.wl.Au(), h2 = this.wl.Xs();
    if (h2 !== null && s !== null && e2 !== null) {
      const i2 = h2.Kr(r2), l2 = this.N_.key(s) > this.N_.key(e2), a2 = t2 !== null && t2 > r2 && !l2, o2 = this.wl.W().allowShiftVisibleRangeOnWhitespaceReplacement, _24 = i2 && (n2 !== void 0 || o2) && this.wl.W().shiftVisibleRangeOnNewBar;
      if (a2 && !_24) {
        const i3 = t2 - r2;
        this.wl.Jn(this.wl.Eu() - i3);
      }
    }
    this.wl.Wu(t2);
  }
  Kl(t2) {
    t2 !== null && t2.B_();
  }
  cr(t2) {
    const i = this.mc.find((i2) => i2.No().includes(t2));
    return i === void 0 ? null : i;
  }
  Iu() {
    this.Cc.On(), this.mc.forEach((t2) => t2.B_()), this.ql();
  }
  S() {
    this.mc.forEach((t2) => t2.S()), this.mc.length = 0, this.cn.localization.priceFormatter = void 0, this.cn.localization.percentageFormatter = void 0, this.cn.localization.timeFormatter = void 0;
  }
  sd() {
    return this.kc;
  }
  mr() {
    return this.kc.W();
  }
  f_() {
    return this.gc;
  }
  ed(t2, i, n2) {
    const s = this.mc[0], e2 = this.rd(i, t2, s, n2);
    return this.bc.push(e2), this.bc.length === 1 ? this.$l() : this.Fh(), e2;
  }
  hd(t2) {
    const i = this.cr(t2), n2 = this.bc.indexOf(t2);
    p$1(n2 !== -1, "Series not found"), this.bc.splice(n2, 1), b(i).jo(t2), t2.S && t2.S();
  }
  Hl(t2, i) {
    const n2 = b(this.cr(t2));
    n2.jo(t2);
    const s = this.Ec(i);
    if (s === null) {
      const s2 = t2.Zi();
      n2.Fo(t2, i, s2);
    } else {
      const e2 = s.Ut === n2 ? t2.Zi() : void 0;
      s.Ut.Fo(t2, i, e2);
    }
  }
  Qu() {
    const t2 = ct.ss();
    t2.$n(), this.Oc(t2);
  }
  ld(t2) {
    const i = ct.ss();
    i.Yn(t2), this.Oc(i);
  }
  Zn() {
    const t2 = ct.ss();
    t2.Zn(), this.Oc(t2);
  }
  Gn(t2) {
    const i = ct.ss();
    i.Gn(t2), this.Oc(i);
  }
  Jn(t2) {
    const i = ct.ss();
    i.Jn(t2), this.Oc(i);
  }
  Xn(t2) {
    const i = ct.ss();
    i.Xn(t2), this.Oc(i);
  }
  Un() {
    const t2 = ct.ss();
    t2.Un(), this.Oc(t2);
  }
  ad() {
    return this.cn.rightPriceScale.visible ? "right" : "left";
  }
  od() {
    return this.Dc;
  }
  q() {
    return this.Pc;
  }
  It(t2) {
    const i = this.Dc, n2 = this.Pc;
    if (i === n2)
      return i;
    if (t2 = Math.max(0, Math.min(100, Math.round(100 * t2))), this.xc === null || this.xc.Ts !== n2 || this.xc.Ps !== i)
      this.xc = { Ts: n2, Ps: i, _d: /* @__PURE__ */ new Map() };
    else {
      const i2 = this.xc._d.get(t2);
      if (i2 !== void 0)
        return i2;
    }
    const s = function(t3, i2, n3) {
      const [s2, e2, r2, h2] = T$1(t3), [l2, a2, o2, _24] = T$1(i2), u2 = [M(s2 + n3 * (l2 - s2)), M(e2 + n3 * (a2 - e2)), M(r2 + n3 * (o2 - r2)), x(h2 + n3 * (_24 - h2))];
      return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
    }(n2, i, t2 / 100);
    return this.xc._d.set(t2, s), s;
  }
  Hc(t2, i) {
    const n2 = new ct(i);
    if (t2 !== null) {
      const s = this.mc.indexOf(t2);
      n2.Nn(s, { Fn: i });
    }
    return n2;
  }
  Ac(t2, i) {
    return i === void 0 && (i = 2), this.Hc(this.cr(t2), i);
  }
  Oc(t2) {
    this.Sc && this.Sc(t2), this.mc.forEach((t3) => t3.z_().Wh().gt());
  }
  rd(t2, i, n2, s) {
    const e2 = new Gi(this, t2, i, n2, s), r2 = t2.priceScaleId !== void 0 ? t2.priceScaleId : this.ad();
    return n2.Fo(e2, r2), ut$1(r2) || e2.Nh(t2), e2;
  }
  Rc(t2) {
    const i = this.cn.layout;
    return i.background.type === "gradient" ? t2 === 0 ? i.background.topColor : i.background.bottomColor : i.background.color;
  }
};
__name(_zn, "zn");
let zn = _zn;
function En(t2) {
  return !O$1(t2) && !V$1(t2);
}
__name(En, "En");
function Ln$1(t2) {
  return O$1(t2);
}
__name(Ln$1, "Ln$1");
(function(t2) {
  t2[t2.Disabled = 0] = "Disabled", t2[t2.Continuous = 1] = "Continuous", t2[t2.OnDataUpdate = 2] = "OnDataUpdate";
})(An || (An = {})), function(t2) {
  t2[t2.LastBar = 0] = "LastBar", t2[t2.LastVisible = 1] = "LastVisible";
}(Vn$1 || (Vn$1 = {})), function(t2) {
  t2.Solid = "solid", t2.VerticalGradient = "gradient";
}(Bn$1 || (Bn$1 = {})), function(t2) {
  t2[t2.Year = 0] = "Year", t2[t2.Month = 1] = "Month", t2[t2.DayOfMonth = 2] = "DayOfMonth", t2[t2.Time = 3] = "Time", t2[t2.TimeWithSeconds = 4] = "TimeWithSeconds";
}(In || (In = {}));
const Nn = /* @__PURE__ */ __name((t2) => t2.getUTCFullYear(), "Nn");
function Fn$1(t2, i, n2) {
  return i.replace(/yyyy/g, ((t3) => ft$1(Nn(t3), 4))(t2)).replace(/yy/g, ((t3) => ft$1(Nn(t3) % 100, 2))(t2)).replace(/MMMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "long" }))(t2, n2)).replace(/MMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "short" }))(t2, n2)).replace(/MM/g, ((t3) => ft$1(((t4) => t4.getUTCMonth() + 1)(t3), 2))(t2)).replace(/dd/g, ((t3) => ft$1(((t4) => t4.getUTCDate())(t3), 2))(t2));
}
__name(Fn$1, "Fn$1");
var _a40;
let Wn$1 = (_a40 = class {
  constructor(t2 = "yyyy-MM-dd", i = "default") {
    this.ud = t2, this.dd = i;
  }
  F_(t2) {
    return Fn$1(t2, this.ud, this.dd);
  }
}, __name(_a40, "Wn"), _a40);
const _jn = class _jn {
  constructor(t2) {
    this.fd = t2 || "%h:%m:%s";
  }
  F_(t2) {
    return this.fd.replace("%h", ft$1(t2.getUTCHours(), 2)).replace("%m", ft$1(t2.getUTCMinutes(), 2)).replace("%s", ft$1(t2.getUTCSeconds(), 2));
  }
};
__name(_jn, "jn");
let jn = _jn;
const Hn$1 = { vd: "yyyy-MM-dd", pd: "%h:%m:%s", md: " ", bd: "default" }, _$n = class _$n {
  constructor(t2 = {}) {
    const i = Object.assign(Object.assign({}, Hn$1), t2);
    this.wd = new Wn$1(i.vd, i.bd), this.gd = new jn(i.pd), this.Md = i.md;
  }
  F_(t2) {
    return `${this.wd.F_(t2)}${this.Md}${this.gd.F_(t2)}`;
  }
};
__name(_$n, "$n");
let $n = _$n;
function Un(t2) {
  return 60 * t2 * 60 * 1e3;
}
__name(Un, "Un");
function qn$1(t2) {
  return 60 * t2 * 1e3;
}
__name(qn$1, "qn$1");
const Yn = [{ xd: (Xn$1 = 1, 1e3 * Xn$1), Sd: 10 }, { xd: qn$1(1), Sd: 20 }, { xd: qn$1(5), Sd: 21 }, { xd: qn$1(30), Sd: 22 }, { xd: Un(1), Sd: 30 }, { xd: Un(3), Sd: 31 }, { xd: Un(6), Sd: 32 }, { xd: Un(12), Sd: 33 }];
var Xn$1;
function Kn$1(t2, i) {
  if (t2.getUTCFullYear() !== i.getUTCFullYear())
    return 70;
  if (t2.getUTCMonth() !== i.getUTCMonth())
    return 60;
  if (t2.getUTCDate() !== i.getUTCDate())
    return 50;
  for (let n2 = Yn.length - 1; n2 >= 0; --n2)
    if (Math.floor(i.getTime() / Yn[n2].xd) !== Math.floor(t2.getTime() / Yn[n2].xd))
      return Yn[n2].Sd;
  return 0;
}
__name(Kn$1, "Kn$1");
function Zn(t2) {
  let i = t2;
  if (V$1(t2) && (i = Jn$1(t2)), !En(i))
    throw new Error("time must be of type BusinessDay");
  const n2 = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0));
  return { kd: Math.round(n2.getTime() / 1e3), yd: i };
}
__name(Zn, "Zn");
function Gn$1(t2) {
  if (!Ln$1(t2))
    throw new Error("time must be of type isUTCTimestamp");
  return { kd: t2 };
}
__name(Gn$1, "Gn$1");
function Jn$1(t2) {
  const i = new Date(t2);
  if (isNaN(i.getTime()))
    throw new Error(`Invalid date string=${t2}, expected format=yyyy-mm-dd`);
  return { day: i.getUTCDate(), month: i.getUTCMonth() + 1, year: i.getUTCFullYear() };
}
__name(Jn$1, "Jn$1");
function Qn$1(t2) {
  V$1(t2.time) && (t2.time = Jn$1(t2.time));
}
__name(Qn$1, "Qn$1");
const _ts = class _ts {
  options() {
    return this.cn;
  }
  setOptions(t2) {
    this.cn = t2, this.updateFormatter(t2.localization);
  }
  preprocessData(t2) {
    Array.isArray(t2) ? function(t3) {
      t3.forEach(Qn$1);
    }(t2) : Qn$1(t2);
  }
  createConverterToInternalObj(t2) {
    return b(function(t3) {
      return t3.length === 0 ? null : En(t3[0].time) || V$1(t3[0].time) ? Zn : Gn$1;
    }(t2));
  }
  key(t2) {
    return typeof t2 == "object" && "kd" in t2 ? t2.kd : this.key(this.convertHorzItemToInternal(t2));
  }
  cacheKey(t2) {
    const i = t2;
    return i.yd === void 0 ? new Date(1e3 * i.kd).getTime() : new Date(Date.UTC(i.yd.year, i.yd.month - 1, i.yd.day)).getTime();
  }
  convertHorzItemToInternal(t2) {
    return Ln$1(i = t2) ? Gn$1(i) : En(i) ? Zn(i) : Zn(Jn$1(i));
    var i;
  }
  updateFormatter(t2) {
    if (!this.cn)
      return;
    const i = t2.dateFormat;
    this.cn.timeScale.timeVisible ? this.Cd = new $n({ vd: i, pd: this.cn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", md: "   ", bd: t2.locale }) : this.Cd = new Wn$1(i, t2.locale);
  }
  formatHorzItem(t2) {
    const i = t2;
    return this.Cd.F_(new Date(1e3 * i.kd));
  }
  formatTickmark(t2, i) {
    const n2 = function(t3, i2, n3) {
      switch (t3) {
        case 0:
        case 10:
          return i2 ? n3 ? 4 : 3 : 2;
        case 20:
        case 21:
        case 22:
        case 30:
        case 31:
        case 32:
        case 33:
          return i2 ? 3 : 2;
        case 50:
          return 2;
        case 60:
          return 1;
        case 70:
          return 0;
      }
    }(t2.weight, this.cn.timeScale.timeVisible, this.cn.timeScale.secondsVisible), s = this.cn.timeScale;
    if (s.tickMarkFormatter !== void 0) {
      const e2 = s.tickMarkFormatter(t2.originalTime, n2, i.locale);
      if (e2 !== null)
        return e2;
    }
    return function(t3, i2, n3) {
      const s2 = {};
      switch (i2) {
        case 0:
          s2.year = "numeric";
          break;
        case 1:
          s2.month = "short";
          break;
        case 2:
          s2.day = "numeric";
          break;
        case 3:
          s2.hour12 = !1, s2.hour = "2-digit", s2.minute = "2-digit";
          break;
        case 4:
          s2.hour12 = !1, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
      }
      const e2 = t3.yd === void 0 ? new Date(1e3 * t3.kd) : new Date(Date.UTC(t3.yd.year, t3.yd.month - 1, t3.yd.day));
      return new Date(e2.getUTCFullYear(), e2.getUTCMonth(), e2.getUTCDate(), e2.getUTCHours(), e2.getUTCMinutes(), e2.getUTCSeconds(), e2.getUTCMilliseconds()).toLocaleString(n3, s2);
    }(t2.time, n2, i.locale);
  }
  maxTickMarkWeight(t2) {
    let i = t2.reduce(Cn, t2[0]).weight;
    return i > 30 && i < 50 && (i = 30), i;
  }
  fillWeightsForPoints(t2, i) {
    (function(t3, i2 = 0) {
      if (t3.length === 0)
        return;
      let n2 = i2 === 0 ? null : t3[i2 - 1].time.kd, s = n2 !== null ? new Date(1e3 * n2) : null, e2 = 0;
      for (let r2 = i2; r2 < t3.length; ++r2) {
        const i3 = t3[r2], h2 = new Date(1e3 * i3.time.kd);
        s !== null && (i3.timeWeight = Kn$1(h2, s)), e2 += i3.time.kd - (n2 || i3.time.kd), n2 = i3.time.kd, s = h2;
      }
      if (i2 === 0 && t3.length > 1) {
        const i3 = Math.ceil(e2 / (t3.length - 1)), n3 = new Date(1e3 * (t3[0].time.kd - i3));
        t3[0].timeWeight = Kn$1(new Date(1e3 * t3[0].time.kd), n3);
      }
    })(t2, i);
  }
  static Td(t2) {
    return D$1({ localization: { dateFormat: "dd MMM 'yy" } }, t2 ?? {});
  }
};
__name(_ts, "ts");
let ts = _ts;
const is = typeof window < "u";
function ns() {
  return !!is && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
}
__name(ns, "ns");
function ss() {
  return !!is && /iPhone|iPad|iPod/.test(window.navigator.platform);
}
__name(ss, "ss");
function es(t2) {
  return t2 + t2 % 2;
}
__name(es, "es");
function rs(t2, i) {
  return t2.Pd - i.Pd;
}
__name(rs, "rs");
function hs(t2, i, n2) {
  const s = (t2.Pd - i.Pd) / (t2.ut - i.ut);
  return Math.sign(s) * Math.min(Math.abs(s), n2);
}
__name(hs, "hs");
const _ls = class _ls {
  constructor(t2, i, n2, s) {
    this.Rd = null, this.Dd = null, this.Od = null, this.Ad = null, this.Vd = null, this.Bd = 0, this.Id = 0, this.zd = t2, this.Ed = i, this.Ld = n2, this.rs = s;
  }
  Nd(t2, i) {
    if (this.Rd !== null) {
      if (this.Rd.ut === i)
        return void (this.Rd.Pd = t2);
      if (Math.abs(this.Rd.Pd - t2) < this.rs)
        return;
    }
    this.Ad = this.Od, this.Od = this.Dd, this.Dd = this.Rd, this.Rd = { ut: i, Pd: t2 };
  }
  Dr(t2, i) {
    if (this.Rd === null || this.Dd === null || i - this.Rd.ut > 50)
      return;
    let n2 = 0;
    const s = hs(this.Rd, this.Dd, this.Ed), e2 = rs(this.Rd, this.Dd), r2 = [s], h2 = [e2];
    if (n2 += e2, this.Od !== null) {
      const t3 = hs(this.Dd, this.Od, this.Ed);
      if (Math.sign(t3) === Math.sign(s)) {
        const i2 = rs(this.Dd, this.Od);
        if (r2.push(t3), h2.push(i2), n2 += i2, this.Ad !== null) {
          const t4 = hs(this.Od, this.Ad, this.Ed);
          if (Math.sign(t4) === Math.sign(s)) {
            const i3 = rs(this.Od, this.Ad);
            r2.push(t4), h2.push(i3), n2 += i3;
          }
        }
      }
    }
    let l2 = 0;
    for (let t3 = 0; t3 < r2.length; ++t3)
      l2 += h2[t3] / n2 * r2[t3];
    Math.abs(l2) < this.zd || (this.Vd = { Pd: t2, ut: i }, this.Id = l2, this.Bd = function(t3, i2) {
      const n3 = Math.log(i2);
      return Math.log(1 * n3 / -t3) / n3;
    }(Math.abs(l2), this.Ld));
  }
  Xu(t2) {
    const i = b(this.Vd), n2 = t2 - i.ut;
    return i.Pd + this.Id * (Math.pow(this.Ld, n2) - 1) / Math.log(this.Ld);
  }
  Yu(t2) {
    return this.Vd === null || this.Fd(t2) === this.Bd;
  }
  Fd(t2) {
    const i = t2 - b(this.Vd).ut;
    return Math.min(i, this.Bd);
  }
};
__name(_ls, "ls");
let ls = _ls;
function as(t2, n2) {
  const s = b(t2.ownerDocument).createElement("canvas");
  t2.appendChild(s);
  const e2 = bindTo(s, { type: "device-pixel-content-box", options: { allowResizeObserver: !1 }, transform: (t3, i) => ({ width: Math.max(t3.width, i.width), height: Math.max(t3.height, i.height) }) });
  return e2.resizeCanvasElement(n2), e2;
}
__name(as, "as");
function os(t2, i, n2, s) {
  t2.G && t2.G(i, n2, s);
}
__name(os, "os");
function _s(t2, i, n2, s) {
  t2.K(i, n2, s);
}
__name(_s, "_s");
function us(t2, i, n2, s) {
  const e2 = t2(n2, s);
  for (const t3 of e2) {
    const n3 = t3.xt();
    n3 !== null && i(n3);
  }
}
__name(us, "us");
function cs(t2) {
  is && window.chrome !== void 0 && t2.addEventListener("mousedown", (t3) => {
    if (t3.button === 1)
      return t3.preventDefault(), !1;
  });
}
__name(cs, "cs");
const _ds = class _ds {
  constructor(t2, i, n2) {
    this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.Yd = null, this.Xd = !1, this.Kd = null, this.Zd = null, this.Gd = !1, this.Jd = !1, this.Qd = !1, this.tf = null, this.if = null, this.nf = null, this.sf = null, this.ef = null, this.rf = null, this.hf = null, this.lf = 0, this.af = !1, this._f = !1, this.uf = !1, this.cf = 0, this.df = null, this.ff = !ss(), this.vf = (t3) => {
      this.pf(t3);
    }, this.mf = (t3) => {
      if (this.bf(t3)) {
        const i2 = this.wf(t3);
        if (++this.$d, this.Ud && this.$d > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.qd);
          n3 < 30 && !this.Qd && this.xf(i2, this.kf.Sf), this.yf();
        }
      } else {
        const i2 = this.wf(t3);
        if (++this.Wd, this.jd && this.Wd > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.Hd);
          n3 < 5 && !this.Jd && this.Cf(i2, this.kf.Tf), this.Pf();
        }
      }
    }, this.Rf = t2, this.kf = i, this.cn = n2, this.Df();
  }
  S() {
    this.tf !== null && (this.tf(), this.tf = null), this.if !== null && (this.if(), this.if = null), this.sf !== null && (this.sf(), this.sf = null), this.ef !== null && (this.ef(), this.ef = null), this.rf !== null && (this.rf(), this.rf = null), this.nf !== null && (this.nf(), this.nf = null), this.Of(), this.Pf();
  }
  Af(t2) {
    this.sf && this.sf();
    const i = this.Vf.bind(this);
    if (this.sf = () => {
      this.Rf.removeEventListener("mousemove", i);
    }, this.Rf.addEventListener("mousemove", i), this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Bf), this.ff = !0;
  }
  Pf() {
    this.jd !== null && clearTimeout(this.jd), this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  yf() {
    this.Ud !== null && clearTimeout(this.Ud), this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  Vf(t2) {
    if (this.uf || this.Zd !== null || this.bf(t2))
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.If), this.ff = !0;
  }
  zf(t2) {
    const i = bs(t2.changedTouches, b(this.df));
    if (i === null || (this.cf = ms(t2), this.hf !== null) || this._f)
      return;
    this.af = !0;
    const n2 = this.Mf(ps(i), b(this.Zd)), { Ef: s, Lf: e2, gf: r2 } = n2;
    if (this.Gd || !(r2 < 5)) {
      if (!this.Gd) {
        const t3 = 0.5 * s, i2 = e2 >= t3 && !this.cn.Nf(), n3 = t3 > e2 && !this.cn.Ff();
        i2 || n3 || (this._f = !0), this.Gd = !0, this.Qd = !0, this.Of(), this.yf();
      }
      if (!this._f) {
        const n3 = this.wf(t2, i);
        this.xf(n3, this.kf.Wf), vs(t2);
      }
    }
  }
  jf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.Mf(ps(t2), b(this.Kd)), { gf: n2 } = i;
    if (n2 >= 5 && (this.Jd = !0, this.Pf()), this.Jd) {
      const i2 = this.wf(t2);
      this.Cf(i2, this.kf.Hf);
    }
  }
  Mf(t2, i) {
    const n2 = Math.abs(i.et - t2.et), s = Math.abs(i.rt - t2.rt);
    return { Ef: n2, Lf: s, gf: n2 + s };
  }
  $f(t2) {
    let i = bs(t2.changedTouches, b(this.df));
    if (i === null && t2.touches.length === 0 && (i = t2.changedTouches[0]), i === null)
      return;
    this.df = null, this.cf = ms(t2), this.Of(), this.Zd = null, this.rf && (this.rf(), this.rf = null);
    const n2 = this.wf(t2, i);
    if (this.xf(n2, this.kf.Uf), ++this.$d, this.Ud && this.$d > 1) {
      const { gf: t3 } = this.Mf(ps(i), this.qd);
      t3 < 30 && !this.Qd && this.xf(n2, this.kf.Sf), this.yf();
    } else
      this.Qd || (this.xf(n2, this.kf.qf), this.kf.qf && vs(t2));
    this.$d === 0 && vs(t2), t2.touches.length === 0 && this.Xd && (this.Xd = !1, vs(t2));
  }
  pf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.wf(t2);
    if (this.Kd = null, this.uf = !1, this.ef && (this.ef(), this.ef = null), ns() && this.Rf.ownerDocument.documentElement.removeEventListener("mouseleave", this.vf), !this.bf(t2))
      if (this.Cf(i, this.kf.Yf), ++this.Wd, this.jd && this.Wd > 1) {
        const { gf: n2 } = this.Mf(ps(t2), this.Hd);
        n2 < 5 && !this.Jd && this.Cf(i, this.kf.Tf), this.Pf();
      } else
        this.Jd || this.Cf(i, this.kf.Xf);
  }
  Of() {
    this.Yd !== null && (clearTimeout(this.Yd), this.Yd = null);
  }
  Kf(t2) {
    if (this.df !== null)
      return;
    const i = t2.changedTouches[0];
    this.df = i.identifier, this.cf = ms(t2);
    const n2 = this.Rf.ownerDocument.documentElement;
    this.Qd = !1, this.Gd = !1, this._f = !1, this.Zd = ps(i), this.rf && (this.rf(), this.rf = null);
    {
      const i2 = this.zf.bind(this), s2 = this.$f.bind(this);
      this.rf = () => {
        n2.removeEventListener("touchmove", i2), n2.removeEventListener("touchend", s2);
      }, n2.addEventListener("touchmove", i2, { passive: !1 }), n2.addEventListener("touchend", s2, { passive: !1 }), this.Of(), this.Yd = setTimeout(this.Zf.bind(this, t2), 240);
    }
    const s = this.wf(t2, i);
    this.xf(s, this.kf.Gf), this.Ud || (this.$d = 0, this.Ud = setTimeout(this.yf.bind(this), 500), this.qd = ps(i));
  }
  Jf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.Rf.ownerDocument.documentElement;
    ns() && i.addEventListener("mouseleave", this.vf), this.Jd = !1, this.Kd = ps(t2), this.ef && (this.ef(), this.ef = null);
    {
      const t3 = this.jf.bind(this), n3 = this.pf.bind(this);
      this.ef = () => {
        i.removeEventListener("mousemove", t3), i.removeEventListener("mouseup", n3);
      }, i.addEventListener("mousemove", t3), i.addEventListener("mouseup", n3);
    }
    if (this.uf = !0, this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Qf), this.jd || (this.Wd = 0, this.jd = setTimeout(this.Pf.bind(this), 500), this.Hd = ps(t2));
  }
  Df() {
    this.Rf.addEventListener("mouseenter", this.Af.bind(this)), this.Rf.addEventListener("touchcancel", this.Of.bind(this));
    {
      const t2 = this.Rf.ownerDocument, i = /* @__PURE__ */ __name((t3) => {
        this.kf.tv && (t3.composed && this.Rf.contains(t3.composedPath()[0]) || t3.target && this.Rf.contains(t3.target) || this.kf.tv());
      }, "i");
      this.if = () => {
        t2.removeEventListener("touchstart", i);
      }, this.tf = () => {
        t2.removeEventListener("mousedown", i);
      }, t2.addEventListener("mousedown", i), t2.addEventListener("touchstart", i, { passive: !0 });
    }
    ss() && (this.nf = () => {
      this.Rf.removeEventListener("dblclick", this.mf);
    }, this.Rf.addEventListener("dblclick", this.mf)), this.Rf.addEventListener("mouseleave", this.iv.bind(this)), this.Rf.addEventListener("touchstart", this.Kf.bind(this), { passive: !0 }), cs(this.Rf), this.Rf.addEventListener("mousedown", this.Jf.bind(this)), this.nv(), this.Rf.addEventListener("touchmove", () => {
    }, { passive: !1 });
  }
  nv() {
    this.kf.sv === void 0 && this.kf.ev === void 0 && this.kf.rv === void 0 || (this.Rf.addEventListener("touchstart", (t2) => this.hv(t2.touches), { passive: !0 }), this.Rf.addEventListener("touchmove", (t2) => {
      if (t2.touches.length === 2 && this.hf !== null && this.kf.ev !== void 0) {
        const i = fs(t2.touches[0], t2.touches[1]) / this.lf;
        this.kf.ev(this.hf, i), vs(t2);
      }
    }, { passive: !1 }), this.Rf.addEventListener("touchend", (t2) => {
      this.hv(t2.touches);
    }));
  }
  hv(t2) {
    t2.length === 1 && (this.af = !1), t2.length !== 2 || this.af || this.Xd ? this.lv() : this.av(t2);
  }
  av(t2) {
    const i = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    this.hf = { et: (t2[0].clientX - i.left + (t2[1].clientX - i.left)) / 2, rt: (t2[0].clientY - i.top + (t2[1].clientY - i.top)) / 2 }, this.lf = fs(t2[0], t2[1]), this.kf.sv !== void 0 && this.kf.sv(), this.Of();
  }
  lv() {
    this.hf !== null && (this.hf = null, this.kf.rv !== void 0 && this.kf.rv());
  }
  iv(t2) {
    if (this.sf && this.sf(), this.bf(t2) || !this.ff)
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.ov), this.ff = !ss();
  }
  Zf(t2) {
    const i = bs(t2.touches, b(this.df));
    if (i === null)
      return;
    const n2 = this.wf(t2, i);
    this.xf(n2, this.kf._v), this.Qd = !0, this.Xd = !0;
  }
  bf(t2) {
    return t2.sourceCapabilities && t2.sourceCapabilities.firesTouchEvents !== void 0 ? t2.sourceCapabilities.firesTouchEvents : ms(t2) < this.cf + 500;
  }
  xf(t2, i) {
    i && i.call(this.kf, t2);
  }
  Cf(t2, i) {
    i && i.call(this.kf, t2);
  }
  wf(t2, i) {
    const n2 = i || t2, s = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    return { clientX: n2.clientX, clientY: n2.clientY, pageX: n2.pageX, pageY: n2.pageY, screenX: n2.screenX, screenY: n2.screenY, localX: n2.clientX - s.left, localY: n2.clientY - s.top, ctrlKey: t2.ctrlKey, altKey: t2.altKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, uv: !t2.type.startsWith("mouse") && t2.type !== "contextmenu" && t2.type !== "click", cv: t2.type, dv: n2.target, fv: t2.view, vv: () => {
      t2.type !== "touchstart" && vs(t2);
    } };
  }
};
__name(_ds, "ds");
let ds = _ds;
function fs(t2, i) {
  const n2 = t2.clientX - i.clientX, s = t2.clientY - i.clientY;
  return Math.sqrt(n2 * n2 + s * s);
}
__name(fs, "fs");
function vs(t2) {
  t2.cancelable && t2.preventDefault();
}
__name(vs, "vs");
function ps(t2) {
  return { et: t2.pageX, rt: t2.pageY };
}
__name(ps, "ps");
function ms(t2) {
  return t2.timeStamp || performance.now();
}
__name(ms, "ms");
function bs(t2, i) {
  for (let n2 = 0; n2 < t2.length; ++n2)
    if (t2[n2].identifier === i)
      return t2[n2];
  return null;
}
__name(bs, "bs");
function ws(t2) {
  return { Ic: t2.Ic, pv: { wr: t2.mv.externalId }, bv: t2.mv.cursorStyle };
}
__name(ws, "ws");
function gs(t2, i, n2) {
  for (const s of t2) {
    const t3 = s.xt();
    if (t3 !== null && t3.br) {
      const e2 = t3.br(i, n2);
      if (e2 !== null)
        return { fv: s, pv: e2 };
    }
  }
  return null;
}
__name(gs, "gs");
function Ms(t2, i) {
  return (n2) => {
    var s, e2, r2, h2;
    return ((e2 = (s = n2.At()) === null || s === void 0 ? void 0 : s.xa()) !== null && e2 !== void 0 ? e2 : "") !== i ? [] : (h2 = (r2 = n2.la) === null || r2 === void 0 ? void 0 : r2.call(n2, t2)) !== null && h2 !== void 0 ? h2 : [];
  };
}
__name(Ms, "Ms");
const _xs = class _xs {
  constructor(i, n2, s, e2) {
    this.Li = null, this.wv = null, this.gv = !1, this.Mv = new si(200), this.Gr = null, this.xv = 0, this.Sv = !1, this.kv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.nn = i, this.cn = n2, this.mo = n2.layout, this.kc = s, this.Tv = e2 === "left", this.Pv = Ms("normal", e2), this.Rv = Ms("top", e2), this.Dv = Ms("bottom", e2), this.Ov = document.createElement("div"), this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Ov.style.width = "25px", this.Ov.style.left = "0", this.Ov.style.position = "relative", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const r2 = this.Av.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "1", r2.style.left = "0", r2.style.top = "0", this.Vv = as(this.Ov, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const h2 = this.Vv.canvasElement;
    h2.style.position = "absolute", h2.style.zIndex = "2", h2.style.left = "0", h2.style.top = "0";
    const l2 = { Qf: this.Bv.bind(this), Gf: this.Bv.bind(this), Hf: this.Iv.bind(this), Wf: this.Iv.bind(this), tv: this.zv.bind(this), Yf: this.Ev.bind(this), Uf: this.Ev.bind(this), Tf: this.Lv.bind(this), Sf: this.Lv.bind(this), Bf: this.Nv.bind(this), ov: this.Fv.bind(this) };
    this.Wv = new ds(this.Vv.canvasElement, l2, { Nf: () => !this.cn.handleScroll.vertTouchDrag, Ff: () => !0 });
  }
  S() {
    this.Wv.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), this.Li !== null && this.Li.$o().p(this), this.Li = null;
  }
  jv() {
    return this.Ov;
  }
  P() {
    return this.mo.fontSize;
  }
  Hv() {
    const t2 = this.kc.W();
    return this.Gr !== t2.R && (this.Mv.ir(), this.Gr = t2.R), t2;
  }
  $v() {
    if (this.Li === null)
      return 0;
    let t2 = 0;
    const i = this.Hv(), n2 = b(this.Av.canvasElement.getContext("2d"));
    n2.save();
    const s = this.Li.Ea();
    n2.font = this.Uv(), s.length > 0 && (t2 = Math.max(this.Mv.Si(n2, s[0].Za), this.Mv.Si(n2, s[s.length - 1].Za)));
    const e2 = this.qv();
    for (let i2 = e2.length; i2--; ) {
      const s2 = this.Mv.Si(n2, e2[i2].Jt());
      s2 > t2 && (t2 = s2);
    }
    const r2 = this.Li.Pt();
    if (r2 !== null && this.wv !== null) {
      const i2 = this.Li.pn(1, r2), s2 = this.Li.pn(this.wv.height - 2, r2);
      t2 = Math.max(t2, this.Mv.Si(n2, this.Li.Wi(Math.floor(Math.min(i2, s2)) + 0.11111111111111, r2)), this.Mv.Si(n2, this.Li.Wi(Math.ceil(Math.max(i2, s2)) - 0.11111111111111, r2)));
    }
    n2.restore();
    const h2 = t2 || 34;
    return es(Math.ceil(i.C + i.T + i.B + i.I + 5 + h2));
  }
  Yv(t2) {
    this.wv !== null && equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = !0, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = !1, this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`);
  }
  Xv() {
    return b(this.wv).width;
  }
  Ji(t2) {
    this.Li !== t2 && (this.Li !== null && this.Li.$o().p(this), this.Li = t2, t2.$o().l(this.ao.bind(this), this));
  }
  At() {
    return this.Li;
  }
  ir() {
    const t2 = this.nn.Kv();
    this.nn.yv().qt().A_(t2, b(this.At()));
  }
  Zv(t2) {
    if (this.wv === null)
      return;
    if (t2 !== 1) {
      this.Gv(), this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      t3 !== null && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4), this.Be(t4);
      }), this.nn.Qv(t3, this.Dv), this.tp(t3), this.nn.Qv(t3, this.Pv), this.ip(t3));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.np(i), this.nn.Qv(i, this.Rv));
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  gt() {
    var t2;
    (t2 = this.Li) === null || t2 === void 0 || t2.Ea();
  }
  Bv(t2) {
    if (this.Li === null || this.Li.Fi() || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = !0, i.y_(n2, this.Li, t2.localY);
  }
  Iv(t2) {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv(), s = this.Li;
    i.C_(n2, s, t2.localY);
  }
  zv() {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const t2 = this.nn.yv().qt(), i = this.nn.Kv(), n2 = this.Li;
    this.gv && (this.gv = !1, t2.T_(i, n2));
  }
  Ev(t2) {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = !1, i.T_(n2, this.Li);
  }
  Lv(t2) {
    this.cn.handleScale.axisDoubleClickReset.price && this.ir();
  }
  Nv(t2) {
    this.Li !== null && (!this.nn.yv().qt().W().handleScale.axisPressedMouseMove.price || this.Li.ph() || this.Li.Co() || this.rp(1));
  }
  Fv(t2) {
    this.rp(0);
  }
  qv() {
    const t2 = [], i = this.Li === null ? void 0 : this.Li;
    return ((n2) => {
      for (let s = 0; s < n2.length; ++s) {
        const e2 = n2[s].Rn(this.nn.Kv(), i);
        for (let i2 = 0; i2 < e2.length; i2++)
          t2.push(e2[i2]);
      }
    })(this.nn.Kv().No()), t2;
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e2 = this.nn.Kv().qt(), r2 = e2.q(), h2 = e2.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, r2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2 }) {
    if (this.wv === null || this.Li === null || !this.Li.W().borderVisible)
      return;
    t2.fillStyle = this.Li.W().borderColor;
    const s = Math.max(1, Math.floor(this.Hv().C * n2));
    let e2;
    e2 = this.Tv ? i.width - s : 0, t2.fillRect(e2, 0, s, i.height);
  }
  tp(t2) {
    if (this.wv === null || this.Li === null)
      return;
    const i = this.Li.Ea(), n2 = this.Li.W(), s = this.Hv(), e2 = this.Tv ? this.wv.width - s.T : 0;
    n2.borderVisible && n2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: r2, verticalPixelRatio: h2 }) => {
      t3.fillStyle = n2.borderColor;
      const l2 = Math.max(1, Math.floor(h2)), a2 = Math.floor(0.5 * h2), o2 = Math.round(s.T * r2);
      t3.beginPath();
      for (const n3 of i)
        t3.rect(Math.floor(e2 * r2), Math.round(n3.Aa * h2) - a2, o2, l2);
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      var r2;
      t3.font = this.Uv(), t3.fillStyle = (r2 = n2.textColor) !== null && r2 !== void 0 ? r2 : this.mo.textColor, t3.textAlign = this.Tv ? "right" : "left", t3.textBaseline = "middle";
      const h2 = this.Tv ? Math.round(e2 - s.B) : Math.round(e2 + s.T + s.B), l2 = i.map((i2) => this.Mv.xi(t3, i2.Za));
      for (let n3 = i.length; n3--; ) {
        const s2 = i[n3];
        t3.fillText(s2.Za, h2, s2.Aa + l2[n3]);
      }
    });
  }
  Gv() {
    if (this.wv === null || this.Li === null)
      return;
    let t2 = this.wv.height / 2;
    const i = [], n2 = this.Li.No().slice(), s = this.nn.Kv(), e2 = this.Hv();
    this.Li === s.vr() && this.nn.Kv().No().forEach((t3) => {
      s.dr(t3) && n2.push(t3);
    });
    const r2 = this.Li.Ta()[0], h2 = this.Li;
    n2.forEach((n3) => {
      const e3 = n3.Rn(s, h2);
      e3.forEach((t3) => {
        t3.Vi(null), t3.Bi() && i.push(t3);
      }), r2 === n3 && e3.length > 0 && (t2 = e3[0].yi());
    }), i.forEach((t3) => t3.Vi(t3.yi())), this.Li.W().alignLabels && this.hp(i, e2, t2);
  }
  hp(t2, i, n2) {
    if (this.wv === null)
      return;
    const s = t2.filter((t3) => t3.yi() <= n2), e2 = t2.filter((t3) => t3.yi() > n2);
    s.sort((t3, i2) => i2.yi() - t3.yi()), s.length && e2.length && e2.push(s[0]), e2.sort((t3, i2) => t3.yi() - i2.yi());
    for (const n3 of t2) {
      const t3 = Math.floor(n3.zt(i) / 2), s2 = n3.yi();
      s2 > -t3 && s2 < t3 && n3.Vi(t3), s2 > this.wv.height - t3 && s2 < this.wv.height + t3 && n3.Vi(this.wv.height - t3);
    }
    for (let t3 = 1; t3 < s.length; t3++) {
      const n3 = s[t3], e3 = s[t3 - 1], r2 = e3.zt(i, !1), h2 = n3.yi(), l2 = e3.Ai();
      h2 > l2 - r2 && n3.Vi(l2 - r2);
    }
    for (let t3 = 1; t3 < e2.length; t3++) {
      const n3 = e2[t3], s2 = e2[t3 - 1], r2 = s2.zt(i, !0), h2 = n3.yi(), l2 = s2.Ai();
      h2 < l2 + r2 && n3.Vi(l2 + r2);
    }
  }
  ip(t2) {
    if (this.wv === null)
      return;
    const i = this.qv(), n2 = this.Hv(), s = this.Tv ? "right" : "left";
    i.forEach((i2) => {
      i2.Ii() && i2.xt(b(this.Li)).K(t2, n2, this.Mv, s);
    });
  }
  np(t2) {
    if (this.wv === null || this.Li === null)
      return;
    const i = this.nn.yv().qt(), n2 = [], s = this.nn.Kv(), e2 = i.Fc().Rn(s, this.Li);
    e2.length && n2.push(e2);
    const r2 = this.Hv(), h2 = this.Tv ? "right" : "left";
    n2.forEach((i2) => {
      i2.forEach((i3) => {
        i3.xt(b(this.Li)).K(t2, r2, this.Mv, h2);
      });
    });
  }
  rp(t2) {
    this.Ov.style.cursor = t2 === 1 ? "ns-resize" : "default";
  }
  ao() {
    const t2 = this.$v();
    this.xv < t2 && this.nn.yv().qt().$l(), this.xv = t2;
  }
  Uv() {
    return N$1(this.mo.fontSize, this.mo.fontFamily);
  }
};
__name(_xs, "xs");
let xs = _xs;
function Ss(t2, i) {
  var n2, s;
  return (s = (n2 = t2.ra) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(Ss, "Ss");
function ks(t2, i) {
  var n2, s;
  return (s = (n2 = t2.Pn) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(ks, "ks");
function ys(t2, i) {
  var n2, s;
  return (s = (n2 = t2.Qi) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(ys, "ys");
function Cs(t2, i) {
  var n2, s;
  return (s = (n2 = t2.na) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(Cs, "Cs");
const _Ts = class _Ts {
  constructor(i, n2) {
    this.wv = size({ width: 0, height: 0 }), this.lp = null, this.ap = null, this.op = null, this._p = !1, this.up = new R(), this.cp = new R(), this.dp = 0, this.fp = !1, this.vp = null, this.pp = !1, this.mp = null, this.bp = null, this.Sv = !1, this.kv = () => {
      this.Sv || this.wp === null || this.Ui().Fh();
    }, this.Cv = () => {
      this.Sv || this.wp === null || this.Ui().Fh();
    }, this.gp = i, this.wp = n2, this.wp.I_().l(this.Mp.bind(this), this, !0), this.xp = document.createElement("td"), this.xp.style.padding = "0", this.xp.style.position = "relative";
    const s = document.createElement("div");
    s.style.width = "100%", s.style.height = "100%", s.style.position = "relative", s.style.overflow = "hidden", this.Sp = document.createElement("td"), this.Sp.style.padding = "0", this.kp = document.createElement("td"), this.kp.style.padding = "0", this.xp.appendChild(s), this.Av = as(s, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const e2 = this.Av.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "1", e2.style.left = "0", e2.style.top = "0", this.Vv = as(s, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const r2 = this.Vv.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0", this.yp = document.createElement("tr"), this.yp.appendChild(this.Sp), this.yp.appendChild(this.xp), this.yp.appendChild(this.kp), this.Cp(), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => this.vp === null && !this.gp.W().handleScroll.vertTouchDrag, Ff: () => this.vp === null && !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.lp !== null && this.lp.S(), this.ap !== null && this.ap.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), this.wp !== null && this.wp.I_().p(this), this.Wv.S();
  }
  Kv() {
    return b(this.wp);
  }
  Tp(t2) {
    this.wp !== null && this.wp.I_().p(this), this.wp = t2, this.wp !== null && this.wp.I_().l(_Ts.prototype.Mp.bind(this), this, !0), this.Cp();
  }
  yv() {
    return this.gp;
  }
  jv() {
    return this.yp;
  }
  Cp() {
    if (this.wp !== null && (this.Pp(), this.Ui().Mt().length !== 0)) {
      if (this.lp !== null) {
        const t2 = this.wp.S_();
        this.lp.Ji(b(t2));
      }
      if (this.ap !== null) {
        const t2 = this.wp.k_();
        this.ap.Ji(b(t2));
      }
    }
  }
  Rp() {
    this.lp !== null && this.lp.gt(), this.ap !== null && this.ap.gt();
  }
  v_() {
    return this.wp !== null ? this.wp.v_() : 0;
  }
  p_(t2) {
    this.wp && this.wp.p_(t2);
  }
  Bf(t2) {
    if (!this.wp)
      return;
    this.Dp();
    const i = t2.localX, n2 = t2.localY;
    this.Op(i, n2, t2);
  }
  Qf(t2) {
    this.Dp(), this.Ap(), this.Op(t2.localX, t2.localY, t2);
  }
  If(t2) {
    var i;
    if (!this.wp)
      return;
    this.Dp();
    const n2 = t2.localX, s = t2.localY;
    this.Op(n2, s, t2);
    const e2 = this.br(n2, s);
    this.gp.Vp((i = e2 == null ? void 0 : e2.bv) !== null && i !== void 0 ? i : null), this.Ui().Bc(e2 && { Ic: e2.Ic, pv: e2.pv });
  }
  Xf(t2) {
    this.wp !== null && (this.Dp(), this.Bp(t2));
  }
  Tf(t2) {
    this.wp !== null && this.Ip(this.cp, t2);
  }
  Sf(t2) {
    this.Tf(t2);
  }
  Hf(t2) {
    this.Dp(), this.zp(t2), this.Op(t2.localX, t2.localY, t2);
  }
  Yf(t2) {
    this.wp !== null && (this.Dp(), this.fp = !1, this.Ep(t2));
  }
  qf(t2) {
    this.wp !== null && this.Bp(t2);
  }
  _v(t2) {
    if (this.fp = !0, this.vp === null) {
      const i = { x: t2.localX, y: t2.localY };
      this.Lp(i, i, t2);
    }
  }
  ov(t2) {
    this.wp !== null && (this.Dp(), this.wp.qt().Bc(null), this.Np());
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  sv() {
    this.dp = 1, this.Ui().Un();
  }
  ev(t2, i) {
    if (!this.gp.W().handleScale.pinch)
      return;
    const n2 = 5 * (i - this.dp);
    this.dp = i, this.Ui().Uc(t2.et, n2);
  }
  Gf(t2) {
    this.fp = !1, this.pp = this.vp !== null, this.Ap();
    const i = this.Ui().Fc();
    this.vp !== null && i.Tt() && (this.mp = { x: i.Kt(), y: i.Zt() }, this.vp = { x: t2.localX, y: t2.localY });
  }
  Wf(t2) {
    if (this.wp === null)
      return;
    const i = t2.localX, n2 = t2.localY;
    if (this.vp === null)
      this.zp(t2);
    else {
      this.pp = !1;
      const s = b(this.mp), e2 = s.x + (i - this.vp.x), r2 = s.y + (n2 - this.vp.y);
      this.Op(e2, r2, t2);
    }
  }
  Uf(t2) {
    this.yv().W().trackingMode.exitMode === 0 && (this.pp = !0), this.jp(), this.Ep(t2);
  }
  br(t2, i) {
    const n2 = this.wp;
    return n2 === null ? null : function(t3, i2, n3) {
      const s = t3.No(), e2 = function(t4, i3, n4) {
        var s2, e3;
        let r2, h2;
        for (const o2 of t4) {
          const t5 = (e3 = (s2 = o2.oa) === null || s2 === void 0 ? void 0 : s2.call(o2, i3, n4)) !== null && e3 !== void 0 ? e3 : [];
          for (const i4 of t5)
            l2 = i4.zOrder, (!(a2 = r2 == null ? void 0 : r2.zOrder) || l2 === "top" && a2 !== "top" || l2 === "normal" && a2 === "bottom") && (r2 = i4, h2 = o2);
        }
        var l2, a2;
        return r2 && h2 ? { mv: r2, Ic: h2 } : null;
      }(s, i2, n3);
      if ((e2 == null ? void 0 : e2.mv.zOrder) === "top")
        return ws(e2);
      for (const r2 of s) {
        if (e2 && e2.Ic === r2 && e2.mv.zOrder !== "bottom" && !e2.mv.isBackground)
          return ws(e2);
        const s2 = gs(r2.Pn(t3), i2, n3);
        if (s2 !== null)
          return { Ic: r2, fv: s2.fv, pv: s2.pv };
        if (e2 && e2.Ic === r2 && e2.mv.zOrder !== "bottom" && e2.mv.isBackground)
          return ws(e2);
      }
      return e2 != null && e2.mv ? ws(e2) : null;
    }(n2, t2, i);
  }
  Hp(i, n2) {
    b(n2 === "left" ? this.lp : this.ap).Yv(size({ width: i, height: this.wv.height }));
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = !0, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = !1, this.xp.style.width = t2.width + "px", this.xp.style.height = t2.height + "px");
  }
  Up() {
    const t2 = b(this.wp);
    t2.x_(t2.S_()), t2.x_(t2.k_());
    for (const i of t2.Ta())
      if (t2.dr(i)) {
        const n2 = i.At();
        n2 !== null && t2.x_(n2), i.On();
      }
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (t2 === 0 || this.wp === null)
      return;
    if (t2 > 1 && this.Up(), this.lp !== null && this.lp.Zv(t2), this.ap !== null && this.ap.Zv(t2), t2 !== 1) {
      this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      t3 !== null && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4);
      }), this.wp && (this.qp(t3, Ss), this.Yp(t3), this.Xp(t3), this.qp(t3, ks), this.qp(t3, ys)));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Kp(i), this.qp(i, Cs));
  }
  Zp() {
    return this.lp;
  }
  Gp() {
    return this.ap;
  }
  Qv(t2, i) {
    this.qp(t2, i);
  }
  Mp() {
    this.wp !== null && this.wp.I_().p(this), this.wp = null;
  }
  Bp(t2) {
    this.Ip(this.up, t2);
  }
  Ip(t2, i) {
    const n2 = i.localX, s = i.localY;
    t2.M() && t2.m(this.Ui().yt().Vu(n2), { x: n2, y: s }, i);
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e2 = this.Ui(), r2 = e2.q(), h2 = e2.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, h2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Yp(t2) {
    const i = b(this.wp).z_().Wh().xt();
    i !== null && i.K(t2, !1);
  }
  Xp(t2) {
    const i = this.Ui().Nc();
    this.Jp(t2, ks, os, i), this.Jp(t2, ks, _s, i);
  }
  Kp(t2) {
    this.Jp(t2, ks, _s, this.Ui().Fc());
  }
  qp(t2, i) {
    const n2 = b(this.wp).No();
    for (const s of n2)
      this.Jp(t2, i, os, s);
    for (const s of n2)
      this.Jp(t2, i, _s, s);
  }
  Jp(t2, i, n2, s) {
    const e2 = b(this.wp), r2 = e2.qt().Vc(), h2 = r2 !== null && r2.Ic === s, l2 = r2 !== null && h2 && r2.pv !== void 0 ? r2.pv.gr : void 0;
    us(i, (i2) => n2(i2, t2, h2, l2), s, e2);
  }
  Pp() {
    if (this.wp === null)
      return;
    const t2 = this.gp, i = this.wp.S_().W().visible, n2 = this.wp.k_().W().visible;
    i || this.lp === null || (this.Sp.removeChild(this.lp.jv()), this.lp.S(), this.lp = null), n2 || this.ap === null || (this.kp.removeChild(this.ap.jv()), this.ap.S(), this.ap = null);
    const s = t2.qt().sd();
    i && this.lp === null && (this.lp = new xs(this, t2.W(), s, "left"), this.Sp.appendChild(this.lp.jv())), n2 && this.ap === null && (this.ap = new xs(this, t2.W(), s, "right"), this.kp.appendChild(this.ap.jv()));
  }
  Qp(t2) {
    return t2.uv && this.fp || this.vp !== null;
  }
  tm(t2) {
    return Math.max(0, Math.min(t2, this.wv.width - 1));
  }
  im(t2) {
    return Math.max(0, Math.min(t2, this.wv.height - 1));
  }
  Op(t2, i, n2) {
    this.Ui().Jc(this.tm(t2), this.im(i), n2, b(this.wp));
  }
  Np() {
    this.Ui().td();
  }
  jp() {
    this.pp && (this.vp = null, this.Np());
  }
  Lp(t2, i, n2) {
    this.vp = t2, this.pp = !1, this.Op(i.x, i.y, n2);
    const s = this.Ui().Fc();
    this.mp = { x: s.Kt(), y: s.Zt() };
  }
  Ui() {
    return this.gp.qt();
  }
  Ep(t2) {
    if (!this._p)
      return;
    const i = this.Ui(), n2 = this.Kv();
    if (i.D_(n2, n2.vn()), this.op = null, this._p = !1, i.Kc(), this.bp !== null) {
      const t3 = performance.now(), n3 = i.yt();
      this.bp.Dr(n3.Eu(), t3), this.bp.Yu(t3) || i.Xn(this.bp);
    }
  }
  Dp() {
    this.vp = null;
  }
  Ap() {
    if (this.wp) {
      if (this.Ui().Un(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
        b(document.activeElement).blur();
      else {
        const t2 = document.getSelection();
        t2 !== null && t2.removeAllRanges();
      }
      !this.wp.vn().Fi() && this.Ui().yt().Fi();
    }
  }
  zp(t2) {
    if (this.wp === null)
      return;
    const i = this.Ui(), n2 = i.yt();
    if (n2.Fi())
      return;
    const s = this.gp.W(), e2 = s.handleScroll, r2 = s.kineticScroll;
    if ((!e2.pressedMouseMove || t2.uv) && (!e2.horzTouchDrag && !e2.vertTouchDrag || !t2.uv))
      return;
    const h2 = this.wp.vn(), l2 = performance.now();
    if (this.op !== null || this.Qp(t2) || (this.op = { x: t2.clientX, y: t2.clientY, kd: l2, nm: t2.localX, sm: t2.localY }), this.op !== null && !this._p && (this.op.x !== t2.clientX || this.op.y !== t2.clientY)) {
      if (t2.uv && r2.touch || !t2.uv && r2.mouse) {
        const t3 = n2.he();
        this.bp = new ls(0.2 / t3, 7 / t3, 0.997, 15 / t3), this.bp.Nd(n2.Eu(), this.op.kd);
      } else
        this.bp = null;
      h2.Fi() || i.P_(this.wp, h2, t2.localY), i.Yc(t2.localX), this._p = !0;
    }
    this._p && (h2.Fi() || i.R_(this.wp, h2, t2.localY), i.Xc(t2.localX), this.bp !== null && this.bp.Nd(n2.Eu(), l2));
  }
};
__name(_Ts, "Ts");
let Ts = _Ts;
const _Ps = class _Ps {
  constructor(i, n2, s, e2, r2) {
    this.bt = !0, this.wv = size({ width: 0, height: 0 }), this.kv = () => this.Zv(3), this.Tv = i === "left", this.kc = s.sd, this.cn = n2, this.rm = e2, this.hm = r2, this.Ov = document.createElement("div"), this.Ov.style.width = "25px", this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
  }
  S() {
    this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.Ov;
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Av.resizeCanvasElement(t2), this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`, this.bt = !0);
  }
  Zv(t2) {
    if (t2 < 3 && !this.bt || this.wv.width === 0 || this.wv.height === 0)
      return;
    this.bt = !1, this.Av.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Av);
    i !== null && i.useBitmapCoordinateSpace((t3) => {
      this.Jv(t3), this.Be(t3);
    });
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (!this.rm())
      return;
    t2.fillStyle = this.cn.timeScale.borderColor;
    const e2 = Math.floor(this.kc.W().C * n2), r2 = Math.floor(this.kc.W().C * s), h2 = this.Tv ? i.width - e2 : 0;
    t2.fillRect(h2, 0, e2, r2);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.hm());
  }
};
__name(_Ps, "Ps");
let Ps = _Ps;
function Rs(t2) {
  return (i) => {
    var n2, s;
    return (s = (n2 = i.aa) === null || n2 === void 0 ? void 0 : n2.call(i, t2)) !== null && s !== void 0 ? s : [];
  };
}
__name(Rs, "Rs");
const Ds = Rs("normal"), Os = Rs("top"), As = Rs("bottom"), _Vs = class _Vs {
  constructor(i, n2) {
    this.lm = null, this.am = null, this.k = null, this.om = !1, this.wv = size({ width: 0, height: 0 }), this._m = new R(), this.Mv = new si(5), this.Sv = !1, this.kv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.gp = i, this.N_ = n2, this.cn = i.W().layout, this.um = document.createElement("tr"), this.dm = document.createElement("td"), this.dm.style.padding = "0", this.fm = document.createElement("td"), this.fm.style.padding = "0", this.Ov = document.createElement("td"), this.Ov.style.height = "25px", this.Ov.style.padding = "0", this.vm = document.createElement("div"), this.vm.style.width = "100%", this.vm.style.height = "100%", this.vm.style.position = "relative", this.vm.style.overflow = "hidden", this.Ov.appendChild(this.vm), this.Av = as(this.vm, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const s = this.Av.canvasElement;
    s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Vv = as(this.vm, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const e2 = this.Vv.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "2", e2.style.left = "0", e2.style.top = "0", this.um.appendChild(this.dm), this.um.appendChild(this.Ov), this.um.appendChild(this.fm), this.pm(), this.gp.qt().f_().l(this.pm.bind(this), this), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => !0, Ff: () => !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.Wv.S(), this.lm !== null && this.lm.S(), this.am !== null && this.am.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.um;
  }
  bm() {
    return this.lm;
  }
  wm() {
    return this.am;
  }
  Qf(t2) {
    if (this.om)
      return;
    this.om = !0;
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.$c(t2.localX);
  }
  Gf(t2) {
    this.Qf(t2);
  }
  tv() {
    const t2 = this.gp.qt();
    !t2.yt().Fi() && this.om && (this.om = !1, this.gp.W().handleScale.axisPressedMouseMove.time && t2.Gc());
  }
  Hf(t2) {
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.Zc(t2.localX);
  }
  Wf(t2) {
    this.Hf(t2);
  }
  Yf() {
    this.om = !1;
    const t2 = this.gp.qt();
    t2.yt().Fi() && !this.gp.W().handleScale.axisPressedMouseMove.time || t2.Gc();
  }
  Uf() {
    this.Yf();
  }
  Tf() {
    this.gp.W().handleScale.axisDoubleClickReset.time && this.gp.qt().Zn();
  }
  Sf() {
    this.Tf();
  }
  Bf() {
    this.gp.qt().W().handleScale.axisPressedMouseMove.time && this.rp(1);
  }
  ov() {
    this.rp(0);
  }
  $p() {
    return this.wv;
  }
  gm() {
    return this._m;
  }
  Mm(i, s, e2) {
    equalSizes(this.wv, i) || (this.wv = i, this.Sv = !0, this.Av.resizeCanvasElement(i), this.Vv.resizeCanvasElement(i), this.Sv = !1, this.Ov.style.width = `${i.width}px`, this.Ov.style.height = `${i.height}px`, this._m.m(i)), this.lm !== null && this.lm.Yv(size({ width: s, height: i.height })), this.am !== null && this.am.Yv(size({ width: e2, height: i.height }));
  }
  xm() {
    const t2 = this.Sm();
    return Math.ceil(t2.C + t2.T + t2.P + t2.L + t2.V + t2.km);
  }
  gt() {
    this.gp.qt().yt().Ea();
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (t2 === 0)
      return;
    if (t2 !== 1) {
      this.Av.applySuggestedBitmapSize();
      const i2 = tryCreateCanvasRenderingTarget2D(this.Av);
      i2 !== null && (i2.useBitmapCoordinateSpace((t3) => {
        this.Jv(t3), this.Be(t3), this.ym(i2, As);
      }), this.tp(i2), this.ym(i2, Ds)), this.lm !== null && this.lm.Zv(t2), this.am !== null && this.am.Zv(t2);
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Cm([...this.gp.qt().Mt(), this.gp.qt().Fc()], i), this.ym(i, Os));
  }
  ym(t2, i) {
    const n2 = this.gp.qt().Mt();
    for (const s of n2)
      us(i, (i2) => os(i2, t2, !1, void 0), s, void 0);
    for (const s of n2)
      us(i, (i2) => _s(i2, t2, !1, void 0), s, void 0);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.gp.qt().od());
  }
  Be({ context: t2, bitmapSize: i, verticalPixelRatio: n2 }) {
    if (this.gp.W().timeScale.borderVisible) {
      t2.fillStyle = this.Tm();
      const s = Math.max(1, Math.floor(this.Sm().C * n2));
      t2.fillRect(0, 0, i.width, s);
    }
  }
  tp(t2) {
    const i = this.gp.qt().yt(), n2 = i.Ea();
    if (!n2 || n2.length === 0)
      return;
    const s = this.N_.maxTickMarkWeight(n2), e2 = this.Sm(), r2 = i.W();
    r2.borderVisible && r2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) => {
      t3.strokeStyle = this.Tm(), t3.fillStyle = this.Tm();
      const r3 = Math.max(1, Math.floor(i2)), h2 = Math.floor(0.5 * i2);
      t3.beginPath();
      const l2 = Math.round(e2.T * s2);
      for (let s3 = n2.length; s3--; ) {
        const e3 = Math.round(n2[s3].coord * i2);
        t3.rect(e3 - h2, 0, r3, l2);
      }
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const i2 = e2.C + e2.T + e2.L + e2.P / 2;
      t3.textAlign = "center", t3.textBaseline = "middle", t3.fillStyle = this.$(), t3.font = this.Uv();
      for (const e3 of n2)
        if (e3.weight < s) {
          const n3 = e3.needAlignCoordinate ? this.Pm(t3, e3.coord, e3.label) : e3.coord;
          t3.fillText(e3.label, n3, i2);
        }
      t3.font = this.Rm();
      for (const e3 of n2)
        if (e3.weight >= s) {
          const n3 = e3.needAlignCoordinate ? this.Pm(t3, e3.coord, e3.label) : e3.coord;
          t3.fillText(e3.label, n3, i2);
        }
    });
  }
  Pm(t2, i, n2) {
    const s = this.Mv.Si(t2, n2), e2 = s / 2, r2 = Math.floor(i - e2) + 0.5;
    return r2 < 0 ? i += Math.abs(0 - r2) : r2 + s > this.wv.width && (i -= Math.abs(this.wv.width - (r2 + s))), i;
  }
  Cm(t2, i) {
    const n2 = this.Sm();
    for (const s of t2)
      for (const t3 of s.tn())
        t3.xt().K(i, n2);
  }
  Tm() {
    return this.gp.W().timeScale.borderColor;
  }
  $() {
    return this.cn.textColor;
  }
  j() {
    return this.cn.fontSize;
  }
  Uv() {
    return N$1(this.j(), this.cn.fontFamily);
  }
  Rm() {
    return N$1(this.j(), this.cn.fontFamily, "bold");
  }
  Sm() {
    this.k === null && (this.k = { C: 1, N: NaN, L: NaN, V: NaN, Hi: NaN, T: 5, P: NaN, R: "", ji: new si(), km: 0 });
    const t2 = this.k, i = this.Uv();
    if (t2.R !== i) {
      const n2 = this.j();
      t2.P = n2, t2.R = i, t2.L = 3 * n2 / 12, t2.V = 3 * n2 / 12, t2.Hi = 9 * n2 / 12, t2.N = 0, t2.km = 4 * n2 / 12, t2.ji.ir();
    }
    return this.k;
  }
  rp(t2) {
    this.Ov.style.cursor = t2 === 1 ? "ew-resize" : "default";
  }
  pm() {
    const t2 = this.gp.qt(), i = t2.W();
    i.leftPriceScale.visible || this.lm === null || (this.dm.removeChild(this.lm.jv()), this.lm.S(), this.lm = null), i.rightPriceScale.visible || this.am === null || (this.fm.removeChild(this.am.jv()), this.am.S(), this.am = null);
    const n2 = { sd: this.gp.qt().sd() }, s = /* @__PURE__ */ __name(() => i.leftPriceScale.borderVisible && t2.yt().W().borderVisible, "s"), e2 = /* @__PURE__ */ __name(() => t2.od(), "e");
    i.leftPriceScale.visible && this.lm === null && (this.lm = new Ps("left", i, n2, s, e2), this.dm.appendChild(this.lm.jv())), i.rightPriceScale.visible && this.am === null && (this.am = new Ps("right", i, n2, s, e2), this.fm.appendChild(this.am.jv()));
  }
};
__name(_Vs, "Vs");
let Vs = _Vs;
const Bs = !!is && !!navigator.userAgentData && navigator.userAgentData.brands.some((t2) => t2.brand.includes("Chromium")) && !!is && (!((Is = navigator == null ? void 0 : navigator.userAgentData) === null || Is === void 0) && Is.platform ? navigator.userAgentData.platform === "Windows" : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
var Is;
const _zs = class _zs {
  constructor(t2, i, n2) {
    var s;
    this.Dm = [], this.Om = 0, this.Qa = 0, this.e_ = 0, this.Am = 0, this.Vm = 0, this.Bm = null, this.Im = !1, this.up = new R(), this.cp = new R(), this.Mc = new R(), this.zm = null, this.Em = null, this.Lm = t2, this.cn = i, this.N_ = n2, this.um = document.createElement("div"), this.um.classList.add("tv-lightweight-charts"), this.um.style.overflow = "hidden", this.um.style.direction = "ltr", this.um.style.width = "100%", this.um.style.height = "100%", (s = this.um).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.Nm = document.createElement("table"), this.Nm.setAttribute("cellspacing", "0"), this.um.appendChild(this.Nm), this.Fm = this.Wm.bind(this), Es(this.cn) && this.jm(!0), this.Ui = new zn(this.Sc.bind(this), this.cn, n2), this.qt().Wc().l(this.Hm.bind(this), this), this.$m = new Vs(this, this.N_), this.Nm.appendChild(this.$m.jv());
    const e2 = i.autoSize && this.Um();
    let r2 = this.cn.width, h2 = this.cn.height;
    if (e2 || r2 === 0 || h2 === 0) {
      const i2 = t2.getBoundingClientRect();
      r2 = r2 || i2.width, h2 = h2 || i2.height;
    }
    this.qm(r2, h2), this.Ym(), t2.appendChild(this.um), this.Xm(), this.Ui.yt().Gu().l(this.Ui.$l.bind(this.Ui), this), this.Ui.f_().l(this.Ui.$l.bind(this.Ui), this);
  }
  qt() {
    return this.Ui;
  }
  W() {
    return this.cn;
  }
  Km() {
    return this.Dm;
  }
  Zm() {
    return this.$m;
  }
  S() {
    this.jm(!1), this.Om !== 0 && window.cancelAnimationFrame(this.Om), this.Ui.Wc().p(this), this.Ui.yt().Gu().p(this), this.Ui.f_().p(this), this.Ui.S();
    for (const t2 of this.Dm)
      this.Nm.removeChild(t2.jv()), t2.Fp().p(this), t2.Wp().p(this), t2.S();
    this.Dm = [], b(this.$m).S(), this.um.parentElement !== null && this.um.parentElement.removeChild(this.um), this.Mc.S(), this.up.S(), this.cp.S(), this.Gm();
  }
  qm(i, n2, s = !1) {
    if (this.Qa === n2 && this.e_ === i)
      return;
    const e2 = function(i2) {
      const n3 = Math.floor(i2.width), s2 = Math.floor(i2.height);
      return size({ width: n3 - n3 % 2, height: s2 - s2 % 2 });
    }(size({ width: i, height: n2 }));
    this.Qa = e2.height, this.e_ = e2.width;
    const r2 = this.Qa + "px", h2 = this.e_ + "px";
    b(this.um).style.height = r2, b(this.um).style.width = h2, this.Nm.style.height = r2, this.Nm.style.width = h2, s ? this.Jm(ct.es(), performance.now()) : this.Ui.$l();
  }
  Zv(t2) {
    t2 === void 0 && (t2 = ct.es());
    for (let i = 0; i < this.Dm.length; i++)
      this.Dm[i].Zv(t2.Hn(i).Fn);
    this.cn.timeScale.visible && this.$m.Zv(t2.jn());
  }
  Nh(t2) {
    const i = Es(this.cn);
    this.Ui.Nh(t2);
    const n2 = Es(this.cn);
    n2 !== i && this.jm(n2), this.Xm(), this.Qm(t2);
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  Wc() {
    return this.Mc;
  }
  tb() {
    this.Bm !== null && (this.Jm(this.Bm, performance.now()), this.Bm = null);
    const t2 = this.ib(null), i = document.createElement("canvas");
    i.width = t2.width, i.height = t2.height;
    const n2 = b(i.getContext("2d"));
    return this.ib(n2), i;
  }
  nb(t2) {
    return t2 === "left" && !this.sb() || t2 === "right" && !this.eb() || this.Dm.length === 0 ? 0 : b(t2 === "left" ? this.Dm[0].Zp() : this.Dm[0].Gp()).Xv();
  }
  rb() {
    return this.cn.autoSize && this.zm !== null;
  }
  hb() {
    return this.um;
  }
  Vp(t2) {
    this.Em = t2, this.Em ? this.hb().style.setProperty("cursor", t2) : this.hb().style.removeProperty("cursor");
  }
  lb() {
    return this.Em;
  }
  ab() {
    return m$1(this.Dm[0]).$p();
  }
  Qm(t2) {
    (t2.autoSize !== void 0 || !this.zm || t2.width === void 0 && t2.height === void 0) && (t2.autoSize && !this.zm && this.Um(), t2.autoSize === !1 && this.zm !== null && this.Gm(), t2.autoSize || t2.width === void 0 && t2.height === void 0 || this.qm(t2.width || this.e_, t2.height || this.Qa));
  }
  ib(i) {
    let n2 = 0, s = 0;
    const e2 = this.Dm[0], r2 = /* @__PURE__ */ __name((t2, n3) => {
      let s2 = 0;
      for (let e3 = 0; e3 < this.Dm.length; e3++) {
        const r3 = this.Dm[e3], h3 = b(t2 === "left" ? r3.Zp() : r3.Gp()), l2 = h3.sp();
        i !== null && h3.ep(i, n3, s2), s2 += l2.height;
      }
    }, "r");
    this.sb() && (r2("left", 0), n2 += b(e2.Zp()).sp().width);
    for (let t2 = 0; t2 < this.Dm.length; t2++) {
      const e3 = this.Dm[t2], r3 = e3.sp();
      i !== null && e3.ep(i, n2, s), s += r3.height;
    }
    n2 += e2.sp().width, this.eb() && (r2("right", n2), n2 += b(e2.Gp()).sp().width);
    const h2 = /* @__PURE__ */ __name((t2, n3, s2) => {
      b(t2 === "left" ? this.$m.bm() : this.$m.wm()).ep(b(i), n3, s2);
    }, "h");
    if (this.cn.timeScale.visible) {
      const t2 = this.$m.sp();
      if (i !== null) {
        let n3 = 0;
        this.sb() && (h2("left", n3, s), n3 = b(e2.Zp()).sp().width), this.$m.ep(i, n3, s), n3 += t2.width, this.eb() && h2("right", n3, s);
      }
      s += t2.height;
    }
    return size({ width: n2, height: s });
  }
  ob() {
    let i = 0, n2 = 0, s = 0;
    for (const t2 of this.Dm)
      this.sb() && (n2 = Math.max(n2, b(t2.Zp()).$v(), this.cn.leftPriceScale.minimumWidth)), this.eb() && (s = Math.max(s, b(t2.Gp()).$v(), this.cn.rightPriceScale.minimumWidth)), i += t2.v_();
    n2 = es(n2), s = es(s);
    const e2 = this.e_, r2 = this.Qa, h2 = Math.max(e2 - n2 - s, 0), l2 = this.cn.timeScale.visible;
    let a2 = l2 ? Math.max(this.$m.xm(), this.cn.timeScale.minimumHeight) : 0;
    var o2;
    a2 = (o2 = a2) + o2 % 2;
    const _24 = 0 + a2, u2 = r2 < _24 ? 0 : r2 - _24, c2 = u2 / i;
    let d2 = 0;
    for (let i2 = 0; i2 < this.Dm.length; ++i2) {
      const e3 = this.Dm[i2];
      e3.Tp(this.Ui.Lc()[i2]);
      let r3 = 0, l3 = 0;
      l3 = i2 === this.Dm.length - 1 ? u2 - d2 : Math.round(e3.v_() * c2), r3 = Math.max(l3, 2), d2 += r3, e3.Yv(size({ width: h2, height: r3 })), this.sb() && e3.Hp(n2, "left"), this.eb() && e3.Hp(s, "right"), e3.Kv() && this.Ui.jc(e3.Kv(), r3);
    }
    this.$m.Mm(size({ width: l2 ? h2 : 0, height: a2 }), l2 ? n2 : 0, l2 ? s : 0), this.Ui.m_(h2), this.Am !== n2 && (this.Am = n2), this.Vm !== s && (this.Vm = s);
  }
  jm(t2) {
    t2 ? this.um.addEventListener("wheel", this.Fm, { passive: !1 }) : this.um.removeEventListener("wheel", this.Fm);
  }
  _b(t2) {
    switch (t2.deltaMode) {
      case t2.DOM_DELTA_PAGE:
        return 120;
      case t2.DOM_DELTA_LINE:
        return 32;
    }
    return Bs ? 1 / window.devicePixelRatio : 1;
  }
  Wm(t2) {
    if (!(t2.deltaX !== 0 && this.cn.handleScroll.mouseWheel || t2.deltaY !== 0 && this.cn.handleScale.mouseWheel))
      return;
    const i = this._b(t2), n2 = i * t2.deltaX / 100, s = -i * t2.deltaY / 100;
    if (t2.cancelable && t2.preventDefault(), s !== 0 && this.cn.handleScale.mouseWheel) {
      const i2 = Math.sign(s) * Math.min(1, Math.abs(s)), n3 = t2.clientX - this.um.getBoundingClientRect().left;
      this.qt().Uc(n3, i2);
    }
    n2 !== 0 && this.cn.handleScroll.mouseWheel && this.qt().qc(-80 * n2);
  }
  Jm(t2, i) {
    var n2;
    const s = t2.jn();
    s === 3 && this.ub(), s !== 3 && s !== 2 || (this.cb(t2), this.fb(t2, i), this.$m.gt(), this.Dm.forEach((t3) => {
      t3.Rp();
    }), ((n2 = this.Bm) === null || n2 === void 0 ? void 0 : n2.jn()) === 3 && (this.Bm.ts(t2), this.ub(), this.cb(this.Bm), this.fb(this.Bm, i), t2 = this.Bm, this.Bm = null)), this.Zv(t2);
  }
  fb(t2, i) {
    for (const n2 of t2.Qn())
      this.ns(n2, i);
  }
  cb(t2) {
    const i = this.Ui.Lc();
    for (let n2 = 0; n2 < i.length; n2++)
      t2.Hn(n2).Wn && i[n2].V_();
  }
  ns(t2, i) {
    const n2 = this.Ui.yt();
    switch (t2.qn) {
      case 0:
        n2.Qu();
        break;
      case 1:
        n2.tc(t2.Vt);
        break;
      case 2:
        n2.Gn(t2.Vt);
        break;
      case 3:
        n2.Jn(t2.Vt);
        break;
      case 4:
        n2.Fu();
        break;
      case 5:
        t2.Vt.Yu(i) || n2.Jn(t2.Vt.Xu(i));
    }
  }
  Sc(t2) {
    this.Bm !== null ? this.Bm.ts(t2) : this.Bm = t2, this.Im || (this.Im = !0, this.Om = window.requestAnimationFrame((t3) => {
      if (this.Im = !1, this.Om = 0, this.Bm !== null) {
        const i = this.Bm;
        this.Bm = null, this.Jm(i, t3);
        for (const n2 of i.Qn())
          if (n2.qn === 5 && !n2.Vt.Yu(t3)) {
            this.qt().Xn(n2.Vt);
            break;
          }
      }
    }));
  }
  ub() {
    this.Ym();
  }
  Ym() {
    const t2 = this.Ui.Lc(), i = t2.length, n2 = this.Dm.length;
    for (let t3 = i; t3 < n2; t3++) {
      const t4 = m$1(this.Dm.pop());
      this.Nm.removeChild(t4.jv()), t4.Fp().p(this), t4.Wp().p(this), t4.S();
    }
    for (let s = n2; s < i; s++) {
      const i2 = new Ts(this, t2[s]);
      i2.Fp().l(this.vb.bind(this), this), i2.Wp().l(this.pb.bind(this), this), this.Dm.push(i2), this.Nm.insertBefore(i2.jv(), this.$m.jv());
    }
    for (let n3 = 0; n3 < i; n3++) {
      const i2 = t2[n3], s = this.Dm[n3];
      s.Kv() !== i2 ? s.Tp(i2) : s.Cp();
    }
    this.Xm(), this.ob();
  }
  mb(t2, i, n2) {
    var s;
    const e2 = /* @__PURE__ */ new Map();
    t2 !== null && this.Ui.Mt().forEach((i2) => {
      const n3 = i2.In().nl(t2);
      n3 !== null && e2.set(i2, n3);
    });
    let r2;
    if (t2 !== null) {
      const i2 = (s = this.Ui.yt().qi(t2)) === null || s === void 0 ? void 0 : s.originalTime;
      i2 !== void 0 && (r2 = i2);
    }
    const h2 = this.qt().Vc(), l2 = h2 !== null && h2.Ic instanceof Gi ? h2.Ic : void 0, a2 = h2 !== null && h2.pv !== void 0 ? h2.pv.wr : void 0;
    return { bb: r2, se: t2 ?? void 0, wb: i ?? void 0, gb: l2, Mb: e2, xb: a2, Sb: n2 ?? void 0 };
  }
  vb(t2, i, n2) {
    this.up.m(() => this.mb(t2, i, n2));
  }
  pb(t2, i, n2) {
    this.cp.m(() => this.mb(t2, i, n2));
  }
  Hm(t2, i, n2) {
    this.Mc.m(() => this.mb(t2, i, n2));
  }
  Xm() {
    const t2 = this.cn.timeScale.visible ? "" : "none";
    this.$m.jv().style.display = t2;
  }
  sb() {
    return this.Dm[0].Kv().S_().W().visible;
  }
  eb() {
    return this.Dm[0].Kv().k_().W().visible;
  }
  Um() {
    return "ResizeObserver" in window && (this.zm = new ResizeObserver((t2) => {
      const i = t2.find((t3) => t3.target === this.Lm);
      i && this.qm(i.contentRect.width, i.contentRect.height);
    }), this.zm.observe(this.Lm, { box: "border-box" }), !0);
  }
  Gm() {
    this.zm !== null && this.zm.disconnect(), this.zm = null;
  }
};
__name(_zs, "zs");
let zs = _zs;
function Es(t2) {
  return !!(t2.handleScroll.mouseWheel || t2.handleScale.mouseWheel);
}
__name(Es, "Es");
function Ls(t2, i) {
  var n2 = {};
  for (var s in t2)
    Object.prototype.hasOwnProperty.call(t2, s) && i.indexOf(s) < 0 && (n2[s] = t2[s]);
  if (t2 != null && typeof Object.getOwnPropertySymbols == "function") {
    var e2 = 0;
    for (s = Object.getOwnPropertySymbols(t2); e2 < s.length; e2++)
      i.indexOf(s[e2]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, s[e2]) && (n2[s[e2]] = t2[s[e2]]);
  }
  return n2;
}
__name(Ls, "Ls");
function Ns(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.color !== void 0 && (r2.O = n2.color), r2;
}
__name(Ns, "Ns");
function Fs(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.lineColor !== void 0 && (r2._t = n2.lineColor), n2.topColor !== void 0 && (r2.Ts = n2.topColor), n2.bottomColor !== void 0 && (r2.Ps = n2.bottomColor), r2;
}
__name(Fs, "Fs");
function Ws(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.topLineColor !== void 0 && (r2.Pe = n2.topLineColor), n2.bottomLineColor !== void 0 && (r2.Re = n2.bottomLineColor), n2.topFillColor1 !== void 0 && (r2.Se = n2.topFillColor1), n2.topFillColor2 !== void 0 && (r2.ke = n2.topFillColor2), n2.bottomFillColor1 !== void 0 && (r2.ye = n2.bottomFillColor1), n2.bottomFillColor2 !== void 0 && (r2.Ce = n2.bottomFillColor2), r2;
}
__name(Ws, "Ws");
function js(t2, i, n2, s) {
  const e2 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return n2.color !== void 0 && (e2.O = n2.color), e2;
}
__name(js, "js");
function Hs(t2, i, n2, s) {
  const e2 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return n2.color !== void 0 && (e2.O = n2.color), n2.borderColor !== void 0 && (e2.Bt = n2.borderColor), n2.wickColor !== void 0 && (e2.$h = n2.wickColor), e2;
}
__name(Hs, "Hs");
function $s(t2, i, n2, s, e2) {
  const r2 = m$1(e2)(n2), h2 = Math.max(...r2), l2 = Math.min(...r2), a2 = r2[r2.length - 1], o2 = [a2, h2, l2, a2], _24 = n2, { time: u2, color: c2 } = _24;
  return { se: i, ut: t2, Vt: o2, bb: s, He: Ls(_24, ["time", "color"]), O: c2 };
}
__name($s, "$s");
function Us(t2) {
  return t2.Vt !== void 0;
}
__name(Us, "Us");
function qs(t2, i) {
  return i.customValues !== void 0 && (t2.kb = i.customValues), t2;
}
__name(qs, "qs");
function Ys(t2) {
  return (i, n2, s, e2, r2, h2) => function(t3, i2) {
    return i2 ? i2(t3) : (n3 = t3).open === void 0 && n3.value === void 0;
    var n3;
  }(s, h2) ? qs({ ut: i, se: n2, bb: e2 }, s) : qs(t2(i, n2, s, e2, r2), s);
}
__name(Ys, "Ys");
function Xs(t2) {
  return { Candlestick: Ys(Hs), Bar: Ys(js), Area: Ys(Fs), Baseline: Ys(Ws), Histogram: Ys(Ns), Line: Ys(Ns), Custom: Ys($s) }[t2];
}
__name(Xs, "Xs");
function Ks(t2) {
  return { se: 0, yb: /* @__PURE__ */ new Map(), ia: t2 };
}
__name(Ks, "Ks");
function Zs(t2, i) {
  if (t2 !== void 0 && t2.length !== 0)
    return { Cb: i.key(t2[0].ut), Tb: i.key(t2[t2.length - 1].ut) };
}
__name(Zs, "Zs");
function Gs(t2) {
  let i;
  return t2.forEach((t3) => {
    i === void 0 && (i = t3.bb);
  }), m$1(i);
}
__name(Gs, "Gs");
const _Js = class _Js {
  constructor(t2) {
    this.Pb = /* @__PURE__ */ new Map(), this.Rb = /* @__PURE__ */ new Map(), this.Db = /* @__PURE__ */ new Map(), this.Ob = [], this.N_ = t2;
  }
  S() {
    this.Pb.clear(), this.Rb.clear(), this.Db.clear(), this.Ob = [];
  }
  Ab(t2, i) {
    let n2 = this.Pb.size !== 0, s = !1;
    const e2 = this.Rb.get(t2);
    if (e2 !== void 0)
      if (this.Rb.size === 1)
        n2 = !1, s = !0, this.Pb.clear();
      else
        for (const i2 of this.Ob)
          i2.pointData.yb.delete(t2) && (s = !0);
    let r2 = [];
    if (i.length !== 0) {
      const n3 = i.map((t3) => t3.time), e3 = this.N_.createConverterToInternalObj(i), h3 = Xs(t2.Xh()), l2 = t2.ga(), a2 = t2.Ma();
      r2 = i.map((i2, r3) => {
        const o2 = e3(i2.time), _24 = this.N_.key(o2);
        let u2 = this.Pb.get(_24);
        u2 === void 0 && (u2 = Ks(o2), this.Pb.set(_24, u2), s = !0);
        const c2 = h3(o2, u2.se, i2, n3[r3], l2, a2);
        return u2.yb.set(t2, c2), c2;
      });
    }
    n2 && this.Vb(), this.Bb(t2, r2);
    let h2 = -1;
    if (s) {
      const t3 = [];
      this.Pb.forEach((i2) => {
        t3.push({ timeWeight: 0, time: i2.ia, pointData: i2, originalTime: Gs(i2.yb) });
      }), t3.sort((t4, i2) => this.N_.key(t4.time) - this.N_.key(i2.time)), h2 = this.Ib(t3);
    }
    return this.zb(t2, h2, function(t3, i2, n3) {
      const s2 = Zs(t3, n3), e3 = Zs(i2, n3);
      if (s2 !== void 0 && e3 !== void 0)
        return { Xl: s2.Tb >= e3.Tb && s2.Cb >= e3.Cb };
    }(this.Rb.get(t2), e2, this.N_));
  }
  hd(t2) {
    return this.Ab(t2, []);
  }
  Eb(t2, i) {
    const n2 = i;
    (function(t3) {
      t3.bb === void 0 && (t3.bb = t3.time);
    })(n2), this.N_.preprocessData(i);
    const s = this.N_.createConverterToInternalObj([i])(i.time), e2 = this.Db.get(t2);
    if (e2 !== void 0 && this.N_.key(s) < this.N_.key(e2))
      throw new Error(`Cannot update oldest data, last time=${e2}, new time=${s}`);
    let r2 = this.Pb.get(this.N_.key(s));
    const h2 = r2 === void 0;
    r2 === void 0 && (r2 = Ks(s), this.Pb.set(this.N_.key(s), r2));
    const l2 = Xs(t2.Xh()), a2 = t2.ga(), o2 = t2.Ma(), _24 = l2(s, r2.se, i, n2.bb, a2, o2);
    r2.yb.set(t2, _24), this.Lb(t2, _24);
    const u2 = { Xl: Us(_24) };
    if (!h2)
      return this.zb(t2, -1, u2);
    const c2 = { timeWeight: 0, time: r2.ia, pointData: r2, originalTime: Gs(r2.yb) }, d2 = Bt$1(this.Ob, this.N_.key(c2.time), (t3, i2) => this.N_.key(t3.time) < i2);
    this.Ob.splice(d2, 0, c2);
    for (let t3 = d2; t3 < this.Ob.length; ++t3)
      Qs(this.Ob[t3].pointData, t3);
    return this.N_.fillWeightsForPoints(this.Ob, d2), this.zb(t2, d2, u2);
  }
  Lb(t2, i) {
    let n2 = this.Rb.get(t2);
    n2 === void 0 && (n2 = [], this.Rb.set(t2, n2));
    const s = n2.length !== 0 ? n2[n2.length - 1] : null;
    s === null || this.N_.key(i.ut) > this.N_.key(s.ut) ? Us(i) && n2.push(i) : Us(i) ? n2[n2.length - 1] = i : n2.splice(-1, 1), this.Db.set(t2, i.ut);
  }
  Bb(t2, i) {
    i.length !== 0 ? (this.Rb.set(t2, i.filter(Us)), this.Db.set(t2, i[i.length - 1].ut)) : (this.Rb.delete(t2), this.Db.delete(t2));
  }
  Vb() {
    for (const t2 of this.Ob)
      t2.pointData.yb.size === 0 && this.Pb.delete(this.N_.key(t2.time));
  }
  Ib(t2) {
    let i = -1;
    for (let n2 = 0; n2 < this.Ob.length && n2 < t2.length; ++n2) {
      const s = this.Ob[n2], e2 = t2[n2];
      if (this.N_.key(s.time) !== this.N_.key(e2.time)) {
        i = n2;
        break;
      }
      e2.timeWeight = s.timeWeight, Qs(e2.pointData, n2);
    }
    if (i === -1 && this.Ob.length !== t2.length && (i = Math.min(this.Ob.length, t2.length)), i === -1)
      return -1;
    for (let n2 = i; n2 < t2.length; ++n2)
      Qs(t2[n2].pointData, n2);
    return this.N_.fillWeightsForPoints(t2, i), this.Ob = t2, i;
  }
  Nb() {
    if (this.Rb.size === 0)
      return null;
    let t2 = 0;
    return this.Rb.forEach((i) => {
      i.length !== 0 && (t2 = Math.max(t2, i[i.length - 1].se));
    }), t2;
  }
  zb(t2, i, n2) {
    const s = { Fb: /* @__PURE__ */ new Map(), yt: { Au: this.Nb() } };
    if (i !== -1)
      this.Rb.forEach((i2, e2) => {
        s.Fb.set(e2, { He: i2, Wb: e2 === t2 ? n2 : void 0 });
      }), this.Rb.has(t2) || s.Fb.set(t2, { He: [], Wb: n2 }), s.yt.jb = this.Ob, s.yt.Hb = i;
    else {
      const i2 = this.Rb.get(t2);
      s.Fb.set(t2, { He: i2 || [], Wb: n2 });
    }
    return s;
  }
};
__name(_Js, "Js");
let Js = _Js;
function Qs(t2, i) {
  t2.se = i, t2.yb.forEach((t3) => {
    t3.se = i;
  });
}
__name(Qs, "Qs");
function te$1(t2) {
  const i = { value: t2.Vt[3], time: t2.bb };
  return t2.kb !== void 0 && (i.customValues = t2.kb), i;
}
__name(te$1, "te$1");
function ie$1(t2) {
  const i = te$1(t2);
  return t2.O !== void 0 && (i.color = t2.O), i;
}
__name(ie$1, "ie$1");
function ne(t2) {
  const i = te$1(t2);
  return t2._t !== void 0 && (i.lineColor = t2._t), t2.Ts !== void 0 && (i.topColor = t2.Ts), t2.Ps !== void 0 && (i.bottomColor = t2.Ps), i;
}
__name(ne, "ne");
function se$1(t2) {
  const i = te$1(t2);
  return t2.Pe !== void 0 && (i.topLineColor = t2.Pe), t2.Re !== void 0 && (i.bottomLineColor = t2.Re), t2.Se !== void 0 && (i.topFillColor1 = t2.Se), t2.ke !== void 0 && (i.topFillColor2 = t2.ke), t2.ye !== void 0 && (i.bottomFillColor1 = t2.ye), t2.Ce !== void 0 && (i.bottomFillColor2 = t2.Ce), i;
}
__name(se$1, "se$1");
function ee$1(t2) {
  const i = { open: t2.Vt[0], high: t2.Vt[1], low: t2.Vt[2], close: t2.Vt[3], time: t2.bb };
  return t2.kb !== void 0 && (i.customValues = t2.kb), i;
}
__name(ee$1, "ee$1");
function re$1(t2) {
  const i = ee$1(t2);
  return t2.O !== void 0 && (i.color = t2.O), i;
}
__name(re$1, "re$1");
function he(t2) {
  const i = ee$1(t2), { O: n2, Bt: s, $h: e2 } = t2;
  return n2 !== void 0 && (i.color = n2), s !== void 0 && (i.borderColor = s), e2 !== void 0 && (i.wickColor = e2), i;
}
__name(he, "he");
function le(t2) {
  return { Area: ne, Line: ie$1, Baseline: se$1, Histogram: ie$1, Bar: re$1, Candlestick: he, Custom: ae$1 }[t2];
}
__name(le, "le");
function ae$1(t2) {
  const i = t2.bb;
  return Object.assign(Object.assign({}, t2.He), { time: i });
}
__name(ae$1, "ae$1");
const oe$1 = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, mode: 1 }, _e$1 = { vertLines: { color: "#D6DCDE", style: 0, visible: !0 }, horzLines: { color: "#D6DCDE", style: 0, visible: !0 } }, ue = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: L$1 }, ce$1 = { autoScale: !0, mode: 0, invertScale: !1, alignLabels: !0, borderVisible: !0, borderColor: "#2B2B43", entireTextOnly: !1, visible: !1, ticksVisible: !1, scaleMargins: { bottom: 0.1, top: 0.2 }, minimumWidth: 0 }, de = { rightOffset: 0, barSpacing: 6, minBarSpacing: 0.5, fixLeftEdge: !1, fixRightEdge: !1, lockVisibleTimeRangeOnResize: !1, rightBarStaysOnScroll: !1, borderVisible: !0, borderColor: "#2B2B43", visible: !0, timeVisible: !1, secondsVisible: !0, shiftVisibleRangeOnNewBar: !0, allowShiftVisibleRangeOnWhitespaceReplacement: !1, ticksVisible: !1, uniformDistribution: !1, minimumHeight: 0 }, fe = { color: "rgba(0, 0, 0, 0)", visible: !1, fontSize: 48, fontFamily: L$1, fontStyle: "", text: "", horzAlign: "center", vertAlign: "center" };
function ve() {
  return { width: 0, height: 0, autoSize: !1, layout: ue, crosshair: oe$1, grid: _e$1, overlayPriceScales: Object.assign({}, ce$1), leftPriceScale: Object.assign(Object.assign({}, ce$1), { visible: !1 }), rightPriceScale: Object.assign(Object.assign({}, ce$1), { visible: !0 }), timeScale: de, watermark: fe, localization: { locale: is ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: !0, pressedMouseMove: !0, horzTouchDrag: !0, vertTouchDrag: !0 }, handleScale: { axisPressedMouseMove: { time: !0, price: !0 }, axisDoubleClickReset: { time: !0, price: !0 }, mouseWheel: !0, pinch: !0 }, kineticScroll: { mouse: !1, touch: !0 }, trackingMode: { exitMode: 1 } };
}
__name(ve, "ve");
const _pe = class _pe {
  constructor(t2, i) {
    this.$b = t2, this.Ub = i;
  }
  applyOptions(t2) {
    this.$b.qt().zc(this.Ub, t2);
  }
  options() {
    return this.Li().W();
  }
  width() {
    return ut$1(this.Ub) ? this.$b.nb(this.Ub) : 0;
  }
  Li() {
    return b(this.$b.qt().Ec(this.Ub)).At;
  }
};
__name(_pe, "pe");
let pe = _pe;
function me(t2, i, n2) {
  const s = Ls(t2, ["time", "originalTime"]), e2 = Object.assign({ time: i }, s);
  return n2 !== void 0 && (e2.originalTime = n2), e2;
}
__name(me, "me");
const be = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: !0, axisLabelVisible: !0, title: "", axisLabelColor: "", axisLabelTextColor: "" }, _we = class _we {
  constructor(t2) {
    this.Bh = t2;
  }
  applyOptions(t2) {
    this.Bh.Nh(t2);
  }
  options() {
    return this.Bh.W();
  }
  qb() {
    return this.Bh;
  }
};
__name(_we, "we");
let we = _we;
const _ge = class _ge {
  constructor(t2, i, n2, s, e2) {
    this.Yb = new R(), this.Es = t2, this.Xb = i, this.Kb = n2, this.N_ = e2, this.Zb = s;
  }
  S() {
    this.Yb.S();
  }
  priceFormatter() {
    return this.Es.ca();
  }
  priceToCoordinate(t2) {
    const i = this.Es.Pt();
    return i === null ? null : this.Es.At().Ot(t2, i.Vt);
  }
  coordinateToPrice(t2) {
    const i = this.Es.Pt();
    return i === null ? null : this.Es.At().pn(t2, i.Vt);
  }
  barsInLogicalRange(t2) {
    if (t2 === null)
      return null;
    const i = new yn$1(new xn$1(t2.from, t2.to)).iu(), n2 = this.Es.In();
    if (n2.Fi())
      return null;
    const s = n2.nl(i.Os(), 1), e2 = n2.nl(i.di(), -1), r2 = b(n2.Qh()), h2 = b(n2.Bn());
    if (s !== null && e2 !== null && s.se > e2.se)
      return { barsBefore: t2.from - r2, barsAfter: h2 - t2.to };
    const l2 = { barsBefore: s === null || s.se === r2 ? t2.from - r2 : s.se - r2, barsAfter: e2 === null || e2.se === h2 ? h2 - t2.to : h2 - e2.se };
    return s !== null && e2 !== null && (l2.from = s.bb, l2.to = e2.bb), l2;
  }
  setData(t2) {
    this.N_, this.Es.Xh(), this.Xb.Gb(this.Es, t2), this.Jb("full");
  }
  update(t2) {
    this.Es.Xh(), this.Xb.Qb(this.Es, t2), this.Jb("update");
  }
  dataByIndex(t2, i) {
    const n2 = this.Es.In().nl(t2, i);
    return n2 === null ? null : le(this.seriesType())(n2);
  }
  data() {
    const t2 = le(this.seriesType());
    return this.Es.In().ie().map((i) => t2(i));
  }
  subscribeDataChanged(t2) {
    this.Yb.l(t2);
  }
  unsubscribeDataChanged(t2) {
    this.Yb.v(t2);
  }
  setMarkers(t2) {
    this.N_;
    const i = t2.map((t3) => me(t3, this.N_.convertHorzItemToInternal(t3.time), t3.time));
    this.Es.Zl(i);
  }
  markers() {
    return this.Es.Gl().map((t2) => me(t2, t2.originalTime, void 0));
  }
  applyOptions(t2) {
    this.Es.Nh(t2);
  }
  options() {
    return I(this.Es.W());
  }
  priceScale() {
    return this.Kb.priceScale(this.Es.At().xa());
  }
  createPriceLine(t2) {
    const i = D$1(I(be), t2), n2 = this.Es.Jl(i);
    return new we(n2);
  }
  removePriceLine(t2) {
    this.Es.Ql(t2.qb());
  }
  seriesType() {
    return this.Es.Xh();
  }
  attachPrimitive(t2) {
    this.Es.ba(t2), t2.attached && t2.attached({ chart: this.Zb, series: this, requestUpdate: () => this.Es.qt().$l() });
  }
  detachPrimitive(t2) {
    this.Es.wa(t2), t2.detached && t2.detached();
  }
  Jb(t2) {
    this.Yb.M() && this.Yb.m(t2);
  }
};
__name(_ge, "ge");
let ge = _ge;
var _a41;
let Me$1 = (_a41 = class {
  constructor(t2, i, n2) {
    this.tw = new R(), this.uu = new R(), this._m = new R(), this.Ui = t2, this.wl = t2.yt(), this.$m = i, this.wl.Ku().l(this.iw.bind(this)), this.wl.Zu().l(this.nw.bind(this)), this.$m.gm().l(this.sw.bind(this)), this.N_ = n2;
  }
  S() {
    this.wl.Ku().p(this), this.wl.Zu().p(this), this.$m.gm().p(this), this.tw.S(), this.uu.S(), this._m.S();
  }
  scrollPosition() {
    return this.wl.Eu();
  }
  scrollToPosition(t2, i) {
    i ? this.wl.qu(t2, 1e3) : this.Ui.Jn(t2);
  }
  scrollToRealTime() {
    this.wl.Uu();
  }
  getVisibleRange() {
    const t2 = this.wl.yu();
    return t2 === null ? null : { from: t2.from.originalTime, to: t2.to.originalTime };
  }
  setVisibleRange(t2) {
    const i = { from: this.N_.convertHorzItemToInternal(t2.from), to: this.N_.convertHorzItemToInternal(t2.to) }, n2 = this.wl.Ru(i);
    this.Ui.ld(n2);
  }
  getVisibleLogicalRange() {
    const t2 = this.wl.ku();
    return t2 === null ? null : { from: t2.Os(), to: t2.di() };
  }
  setVisibleLogicalRange(t2) {
    p$1(t2.from <= t2.to, "The from index cannot be after the to index."), this.Ui.ld(t2);
  }
  resetTimeScale() {
    this.Ui.Zn();
  }
  fitContent() {
    this.Ui.Qu();
  }
  logicalToCoordinate(t2) {
    const i = this.Ui.yt();
    return i.Fi() ? null : i.Et(t2);
  }
  coordinateToLogical(t2) {
    return this.wl.Fi() ? null : this.wl.Vu(t2);
  }
  timeToCoordinate(t2) {
    const i = this.N_.convertHorzItemToInternal(t2), n2 = this.wl.ya(i, !1);
    return n2 === null ? null : this.wl.Et(n2);
  }
  coordinateToTime(t2) {
    const i = this.Ui.yt(), n2 = i.Vu(t2), s = i.qi(n2);
    return s === null ? null : s.originalTime;
  }
  width() {
    return this.$m.$p().width;
  }
  height() {
    return this.$m.$p().height;
  }
  subscribeVisibleTimeRangeChange(t2) {
    this.tw.l(t2);
  }
  unsubscribeVisibleTimeRangeChange(t2) {
    this.tw.v(t2);
  }
  subscribeVisibleLogicalRangeChange(t2) {
    this.uu.l(t2);
  }
  unsubscribeVisibleLogicalRangeChange(t2) {
    this.uu.v(t2);
  }
  subscribeSizeChange(t2) {
    this._m.l(t2);
  }
  unsubscribeSizeChange(t2) {
    this._m.v(t2);
  }
  applyOptions(t2) {
    this.wl.Nh(t2);
  }
  options() {
    return Object.assign(Object.assign({}, I(this.wl.W())), { barSpacing: this.wl.he() });
  }
  iw() {
    this.tw.M() && this.tw.m(this.getVisibleRange());
  }
  nw() {
    this.uu.M() && this.uu.m(this.getVisibleLogicalRange());
  }
  sw(t2) {
    this._m.m(t2.width, t2.height);
  }
}, __name(_a41, "Me"), _a41);
function xe(t2) {
  if (t2 === void 0 || t2.type === "custom")
    return;
  const i = t2;
  i.minMove !== void 0 && i.precision === void 0 && (i.precision = function(t3) {
    if (t3 >= 1)
      return 0;
    let i2 = 0;
    for (; i2 < 8; i2++) {
      const n2 = Math.round(t3);
      if (Math.abs(n2 - t3) < 1e-8)
        return i2;
      t3 *= 10;
    }
    return i2;
  }(i.minMove));
}
__name(xe, "xe");
function Se(t2) {
  return function(t3) {
    if (B$1(t3.handleScale)) {
      const i2 = t3.handleScale;
      t3.handleScale = { axisDoubleClickReset: { time: i2, price: i2 }, axisPressedMouseMove: { time: i2, price: i2 }, mouseWheel: i2, pinch: i2 };
    } else if (t3.handleScale !== void 0) {
      const { axisPressedMouseMove: i2, axisDoubleClickReset: n2 } = t3.handleScale;
      B$1(i2) && (t3.handleScale.axisPressedMouseMove = { time: i2, price: i2 }), B$1(n2) && (t3.handleScale.axisDoubleClickReset = { time: n2, price: n2 });
    }
    const i = t3.handleScroll;
    B$1(i) && (t3.handleScroll = { horzTouchDrag: i, vertTouchDrag: i, mouseWheel: i, pressedMouseMove: i });
  }(t2), t2;
}
__name(Se, "Se");
var _a42;
let ke$1 = (_a42 = class {
  constructor(t2, i, n2) {
    this.ew = /* @__PURE__ */ new Map(), this.rw = /* @__PURE__ */ new Map(), this.hw = new R(), this.lw = new R(), this.aw = new R(), this.ow = new Js(i);
    const s = n2 === void 0 ? I(ve()) : D$1(I(ve()), Se(n2));
    this.N_ = i, this.$b = new zs(t2, s, i), this.$b.Fp().l((t3) => {
      this.hw.M() && this.hw.m(this._w(t3()));
    }, this), this.$b.Wp().l((t3) => {
      this.lw.M() && this.lw.m(this._w(t3()));
    }, this), this.$b.Wc().l((t3) => {
      this.aw.M() && this.aw.m(this._w(t3()));
    }, this);
    const e2 = this.$b.qt();
    this.uw = new Me$1(e2, this.$b.Zm(), this.N_);
  }
  remove() {
    this.$b.Fp().p(this), this.$b.Wp().p(this), this.$b.Wc().p(this), this.uw.S(), this.$b.S(), this.ew.clear(), this.rw.clear(), this.hw.S(), this.lw.S(), this.aw.S(), this.ow.S();
  }
  resize(t2, i, n2) {
    this.autoSizeActive() || this.$b.qm(t2, i, n2);
  }
  addCustomSeries(t2, i) {
    const n2 = w$1(t2), s = Object.assign(Object.assign({}, _$1), n2.defaultOptions());
    return this.cw("Custom", s, i, n2);
  }
  addAreaSeries(t2) {
    return this.cw("Area", l, t2);
  }
  addBaselineSeries(t2) {
    return this.cw("Baseline", a, t2);
  }
  addBarSeries(t2) {
    return this.cw("Bar", r, t2);
  }
  addCandlestickSeries(t2 = {}) {
    return function(t3) {
      t3.borderColor !== void 0 && (t3.borderUpColor = t3.borderColor, t3.borderDownColor = t3.borderColor), t3.wickColor !== void 0 && (t3.wickUpColor = t3.wickColor, t3.wickDownColor = t3.wickColor);
    }(t2), this.cw("Candlestick", e, t2);
  }
  addHistogramSeries(t2) {
    return this.cw("Histogram", o, t2);
  }
  addLineSeries(t2) {
    return this.cw("Line", h$1, t2);
  }
  removeSeries(t2) {
    const i = m$1(this.ew.get(t2)), n2 = this.ow.hd(i);
    this.$b.qt().hd(i), this.dw(n2), this.ew.delete(t2), this.rw.delete(i);
  }
  Gb(t2, i) {
    this.dw(this.ow.Ab(t2, i));
  }
  Qb(t2, i) {
    this.dw(this.ow.Eb(t2, i));
  }
  subscribeClick(t2) {
    this.hw.l(t2);
  }
  unsubscribeClick(t2) {
    this.hw.v(t2);
  }
  subscribeCrosshairMove(t2) {
    this.aw.l(t2);
  }
  unsubscribeCrosshairMove(t2) {
    this.aw.v(t2);
  }
  subscribeDblClick(t2) {
    this.lw.l(t2);
  }
  unsubscribeDblClick(t2) {
    this.lw.v(t2);
  }
  priceScale(t2) {
    return new pe(this.$b, t2);
  }
  timeScale() {
    return this.uw;
  }
  applyOptions(t2) {
    this.$b.Nh(Se(t2));
  }
  options() {
    return this.$b.W();
  }
  takeScreenshot() {
    return this.$b.tb();
  }
  autoSizeActive() {
    return this.$b.rb();
  }
  chartElement() {
    return this.$b.hb();
  }
  paneSize() {
    const t2 = this.$b.ab();
    return { height: t2.height, width: t2.width };
  }
  setCrosshairPosition(t2, i, n2) {
    const s = this.ew.get(n2);
    if (s === void 0)
      return;
    const e2 = this.$b.qt().cr(s);
    e2 !== null && this.$b.qt().Qc(t2, i, e2);
  }
  clearCrosshairPosition() {
    this.$b.qt().td(!0);
  }
  cw(t2, i, n2 = {}, s) {
    xe(n2.priceFormat);
    const e2 = D$1(I(u), I(i), n2), r2 = this.$b.qt().ed(t2, e2, s), h2 = new ge(r2, this, this, this, this.N_);
    return this.ew.set(h2, r2), this.rw.set(r2, h2), h2;
  }
  dw(t2) {
    const i = this.$b.qt();
    i.nd(t2.yt.Au, t2.yt.jb, t2.yt.Hb), t2.Fb.forEach((t3, i2) => i2.it(t3.He, t3.Wb)), i.Iu();
  }
  fw(t2) {
    return m$1(this.rw.get(t2));
  }
  _w(t2) {
    const i = /* @__PURE__ */ new Map();
    t2.Mb.forEach((t3, n3) => {
      const s = n3.Xh(), e2 = le(s)(t3);
      if (s !== "Custom")
        p$1(function(t4) {
          return t4.open !== void 0 || t4.value !== void 0;
        }(e2));
      else {
        const t4 = n3.Ma();
        p$1(!t4 || t4(e2) === !1);
      }
      i.set(this.fw(n3), e2);
    });
    const n2 = t2.gb === void 0 ? void 0 : this.fw(t2.gb);
    return { time: t2.bb, logical: t2.se, point: t2.wb, hoveredSeries: n2, hoveredObjectId: t2.xb, seriesData: i, sourceEvent: t2.Sb };
  }
}, __name(_a42, "ke"), _a42);
function ye(t2, i, n2) {
  let s;
  if (V$1(t2)) {
    const i2 = document.getElementById(t2);
    p$1(i2 !== null, `Cannot find element in DOM with id=${t2}`), s = i2;
  } else
    s = t2;
  const e2 = new ke$1(s, i, n2);
  return i.setOptions(e2.options()), e2;
}
__name(ye, "ye");
function Ce$1(t2, i) {
  return ye(t2, new ts(), ts.Td(i));
}
__name(Ce$1, "Ce$1");
Object.assign(Object.assign({}, u), _$1);
const skeleton = "_skeleton_13p4i_1", style$n = {
  skeleton,
  "skeleton-loading": "_skeleton-loading_13p4i_1"
}, Skeleton = /* @__PURE__ */ __name(({
  fontSize,
  minWidth = "100%"
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$n.skeleton, style: { fontSize, minWidth } }), "Skeleton"), chart = "_chart_1bo3n_1", invisible = "_invisible_1bo3n_7", chartUpdatingMessage = "_chartUpdatingMessage_1bo3n_11", summary$1 = "_summary_1bo3n_28", filters = "_filters_1bo3n_35", filterActive = "_filterActive_1bo3n_87", arrow = "_arrow_1bo3n_104", up = "_up_1bo3n_109", down = "_down_1bo3n_113", totalValue = "_totalValue_1bo3n_117", totalUnit = "_totalUnit_1bo3n_121", diffValue = "_diffValue_1bo3n_128", diffUnit = "_diffUnit_1bo3n_132", chartCanvas = "_chartCanvas_1bo3n_137", tooltip = "_tooltip_1bo3n_149", toolTipValue = "_toolTipValue_1bo3n_164", toolTipUnit = "_toolTipUnit_1bo3n_170", toolTipTime = "_toolTipTime_1bo3n_176", styles$j = {
  chart,
  invisible,
  chartUpdatingMessage,
  summary: summary$1,
  filters,
  filterActive,
  arrow,
  up,
  down,
  totalValue,
  totalUnit,
  diffValue,
  diffUnit,
  chartCanvas,
  tooltip,
  toolTipValue,
  toolTipUnit,
  toolTipTime
}, Filters = /* @__PURE__ */ __name(({
  display,
  disableFilters,
  onDisplayWeek,
  onDisplayMonth,
  onDisplayYear,
  onDisplayAll
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.filters, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "week" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayWeek,
        children: t2("chart.filter.week")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "month" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayMonth,
        children: t2("chart.filter.month")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "year" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayYear,
        children: t2("chart.filter.year")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "all" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayAll,
        children: t2("chart.filter.all")
      }
    )
  ] });
}, "Filters");
let darkmode;
const Darkmode = /* @__PURE__ */ __name(() => {
  const { isDarkMode } = useDarkmode();
  return darkmode = isDarkMode, null;
}, "Darkmode"), getDarkmode = /* @__PURE__ */ __name(() => darkmode, "getDarkmode"), _Chart = class _Chart extends reactExports.Component {
  constructor() {
    super(...arguments), this.ref = reactExports.createRef(), this.refToolTip = reactExports.createRef(), this.height = 300, this.mobileHeight = 150, this.state = {
      display: "all",
      source: "daily",
      toolTipVisible: !1,
      toolTipValue: void 0,
      toolTipTop: 0,
      toolTipLeft: 0,
      toolTipTime: 0,
      isMobile: !1
    }, this.hasData = () => this.props.data.chartDataDaily && this.props.data.chartDataDaily.length > 0, this.checkIfMobile = () => {
      this.setState({ isMobile: window.innerWidth <= 640 });
    }, this.createChart = () => {
      const { data: { chartDataMissing } } = this.props, darkmode2 = getDarkmode();
      if (this.ref.current && this.hasData() && !chartDataMissing) {
        if (!this.chart) {
          const chartWidth = this.state.isMobile ? document.body.clientWidth : this.ref.current.offsetWidth, chartHeight = this.state.isMobile ? this.mobileHeight : this.height;
          this.chart = Ce$1(this.ref.current, {
            width: chartWidth,
            height: chartHeight,
            handleScroll: !1,
            handleScale: !1,
            crosshair: {
              vertLine: {
                visible: !1,
                labelVisible: !1
              },
              horzLine: {
                visible: !1,
                labelVisible: !1
              },
              mode: 1
            },
            grid: {
              vertLines: {
                visible: !1
              },
              horzLines: {
                color: darkmode2 ? "#333333" : "#dedede",
                style: d.Solid,
                visible: !this.state.isMobile
              }
            },
            layout: {
              background: {
                type: Bn$1.Solid,
                color: darkmode2 ? "#1D1D1B" : "#F5F5F5"
              },
              fontSize: 11,
              fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Ubuntu", "Roboto", "Oxygen", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
              textColor: darkmode2 ? "#F5F5F5" : "#1D1D1B"
            },
            leftPriceScale: {
              borderVisible: !1,
              ticksVisible: !1,
              visible: this.props.hideAmounts ? !1 : !this.state.isMobile,
              entireTextOnly: !0
            },
            localization: {
              locale: this.props.i18n.language
            },
            rightPriceScale: {
              visible: !1,
              ticksVisible: !1
            },
            timeScale: {
              borderVisible: !1,
              timeVisible: !1,
              visible: !this.state.isMobile
            },
            trackingMode: {
              exitMode: 0
            }
          });
        }
        this.lineSeries = this.chart.addAreaSeries({
          priceLineVisible: !1,
          lastValueVisible: !1,
          priceFormat: {
            type: "volume"
          },
          topColor: darkmode2 ? "#5E94BF" : "#DFF1FF",
          bottomColor: darkmode2 ? "#1D1D1B" : "#F5F5F5",
          lineColor: "rgba(94, 148, 192, 1)",
          crosshairMarkerRadius: 6
        }), this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.timeScale().subscribeVisibleLogicalRangeChange(this.calculateChange), this.chart.subscribeCrosshairMove(this.handleCrosshair), this.chart.timeScale().fitContent(), window.addEventListener("resize", this.onResize), setTimeout(() => {
          var _a46;
          return (_a46 = this.ref.current) == null ? void 0 : _a46.classList.remove(styles$j.invisible);
        }, 200);
      }
    }, this.onResize = () => {
      this.checkIfMobile(), this.resizeTimerID && clearTimeout(this.resizeTimerID), this.resizeTimerID = setTimeout(() => {
        if (!this.chart || !this.ref.current)
          return;
        const chartWidth = this.state.isMobile ? document.body.clientWidth : this.ref.current.offsetWidth, chartHeight = this.state.isMobile ? this.mobileHeight : this.height;
        this.chart.resize(chartWidth, chartHeight), this.chart.applyOptions({
          grid: {
            horzLines: {
              visible: !this.state.isMobile
            }
          },
          timeScale: {
            visible: !this.state.isMobile
          },
          leftPriceScale: {
            visible: this.props.hideAmounts ? !1 : !this.state.isMobile
          }
        });
      }, 200);
    }, this.getUTCRange = () => {
      const now = /* @__PURE__ */ new Date(), utcYear = now.getUTCFullYear(), utcMonth = now.getUTCMonth(), utcDate = now.getUTCDate(), utcHours = now.getUTCHours(), to = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0)), from2 = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      return {
        utcYear,
        utcMonth,
        utcDate,
        to,
        from: from2
      };
    }, this.displayWeek = () => {
      this.state.source !== "hourly" && this.lineSeries && this.props.data.chartDataHourly && this.chart && (this.lineSeries.setData(this.props.data.chartDataHourly || []), this.setFormattedData(this.props.data.chartDataHourly || []), this.chart.applyOptions({ timeScale: { timeVisible: !0 } })), this.setState(
        { display: "week", source: "hourly" },
        () => {
          if (!this.chart)
            return;
          const { utcDate, from: from2, to } = this.getUTCRange();
          from2.setUTCDate(utcDate - 7), this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayMonth = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily || []), this.setFormattedData(this.props.data.chartDataDaily || []), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "month", source: "daily" },
        () => {
          if (!this.chart)
            return;
          const { utcMonth, from: from2, to } = this.getUTCRange();
          from2.setUTCMonth(utcMonth - 1), this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayYear = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "year", source: "daily" },
        () => {
          if (!this.chart)
            return;
          const { utcYear, from: from2, to } = this.getUTCRange();
          from2.setUTCFullYear(utcYear - 1), this.chart && this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayAll = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "all", source: "daily" },
        () => {
          this.chart && this.chart.timeScale().fitContent();
        }
      );
    }, this.calculateChange = () => {
      const data = this.props.data[this.state.source === "daily" ? "chartDataDaily" : "chartDataHourly"];
      if (!data || !this.chart || !this.lineSeries)
        return;
      const logicalrange = this.chart.timeScale().getVisibleLogicalRange(), visiblerange = this.lineSeries.barsInLogicalRange(logicalrange);
      if (!visiblerange)
        return;
      const rangeFrom = Math.max(Math.floor(visiblerange.barsBefore), 0);
      if (!data[rangeFrom]) {
        this.setState({ difference: 0, diffSince: "" });
        return;
      }
      const valueFrom = data[rangeFrom].value, valueTo = this.props.data.chartTotal, valueDiff = valueTo ? valueTo - valueFrom : 0;
      this.setState({
        difference: valueDiff / valueFrom * 100,
        diffSince: `${data[rangeFrom].formattedValue} (${this.renderDate(Number(data[rangeFrom].time) * 1e3)})`
      });
    }, this.handleCrosshair = ({ point, time: time2, seriesData }) => {
      if (!this.refToolTip.current)
        return;
      const tooltip2 = this.refToolTip.current, parent = tooltip2.parentNode;
      if (!this.lineSeries || !point || !time2 || point.x < 0 || point.x > parent.clientWidth || point.y < 0 || point.y > parent.clientHeight) {
        this.setState({
          toolTipVisible: !1
        });
        return;
      }
      const price = seriesData.get(this.lineSeries);
      if (!price)
        return;
      const coordinate = this.lineSeries.priceToCoordinate(price.value);
      if (!coordinate)
        return;
      const coordinateY = coordinate - tooltip2.clientHeight > 0 ? coordinate - tooltip2.clientHeight : Math.max(
        0,
        Math.min(
          parent.clientHeight - tooltip2.clientHeight,
          coordinate + 70
        )
      ), toolTipTop = Math.floor(Math.max(coordinateY, 0)), toolTipLeft = Math.floor(Math.max(40, Math.min(parent.clientWidth - 140, point.x + 40 - 70)));
      this.setState({
        toolTipVisible: !0,
        toolTipValue: this.formattedData ? this.formattedData[time2] : "",
        toolTipTop,
        toolTipLeft,
        toolTipTime: time2
      });
    }, this.renderDate = (date2) => new Date(date2).toLocaleString(
      this.props.i18n.language,
      {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        ...this.state.source === "hourly" ? {
          hour: "2-digit",
          minute: "2-digit"
        } : null
      }
    );
  }
  componentDidMount() {
    this.checkIfMobile(), this.createChart();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.onResize), this.chart && (this.chart.timeScale().unsubscribeVisibleLogicalRangeChange(this.calculateChange), this.chart.unsubscribeCrosshairMove(this.handleCrosshair));
  }
  componentDidUpdate(prev2) {
    var _a46;
    const { chartDataDaily, chartDataHourly } = this.props.data;
    if (this.chart || this.createChart(), this.lineSeries && prev2.data.chartDataDaily && prev2.data.chartDataHourly && chartDataDaily && chartDataHourly && (prev2.data.chartDataDaily.length !== chartDataDaily.length || prev2.data.chartDataHourly.length !== chartDataHourly.length)) {
      const data = this.state.source === "hourly" ? chartDataHourly : chartDataDaily;
      this.lineSeries.setData(data), this.setFormattedData(data);
    }
    prev2.hideAmounts !== this.props.hideAmounts && ((_a46 = this.chart) == null || _a46.applyOptions({
      leftPriceScale: {
        visible: this.props.hideAmounts ? !1 : !this.state.isMobile
      }
    }));
  }
  setFormattedData(data) {
    this.formattedData = {}, data.forEach((entry2) => {
      this.formattedData && (this.formattedData[entry2.time] = entry2.formattedValue);
    });
  }
  render() {
    const {
      t: t2,
      data: {
        lastTimestamp,
        chartDataMissing,
        chartFiat,
        chartIsUpToDate,
        chartTotal,
        formattedChartTotal
      },
      noDataPlaceholder,
      hideAmounts
    } = this.props, {
      difference,
      diffSince,
      display,
      toolTipVisible,
      toolTipValue: toolTipValue2,
      toolTipTop,
      toolTipLeft,
      toolTipTime: toolTipTime2,
      isMobile
    } = this.state, hasDifferenece = difference && Number.isFinite(difference), hasData = this.hasData(), disableFilters = !hasData || chartTotal === 0 || chartDataMissing, showMobileTotalValue = toolTipVisible && !!toolTipValue2 && isMobile, chartFiltersProps = {
      display,
      disableFilters,
      onDisplayWeek: this.displayWeek,
      onDisplayMonth: this.displayMonth,
      onDisplayYear: this.displayYear,
      onDisplayAll: this.displayAll
    }, chartHeight = `${isMobile ? this.mobileHeight : this.height}px`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: styles$j.chart, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.summary, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.totalValue, children: [
            formattedChartTotal !== null ? (
              // remove trailing zeroes for BTC fiat total
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: showMobileTotalValue ? toolTipValue2 : formattedChartTotal, unit: chartFiat, removeBtcTrailingZeroes: !0 })
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { minWidth: "220px" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.totalUnit, children: chartTotal !== null && chartFiat })
          ] }),
          showMobileTotalValue ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.diffValue, children: this.renderDate(toolTipTime2 * 1e3) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: hasDifferenece ? styles$j[difference < 0 ? "down" : "up"] : "", title: diffSince, children: hasDifferenece ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.arrow, children: difference < 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDown, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$j.diffValue, children: [
              hideAmounts ? "***" : formatNumber(difference, 2),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.diffUnit, children: "%" })
            ] })
          ] }) : chartTotal === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "1.125rem", minWidth: "125px" }) })
        ] }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.chartCanvas, style: { minHeight: chartHeight }, children: [
        chartDataMissing ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.chartUpdatingMessage, style: { height: chartHeight }, children: t2("chart.dataMissing") }) : hasData ? !chartIsUpToDate && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.chartUpdatingMessage, children: t2("chart.dataOldTimestamp", { time: new Date(lastTimestamp).toLocaleString(this.props.i18n.language) }) }) : noDataPlaceholder,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: this.ref, className: styles$j.invisible }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ref: this.refToolTip,
            className: styles$j.tooltip,
            style: { left: toolTipLeft, top: toolTipTop },
            hidden: !toolTipVisible || isMobile,
            children: toolTipValue2 !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: styles$j.toolTipValue, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: toolTipValue2, unit: chartFiat }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.toolTipUnit, children: chartFiat })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.toolTipTime, children: this.renderDate(toolTipTime2 * 1e3) })
            ] }) : null
          }
        )
      ] }),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
    ] });
  }
};
__name(_Chart, "Chart");
let Chart = _Chart;
Chart.defaultProps = {
  data: {
    chartDataMissing: !0,
    chartDataDaily: [],
    chartDataHourly: [],
    chartFiat: "USD",
    chartTotal: null,
    formattedChartTotal: null,
    chartIsUpToDate: !1,
    lastTimestamp: 0
  },
  hideAmounts: !1
};
const HOC$4 = translate()(Chart), ArrowUp = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
), "ArrowUp"), ArrowDown = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
), "ArrowDown"), spinnerContainer$1 = "_spinnerContainer_1akm7_1", spinner$1 = "_spinner_1akm7_1", changeContent$2 = "_changeContent_1akm7_1", style$m = {
  spinnerContainer: spinnerContainer$1,
  spinner: spinner$1,
  changeContent: changeContent$2
};
function AsciiSpinner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$m.spinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$m.spinner }) });
}
__name(AsciiSpinner, "AsciiSpinner");
const balanceTable = "_balanceTable_1v4c8_1", coincode = "_coincode_1v4c8_4", coinheader = "_coinheader_1v4c8_9", dataMissing = "_dataMissing_1v4c8_20", openFileText = "_openFileText_1v4c8_24", table = "_table_1v4c8_30", noAccount = "_noAccount_1v4c8_45", clickable = "_clickable_1v4c8_80", summaryTableBalance = "_summaryTableBalance_1v4c8_84", coinName = "_coinName_1v4c8_94", coinUnit = "_coinUnit_1v4c8_104", syncText$1 = "_syncText_1v4c8_108", showOnTableView = "_showOnTableView_1v4c8_112", showInCollapsedView = "_showInCollapsedView_1v4c8_116", subTotal = "_subTotal_1v4c8_167", style$l = {
  balanceTable,
  coincode,
  coinheader,
  dataMissing,
  openFileText,
  table,
  noAccount,
  clickable,
  summaryTableBalance,
  coinName,
  coinUnit,
  syncText: syncText$1,
  showOnTableView,
  showInCollapsedView,
  subTotal
};
function BalanceRow({ code, name, coinCode, balance: balance2 }) {
  const { t: t2 } = useTranslation(), syncStatus2 = useSubscribe(syncAddressesCount(code)), nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      className: style$l.clickable,
      "data-label": t2("accountSummary.name"),
      onClick: () => route(`/account/${code}`),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$l.coinName, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$l.coincode, coinCode, active: !0, alt: coinCode }),
        name
      ] })
    }
  );
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$l.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.available.amount, unit: balance2.available.unit }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: balance2.available.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.available, noAction: !0 }) })
  ] }, `${code}_balance`) : /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 2, className: style$l.syncText, children: [
      t2("account.syncedAddressesCount", {
        count: syncStatus2 == null ? void 0 : syncStatus2.toString(),
        defaultValue: 0
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] })
  ] }, `${code}_syncing`);
}
__name(BalanceRow, "BalanceRow");
function SubTotalRow({ coinCode, coinName: coinName2, balance: balance2 }) {
  const { t: t2 } = useTranslation(), nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.total"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$l.coinName, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$l.coincode, coinCode, active: !0, alt: coinCode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$l.showOnTableView, children: t2("accountSummary.subtotalWithCoinName", { coinName: coinName2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$l.showInCollapsedView, children: coinName2 })
  ] }) });
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: style$l.subTotal, children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$l.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.amount, unit: balance2.unit }) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: balance2.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2, noAction: !0 }) }) })
  ] }, `${coinCode}_subtotal`) : null;
}
__name(SubTotalRow, "SubTotalRow");
function SummaryBalance({
  accounts,
  summaryData,
  totalBalancePerCoin,
  balances
}) {
  const { t: t2 } = useTranslation(), accountsPerCoin = (/* @__PURE__ */ __name(() => accounts.reduce((accountPerCoin, account2) => (accountPerCoin[account2.coinCode] ? accountPerCoin[account2.coinCode].push(account2) : accountPerCoin[account2.coinCode] = [account2], accountPerCoin), {}), "getAccountsPerCoin"))(), coins2 = Object.keys(accountsPerCoin);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$l.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: style$l.table, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.balance") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.fiatBalance") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: accounts.length > 0 ? coins2.map((coinCode) => {
      const balanceRows = accountsPerCoin[coinCode].map(
        (account2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BalanceRow,
          {
            code: account2.code,
            name: account2.name,
            coinCode: account2.coinCode,
            balance: balances && balances[account2.code]
          },
          account2.code
        )
      );
      if ((balanceRows == null ? void 0 : balanceRows.length) > 1) {
        const account2 = accountsPerCoin[coinCode][0];
        balanceRows.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SubTotalRow,
            {
              coinCode: account2.coinCode,
              coinName: account2.coinName,
              balance: totalBalancePerCoin && totalBalancePerCoin[coinCode]
            },
            account2.coinCode
          )
        );
      }
      return balanceRows;
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 3, className: style$l.noAccount, children: t2("accountSummary.noAccount") }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("tfoot", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("accountSummary.total") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 2, children: summaryData && summaryData.formattedChartTotal !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: summaryData.formattedChartTotal, unit: summaryData.chartFiat }) }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: summaryData.chartFiat })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
    ] }) })
  ] }) });
}
__name(SummaryBalance, "SummaryBalance");
const useMediaQuery = /* @__PURE__ */ __name((query) => {
  const getMatches = /* @__PURE__ */ __name((query2) => window.matchMedia(query2).matches, "getMatches"), [matches, setMatches] = reactExports.useState(getMatches(query));
  return reactExports.useEffect(() => {
    const handleChange = /* @__PURE__ */ __name(() => {
      setMatches(getMatches(query));
    }, "handleChange"), matchMedia = window.matchMedia(query);
    return handleChange(), matchMedia.addEventListener("change", handleChange), () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]), matches;
}, "useMediaQuery"), container$e = "_container_1mptn_1", main = "_main_1mptn_8", walletConnect$1 = "_walletConnect_1mptn_17", styles$i = {
  container: container$e,
  main,
  walletConnect: walletConnect$1
}, BuyReceiveCTA = /* @__PURE__ */ __name(({ code, unit: unit2, balanceList, exchangeBuySupported = !0, account: account2 }) => {
  const formattedUnit = isBitcoinCoin(unit2) ? "BTC" : unit2, { t: t2 } = useTranslation(), isMobile = useMediaQuery("(max-width: 768px)"), onBuyCTA = /* @__PURE__ */ __name(() => route(code ? `/buy/info/${code}` : "/buy/info"), "onBuyCTA"), onWalletConnect = /* @__PURE__ */ __name(() => route(`/account/${code}/wallet-connect/dashboard`), "onWalletConnect"), onReceiveCTA = /* @__PURE__ */ __name(() => {
    if (balanceList) {
      if (balanceList.length > 1) {
        route("accounts/select-receive");
        return;
      }
      route(`/account/${code}/receive`);
    }
  }, "onReceiveCTA");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$i.main}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.looksEmpty") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.start") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.container, children: [
      balanceList && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onReceiveCTA, children: formattedUnit ? t2("receive.title", { accountName: formattedUnit }) : t2("receive.title", { accountName: t2("buy.info.crypto") }) }),
      exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onBuyCTA, children: formattedUnit ? t2("accountInfo.buyCTA.buy", { unit: formattedUnit }) : t2("accountInfo.buyCTA.buyCrypto") }),
      account2 && isEthereumBased(account2.coinCode) && !account2.isToken && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onWalletConnect, className: styles$i.walletConnect, children: isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
      ] }) })
    ] })
  ] });
}, "BuyReceiveCTA"), AddBuyReceiveOnEmptyBalances = /* @__PURE__ */ __name(({ balances, accounts }) => {
  const mounted = useMountedRef(), [supportedAccounts, setSupportedAccounts] = reactExports.useState(), onlyHasOneActiveAccount = accounts.length === 1;
  if (reactExports.useEffect(() => {
    mounted.current && getExchangeSupportedAccounts(accounts).then((supportedAccounts2) => {
      mounted.current && setSupportedAccounts(supportedAccounts2);
    }).catch(console.error);
  }, [accounts, mounted]), balances === void 0 || supportedAccounts === void 0)
    return null;
  const balanceList = accounts.map((account2) => balances[account2.code]).filter((balance2) => !!balance2);
  return balanceList.some((entry2) => entry2.hasAvailable) ? null : balanceList.map((entry2) => entry2.available.unit).every(isBitcoinCoin) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { code: onlyHasOneActiveAccount ? accounts[0].code : void 0, unit: "BTC", balanceList }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { exchangeBuySupported: supportedAccounts.length > 0, balanceList });
}, "AddBuyReceiveOnEmptyBalances");
function AccountsSummary({
  accounts,
  devices
}) {
  const { t: t2 } = useTranslation(), summaryReqTimerID = reactExports.useRef(), mounted = useMountedRef(), { hideAmounts } = reactExports.useContext(AppContext), [summaryData, setSummaryData] = reactExports.useState(), [totalBalancePerCoin, setTotalBalancePerCoin] = reactExports.useState(), [balances, setBalances] = reactExports.useState(), hasCard = useSDCard(devices), getAccountSummary = reactExports.useCallback(async () => {
    summaryReqTimerID.current && window.clearTimeout(summaryReqTimerID.current);
    try {
      const summaryData2 = await getSummary();
      if (!mounted.current)
        return;
      setSummaryData(summaryData2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]), getAccountsTotalBalance$1 = reactExports.useCallback(async () => {
    try {
      const totalBalance = await getAccountsTotalBalance();
      if (!mounted.current)
        return;
      setTotalBalancePerCoin(totalBalance);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]), onStatusChanged = reactExports.useCallback(async (code) => {
    if (!mounted.current)
      return;
    const status2 = await getStatus$2(code);
    if (status2.disabled || !mounted.current)
      return;
    if (!status2.synced)
      return init(code);
    const balance2 = await getBalance(code);
    mounted.current && setBalances((prevBalances) => ({
      ...prevBalances,
      [code]: balance2
    }));
  }, [mounted]), update = reactExports.useCallback((code) => {
    mounted.current && (onStatusChanged(code), getAccountSummary());
  }, [getAccountSummary, mounted, onStatusChanged]);
  return reactExports.useEffect(() => {
    const subscriptions2 = [
      statusChanged$1(update),
      syncdone(update)
    ];
    return getAccountSummary(), getAccountsTotalBalance$1(), () => unsubscribe(subscriptions2);
  }, [getAccountSummary, getAccountsTotalBalance$1, update]), reactExports.useEffect(() => {
    const delay2 = !summaryData || summaryData.chartDataMissing ? 1e3 : 1e4;
    return summaryReqTimerID.current = window.setTimeout(getAccountSummary, delay2), () => {
      summaryReqTimerID.current && window.clearTimeout(summaryReqTimerID.current);
    };
  }, [summaryData, getAccountSummary]), reactExports.useEffect(() => {
    accounts.forEach((account2) => {
      onStatusChanged(account2.code);
    }), getAccountsTotalBalance$1();
  }, [onStatusChanged, getAccountsTotalBalance$1, accounts]), /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountSummary.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HOC$4,
          {
            hideAmounts,
            data: summaryData,
            noDataPlaceholder: accounts.length && accounts.length <= Object.keys(balances || {}).length ? /* @__PURE__ */ jsxRuntimeExports.jsx(AddBuyReceiveOnEmptyBalances, { accounts, balances }) : void 0
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SummaryBalance,
          {
            accounts,
            summaryData,
            totalBalancePerCoin,
            balances
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSummaryDescription") }, "accountSummaryDescription"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: "www.coingecko.com",
          url: "https://www.coingecko.com/"
        },
        text: t2("guide.accountSummaryAmount.text"),
        title: t2("guide.accountSummaryAmount.title")
      } }, "accountSummaryAmount"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.trackingModePortfolioChart") }, "trackingModePortfolioChart")
    ] })
  ] });
}
__name(AccountsSummary, "AccountsSummary");
const URL_CONSTANTS = {
  DOWNLOAD_LINK_GLOBAL: "https://bitbox.swiss/download/?source=bitboxapp",
  DOWNLOAD_LINK_DE: "https://bitbox.swiss/de/download/?source=bitboxapp",
  DOWNLOAD_LINK_ES: "https://bitbox.swiss/es/descargar/?source=bitboxapp"
}, downloadLinkByLanguage = /* @__PURE__ */ __name(() => {
  switch (instance.resolvedLanguage) {
    case "de":
      return URL_CONSTANTS.DOWNLOAD_LINK_DE;
    case "es":
      return URL_CONSTANTS.DOWNLOAD_LINK_ES;
    default:
      return URL_CONSTANTS.DOWNLOAD_LINK_GLOBAL;
  }
}, "downloadLinkByLanguage"), AppDownloadLink = /* @__PURE__ */ __name(({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: t2("button.download") });
}, "AppDownloadLink"), AppDownloadButton = /* @__PURE__ */ __name(({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, children: t2("button.download") }) });
}, "AppDownloadButton"), AppUpgradeRequired = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        verticallyCentered: !0,
        width: "840px",
        withBottomBar: !0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("device.appUpradeRequired") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadButton, {}) })
        ]
      }
    )
  ] });
}, "AppUpgradeRequired"), stateEnum$1 = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
var _a43;
let Unlock$1 = (_a43 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      status: stateEnum$1.DEFAULT,
      errorMessage: "",
      errorCode: null,
      remainingAttempts: null,
      needsLongTouch: !1,
      password: ""
    });
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.password !== "", "validate"));
    __publicField(this, "handleSubmit", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        status: stateEnum$1.WAITING
      }), apiPost("devices/" + this.props.deviceID + "/login", { password: this.state.password }).then((data) => {
        data.success && apiGet("devices/" + this.props.deviceID + "/status").then((status2) => {
          status2 === "seeded" && (console.info("unlock.jsx route to /account-summary"), route("/account-summary", !0));
        }), data.success || (data.code && this.setState({ errorCode: data.code }), data.remainingAttempts && this.setState({ remainingAttempts: data.remainingAttempts }), data.needsLongTouch && this.setState({ needsLongTouch: data.needsLongTouch }), this.setState({ status: stateEnum$1.ERROR, errorMessage: data.errorMessage }));
      }), this.setState({ password: "" }));
    }, "handleSubmit"));
  }
  render() {
    const { t: t2 } = this.props, {
      status: status2,
      password: password2,
      errorCode,
      errorMessage,
      remainingAttempts,
      needsLongTouch
    } = this.state;
    let submissionState = null;
    switch (status2) {
      case stateEnum$1.DEFAULT:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("unlock.description") });
        break;
      case stateEnum$1.WAITING:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: t2("unlock.unlocking") });
        break;
      case stateEnum$1.ERROR:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`unlock.error.e${errorCode}`, {
          defaultValue: errorMessage,
          remainingAttempts,
          context: needsLongTouch ? "touch" : "normal"
        }) });
        break;
    }
    const darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content narrow padded isVerticallyCentered", children: [
          darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            submissionState,
            status2 !== stateEnum$1.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordSingleInput,
                {
                  autoFocus: !0,
                  id: "password",
                  type: "password",
                  label: t2("unlock.input.label"),
                  disabled: status2 === stateEnum$1.WAITING,
                  placeholder: t2("unlock.input.placeholder"),
                  onValidPassword: this.handleFormChange,
                  value: password2
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  type: "submit",
                  disabled: !this.validate() || status2 === stateEnum$1.WAITING,
                  children: t2("button.unlock")
                }
              ) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.forgotDevicePassword") }, "guide.unlock.forgotDevicePassword"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.reset") }, "guide.unlock.reset")
      ] })
    ] });
  }
}, __name(_a43, "Unlock"), _a43);
const Unlock$2 = withTranslation()(Unlock$1), container$d = "_container_17oq2_1", scrollable = "_scrollable_17oq2_17", agreements$1 = "_agreements_17oq2_22", agreementsLabel = "_agreementsLabel_17oq2_26", title$1 = "_title_17oq2_30", summary = "_summary_17oq2_36", heading = "_heading_17oq2_45", content = "_content_17oq2_49", verticalButtons = "_verticalButtons_17oq2_60", block$1 = "_block_17oq2_72", list = "_list_17oq2_85", buttons = "_buttons_17oq2_93", stepNumber = "_stepNumber_17oq2_98", badge$2 = "_badge_17oq2_108", waitingLogo = "_waitingLogo_17oq2_113", waitingContent = "_waitingContent_17oq2_117", waitingText = "_waitingText_17oq2_126", waitingDescription = "_waitingDescription_17oq2_134", qrcodeContainer = "_qrcodeContainer_17oq2_140", style$k = {
  container: container$d,
  scrollable,
  agreements: agreements$1,
  agreementsLabel,
  title: title$1,
  summary,
  heading,
  content,
  verticalButtons,
  block: block$1,
  list,
  buttons,
  stepNumber,
  badge: badge$2,
  waitingLogo,
  waitingContent,
  waitingText,
  waitingDescription,
  qrcodeContainer
}, _Bootloader = class _Bootloader extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "onEvent", /* @__PURE__ */ __name((data) => {
      if (data.type === "device")
        switch (data.data) {
          case "bootloaderStatusChanged":
            this.onStatusChanged();
            break;
        }
    }, "onEvent"));
    __publicField(this, "onStatusChanged", /* @__PURE__ */ __name(() => {
      apiGet("devices/" + this.props.deviceID + "/bootloader-status").then(({ upgrading, progress, upgradeSuccessful, errMsg }) => {
        this.setState({
          upgrading,
          progress,
          upgradeSuccessful,
          errMsg
        });
      });
    }, "onStatusChanged"));
    __publicField(this, "upgradeFirmware", /* @__PURE__ */ __name(() => {
      apiPost("devices/" + this.props.deviceID + "/bootloader/upgrade-firmware");
    }, "upgradeFirmware"));
    this.state = {
      upgrading: !1,
      errMsg: null,
      progress: 0,
      upgradeSuccessful: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onEvent), this.onStatusChanged();
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const { t: t2 } = this.props, {
      upgrading,
      progress,
      upgradeSuccessful,
      errMsg
    } = this.state;
    let UpgradeOrStatus;
    if (upgrading)
      if (upgradeSuccessful)
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bootloader.success") });
      else {
        const value = Math.round(progress * 100);
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
            value,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none text-center", children: t2("bootloader.progress", {
            progress: value
          }) })
        ] });
      }
    else
      UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: this.upgradeFirmware,
          children: t2("bootloader.button")
        }
      ) });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$k.container, style$k.scrollable].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        UpgradeOrStatus,
        errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none", children: errMsg })
      ] })
    ] }) }) }) }) });
  }
};
__name(_Bootloader, "Bootloader");
let Bootloader = _Bootloader;
const Bootloader$1 = withTranslation()(Bootloader), container$c = "_container_l7fdu_1", danger = "_danger_l7fdu_27", children = "_children_l7fdu_31", optionalText = "_optionalText_l7fdu_35", secondaryText$1 = "_secondaryText_l7fdu_46", primaryText$1 = "_primaryText_l7fdu_54", icon = "_icon_l7fdu_58", disabled$1 = "_disabled_l7fdu_63", item$2 = "_item_l7fdu_68", style$j = {
  container: container$c,
  danger,
  children,
  optionalText,
  secondaryText: secondaryText$1,
  primaryText: primaryText$1,
  icon,
  disabled: disabled$1,
  item: item$2
}, SettingsButton = /* @__PURE__ */ __name(({
  onClick,
  danger: danger2,
  optionalText: optionalText2,
  secondaryText: secondaryText2,
  disabled: disabled2,
  children: children2,
  optionalIcon
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "button",
  {
    className: [
      style$j.container,
      danger2 ? style$j.danger : "",
      disabled2 === !0 ? style$j.disabled : ""
    ].join(" "),
    onClick: disabled2 ? void 0 : onClick,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$j.children, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.primaryText, children: children2 }),
        secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.secondaryText, children: secondaryText2 }) : null
      ] }),
      optionalText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.optionalText, children: optionalText2 }) : null,
      optionalIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.icon, children: optionalIcon }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 18 15 12 9 6" }) })
    ]
  }
), "SettingsButton"), _UpgradeFirmware = class _UpgradeFirmware extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      unlocked: !1,
      newVersion: "",
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "upgradeFirmware", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/unlock-bootloader").then((success2) => {
        this.setState({
          unlocked: success2,
          isConfirming: success2
        });
      }).catch(() => {
        this.setState({
          isConfirming: !1
        });
      });
    }, "upgradeFirmware"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({ activeDialog: !1 });
    }, "abort"));
  }
  componentDidMount() {
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
  }
  render() {
    const {
      t: t2,
      currentVersion,
      disabled: disabled2,
      asButton
    } = this.props, {
      unlocked,
      newVersion,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("upgradeFirmware.button")
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: () => this.setState({ activeDialog: !0 }),
          disabled: disabled2,
          optionalText: newVersion,
          children: t2("upgradeFirmware.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("upgradeFirmware.title"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.description", {
          currentVersion,
          newVersion
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.upgradeFirmware, children: t2("button.upgrade") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
        ] })
      ] }),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("upgradeFirmware.title"), includeDefault: !unlocked, children: unlocked ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.unlocked") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { style: { lineHeight: "1.5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked3") })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.locked", {
        currentVersion,
        newVersion
      }) }) })
    ] });
  }
};
__name(_UpgradeFirmware, "UpgradeFirmware");
let UpgradeFirmware = _UpgradeFirmware;
const UpgradeFirmware$1 = withTranslation()(UpgradeFirmware), _RequireUpgrade = class _RequireUpgrade extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null
    });
  }
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({ version }) => {
      this.setState({
        firmwareVersion: version.replace("v", "")
      });
    });
  }
  render() {
    const { t: t2, deviceID } = this.props, { firmwareVersion } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$k.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion, asButton: !0 }) })
      ] })
    ] }) });
  }
};
__name(_RequireUpgrade, "RequireUpgrade");
let RequireUpgrade = _RequireUpgrade;
const RequireUpgrade$1 = withTranslation()(RequireUpgrade), _Goal = class _Goal extends reactExports.Component {
  render() {
    const {
      t: t2,
      onCreate,
      onRestore
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("goal.paragraph") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onCreate, children: t2("goal.buttons.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: onRestore, children: t2("goal.buttons.restore") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) })
    ] }) });
  }
};
__name(_Goal, "Goal");
let Goal = _Goal;
const Goal$1 = withTranslation()(Goal), _SecurityInformation = class _SecurityInformation extends reactExports.Component {
  constructor(props) {
    super(props), this.handleStart = () => {
      this.setState({ showInfo: !1 });
    }, this.state = {
      showInfo: !0
    };
  }
  render() {
    const { t: t2, goBack, goal: goal2, children: children2 } = this.props, { showInfo } = this.state;
    return showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(`securityInformation.${goal2}.title`) }),
        goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$k.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description4") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$k.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description2") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("securityInformation.restore.description3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "warning", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("deviceTampered") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) })
    ] }) }) : children2;
  }
};
__name(_SecurityInformation, "SecurityInformation");
let SecurityInformation = _SecurityInformation;
const translatedSecutiryInformation = translate()(SecurityInformation), STATUS$1 = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
}), _SeedCreateNew = class _SeedCreateNew extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      showInfo: !0,
      status: STATUS$1.CHECKING,
      walletName: "",
      backupPassword: "",
      error: "",
      agreements: {
        password_change: !1,
        password_required: !1,
        funds_access: !1
      }
    });
    __publicField(this, "walletNameInput", reactExports.createRef());
    __publicField(this, "validate", /* @__PURE__ */ __name(() => !this.walletNameInput.current || !this.walletNameInput.current.validity.valid || !this.validAgreements() ? !1 : this.state.backupPassword && this.state.walletName !== "", "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name(({ target }) => {
      this.setState({ [target.id]: target.value });
    }, "handleFormChange"));
    __publicField(this, "handleSubmit", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ status: STATUS$1.CREATING, error: "" }), apiPost("devices/" + this.props.deviceID + "/create-wallet", {
        walletName: this.state.walletName,
        backupPassword: this.state.backupPassword
      }).then((data) => {
        data.success ? this.props.onSuccess() : this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t(`seed.error.e${data.code}`, {
            defaultValue: data.errorMessage
          })
        }), this.setState({ backupPassword: "" });
      }));
    }, "handleSubmit"));
    __publicField(this, "setValidBackupPassword", /* @__PURE__ */ __name((backupPassword) => {
      this.setState({ backupPassword });
    }, "setValidBackupPassword"));
    __publicField(this, "validAgreements", /* @__PURE__ */ __name(() => {
      const { agreements: agreements2 } = this.state;
      return !Object.keys(agreements2).map((agr) => agreements2[agr]).includes(!1);
    }, "validAgreements"));
    __publicField(this, "handleAgreementChange", /* @__PURE__ */ __name(({ target }) => {
      this.setState((state) => ({ agreements: {
        ...state.agreements,
        [target.id]: target.checked
      } }));
    }, "handleAgreementChange"));
    __publicField(this, "checkSDcard", /* @__PURE__ */ __name(() => {
      getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
        if (sdcard)
          return this.setState({ status: STATUS$1.DEFAULT, error: "" });
        this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t("seed.error.e200")
        }), setTimeout(this.checkSDcard, 2500);
      });
    }, "checkSDcard"));
    __publicField(this, "handleStart", /* @__PURE__ */ __name(() => {
      this.setState({ showInfo: !1 }), this.checkSDcard();
    }, "handleStart"));
  }
  componentDidMount() {
    this.checkSDcard();
  }
  renderSpinner() {
    switch (this.state.status) {
      case STATUS$1.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("checkSDcard") });
      case STATUS$1.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      goBack
    } = this.props, {
      showInfo,
      status: status2,
      walletName,
      error: error3,
      agreements: agreements2
    } = this.state, content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: this.handleStart,
            disabled: status2 !== STATUS$1.DEFAULT,
            children: t2("seed.info.button")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            pattern: "^[0-9a-zA-Z-_]{1,31}$",
            autoFocus: !0,
            id: "walletName",
            label: t2("seed.walletName.label"),
            disabled: status2 === STATUS$1.CREATING,
            onInput: this.handleFormChange,
            ref: this.walletNameInput,
            value: walletName
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PasswordRepeatInput,
          {
            label: t2("seed.password.label"),
            repeatPlaceholder: t2("seed.password.repeatPlaceholder"),
            disabled: status2 === STATUS$1.CREATING,
            onValidPassword: this.setValidBackupPassword
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$k.agreements, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { width: 18, marginRight: 10, position: "relative", bottom: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$k.agreementsLabel, children: t2("seed.description") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_change",
            label: t2("seed.agreements.password-change"),
            checked: agreements2.password_change,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_required",
            label: t2("seed.agreements.password-required"),
            checked: agreements2.password_required,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "funds_access",
            label: t2("seed.agreements.funds-access"),
            checked: agreements2.funds_access,
            onChange: this.handleAgreementChange
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: !0,
            disabled: !this.validate() || status2 === STATUS$1.CREATING,
            children: t2("seed.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2("seed.info.title") }),
          error3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS$1.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }),
          content2,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
};
__name(_SeedCreateNew, "SeedCreateNew");
let SeedCreateNew = _SeedCreateNew;
const SeedCreateNew$1 = withTranslation()(SeedCreateNew), convertDateToLocaleString = /* @__PURE__ */ __name((date2, language2) => new Date(date2).toLocaleString(language2, {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "2-digit",
  minute: "2-digit"
}), "convertDateToLocaleString"), stepContext = "_stepContext_g2o2c_1", backupsList = "_backupsList_g2o2c_5", listContainer$1 = "_listContainer_g2o2c_14", item$1 = "_item_g2o2c_24", agreements = "_agreements_g2o2c_37", emptyText = "_emptyText_g2o2c_41", backupItem = "_backupItem_g2o2c_47", backupID = "_backupID_g2o2c_52", backupButtons = "_backupButtons_g2o2c_59", backupStyle = {
  stepContext,
  backupsList,
  listContainer: listContainer$1,
  item: item$1,
  agreements,
  emptyText,
  backupItem,
  backupID,
  backupButtons
}, BackupsListItem = /* @__PURE__ */ __name(({
  backup: backup2,
  disabled: disabled2,
  handleChange,
  onFocus: onFocus2,
  radio: radio2,
  selectedBackup
}) => {
  let date2 = "";
  return backup2.date && backup2.date !== "" ? date2 = convertDateToLocaleString(backup2.date, instance.language) : date2 = "unknown", radio2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Radio,
    {
      disabled: !!disabled2,
      checked: selectedBackup === backup2.id,
      onChange: (event2) => {
        handleChange && handleChange(event2.target.value);
      },
      id: backup2.id,
      label: backup2.name && backup2.name !== "" ? backup2.name : backup2.id,
      value: backup2.id,
      onFocus: onFocus2,
      className: backupStyle.backupItem,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-small text-gray", children: date2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-small text-gray", children: [
          "ID: ",
          backup2.id
        ] })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-medium m-bottom-quarter", children: backup2.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupID, children: [
      "ID: ",
      backup2.id
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-small text-gray", children: date2 })
  ] });
}, "BackupsListItem");
var _a44;
let Check$1 = (_a44 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: null,
      activeDialog: !1,
      message: null
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        password: null,
        activeDialog: !1,
        message: null
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.props.selectedBackup && this.state.password, "validate"));
    __publicField(this, "check", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ message: this.props.t("backup.check.checking") }), apiPost("devices/" + this.props.deviceID + "/backups/check", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).catch(() => {
      }).then(({ success: success2, matches, errorMessage }) => {
        let message2;
        success2 ? matches ? message2 = this.props.t("backup.check.ok") : message2 = this.props.t("backup.check.notOK") : errorMessage && (message2 = errorMessage), this.setState({ message: message2 });
      }));
    }, "check"));
    __publicField(this, "setValidPassword", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "setValidPassword"));
  }
  render() {
    const {
      t: t2,
      selectedBackup
    } = this.props, {
      activeDialog,
      message: message2
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          secondary: !0,
          disabled: selectedBackup === null,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.check")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.check.title"),
          onClose: this.abort,
          children: message2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { minHeight: "3rem" }, children: message2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.check, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordSingleInput,
              {
                label: t2("backup.check.password.label"),
                placeholder: t2("backup.check.password.placeholder"),
                showLabel: t2("backup.check.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: !0, disabled: !this.validate(), children: t2("button.check") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
            ] })
          ] })
        }
      )
    ] });
  }
}, __name(_a44, "Check"), _a44);
const Check$2 = withTranslation()(Check$1);
var _a45;
let Create$1 = (_a45 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      waiting: !1,
      backupName: "",
      recoveryPassword: "",
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        waiting: !1,
        backupName: "",
        recoveryPassword: "",
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => !this.state.waiting && this.state.backupName !== "", "validate"));
    __publicField(this, "create", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ waiting: !0 }), apiPost("devices/" + this.props.deviceID + "/backups/create", {
        backupName: this.state.backupName,
        recoveryPassword: this.state.recoveryPassword
      }).then((data) => {
        this.abort(), data.success ? (this.props.onCreate(), data.verification || alertUser(this.props.t("backup.create.verificationFailed"))) : alertUser(data.errorMessage);
      }));
    }, "create"));
  }
  render() {
    const { t: t2 } = this.props, {
      waiting,
      recoveryPassword,
      backupName,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.create")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.create.title"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.create, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: !0,
                id: "backupName",
                label: t2("backup.create.name.label"),
                placeholder: t2("backup.create.name.placeholder"),
                onInput: this.handleFormChange,
                value: backupName
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.create.info") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                id: "recoveryPassword",
                label: t2("backup.create.password.label"),
                placeholder: t2("backup.create.password.placeholder"),
                onInput: this.handleFormChange,
                value: recoveryPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: !0, disabled: waiting || !this.validate(), children: t2("button.create") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.abort") })
            ] })
          ] })
        }
      )
    ] });
  }
}, __name(_a45, "Create"), _a45);
const Create$2 = withTranslation()(Create$1), _Restore = class _Restore extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      isConfirming: !1,
      activeDialog: !1,
      isLoading: !1,
      understand: !1,
      password: void 0
    }, this.abort = () => {
      this.setState({
        isConfirming: !1,
        activeDialog: !1,
        isLoading: !1,
        understand: !1,
        password: void 0
      });
    }, this.validate = () => this.props.selectedBackup && this.state.password, this.restore = (event2) => {
      event2.preventDefault(), this.validate() && (this.props.requireConfirmation ? this.setState({
        activeDialog: !1,
        isConfirming: !0
      }) : this.setState({
        activeDialog: !1,
        isLoading: !0
      }), apiPost("devices/" + this.props.deviceID + "/backups/restore", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).then((data) => {
        const { success: success2, didRestore, errorMessage, code } = data;
        if (this.abort(), success2) {
          if (didRestore) {
            if (this.props.onRestore)
              return this.props.onRestore();
            console.info("restore.jsx route to /"), route("/", !0);
          }
        } else
          alertUser(this.props.t(`backup.restore.error.e${code}`, {
            defaultValue: errorMessage
          }));
      }));
    }, this.handleUnderstandChange = (e2) => {
      this.setState({ understand: e2.target.checked });
    }, this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
  }
  render() {
    const {
      t: t2,
      selectedBackup,
      requireConfirmation
    } = this.props, {
      isConfirming,
      activeDialog,
      isLoading,
      understand
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          ...requireConfirmation ? { danger: !0 } : { primary: !0 },
          disabled: !selectedBackup,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.restore")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.restore.title"),
          disableEscape: isConfirming || isLoading,
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.restore, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                label: t2("backup.restore.password.label"),
                placeholder: t2("backup.restore.password.placeholder"),
                repeatPlaceholder: t2("backup.restore.password.repeatPlaceholder"),
                showLabel: t2("backup.restore.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("backup.restore.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "submit",
                  ...requireConfirmation ? { danger: !0 } : { primary: !0 },
                  disabled: !understand || !this.validate() || isConfirming,
                  children: t2("button.restore")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: this.abort,
                  disabled: isConfirming,
                  children: t2("button.back")
                }
              )
            ] })
          ] })
        }
      ),
      isConfirming && requireConfirmation && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.restore.confirmTitle") }),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("backup.restore.restoring") })
    ] });
  }
};
__name(_Restore, "Restore");
let Restore = _Restore;
const TranslatedRestore = translate()(Restore), _Backups = class _Backups extends reactExports.Component {
  constructor(props) {
    super(props), this.scrollableContainer = reactExports.createRef(), this.refresh = () => {
      getDeviceInfo$1(this.props.deviceID).then(({ lock }) => this.setState({ lock })), apiGet("devices/" + this.props.deviceID + "/backups/list").then(({ sdCardInserted, backupList, success: success2, errorMessage }) => {
        success2 ? this.setState({
          sdCardInserted,
          backupList
        }) : errorMessage && alertUser(errorMessage);
      });
    }, this.handleBackuplistChange = (backupID2) => {
      this.setState({ selectedBackup: backupID2 });
    }, this.scrollIntoView = (event2) => {
      if (!this.scrollableContainer.current)
        return;
      const target = event2.target, offsetTop = target.offsetTop, offsetHeight = target.parentNode.offsetHeight;
      if (offsetTop > this.scrollableContainer.current.scrollTop + offsetHeight)
        return;
      const top = Math.max(offsetTop + offsetHeight - this.scrollableContainer.current.offsetHeight, 0);
      this.scrollableContainer.current.scroll({ top, behavior: "smooth" });
    }, this.state = {
      backupList: [],
      sdCardInserted: null
    };
  }
  componentDidMount() {
    this.refresh();
  }
  render() {
    const {
      t: t2,
      children: children2,
      showCreate = !1,
      showRestore = !0,
      deviceID,
      requireConfirmation = !0,
      onRestore
    } = this.props, { backupList, selectedBackup, sdCardInserted, lock } = this.state;
    return lock === void 0 ? null : sdCardInserted === !1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("backup.insert") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.refresh, children: t2("backup.insertButton") }),
        children2
      ] })
    ] }) : sdCardInserted ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("backup.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, ref: this.scrollableContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backupList.length ? backupList.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: backup2,
          selectedBackup,
          handleChange: this.handleBackuplistChange,
          onFocus: this.scrollIntoView,
          radio: !0
        }
      ) }, backup2.id)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: backupStyle.emptyText, children: t2("backup.noBackups") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        showCreate && !lock && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Create$2,
          {
            onCreate: this.refresh,
            deviceID
          }
        ),
        showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Check$2,
          {
            selectedBackup,
            deviceID
          }
        ),
        showRestore && onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedRestore,
          {
            selectedBackup,
            deviceID,
            onRestore,
            requireConfirmation
          }
        ),
        children2
      ] })
    ] }) : null;
  }
};
__name(_Backups, "Backups");
let Backups = _Backups;
const TranslatedBackups = translate()(Backups), STATUS = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
}), _SeedRestore = class _SeedRestore extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      showInfo: !0,
      status: STATUS.CHECKING,
      error: ""
    });
    __publicField(this, "checkSDcard", /* @__PURE__ */ __name(() => {
      getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
        if (sdcard)
          return this.setState({ status: STATUS.DEFAULT, error: "" });
        this.setState({
          status: STATUS.ERROR,
          error: this.props.t("seedRestore.error.e200")
        }), setTimeout(this.checkSDcard, 2500);
      });
    }, "checkSDcard"));
    __publicField(this, "handleStart", /* @__PURE__ */ __name(() => {
      this.setState({ showInfo: !1 }), this.checkSDcard();
    }, "handleStart"));
  }
  componentDidMount() {
    this.checkSDcard();
  }
  renderSpinner() {
    switch (this.state.status) {
      case STATUS.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("checkSDcard") });
      case STATUS.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      deviceID,
      goBack,
      onSuccess
    } = this.props, {
      showInfo,
      status: status2,
      error: error3
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2("seedRestore.info.title") }),
          error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }) : null,
          showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description3") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seedRestore.info.description4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  onClick: this.handleStart,
                  disabled: status2 !== STATUS.DEFAULT,
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              showCreate: !1,
              deviceID,
              requireConfirmation: !1,
              onRestore: onSuccess,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
};
__name(_SeedRestore, "SeedRestore");
let SeedRestore = _SeedRestore;
const SeedRestore$1 = withTranslation()(SeedRestore), stateEnum = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
}), _Initialize = class _Initialize extends reactExports.Component {
  constructor(props) {
    super(props), this.handleSubmit = (event2) => {
      event2.preventDefault(), this.state.password && (this.setState({
        status: stateEnum.WAITING,
        errorCode: null,
        errorMessage: ""
      }), apiPost("devices/" + this.props.deviceID + "/set-password", {
        password: this.state.password
      }).then((data) => {
        data.success || (data.code && this.setState({ errorCode: data.code }), this.setState({
          status: stateEnum.ERROR,
          errorMessage: data.errorMessage
        }));
      }));
    }, this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    }, this.handleStart = () => {
      this.setState({ showInfo: !1 });
    }, this.state = {
      showInfo: !0,
      password: null,
      status: stateEnum.DEFAULT,
      errorCode: null,
      errorMessage: ""
    };
  }
  render() {
    const { t: t2, goBack } = this.props, { showInfo, password: password2, status: status2, errorCode, errorMessage } = this.state;
    let formSubmissionState;
    switch (status2) {
      case stateEnum.DEFAULT:
        formSubmissionState = null;
        break;
      case stateEnum.WAITING:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("initialize.creating") });
        break;
      case stateEnum.ERROR:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`initialize.error.e${errorCode}`, {
          defaultValue: errorMessage
        }) });
    }
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("initialize.info.subtitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("initialize.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordRepeatInput,
        {
          pattern: "^.{4,}$",
          label: t2("initialize.input.label"),
          repeatLabel: t2("initialize.input.labelRepeat"),
          repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
          disabled: status2 === stateEnum.WAITING,
          onValidPassword: this.setValidPassword
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: !0,
            disabled: !password2 || status2 === stateEnum.WAITING,
            children: t2("initialize.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(showInfo ? "initialize.info.title" : "setup") }),
        formSubmissionState,
        content2,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) }),
      status2 === stateEnum.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("initialize.creating") })
    ] }) });
  }
};
__name(_Initialize, "Initialize");
let Initialize = _Initialize;
const TranslatedInitialize = translate()(Initialize), _Success = class _Success extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "handleGetStarted", /* @__PURE__ */ __name(() => {
      route("/account-summary", !0);
    }, "handleGetStarted"));
  }
  render() {
    const {
      t: t2,
      handleHideSuccess,
      goal: goal2
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(`success.${goal2}.title`) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { textAlign: "center" }, children: t2(`success.${goal2}.summary`) }),
          goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$k.summary, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info3") })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleGetStarted, children: t2("success.getstarted") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: handleHideSuccess, children: t2("sidebar.device") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] })
    ] }) }) });
  }
};
__name(_Success, "Success");
let Success = _Success;
const Success$1 = withTranslation()(Success), _Blink = class _Blink extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "blinkDevice", /* @__PURE__ */ __name(() => {
      apiPost("devices/" + this.props.deviceID + "/blink");
    }, "blinkDevice"));
  }
  render() {
    const { t: t2 } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.blinkDevice, children: t2("blink.button") });
  }
};
__name(_Blink, "Blink");
let Blink = _Blink;
const Blink$1 = withTranslation()(Blink), _LegacyHiddenWallet = class _LegacyHiddenWallet extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "toggle", /* @__PURE__ */ __name(() => {
      const newValue = !this.props.newHiddenWallet;
      apiPost("devices/" + this.props.deviceID + "/feature-set", {
        new_hidden_wallet: newValue
      }).then(() => {
        alertUser(newValue ? this.props.t("legacyhiddenwallet.successDisable") : this.props.t("legacyhiddenwallet.successEnable")), this.props.onChange && this.props.onChange(newValue);
      });
    }, "toggle"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      newHiddenWallet
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        danger: !0,
        disabled: disabled2,
        onclick: this.toggle,
        children: t2(newHiddenWallet ? "legacyhiddenwallet.enable" : "legacyhiddenwallet.disable")
      }
    );
  }
};
__name(_LegacyHiddenWallet, "LegacyHiddenWallet");
let LegacyHiddenWallet = _LegacyHiddenWallet;
const LegacyHiddenWallet$1 = withTranslation()(LegacyHiddenWallet), _RandomNumber = class _RandomNumber extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "getRandomNumber", /* @__PURE__ */ __name(() => {
      apiPost(this.props.apiPrefix + "/random-number").then((number) => {
        this.setState({
          active: !0,
          number
        });
      });
    }, "getRandomNumber"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        active: !1,
        number: void 0
      });
    }, "abort"));
    this.state = {
      active: !1,
      number: ""
    };
  }
  render() {
    const { t: t2 } = this.props, { number, active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.getRandomNumber, children: t2("random.button") }),
      // @ts-ignore Object is possibly 'undefined'.
      active2 && number ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: "Generate Random Number", onClose: this.abort, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("random.description", {
            // @ts-ignore
            bits: number.length * 4
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: number, flexibleHeight: !0 })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.abort, children: t2("button.ok") }) })
      ] }) : null
    ] });
  }
};
__name(_RandomNumber, "RandomNumber");
let RandomNumber = _RandomNumber;
const RandomNumber$1 = withTranslation()(RandomNumber), _HiddenWallet = class _HiddenWallet extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: null,
      pin: null,
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        password: null,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.password && this.state.pin, "validate"));
    __publicField(this, "createHiddenWallet", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/set-hidden-password", {
        pin: this.state.pin,
        backupPassword: this.state.password
      }).catch(() => {
      }).then(({ success: success2, didCreate, errorMessage, code }) => {
        this.abort(), success2 ? didCreate && alertUser(this.props.t("hiddenWallet.success")) : alertUser(this.props.t(`bitbox.error.e${code}`, {
          defaultValue: errorMessage
        }));
      }));
    }, "createHiddenWallet"));
    __publicField(this, "setValidPassword", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "setValidPassword"));
    __publicField(this, "setValidPIN", /* @__PURE__ */ __name((pin) => {
      this.setState({ pin });
    }, "setValidPIN"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props, {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.hiddenwallet")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("button.hiddenwallet"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info1HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info2HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.createHiddenWallet, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "pin",
                  pattern: "^.{4,}$",
                  label: t2("hiddenWallet.pinLabel"),
                  repeatLabel: t2("hiddenWallet.pinRepeatLabel"),
                  repeatPlaceholder: t2("hiddenWallet.pinRepeatPlaceholder"),
                  onValidPassword: this.setValidPIN
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "password",
                  label: t2("hiddenWallet.passwordLabel"),
                  repeatPlaceholder: t2("hiddenWallet.passwordPlaceholder"),
                  onValidPassword: this.setValidPassword
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: !0, disabled: !this.validate() || isConfirming, children: t2("button.hiddenwallet") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.abort") })
              ] })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.hiddenwallet") })
    ] });
  }
};
__name(_HiddenWallet, "HiddenWallet");
let HiddenWallet = _HiddenWallet;
const HiddenWallet$1 = withTranslation()(HiddenWallet), _ChangePIN = class _ChangePIN extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      oldPIN: null,
      newPIN: null,
      errorCode: null,
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        oldPIN: null,
        newPIN: null,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.newPIN && this.state.oldPIN, "validate"));
    __publicField(this, "changePin", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/change-password", {
        oldPIN: this.state.oldPIN,
        newPIN: this.state.newPIN
      }).catch(() => {
      }).then((data) => {
        this.abort(), data.success || alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }));
    }, "changePin"));
    __publicField(this, "setValidOldPIN", /* @__PURE__ */ __name((e2) => {
      this.setState({ oldPIN: e2.target.value });
    }, "setValidOldPIN"));
    __publicField(this, "setValidNewPIN", /* @__PURE__ */ __name((newPIN) => {
      this.setState({ newPIN });
    }, "setValidNewPIN"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props, {
      oldPIN,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.changepin")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("button.changepin"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.changePin, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "oldPIN",
                label: t2("changePin.oldLabel"),
                value: oldPIN,
                onInput: this.setValidOldPIN
              }
            ),
            t2("changePin.newTitle") && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("changePin.newTitle") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                idPrefix: "newPIN",
                pattern: "^.{4,}$",
                label: t2("initialize.input.label"),
                repeatLabel: t2("initialize.input.labelRepeat"),
                repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
                onValidPassword: this.setValidNewPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: !0, disabled: !this.validate() || isConfirming, children: t2("button.changepin") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ] })
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.changepin") })
    ] });
  }
};
__name(_ChangePIN, "ChangePIN");
let ChangePIN = _ChangePIN;
const ChangePIN$1 = withTranslation()(ChangePIN), _Reset = class _Reset extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      pin: null,
      isConfirming: !1,
      activeDialog: !1,
      understand: !1
    });
    __publicField(this, "handleUnderstandChange", /* @__PURE__ */ __name((e2) => {
      this.setState({ understand: e2.target.checked });
    }, "handleUnderstandChange"));
    __publicField(this, "resetDevice", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/reset", { pin: this.state.pin }).then((data) => {
        this.abort(), data.success ? data.didReset && route("/", !0) : data.errorMessage && alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      });
    }, "resetDevice"));
    __publicField(this, "setValidPIN", /* @__PURE__ */ __name((e2) => {
      this.setState({ pin: e2.target.value });
    }, "setValidPIN"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        pin: null,
        understand: !1,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
  }
  render() {
    const { t: t2 } = this.props, {
      isConfirming,
      activeDialog,
      understand,
      pin
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { danger: !0, onClick: () => this.setState({ activeDialog: !0 }), children: t2("reset.title") }),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("reset.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "pin",
                label: t2("initialize.input.label"),
                value: pin,
                onInput: this.setValidPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$k.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("reset.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, disabled: !pin || !understand, onClick: this.resetDevice, children: t2("reset.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("reset.title") }) : null
    ] });
  }
};
__name(_Reset, "Reset");
let Reset = _Reset;
const Reset$1 = withTranslation()(Reset), appStoreBadge = "" + new URL("app-store-badge.svg", import.meta.url).href, playStoreBadge = "" + new URL("google-play-badge.png", import.meta.url).href, _MobilePairing = class _MobilePairing extends reactExports.Component {
  constructor(props) {
    super(props), this.onDeviceStatus = (payload) => {
      if ("type" in payload) {
        const { type: type2, data, deviceID } = payload;
        if (type2 === "device" && deviceID === this.props.deviceID)
          switch (data) {
            case "pairingStarted":
              this.setState({ status: "started" });
              break;
            case "pairingTimedout":
              this.state.status && this.setState({ status: "timeout" });
              break;
            case "pairingPullMessageFailed":
              this.setState({ status: "pullFailed" });
              break;
            case "pairingScanningFailed":
              this.setState({ status: "scanningFailed" });
              break;
            case "pairingAborted":
              this.setState({ status: "aborted" });
              break;
            case "pairingError":
              this.setState({ status: "error" });
              break;
            case "pairingSuccess":
              this.setState({ status: "success" });
              break;
          }
      }
    }, this.reconnectUnpaired = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        response && apiPost("devices/" + this.props.deviceID + "/feature-set", {
          pairing: !0
        }).then(() => {
          this.props.onPairingEnabled(), alertUser(this.props.t("pairing.success.text"));
        });
      });
    }, this.startPairing = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        response && (this.setState({
          channel: null,
          status: "loading"
        }), apiPost("devices/" + this.props.deviceID + "/pairing/start").then((channel) => {
          this.props.deviceLocked ? this.setState({
            channel,
            status: "connectOnly"
          }) : this.setState({
            channel,
            status: "start"
          });
        }));
      });
    }, this.abort = () => {
      this.setState({
        showQRCode: !1,
        status: !1
      });
    }, this.toggleQRCode = () => {
      this.setState({ showQRCode: !this.state.showQRCode });
    }, this.state = {
      channel: null,
      status: !1,
      showQRCode: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onDeviceStatus);
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const { t: t2, deviceLocked, paired, hasMobileChannel: hasMobileChannel2 } = this.props, { channel, status: status2, showQRCode } = this.state;
    let content2;
    return status2 === "start" ? content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "1." }),
          " ",
          t2("pairing.start.step1")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.toggleQRCode, className: "width-1-1", children: t2(`pairing.start.${showQRCode ? "hideAppQRCode" : "revealAppQRCode"}`) }) }),
        showQRCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Apple App Store" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", size: 148 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: appStoreBadge, className: style$k.badge }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Google Play Store" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", size: 148 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playStoreBadge, className: style$k.badge }) })
            ] })
          ] })
        ] }) }) : null
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "2." }),
          t2("pairing.start.step2")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: JSON.stringify(channel), size: 196 }) })
      ] }) })
    ] }) : status2 === "connectOnly" ? content2 = /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: JSON.stringify({ channel, connectOnly: !0 }) }) : content2 = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2(`pairing.${status2}.text`) }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: hasMobileChannel2 && !paired ? this.reconnectUnpaired : this.startPairing,
          optionalText: t2(`deviceSettings.pairing.status.${paired}`),
          children: t2(deviceLocked ? hasMobileChannel2 ? "pairing.reconnectOnly.button" : "pairing.connectOnly.button" : hasMobileChannel2 && !paired ? "pairing.reconnectOnly.button" : "pairing.button")
        }
      ),
      status2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("pairing.title"),
          onClose: this.abort,
          medium: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-center flex-items-center", children: channel ? content2 : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("loading") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") }) })
          ]
        }
      )
    ] });
  }
};
__name(_MobilePairing, "MobilePairing");
let MobilePairing = _MobilePairing;
const translatedMobilePairing = translate()(MobilePairing), _DeviceLock = class _DeviceLock extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "resetDevice", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/lock").then((didLock) => {
        this.setState({
          isConfirming: !1
        }), didLock && this.props.onLock();
      });
    }, "resetDevice"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({ activeDialog: !1 });
    }, "abort"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      lock
    } = this.props, {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          danger: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          disabled: disabled2,
          optionalText: t2(`deviceSettings.pairing.lock.${lock}`),
          children: t2("deviceLock.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("deviceLock.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, onClick: this.resetDevice, children: t2("deviceLock.confirm") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("deviceLock.title") })
    ] });
  }
};
__name(_DeviceLock, "DeviceLock");
let DeviceLock = _DeviceLock;
const DeviceLock$1 = withTranslation()(DeviceLock), SettingsItem$1 = /* @__PURE__ */ __name(({ optionalText: optionalText2, optionalIcon, children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$j.container, style$j.item].join(" "), children: [
  children2,
  optionalText2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.optionalText, children: optionalText2 }),
  optionalIcon
] }), "SettingsItem$1"), _Settings = class _Settings extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null,
      newVersion: null,
      lock: !0,
      name: null,
      spinner: !0,
      sdcard: !1,
      serial: "",
      pairing: !1,
      mobileChannel: !1,
      connected: !1,
      newHiddenWallet: !0
    });
  }
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({
      lock,
      name,
      new_hidden_wallet,
      pairing: pairing2,
      sdcard,
      serial,
      version
    }) => {
      this.setState({
        firmwareVersion: version.replace("v", ""),
        lock,
        name,
        newHiddenWallet: new_hidden_wallet,
        pairing: pairing2,
        sdcard,
        serial,
        spinner: !1
      });
    }), apiGet("devices/" + this.props.deviceID + "/has-mobile-channel").then((mobileChannel) => {
      this.setState({ mobileChannel });
    }), apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    }), this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "device") {
        if (deviceID !== this.props.deviceID)
          return;
        switch (data) {
          case "mobileDisconnected":
            this.setState({ connected: !1 });
            break;
          case "mobileConnected":
            this.setState({ connected: !0 });
            break;
          case "pairingSuccess":
            this.setState({ pairing: !0, mobileChannel: !0 });
            break;
          case "pairingFalse":
            this.setState({ mobileChannel: !1 });
            break;
        }
      }
    });
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const {
      t: t2,
      deviceID
    } = this.props, {
      firmwareVersion,
      newVersion,
      lock,
      name,
      spinner: spinner4,
      sdcard,
      serial,
      pairing: pairing2,
      mobileChannel,
      connected,
      newHiddenWallet
    } = this.state, canUpgrade = firmwareVersion && newVersion !== firmwareVersion, paired = pairing2 && mobileChannel;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: name === null ? "" : name || "BitBox" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columnsContainer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.secrets.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: () => route(`/manage-backups/${deviceID}`), children: t2("deviceSettings.secrets.manageBackups") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChangePIN$1, { deviceID }),
                newHiddenWallet ? /* @__PURE__ */ jsxRuntimeExports.jsx(HiddenWallet$1, { deviceID, disabled: lock }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LegacyHiddenWallet$1,
                  {
                    deviceID,
                    newHiddenWallet,
                    disabled: lock,
                    onChange: (value) => this.setState({ newHiddenWallet: value })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Reset$1, { deviceID })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.pairing.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.pairing.mobile.${connected}`), children: t2("deviceSettings.pairing.mobile.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  translatedMobilePairing,
                  {
                    deviceID,
                    deviceLocked: lock,
                    hasMobileChannel: mobileChannel,
                    paired,
                    onPairingEnabled: () => this.setState({ pairing: !0 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DeviceLock$1,
                  {
                    lock,
                    deviceID,
                    onLock: () => this.setState({ lock: !0 }),
                    disabled: lock || !paired
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.firmware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box slim divide", children: canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: `${t2("deviceSettings.firmware.version.label")} ${firmwareVersion || t2("loading")}`, children: t2("deviceSettings.firmware.upToDate") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.hardware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: serial, children: "Serial number" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.hardware.sdcard.${sdcard}`), children: t2("deviceSettings.hardware.sdcard.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(RandomNumber$1, { apiPrefix: "devices/" + deviceID }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Blink$1, { deviceID })
              ] })
            ] })
          ] })
        ] }) }),
        spinner4 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: t2("deviceSettings.loading") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectBitbox") }, "guide.bitbox.ejectBitbox"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectSD") }, "guide.bitbox.ejectSD"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.hiddenWallet") }, "guide.bitbox.hiddenWallet"),
        !lock && newHiddenWallet && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.legacyHiddenWallet"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LegacyHiddenWallet$1,
          {
            deviceID,
            newHiddenWallet,
            onChange: (value) => this.setState({ newHiddenWallet: value })
          }
        ) }) }, "guide.bitbox.legacyHiddenWallet"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.pairing") }, "guide.bitbox.pairing"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.2FA") }, "guide.bitbox.2FA"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.disable2FA") }, "guide.bitbox.disable2FA")
      ] })
    ] });
  }
};
__name(_Settings, "Settings");
let Settings = _Settings;
const Settings$1 = withTranslation()(Settings), DeviceStatus = Object.freeze({
  BOOTLOADER: "bootloader",
  INITIALIZED: "initialized",
  UNINITIALIZED: "uninitialized",
  LOGGED_IN: "logged_in",
  SEEDED: "seeded",
  REQUIRE_FIRMWARE_UPGRADE: "require_firmware_upgrade",
  REQUIRE_APP_UPGRADE: "require_app_upgrade"
}), GOAL = Object.freeze({
  CREATE: "create",
  RESTORE: "restore"
}), _Device = class _Device extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null,
      deviceRegistered: !1,
      deviceStatus: "",
      goal: "",
      success: null
    });
    __publicField(this, "onDevicesRegisteredChanged", /* @__PURE__ */ __name(() => {
      apiGet("devices/registered").then((devices) => {
        const deviceRegistered = Object.keys(devices).includes(this.getDeviceID());
        this.setState({
          deviceRegistered,
          deviceStatus: null
        }, () => {
          this.state.deviceRegistered && this.onDeviceStatusChanged();
        });
      });
    }, "onDevicesRegisteredChanged"));
    __publicField(this, "onDeviceStatusChanged", /* @__PURE__ */ __name(() => {
      this.state.deviceRegistered && apiGet("devices/" + this.props.deviceID + "/status").then((deviceStatus) => {
        ["seeded", "initialized"].includes(deviceStatus) ? setSidebarStatus("") : setSidebarStatus("forceHidden"), this.setState({ deviceStatus });
      });
    }, "onDeviceStatusChanged"));
    __publicField(this, "handleCreate", /* @__PURE__ */ __name(() => {
      this.setState({ goal: GOAL.CREATE });
    }, "handleCreate"));
    __publicField(this, "handleRestore", /* @__PURE__ */ __name(() => {
      this.setState({ goal: GOAL.RESTORE });
    }, "handleRestore"));
    __publicField(this, "handleBack", /* @__PURE__ */ __name(() => {
      this.setState({ goal: null });
    }, "handleBack"));
    __publicField(this, "handleSuccess", /* @__PURE__ */ __name(() => {
      this.setState({ success: !0 });
    }, "handleSuccess"));
  }
  componentDidMount() {
    this.onDevicesRegisteredChanged(), this.onDeviceStatusChanged(), this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      type2 === "devices" && data === "registeredChanged" && this.onDevicesRegisteredChanged(), type2 === "device" && data === "statusChanged" && deviceID === this.getDeviceID() && this.onDeviceStatusChanged();
    });
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  componentDidUpdate(prevProps) {
    this.props.deviceID !== prevProps.deviceID && this.onDevicesRegisteredChanged();
  }
  getDeviceID() {
    return this.props.deviceID || null;
  }
  render() {
    const {
      deviceID
    } = this.props, {
      deviceRegistered,
      deviceStatus,
      goal: goal2,
      success: success2
    } = this.state;
    if (!deviceRegistered || !deviceStatus)
      return null;
    if (success2)
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Success$1, { goal: goal2, handleHideSuccess: () => this.setState({ success: null }) });
    switch (deviceStatus) {
      case DeviceStatus.BOOTLOADER:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Bootloader$1, { deviceID });
      case DeviceStatus.REQUIRE_FIRMWARE_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RequireUpgrade$1, { deviceID });
      case DeviceStatus.REQUIRE_APP_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
      case DeviceStatus.INITIALIZED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Unlock$2, { deviceID });
      case DeviceStatus.UNINITIALIZED:
        return goal2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(translatedSecutiryInformation, { goal: goal2, goBack: this.handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedInitialize, { goBack: this.handleBack, deviceID }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
      case DeviceStatus.LOGGED_IN:
        switch (goal2) {
          case GOAL.CREATE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedCreateNew$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          case GOAL.RESTORE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedRestore$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
      case DeviceStatus.SEEDED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, { deviceID });
      default:
        return null;
    }
  }
};
__name(_Device, "Device");
let Device = _Device;
const BitBox01 = withTranslation()(Device), syncDeviceList = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("devices/registered", cb2), "syncDeviceList"), statusChanged = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("statusChanged", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2();
}), "statusChanged"), channelHashChanged = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("channelHashChanged", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2(deviceID);
}), "channelHashChanged"), attestationCheckDone = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("attestationCheckDone", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2(deviceID);
}), "attestationCheckDone"), container$b = "_container_6tizs_1", primaryText = "_primaryText_6tizs_21", isButton = "_isButton_6tizs_27", rightContentContainer = "_rightContentContainer_6tizs_32", displayedValue = "_displayedValue_6tizs_38", withMargin = "_withMargin_6tizs_47", secondaryText = "_secondaryText_6tizs_51", collapse = "_collapse_6tizs_74", hideDisplayedValueOnSmall = "_hideDisplayedValueOnSmall_6tizs_87", styles$h = {
  container: container$b,
  primaryText,
  isButton,
  rightContentContainer,
  displayedValue,
  withMargin,
  secondaryText,
  collapse,
  hideDisplayedValueOnSmall
}, SettingsItem = /* @__PURE__ */ __name(({
  className = "",
  collapseOnSmall = !1,
  displayedValue: displayedValue2 = "",
  extraComponent,
  hideDisplayedValueOnSmall: hideDisplayedValueOnSmall2 = !1,
  onClick,
  secondaryText: secondaryText2,
  settingName: settingName2
}) => {
  const notButton = onClick === void 0, rightContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.rightContentContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: `
        ${displayedValue2 ? styles$h.displayedValue : ""}
        ${extraComponent ? styles$h.withMargin : ""}
        ${hideDisplayedValueOnSmall2 ? styles$h.hideDisplayedValueOnSmall : ""}
       `,
        children: displayedValue2
      }
    ),
    extraComponent || null
  ] }), content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      typeof settingName2 == "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$h.primaryText, children: settingName2 }) : settingName2,
      secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$h.secondaryText, children: secondaryText2 }) : null
    ] }),
    rightContent
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: notButton ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$h.container} ${className} 
          ${collapseOnSmall ? styles$h.collapse : ""}`, children: content2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: `${styles$h.container} ${styles$h.isButton} ${className}`,
      onClick,
      children: content2
    }
  ) });
}, "SettingsItem"), container$a = "_container_1rta5_1", active$1 = "_active_1rta5_13", styles$g = {
  container: container$a,
  active: active$1
}, WithSettingsTabs = /* @__PURE__ */ __name(({
  children: children2,
  deviceIDs,
  hideMobileMenu,
  hasAccounts
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { hideMobileMenu, deviceIDs, hasAccounts }) }),
  children2
] }), "WithSettingsTabs"), Tab = /* @__PURE__ */ __name(({ name, url, hideMobileMenu }) => hideMobileMenu ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  NavLink,
  {
    className: ({ isActive }) => isActive ? `${styles$g.active} hide-on-small` : "hide-on-small",
    to: url,
    children: name
  },
  url
) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "show-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  SettingsItem,
  {
    settingName: name,
    onClick: () => route(url),
    extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
  }
) }, url), "Tab"), Tabs = /* @__PURE__ */ __name(({ deviceIDs, hideMobileMenu, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.appearance"), url: "/settings/appearance" }, "appearance"),
    hasAccounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("manageAccounts.title"), url: "/settings/manage-accounts" }, "manage-accounts") : null,
    deviceIDs.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("sidebar.device"), url: `/settings/device-settings/${id2}` }, `device-${id2}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.advancedSettings"), url: "/settings/advanced-settings" }, "advanced-settings"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.about"), url: "/settings/about" }, "about")
  ] });
}, "Tabs"), ManageBackupSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/manage-backups/${deviceID}`),
      settingName: t2("backup.title"),
      secondaryText: t2("deviceSettings.backups.manageBackups.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
}, "ManageBackupSetting"), ShowRecoveryWordsSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [inProgress, setInProgress] = reactExports.useState(!1), [showDialog, setShowDialog] = reactExports.useState(!1), confirmShowWords = /* @__PURE__ */ __name(async () => {
    setShowDialog(!1), setInProgress(!0), await showMnemonic(deviceID), setInProgress(!1);
  }, "confirmShowWords");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("backup.showMnemonic.title"),
        secondaryText: t2("deviceSettings.backups.showRecoveryWords.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setShowDialog(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMnemonicWaitDialog, { inProgress }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("backup.showMnemonic.title"), open: showDialog, onClose: () => setShowDialog(!1), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MultilineMarkup,
        {
          markup: t2("backup.showMnemonic.description"),
          tagName: "span",
          withBreaks: !0
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: confirmShowWords, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => setShowDialog(!1), children: t2("dialog.cancel") })
      ] })
    ] })
  ] });
}, "ShowRecoveryWordsSetting"), ShowMnemonicWaitDialog = /* @__PURE__ */ __name(({ inProgress }) => {
  const { t: t2 } = useTranslation();
  return inProgress ? /* @__PURE__ */ jsxRuntimeExports.jsxs(TranslatedWaitDialog, { title: t2("backup.showMnemonic.title"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MultilineMarkup,
      {
        markup: t2("backup.showMnemonic.description"),
        tagName: "span",
        withBreaks: !0
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Interact.followInstructions") })
  ] }) : null;
}, "ShowMnemonicWaitDialog"), StartupSettingsWaitDialog = /* @__PURE__ */ __name(({ show: show2 }) => {
  const { t: t2 } = useTranslation();
  return show2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("bitbox02Settings.gotoStartupSettings.title"),
      children: t2("bitbox02Settings.gotoStartupSettings.description")
    }
  ) : null;
}, "StartupSettingsWaitDialog"), GoToStartupSettings = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [show2, setShow] = reactExports.useState(!1), handleGoToStartupSettings = /* @__PURE__ */ __name(async () => {
    setShow(!0), await apiPost(`devices/bitbox02/${deviceID}/goto-startup-settings`).catch(console.error), setShow(!1);
  }, "handleGoToStartupSettings");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.gotoStartupSettings.title"),
        secondaryText: t2("deviceSettings.expert.goToStartupSettings.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: handleGoToStartupSettings
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StartupSettingsWaitDialog, { show: show2 })
  ] });
}, "GoToStartupSettings"), PassphraseSetting = /* @__PURE__ */ __name(({ deviceID, passphraseEnabled }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/settings/device-settings/passphrase/${deviceID}`),
      settingName: t2("deviceSettings.expert.passphrase.title"),
      secondaryText: t2("deviceSettings.expert.passphrase.description"),
      displayedValue: t2(passphraseEnabled ? "generic.enabled_true" : "generic.enabled_false"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
}, "PassphraseSetting"), AttestationCheckSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const [attestation, setAttestation] = reactExports.useState(null), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    verifyAttestation(deviceID).then(setAttestation);
  }, [deviceID]);
  const icon2 = attestation ? /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { width: 20, height: 20 });
  return attestation === null ? /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.attestation.label"),
      secondaryText: t2("deviceSettings.deviceInformation.attestation.description"),
      extraComponent: icon2,
      displayedValue: t2(`deviceSettings.hardware.attestation.${attestation}`),
      hideDisplayedValueOnSmall: !0
    }
  );
}, "AttestationCheckSetting"), FirmwareSetting = /* @__PURE__ */ __name(({ deviceID, versionInfo, asButton = !1 }) => {
  const { t: t2 } = useTranslation(), [dialogOpen, setDialogOpen] = reactExports.useState(!1), [confirming, setConfirming] = reactExports.useState(!1), canUpgrade = versionInfo.canUpgrade, secondaryText2 = t2(canUpgrade ? "deviceSettings.firmware.upgradeAvailable" : "deviceSettings.firmware.upToDate"), extraComponent = canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}), handleOpenDialog = canUpgrade ? () => setDialogOpen(!0) : void 0, handleUpgradeFirmware = /* @__PURE__ */ __name(async () => {
    setConfirming(!0), await upgradeDeviceFirmware(deviceID), setConfirming(!1), setDialogOpen(!1);
  }, "handleUpgradeFirmware");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleOpenDialog,
        primary: !0,
        children: t2("button.upgrade")
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("deviceSettings.firmware.title"),
        secondaryText: secondaryText2,
        onClick: handleOpenDialog,
        displayedValue: versionInfo.currentVersion,
        extraComponent
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UpgradeDialog,
      {
        open: dialogOpen && canUpgrade,
        versionInfo,
        confirming,
        onUpgradeFirmware: handleUpgradeFirmware,
        onClose: () => setDialogOpen(!1)
      }
    )
  ] });
}, "FirmwareSetting"), UpgradeDialog = /* @__PURE__ */ __name(({
  open: open2,
  versionInfo,
  confirming,
  onUpgradeFirmware,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onClose, open: open2, title: t2("upgradeFirmware.title"), children: [
    confirming ? t2("confirmOnDevice") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("upgradeFirmware.description", {
      currentVersion: versionInfo.currentVersion,
      newVersion: versionInfo.newVersion
    }) }),
    !confirming && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: onUpgradeFirmware,
          children: t2("button.upgrade")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: onClose, children: t2("button.back") })
    ] })
  ] });
}, "UpgradeDialog"), SecureChipSetting = /* @__PURE__ */ __name(({ secureChipModel }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.securechip"),
      secondaryText: t2("deviceSettings.deviceInformation.securechip.description"),
      displayedValue: secureChipModel
    }
  );
}, "SecureChipSetting"), DeviceNameSetting = /* @__PURE__ */ __name(({ deviceName, deviceID }) => {
  const { t: t2 } = useTranslation(), [active2, setActive] = reactExports.useState(!1), [currentName, setCurrentName] = reactExports.useState(deviceName), [name, setName] = reactExports.useState(""), [inProgress, setInProgress] = reactExports.useState(!1), updateName = /* @__PURE__ */ __name(async () => {
    setInProgress(!0);
    try {
      const setNameResult = await setDeviceName(deviceID, name);
      if (!setNameResult.success)
        throw new Error(setNameResult.message);
      const deviceInfoResult = await getDeviceInfo(deviceID);
      if (!deviceInfoResult.success)
        throw new Error(deviceInfoResult.message);
      setCurrentName(deviceInfoResult.deviceInfo.name);
    } catch (error3) {
      alertUser(t2("bitbox02Settings.deviceName.error")), console.error(error3);
    } finally {
      setActive(!1), setInProgress(!1);
    }
  }, "updateName"), handleCloseDialog = /* @__PURE__ */ __name(() => {
    setActive(!1), setName("");
  }, "handleCloseDialog");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.deviceName.input"),
        secondaryText: t2("deviceSettings.deviceInformation.deviceName.description"),
        displayedValue: currentName,
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActive(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetDeviceNameDialog,
      {
        open: active2,
        onClose: handleCloseDialog,
        currentName,
        onInputChange: (e2) => setName(e2.target.value),
        name,
        handleUpdateName: updateName
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetDeviceNameWaitDialog, { inProgress })
  ] });
}, "DeviceNameSetting"), SetDeviceNameDialog = /* @__PURE__ */ __name(({ open: open2, onClose, currentName, onInputChange, name, handleUpdateName }) => {
  var _a46;
  const { t: t2 } = useTranslation(), inputRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      onClose,
      title: t2("bitbox02Settings.deviceName.title"),
      small: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns half", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("bitbox02Settings.deviceName.current") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-half", children: currentName })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              pattern: "^.{0,63}$",
              label: t2("bitbox02Settings.deviceName.input"),
              onInput: onInputChange,
              ref: inputRef,
              placeholder: t2("bitbox02Settings.deviceName.placeholder"),
              value: name,
              id: "deviceName"
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            disabled: !(name && ((_a46 = inputRef == null ? void 0 : inputRef.current) != null && _a46.validity.valid)),
            onClick: handleUpdateName,
            children: t2("button.ok")
          }
        ) })
      ]
    }
  );
}, "SetDeviceNameDialog"), SetDeviceNameWaitDialog = /* @__PURE__ */ __name(({ inProgress }) => {
  const { t: t2 } = useTranslation();
  return inProgress ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: t2("bitbox02Interact.followInstructions") }) : null;
}, "SetDeviceNameWaitDialog"), settingNameContainer = "_settingNameContainer_usdew_1", settingName = "_settingName_usdew_1", styles$f = {
  settingNameContainer,
  settingName
}, FactoryResetSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const [understand, setUnderstand] = reactExports.useState(!1), [isConfirming, setIsConfirming] = reactExports.useState(!1), [activeDialog, setActiveDialog] = reactExports.useState(!1), { t: t2 } = useTranslation(), abort = /* @__PURE__ */ __name(() => {
    setUnderstand(!1), setIsConfirming(!1), setActiveDialog(!1);
  }, "abort"), handleUnderstandChange = /* @__PURE__ */ __name((e2) => {
    setUnderstand(e2.target.checked);
  }, "handleUnderstandChange"), reset2 = /* @__PURE__ */ __name(async () => {
    setActiveDialog(!1), setIsConfirming(!0);
    const responseData = await resetDevice(deviceID);
    abort(), responseData.success || alertUser(t2("reset.notReset"));
  }, "reset"), settingName2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.settingNameContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WarningOutlined, { width: 16, height: 16 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$f.settingName, children: t2("deviceSettings.expert.factoryReset.title") })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: settingName2,
        secondaryText: t2("deviceSettings.expert.factoryReset.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActiveDialog(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FactoryResetDialog,
      {
        open: activeDialog,
        handleCloseDialog: abort,
        isConfirming,
        understand,
        handleUnderstandChange,
        handleReset: reset2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetWaitDialog, { isConfirming })
  ] });
}, "FactoryResetSetting"), FactoryResetDialog = /* @__PURE__ */ __name(({
  open: open2,
  handleCloseDialog,
  isConfirming,
  understand,
  handleUnderstandChange,
  handleReset
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      title: t2("reset.title"),
      onClose: handleCloseDialog,
      disabledClose: isConfirming,
      small: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: "reset_understand",
              label: t2("reset.understandBB02"),
              checked: understand,
              onChange: handleUnderstandChange
            }
          ) })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, disabled: !understand, onClick: handleReset, children: t2("reset.title") }) })
      ]
    }
  );
}, "FactoryResetDialog"), FactoryResetWaitDialog = /* @__PURE__ */ __name(({ isConfirming }) => {
  const { t: t2 } = useTranslation();
  return isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("reset.title"),
      children: t2("bitbox02Interact.followInstructions")
    }
  ) : null;
}, "FactoryResetWaitDialog"), RootFingerprintSetting = /* @__PURE__ */ __name(({ rootFingerprint }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: "Root fingerprint",
      secondaryText: t2("deviceSettings.deviceInformation.rootFingerprint.description"),
      displayedValue: rootFingerprint
    }
  );
}, "RootFingerprintSetting"), section = "_section_18i3w_1", skeletonWrapper = "_skeletonWrapper_18i3w_9", styles$e = {
  section,
  skeletonWrapper
}, getLink = /* @__PURE__ */ __name(() => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/bitbox02/sicherheit/#device-authenticity-check";
    case "es":
      return "https://bitbox.swiss/es/bitbox02/seguridad/#device-authenticity-check";
    default:
      return "https://bitbox.swiss/bitbox02/security-features/#device-authenticity-check";
  }
}, "getLink"), ManageDeviceGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.device.name") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.secure-chip.link.text"),
        url: "https://bitbox.swiss/blog/bitbox-05-2021-masnee-update/#check-your-secure-chip-variant"
      },
      text: t2("guide.device.secure-chip.text"),
      title: t2("guide.device.secure-chip.title")
    } }, "guide.device.secure-chip"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.attestation.link.text"),
        url: getLink()
      },
      text: t2("guide.device.attestation.text"),
      title: t2("guide.device.attestation.title")
    } }, "guide.device.attestation")
  ] });
}, "ManageDeviceGuide"), container$9 = "_container_flzib_1", backButton = "_backButton_flzib_7", headerText = "_headerText_flzib_31", withGuide = "_withGuide_flzib_40", styles$d = {
  container: container$9,
  backButton,
  headerText,
  withGuide
}, MobileHeader = /* @__PURE__ */ __name(({ title: title2, withGuide: withGuide2 = !1 }) => {
  const { t: t2 } = useTranslation(), handleClick = /* @__PURE__ */ __name(() => {
    route("/settings");
  }, "handleClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$d.container} ${withGuide2 ? `${styles$d.withGuide}` : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleClick, className: styles$d.backButton, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftDark, {}),
      " ",
      t2("button.back")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$d.headerText, children: title2 })
  ] });
}, "MobileHeader"), StyledSkeleton = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$e.skeletonWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "var(--item-height-xlarge)" }) }), "StyledSkeleton"), BB02Settings = /* @__PURE__ */ __name(({ deviceID, deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("sidebar.device") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: !0,
          hasAccounts,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { deviceID })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDeviceGuide, {})
  ] }) });
}, "BB02Settings"), Content = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [deviceInfo, setDeviceInfo] = reactExports.useState(), versionInfo = useLoad(() => getVersion(deviceID), [deviceID]), rootFingerprintResult = useLoad(() => getRootFingerprint(deviceID), [deviceID]);
  return reactExports.useEffect(() => {
    getDeviceInfo(deviceID).then((result) => {
      if (!result.success) {
        alertUser(t2("genericError"));
        return;
      }
      setDeviceInfo(result.deviceInfo);
    }).catch(console.error);
  }, [deviceID, t2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.backups.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ManageBackupSetting, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ShowRecoveryWordsSetting, { deviceID })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.deviceInformation.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeviceNameSetting,
        {
          deviceName: deviceInfo.name,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AttestationCheckSetting, { deviceID }),
      versionInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        FirmwareSetting,
        {
          deviceID,
          versionInfo
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      deviceInfo && deviceInfo.securechipModel !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SecureChipSetting, { secureChipModel: deviceInfo.securechipModel }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      rootFingerprintResult && rootFingerprintResult.success ? /* @__PURE__ */ jsxRuntimeExports.jsx(RootFingerprintSetting, { rootFingerprint: rootFingerprintResult.rootFingerprint }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("settings.expert.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        PassphraseSetting,
        {
          passphraseEnabled: deviceInfo.mnemonicPassphraseEnabled,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(GoToStartupSettings, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetSetting, { deviceID })
    ] })
  ] });
}, "Content"), BitBox02 = /* @__PURE__ */ __name(({ deviceID, deviceIDs, hasAccounts }) => useSync(
  () => getStatus$1(deviceID),
  (cb2) => statusChanged(deviceID, () => {
    getStatus$1(deviceID).then(cb2);
  })
) !== "initialized" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(BB02Settings, { deviceID, deviceIDs, hasAccounts }), "BitBox02"), getStatus = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02-bootloader/${deviceID}/status`), "getStatus"), syncStatus = /* @__PURE__ */ __name((deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02-bootloader/${deviceID}/status`, cb2), "syncStatus"), getVersionInfo = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02-bootloader/${deviceID}/version-info`), "getVersionInfo"), upgradeFirmware = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/upgrade-firmware`), "upgradeFirmware"), reboot = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/reboot`), "reboot"), screenRotate = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/screen-rotate`), "screenRotate"), getShowFirmwareHash = /* @__PURE__ */ __name((deviceID) => () => apiGet(`devices/bitbox02-bootloader/${deviceID}/show-firmware-hash-enabled`), "getShowFirmwareHash"), setShowFirmwareHash = /* @__PURE__ */ __name((deviceID, enabled) => apiPost(
  `devices/bitbox02-bootloader/${deviceID}/set-firmware-hash-enabled`,
  enabled
), "setShowFirmwareHash"), container$8 = "_container_18axn_1", style$i = {
  container: container$8
}, CenteredContent = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$i.container, children: children2 }) }), "CenteredContent"), container$7 = "_container_14uup_1", slider = "_slider_14uup_16", style$h = {
  container: container$7,
  slider
}, Toggle = /* @__PURE__ */ __name(({
  className = "",
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `${style$h.container} ${className}`, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      ...props
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$h.slider })
] }), "Toggle"), ToggleShowFirmwareHash = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [enabledState, setEnabledState] = reactExports.useState(!1), enabledConfig = useLoad(getShowFirmwareHash(deviceID));
  reactExports.useEffect(() => {
    enabledConfig !== void 0 && setEnabledState(enabledConfig);
  }, [enabledConfig]);
  const handleToggle = /* @__PURE__ */ __name((event2) => {
    const enabled = event2.target.checked;
    setShowFirmwareHash(deviceID, enabled), setEnabledState(enabled);
  }, "handleToggle");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bb02Bootloader.advanced.toggleShowFirmwareHash") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        checked: enabledState,
        id: "togggle-show-firmware-hash",
        onChange: handleToggle
      }
    )
  ] });
}, "ToggleShowFirmwareHash"), BitBox02Bootloader = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), status2 = useSync(
    () => getStatus(deviceID),
    syncStatus(deviceID)
  ), versionInfo = useLoad(() => getVersionInfo(deviceID));
  if (versionInfo === void 0)
    return null;
  let contents;
  if (status2 && status2.upgrading)
    if (status2.upgradeSuccessful)
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bb02Bootloader.success", {
        rebootSeconds: status2.rebootSeconds.toString(),
        context: versionInfo.erased ? "install" : ""
      }) }) });
    else {
      const value = Math.round(status2.progress * 100);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
          value,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bootloader.progress", {
          progress: value.toString(),
          context: versionInfo.erased ? "install" : ""
        }) })
      ] });
    }
  else
    contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", style: { minHeight: 390 }, children: [
      versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("welcome.getStarted") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        versionInfo.canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: () => upgradeFirmware(deviceID),
            children: t2("bootloader.button", { context: versionInfo.erased ? "install" : "" })
          }
        ) : null,
        !versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: () => reboot(deviceID),
            children: t2("bb02Bootloader.abort", { context: versionInfo.canUpgrade ? "" : "noUpgrade" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-center", style: { marginTop: 32 }, children: [
        t2("bb02Bootloader.orientation"),
        "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            onClick: () => screenRotate(deviceID),
            style: { textDecoration: "underline", cursor: "pointer" },
            children: t2("bb02Bootloader.flipscreen")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { children: t2("bb02Bootloader.advanced.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleShowFirmwareHash, { deviceID })
        ] })
      ] })
    ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredContent, { children: [
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Inverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02$1, {}),
    status2 && status2.errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: status2.errMsg }),
    contents
  ] });
}, "BitBox02Bootloader"), Waiting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$k.waitingText, children: t2("welcome.insertDevice") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$k.waitingDescription, children: t2("welcome.insertBitBox02") })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.welcome"), shown: !0 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.getDevice.link.text"),
          url: "https://bitbox.shop/"
        },
        text: t2("guide.waiting.getDevice.text"),
        title: t2("guide.waiting.getDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.lostDevice.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/5-backup/8-wie-kann-ich-ein-bitbox02-wallet-in-ein-drittanbieter-wallet-importieren" : "https://shiftcrypto.support/help/en-us/5-backup/8-how-do-i-restore-my-wallet-if-my-bitbox02-is-lost"
        },
        text: t2("guide.waiting.lostDevice.text"),
        title: t2("guide.waiting.lostDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.internet") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.deviceNotRecognized") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.useWithoutDevice") })
    ] })
  ] });
}, "Waiting"), DeviceSwitch = /* @__PURE__ */ __name(({ deviceID, devices, hasAccounts }) => {
  const deviceIDs = Object.keys(devices);
  if (deviceID === null || !deviceIDs.includes(deviceID))
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  switch (devices[deviceID]) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox01, { deviceID });
    case "bitbox02":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitBox02,
        {
          deviceID,
          deviceIDs,
          hasAccounts
        }
      );
    case "bitbox02-bootloader":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Bootloader, { deviceID });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
}, "DeviceSwitch"), getBackupList = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/backups/list`), "getBackupList"), subscribeBackupList = /* @__PURE__ */ __name((deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02/${deviceID}/backups/list`, cb2), "subscribeBackupList"), toast = "_toast_4ztjp_1", active = "_active_4ztjp_17", shifted = "_shifted_4ztjp_21", info = "_info_4ztjp_25", success$1 = "_success_4ztjp_29", warning$1 = "_warning_4ztjp_33", style$g = {
  toast,
  active,
  shifted,
  info,
  success: success$1,
  warning: warning$1
}, _Toast = class _Toast extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      active: !1
    });
    __publicField(this, "show", /* @__PURE__ */ __name(() => {
      this.setState({ active: !0 });
    }, "show"));
    __publicField(this, "hide", /* @__PURE__ */ __name(() => {
      this.setState({ active: !1 }), this.props.onHide && this.props.onHide();
    }, "hide"));
  }
  componentDidMount() {
    setTimeout(this.show, 5);
  }
  render() {
    const {
      theme,
      children: children2,
      withGuide: withGuide2
    } = this.props, { active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: [style$g.toast, style$g[theme], active2 ? style$g.active : "", withGuide2 ? style$g.shifted : ""].join(" "),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: children2 })
      }
    );
  }
};
__name(_Toast, "Toast");
let Toast = _Toast;
const Check = /* @__PURE__ */ __name(({ deviceID, backups, disabled: disabled2 }) => {
  const [activeDialog, setActiveDialog] = reactExports.useState(!1), [message2, setMessage] = reactExports.useState(""), [foundBackup, setFoundBackup] = reactExports.useState(), [userVerified, setUserVerified] = reactExports.useState(!1), { t: t2 } = useTranslation(), checkBackup$1 = /* @__PURE__ */ __name(async () => {
    setMessage(t2("backup.check.confirmTitle"));
    try {
      const result = await checkBackup(deviceID, !0);
      if (result.success) {
        const { backupID: backupID2 } = result, foundBackup2 = backups.find((backup2) => backup2.id === backupID2);
        if (!foundBackup2) {
          alertUser(t2("unknownError", { errorMessage: "Not found" }));
          return;
        }
        setActiveDialog(!0), setFoundBackup(foundBackup2);
      }
      if (!(await checkBackup(deviceID, !1)).success) {
        setActiveDialog(!0), setMessage(t2("backup.check.notOK")), setUserVerified(!0);
        return;
      }
      setMessage(t2("backup.check.success")), setUserVerified(!0);
    } catch (error3) {
      console.error(error3);
    }
  }, "checkBackup$1");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        disabled: disabled2,
        onClick: checkBackup$1,
        children: t2("button.check")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: activeDialog, title: message2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: (e2) => {
      e2.preventDefault(), setActiveDialog(!1), setUserVerified(!1);
    }, children: [
      foundBackup !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: foundBackup,
          radio: !1
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: userVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          autoFocus: !0,
          disabled: !userVerified,
          primary: !0,
          type: "submit",
          children: t2(userVerified ? "button.ok" : "accountInfo.verify")
        }
      ) })
    ] }) })
  ] });
}, "Check"), Create = /* @__PURE__ */ __name(({ deviceID }) => {
  const [creatingBackup, setCreatingBackup] = reactExports.useState(!1), [disabled2, setDisabled] = reactExports.useState(!1), { t: t2 } = useTranslation(), createBackup$1 = /* @__PURE__ */ __name(() => {
    setCreatingBackup(!0), createBackup(deviceID, "sdcard").then((result) => {
      setCreatingBackup(!1), setDisabled(!1), result.success || alertUser(t2("backup.create.fail"));
    }).catch(console.error);
  }, "createBackup$1"), maybeCreateBackup = /* @__PURE__ */ __name(async () => {
    setDisabled(!0);
    try {
      if ((await checkBackup(deviceID, !0)).success) {
        confirmation(t2("backup.create.alreadyExists"), (result) => {
          result ? createBackup$1() : setDisabled(!1);
        });
        return;
      }
      createBackup$1();
    } catch (error3) {
      console.error(error3);
    }
  }, "maybeCreateBackup");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        disabled: disabled2,
        onClick: maybeCreateBackup,
        children: t2("backup.create.title")
      }
    ),
    creatingBackup && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.create.title"), children: t2("bitbox02Interact.followInstructions") })
  ] });
}, "Create"), BackupsV2 = /* @__PURE__ */ __name(({
  deviceID,
  showRestore,
  showCreate,
  showRadio,
  onSelectBackup,
  onRestoreBackup,
  children: children2
}) => {
  const { t: t2 } = useTranslation(), [selectedBackup, setSelectedBackup] = reactExports.useState(), [restoring, setRestoring] = reactExports.useState(!1), [errorText2, setErrorText] = reactExports.useState(""), backups = useSync(() => getBackupList(deviceID), subscribeBackupList(deviceID)), hasBackups = backups && backups.success && backups !== void 0, restore = /* @__PURE__ */ __name(() => {
    if (!hasBackups || !selectedBackup)
      return;
    const backup2 = backups.backups.find((b2) => b2.id === selectedBackup);
    backup2 && (setRestoring(!0), onSelectBackup && onSelectBackup(backup2), restoreBackup(deviceID, selectedBackup).then(({ success: success2 }) => {
      setRestoring(!1), setErrorText(success2 ? "" : t2("backup.restore.error.general")), onRestoreBackup && onRestoreBackup(success2);
    }));
  }, "restore");
  return hasBackups ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.stepContext, children: [
    errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toast, { theme: "warning", children: errorText2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, children: backups.backups.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backups.backups.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BackupsListItem,
      {
        disabled: restoring,
        backup: backup2,
        selectedBackup,
        handleChange: (b2) => setSelectedBackup(b2),
        onFocus: () => {
        },
        radio: showRadio
      }
    ) }, backup2.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.noBackups") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupButtons, children: [
      showRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          disabled: !selectedBackup || restoring,
          onClick: restore,
          children: t2("button.restore")
        }
      ),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(Create, { deviceID }),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Check,
        {
          deviceID,
          backups: backups.backups ? backups.backups : [],
          disabled: backups.backups.length === 0
        }
      ),
      children2
    ] })
  ] }) }) : hasBackups === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Error fetching backups" });
}, "BackupsV2"), SDCardCheck = /* @__PURE__ */ __name(({ deviceID, children: children2 }) => {
  const { t: t2 } = useTranslation(), [sdCardInserted, setSdCardInserted] = reactExports.useState(), check = reactExports.useCallback(() => checkSDCard(deviceID).then(setSdCardInserted), [deviceID]);
  return reactExports.useEffect(() => {
    check();
  }, [check]), sdCardInserted === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: sdCardInserted ? children2 : /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !sdCardInserted, title: "Check your device", small: !0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.insert") }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: check,
          children: t2("button.ok")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ButtonLink,
        {
          secondary: !0,
          to: `/settings/device-settings/${deviceID}`,
          children: t2("button.back")
        }
      )
    ] })
  ] }) });
}, "SDCardCheck"), _ManageBackups = class _ManageBackups extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "hasDevice", /* @__PURE__ */ __name(() => !!this.props.devices[this.props.deviceID], "hasDevice"));
    __publicField(this, "backButton", /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx(
      ButtonLink,
      {
        secondary: !0,
        to: `/settings/device-settings/${this.props.deviceID}`,
        children: this.props.t("button.back")
      }
    ), "backButton"));
    __publicField(this, "listBackups", /* @__PURE__ */ __name(() => {
      switch (this.props.devices[this.props.deviceID]) {
        case "bitbox":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              deviceID: this.props.deviceID,
              showCreate: !0,
              showRestore: !1,
              children: this.backButton()
            }
          );
        case "bitbox02":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SDCardCheck, { deviceID: this.props.deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            BackupsV2,
            {
              deviceID: this.props.deviceID,
              showCreate: !0,
              showRestore: !1,
              showRadio: !1,
              children: this.backButton()
            }
          ) });
        default:
          return;
      }
    }, "listBackups"));
    __publicField(this, "renderGuide", /* @__PURE__ */ __name((t2) => {
      switch (this.props.devices[this.props.deviceID]) {
        case "bitbox":
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.whatIsABackup") }, "guide.backups.whatIsABackup"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.encrypt") }, "guide.backups.encrypt"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.check") }, "guide.backups.check"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
          ] });
        case "bitbox02":
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.whatIsABackup") }, "guide.backupsBB02.whatIsABackup"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.encrypt"), shown: !0 }, "guide.backupsBB02.encrypt"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.check") }, "guide.backupsBB02.check"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
          ] });
        default:
          return null;
      }
    }, "renderGuide"));
  }
  UNSAFE_componentWillMount() {
    this.hasDevice() || route("/", !0);
  }
  render() {
    const { t: t2 } = this.props;
    return this.hasDevice() ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("backup.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("backup.list") }),
          this.listBackups()
        ] })
      ] }) }),
      this.renderGuide(t2)
    ] }) : null;
  }
};
__name(_ManageBackups, "ManageBackups");
let ManageBackups = _ManageBackups;
const ManageBackups$1 = withTranslation()(ManageBackups), AccountGuide$1 = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatIsRememberWallet") }, "whatIsRememberWallet"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
}, "AccountGuide$1"), label$2 = "_label_g3ts4_1", labelText = "_labelText_g3ts4_5", style$f = {
  label: label$2,
  labelText
}, WatchonlySetting = /* @__PURE__ */ __name(({ keystore }) => {
  const { t: t2 } = useTranslation(), [disabled2, setDisabled] = reactExports.useState(!1), [watchonly, setWatchonly$1] = reactExports.useState(), [warningDialogOpen, setWarningDialogOpen] = reactExports.useState(!1), config = useLoad(getConfig);
  reactExports.useEffect(() => {
    config && setWatchonly$1(keystore.watchonly);
  }, [config, keystore]);
  const toggleWatchonly = /* @__PURE__ */ __name(async () => {
    if (!watchonly) {
      setDisabled(!0);
      const { success: success2 } = await setWatchonly(keystore.rootFingerprint, !watchonly);
      success2 && setWatchonly$1(!watchonly), setDisabled(!1);
      return;
    }
    setWarningDialogOpen(!0), setDisabled(!1);
  }, "toggleWatchonly"), handleCloseDialog = /* @__PURE__ */ __name(() => {
    setWarningDialogOpen(!1), setDisabled(!1);
  }, "handleCloseDialog"), handleConfirmDisableWatchonly = /* @__PURE__ */ __name(async () => {
    setDisabled(!0), await setWatchonly(keystore.rootFingerprint, !1), setWatchonly$1(!1), setDisabled(!1), setWarningDialogOpen(!1);
  }, "handleConfirmDisableWatchonly");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("newSettings.appearance.remebmerWallet.warningTitle"), medium: !0, onClose: handleCloseDialog, open: warningDialogOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.remebmerWallet.warning") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: handleConfirmDisableWatchonly, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: handleCloseDialog, children: t2("dialog.cancel") })
      ] })
    ] }),
    watchonly !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: style$f.label, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$f.labelText, children: t2("newSettings.appearance.remebmerWallet.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: watchonly,
          disabled: disabled2,
          onChange: toggleWatchonly
        }
      )
    ] }) : null
  ] });
}, "WatchonlySetting"), addAccountBtn = "_addAccountBtn_17bcq_2", walletHeader = "_walletHeader_17bcq_6", walletTitle = "_walletTitle_17bcq_14", setting = "_setting_17bcq_25", coinLogo = "_coinLogo_17bcq_39", acccountLink = "_acccountLink_17bcq_44", editBtn = "_editBtn_17bcq_52", toggleLabel$1 = "_toggleLabel_17bcq_64", toggleLabelText = "_toggleLabelText_17bcq_70", toggle$1 = "_toggle_17bcq_64", accountActive = "_accountActive_17bcq_87", tokenSection = "_tokenSection_17bcq_91", tokenContainer = "_tokenContainer_17bcq_100", tokenContainerOpen = "_tokenContainerOpen_17bcq_107", token$1 = "_token_17bcq_91", tokenIcon = "_tokenIcon_17bcq_149", tokenName = "_tokenName_17bcq_154", tokenInactive = "_tokenInactive_17bcq_160", expandBtn = "_expandBtn_17bcq_165", expandBtnOpen = "_expandBtnOpen_17bcq_173", watchOnlyContainer = "_watchOnlyContainer_17bcq_186", watchOnlyNote = "_watchOnlyNote_17bcq_193", watchOnlyAccountHidden = "_watchOnlyAccountHidden_17bcq_198", style$e = {
  addAccountBtn,
  walletHeader,
  walletTitle,
  setting,
  coinLogo,
  acccountLink,
  editBtn,
  toggleLabel: toggleLabel$1,
  toggleLabelText,
  toggle: toggle$1,
  accountActive,
  tokenSection,
  tokenContainer,
  tokenContainerOpen,
  token: token$1,
  tokenIcon,
  tokenName,
  tokenInactive,
  expandBtn,
  expandBtnOpen,
  watchOnlyContainer,
  watchOnlyNote,
  watchOnlyAccountHidden
}, _ManageAccounts = class _ManageAccounts extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      editErrorMessage: void 0,
      showTokens: {},
      currentlyEditedAccount: void 0
    }, this.renderAccounts = (accounts) => {
      const { showTokens } = this.state, { t: t2 } = this.props;
      return accounts.filter((account2) => !account2.isToken).map((account2) => {
        var _a46;
        const active2 = account2.active, tokensVisible = showTokens[account2.code];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.setting, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${style$e.acccountLink} ${active2 ? style$e.accountActive : ""}`,
              onClick: () => active2 && route(`/account/${account2.code}`),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: `${style$e.coinLogo} m-right-half`, coinCode: account2.coinCode, alt: account2.coinUnit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  account2.name,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "unit", children: [
                    "(",
                    account2.coinUnit,
                    ")"
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              className: style$e.editBtn,
              onClick: () => this.setState({ currentlyEditedAccount: account2 }),
              transparent: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(EditActive, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hide-on-small", children: t2("manageAccounts.editAccount") })
              ]
            }
          ),
          active2 && account2.coinCode === "eth" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.tokenSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$e.tokenContainer} ${tokensVisible ? style$e.tokenContainerOpen : ""}`, children: this.renderTokens(account2.code, account2.activeTokens) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: `${style$e.expandBtn} ${tokensVisible ? style$e.expandBtnOpen : ""}`,
                onClick: () => this.toggleShowTokens(account2.code),
                transparent: !0,
                children: t2(tokensVisible ? "manageAccounts.settings.hideTokens" : "manageAccounts.settings.showTokens", {
                  activeTokenCount: `${((_a46 = account2.activeTokens) == null ? void 0 : _a46.length) || 0}`
                })
              }
            )
          ] }) : null
        ] }, account2.code);
      });
    }, this.renderWatchOnlyToggle = () => {
      const { currentlyEditedAccount } = this.state;
      if (currentlyEditedAccount && currentlyEditedAccount.keystore.watchonly)
        return null;
    }, this.toggleAccount = (accountCode, active2) => setAccountActive(accountCode, active2).then(({ success: success2, errorMessage }) => {
      !success2 && errorMessage && alertUser(errorMessage);
    }), this.toggleShowTokens = (accountCode) => {
      this.setState(({ showTokens }) => ({
        showTokens: {
          ...showTokens,
          [accountCode]: accountCode in showTokens ? !showTokens[accountCode] : !0
        }
      }));
    }, this.erc20Tokens = [
      { code: "eth-erc20-usdt", name: "Tether USD", unit: "USDT" },
      { code: "eth-erc20-usdc", name: "USD Coin", unit: "USDC" },
      { code: "eth-erc20-link", name: "Chainlink", unit: "LINK" },
      { code: "eth-erc20-bat", name: "Basic Attention Token", unit: "BAT" },
      { code: "eth-erc20-mkr", name: "Maker", unit: "MKR" },
      { code: "eth-erc20-zrx", name: "0x", unit: "ZRX" },
      { code: "eth-erc20-wbtc", name: "Wrapped Bitcoin", unit: "WBTC" },
      { code: "eth-erc20-paxg", name: "Pax Gold", unit: "PAXG" },
      { code: "eth-erc20-dai0x6b17", name: "Dai", unit: "DAI" }
    ], this.renderTokens = (ethAccountCode, activeTokens) => this.erc20Tokens.map((token2) => {
      const activeToken = (activeTokens || []).find((t2) => t2.tokenCode === token2.code), active2 = activeToken !== void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${style$e.token} ${active2 ? "" : style$e.tokenInactive}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `${style$e.acccountLink} ${active2 ? style$e.accountActive : ""}`,
                onClick: () => activeToken !== void 0 && route(`/account/${activeToken.accountCode}`),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Logo,
                    {
                      active: active2,
                      alt: token2.name,
                      className: style$e.tokenIcon,
                      coinCode: token2.code,
                      stacked: !0
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$e.tokenName, children: [
                    token2.name,
                    " (",
                    token2.unit,
                    ")"
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Toggle,
              {
                checked: active2,
                className: style$e.toggle,
                id: token2.code,
                onChange: () => this.toggleToken(ethAccountCode, token2.code, !active2)
              }
            )
          ]
        },
        token2.code
      );
    }), this.toggleToken = (ethAccountCode, tokenCode, active2) => {
      setTokenActive(ethAccountCode, tokenCode, active2).then(({ success: success2, errorMessage }) => {
        !success2 && errorMessage && alertUser(errorMessage);
      });
    }, this.updateAccount = (event2) => {
      event2.preventDefault();
      const { accounts } = this.props, { currentlyEditedAccount } = this.state;
      currentlyEditedAccount && renameAccount(currentlyEditedAccount.code, currentlyEditedAccount.name).then((result) => {
        if (!result.success) {
          result.errorCode ? this.setState({ editErrorMessage: this.props.t(`error.${result.errorCode}`) }) : result.errorMessage && this.setState({ editErrorMessage: result.errorMessage });
          return;
        }
        const account2 = accounts.find(({ code }) => currentlyEditedAccount.code === code);
        currentlyEditedAccount.active !== (account2 == null ? void 0 : account2.active) && this.toggleAccount(currentlyEditedAccount.code, currentlyEditedAccount.active), this.setState({
          editErrorMessage: void 0,
          currentlyEditedAccount: void 0
        });
      });
    };
  }
  render() {
    const { t: t2, accounts, deviceIDs, hasAccounts } = this.props, { editErrorMessage, currentlyEditedAccount } = this.state, accountsByKeystore = getAccountsByKeystore(accounts);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SharedHeader,
          {
            hideSidebarToggler: !0,
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("settings.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("manageAccounts.title") })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { deviceIDs, hideMobileMenu: !0, hasAccounts, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: style$e.addAccountBtn,
              primary: !0,
              onClick: () => route("/add-account", !0),
              children: t2("addAccount.title")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: accountsByKeystore.map((keystore) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Column,
            {
              asCard: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.walletHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: style$e.walletTitle, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                      keystore.keystore.name,
                      isAmbiguiousName(keystore.keystore.name, accountsByKeystore) ? (
                        // Disambiguate accounts group by adding the fingerprint.
                        // The most common case where this would happen is when adding accounts from the
                        // same seed using different passphrases.
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                          " ",
                          keystore.keystore.rootFingerprint
                        ] })
                      ) : null
                    ] }),
                    keystore.keystore.connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Badge,
                      {
                        className: "m-right-quarter",
                        icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                        type: "success",
                        children: t2("device.keystoreConnected")
                      }
                    ) : null
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(WatchonlySetting, { keystore: keystore.keystore })
                ] }),
                this.renderAccounts(keystore.accounts)
              ]
            },
            keystore.keystore.rootFingerprint
          )) }),
          currentlyEditedAccount && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: !!currentlyEditedAccount,
              onClose: () => this.setState({ currentlyEditedAccount: void 0 }),
              title: t2("manageAccounts.editAccountNameTitle"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.updateAccount, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", hidden: !editErrorMessage, children: editErrorMessage }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$2,
                  {
                    onInput: (e2) => this.setState({ currentlyEditedAccount: { ...currentlyEditedAccount, name: e2.target.value } }),
                    value: currentlyEditedAccount.name
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    className: style$e.toggleLabel,
                    htmlFor: currentlyEditedAccount.code,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$e.toggleLabelText, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpenedDark, {}),
                        t2("newSettings.appearance.enableAccount.title")
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Toggle,
                        {
                          checked: currentlyEditedAccount.active,
                          className: style$e.toggle,
                          id: currentlyEditedAccount.code,
                          onChange: (event2) => {
                            event2.target.disabled = !0, this.setState({
                              currentlyEditedAccount: {
                                ...currentlyEditedAccount,
                                active: event2.target.checked
                              }
                            }, () => event2.target.disabled = !1);
                          }
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.enableAccount.description") }),
                this.renderWatchOnlyToggle(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    disabled: !currentlyEditedAccount.name,
                    primary: !0,
                    type: "submit",
                    children: t2("button.update")
                  }
                ) })
              ] })
            }
          )
        ] }) }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AccountGuide$1, {})
    ] });
  }
};
__name(_ManageAccounts, "ManageAccounts");
let ManageAccounts = _ManageAccounts;
const HOC$3 = translate()(ManageAccounts), title = "_title_ahh86_1", resetLink = "_resetLink_ahh86_7", serversContainer = "_serversContainer_ahh86_11", servers = "_servers_ahh86_11", server = "_server_ahh86_11", serverLabel = "_serverLabel_ahh86_32", primary = "_primary_ahh86_82", warning = "_warning_ahh86_93", textarea$1 = "_textarea_ahh86_104", block = "_block_ahh86_112", addServer = "_addServer_ahh86_116", badge$1 = "_badge_ahh86_140", miniSpinnerContainer = "_miniSpinnerContainer_ahh86_152", miniSpinner = "_miniSpinner_ahh86_152", changeContent$1 = "_changeContent_ahh86_1", style$d = {
  title,
  resetLink,
  serversContainer,
  servers,
  server,
  serverLabel,
  primary,
  warning,
  textarea: textarea$1,
  block,
  addServer,
  badge: badge$1,
  miniSpinnerContainer,
  miniSpinner,
  changeContent: changeContent$1
}, ElectrumAddServer = /* @__PURE__ */ __name(({
  onAdd
}) => {
  const { t: t2 } = useTranslation(), [valid, setValid] = reactExports.useState(), [electrumServer, setElectrumServer] = reactExports.useState(""), [electrumCert, setElectrumCert] = reactExports.useState(""), [loadingCheck, setLoadingCheck] = reactExports.useState(!1), [loadingCert, setLoadingCert] = reactExports.useState(!1), getServer = /* @__PURE__ */ __name(() => ({
    server: electrumServer.trim(),
    pemCert: electrumCert,
    tls: electrumCert !== ""
  }), "getServer"), add = /* @__PURE__ */ __name(() => {
    onAdd(getServer()), setElectrumServer(""), setElectrumCert("");
  }, "add"), downloadCert = /* @__PURE__ */ __name(async () => {
    setLoadingCert(!0);
    const data = await apiPost("certs/download", electrumServer.trim());
    data.success ? setElectrumCert(data.pemCert) : alertUser(data.errorMessage), setLoadingCert(!1);
  }, "downloadCert"), check = /* @__PURE__ */ __name(async () => {
    setLoadingCheck(!0);
    const { success: success2, errorMessage } = await apiPost("electrum/check", getServer());
    alertUser(success2 ? t2("settings.electrum.checkSuccess", { host: electrumServer }) : t2("settings.electrum.checkFailed") + `:
` + errorMessage), setValid(success2), setLoadingCheck(!1);
  }, "check"), downloadCertButtonDisabled = electrumServer.trim().length === 0 || electrumCert.trim().length > 0 || loadingCert, checkConnectionButtonDisabled = electrumServer.trim().length === 0 || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.addServer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step1-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        name: "electrumServer",
        onInput: (event2) => setElectrumServer(event2.target.value),
        value: electrumServer,
        placeholder: "host:port"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text-tcp") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: style$d.textarea,
        rows: 10,
        cols: 80,
        name: "electrumCert",
        onInput: (event2) => setElectrumCert(event2.target.value),
        value: electrumCert,
        placeholder: `-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----`
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$d.block, "flex flex-row flex-end"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: !0, disabled: downloadCertButtonDisabled, onClick: downloadCert, children: [
      loadingCert && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
      t2("settings.electrum.download-cert")
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step3-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-end spaced", style$d.block].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: !0, disabled: checkConnectionButtonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
        t2(loadingCheck ? "settings.electrum.checking" : "settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, disabled: !valid, onClick: add, children: t2("settings.electrum.add-server") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step4-text") }) })
    ] })
  ] });
}, "ElectrumAddServer"), ElectrumServer = /* @__PURE__ */ __name(({
  onRemove,
  server: server2
}) => {
  const { t: t2 } = useTranslation(), [loadingCheck, setLoadingCheck] = reactExports.useState(!1), check = /* @__PURE__ */ __name(async () => {
    setLoadingCheck(!0);
    const { success: success2, errorMessage } = await apiPost("electrum/check", {
      server: server2.server.trim(),
      pemCert: server2.pemCert,
      tls: server2.tls
    });
    alertUser(success2 ? t2("settings.electrum.checkSuccess", { host: server2.server }) : t2("settings.electrum.checkFailed") + `:
` + errorMessage), setLoadingCheck(!1);
  }, "check"), buttonDisabled = server2.server === "" || server2.tls && server2.pemCert === "" || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.server, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.serverLabel, children: [
      server2.server,
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: server2.tls ? "TLS" : "TCP" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$d.primary, disabled: buttonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
        t2(loadingCheck ? "settings.electrum.checking" : "settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$d.warning, onClick: onRemove, children: t2("settings.electrum.remove-server") })
    ] })
  ] }) });
}, "ElectrumServer"), ElectrumServers = /* @__PURE__ */ __name(({
  coin
}) => {
  const { t: t2 } = useTranslation(), [config, setConfigState] = reactExports.useState(), loadConfig = /* @__PURE__ */ __name(() => {
    getConfig().then(setConfigState);
  }, "loadConfig");
  if (reactExports.useEffect(loadConfig, []), config === void 0)
    return null;
  const electrumServers = config.backend[coin].electrumServers, save = /* @__PURE__ */ __name(async (newElectrumServers) => {
    const currentConfig = await getConfig();
    currentConfig.backend[coin].electrumServers = newElectrumServers, await setConfig(currentConfig), setConfigState(currentConfig);
  }, "save"), onAdd = /* @__PURE__ */ __name((server2) => {
    let newElectrumServers = [...electrumServers, server2];
    save(newElectrumServers);
  }, "onAdd"), onRemove = /* @__PURE__ */ __name((index) => {
    let newElectrumServers = [...electrumServers];
    newElectrumServers.splice(index, 1), save(newElectrumServers);
  }, "onRemove"), resetToDefault = /* @__PURE__ */ __name(() => {
    confirmation(t2("settings.electrum.resetConfirm"), (response) => {
      response && getDefaultConfig().then((config2) => {
        save(config2.backend[coin].electrumServers);
      });
    });
  }, "resetToDefault"), onRemoveCb = /* @__PURE__ */ __name((server2, index) => () => {
    confirmation(t2("settings.electrum.removeConfirm", { server: server2.server }), (confirmed) => {
      confirmed && onRemove(index);
    });
  }, "onRemoveCb");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.serversContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.servers") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            transparent: !0,
            className: style$d.resetLink,
            onClick: resetToDefault,
            children: t2("settings.electrum.reset")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$d.servers, children: electrumServers.map((server2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ElectrumServer,
        {
          server: server2,
          onRemove: onRemoveCb(server2, index)
        },
        server2.server + server2.tls.toString() + "-" + index.toString()
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.add") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumAddServer, { onAdd })
    ] })
  ] });
}, "ElectrumServers"), ElectrumSettings = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [activeTab, setActiveTab] = reactExports.useState("btc"), testing = useLoad(() => getTesting()), handleTab = /* @__PURE__ */ __name((e2) => {
    const selectedTab = e2.currentTarget.getAttribute("data-tab");
    if (selectedTab !== "btc" && selectedTab !== "ltc") {
      console.error("Unrecognized tab ID");
      return;
    }
    setActiveTab(selectedTab);
  }, "handleTab");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.expert.electrum.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center tabs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "btc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "btc", children: t2(`settings.electrum.title-${testing ? "tbtc" : "btc"}`) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "ltc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "ltc", children: t2(`settings.electrum.title-${testing ? "tltc" : "ltc"}`) }) })
        ] }),
        activeTab === "btc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tbtc" : "btc"
          },
          testing ? "tbtc" : "btc"
        ),
        activeTab === "ltc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tltc" : "ltc"
          },
          testing ? "tltc" : "ltc"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonLink,
          {
            secondary: !0,
            to: "/settings",
            children: t2("button.back")
          }
        ) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.what") }, "guide.settings-electrum.what"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.options") }, "guide.settings-electrum.options"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.connection") }, "guide.settings-electrum.connection"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.settings-electrum.instructions.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/14-privatsphare/29-verbindung-der-bitboxapp-zu-meinem-bitcoin-full-node" : "https://shiftcrypto.support/help/en-us/14-privacy/29-how-to-connect-the-bitboxapp-to-my-own-full-node"
        },
        text: t2("guide.settings-electrum.instructions.text"),
        title: t2("guide.settings-electrum.instructions.title")
      } }, "guide.settings-electrum.instructions")
    ] })
  ] });
}, "ElectrumSettings"), INFO_STEPS_ENABLE = 5, INFO_STEPS_DISABLE = 0, CONTENT_MIN_HEIGHT = "38em", _Passphrase = class _Passphrase extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      infoStep: 0,
      status: "info",
      understood: !1
    }, this.togglePassphrase = async () => {
      const { deviceID, t: t2 } = this.props, enable = !this.state.passphraseEnabled;
      this.setState({ status: "progress" });
      try {
        const result = await setMnemonicPassphraseEnabled(deviceID, enable);
        if (!result.success) {
          route(`/settings/device-settings/${deviceID}`), alertUser(t2(`passphrase.error.e${result.code}`, {
            defaultValue: result.message || t2("genericError")
          }));
          return;
        }
        const deviceInfoResult = await getDeviceInfo(deviceID);
        deviceInfoResult.success && this.setState({
          passphraseEnabled: deviceInfoResult.deviceInfo.mnemonicPassphraseEnabled,
          status: "success"
        });
      } catch (error3) {
        console.error(error3);
      }
    }, this.stopInfo = () => route(`/settings/device-settings/${this.props.deviceID}`), this.continueInfo = () => {
      if (this.state.infoStep === 0) {
        this.togglePassphrase();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep - 1 }));
    }, this.backInfo = () => {
      if (this.state.infoStep === void 0)
        return;
      const enabled = this.state.passphraseEnabled;
      if (!enabled && this.state.infoStep >= INFO_STEPS_ENABLE || enabled && this.state.infoStep >= INFO_STEPS_DISABLE) {
        this.stopInfo();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep + 1 }));
    }, this.renderEnableInfo = () => {
      const { infoStep, understood } = this.state, { t: t2 } = this.props;
      switch (infoStep) {
        case 5:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.intro.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.intro.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.what.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-intro"
          );
        case 4:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.what.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.what.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.why.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-what"
          );
        case 3:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.why.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.why.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.considerations.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-why"
          );
        case 2:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.considerations.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.considerations.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.how.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-considerations"
          );
        case 1:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.how.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.how.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.summary.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-how"
          );
        case 0:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.summary.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.0") }, "info-1"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.1") }, "info-2"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.2") }, "info-3"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.3") }, "info-4")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: understood ? "success" : "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      onChange: (e2) => {
                        var _a46;
                        return this.setState({ understood: (_a46 = e2.target) == null ? void 0 : _a46.checked });
                      },
                      id: "understood",
                      checked: understood,
                      label: t2("passphrase.summary.understand"),
                      checkboxStyle: understood ? "success" : "warning"
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, disabled: !understood, children: t2("passphrase.enable") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-summary"
          );
        default:
          console.error(`invalid infoStep ${infoStep}`);
          return;
      }
    }, this.renderDisableInfo = () => {
      const { t: t2 } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          minHeight: CONTENT_MIN_HEIGHT,
          onClose: this.stopInfo,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.disable") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.disableInfo.message") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.disableInfo.button") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
            ] })
          ]
        },
        "step-disable-info1"
      );
    };
  }
  componentDidMount() {
    getDeviceInfo(this.props.deviceID).then((result) => {
      if (!result.success) {
        console.error(result.message), alertUser(this.props.t("genericError"));
        return;
      }
      const { mnemonicPassphraseEnabled } = result.deviceInfo;
      this.setState({
        // before enabling/disabling we show 1 or more pages to inform about the feature
        // each page has a continue button that jumps to the next or finally toggles passphrase
        // infoStep counts down in decreasing order
        infoStep: mnemonicPassphraseEnabled ? INFO_STEPS_DISABLE : INFO_STEPS_ENABLE,
        passphraseEnabled: mnemonicPassphraseEnabled
      });
    }).catch(console.error);
  }
  render() {
    const { t: t2 } = this.props, { passphraseEnabled, status: status2 } = this.state;
    return passphraseEnabled === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "info" && (passphraseEnabled ? this.renderDisableInfo() : this.renderEnableInfo()),
      status2 === "progress" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          minHeight: CONTENT_MIN_HEIGHT,
          textCenter: !0,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                title: t2(passphraseEnabled ? "passphrase.progressDisable.title" : "passphrase.progressEnable.title"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SimpleMarkup,
                  {
                    tagName: "p",
                    markup: t2(passphraseEnabled ? "passphrase.progressDisable.message" : "passphrase.progressEnable.message")
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
          ]
        },
        "progress"
      ),
      status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                small: !0,
                title: t2(passphraseEnabled ? "passphrase.successDisabled.title" : "passphrase.successEnabled.title")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2(passphraseEnabled ? "passphrase.successDisabled.message" : "passphrase.successEnabled.message") }),
              passphraseEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { paddingLeft: "var(--space-default)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.0") }, "tip-1"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.1") }, "tip-2")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2(
                passphraseEnabled ? "passphrase.successDisabled.messageEnd" : "passphrase.successEnabled.messageEnd"
              ) })
            ] })
          ]
        },
        "progress"
      )
    ] });
  }
};
__name(_Passphrase, "Passphrase");
let Passphrase = _Passphrase;
const HOC$2 = translate()(Passphrase);
function AccountGuide({
  account: account2,
  unit: unit2,
  hasNoBalance,
  hasIncomingBalance,
  hasTransactions
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountDescription") }, "accountDescription"),
    hasNoBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSendDisabled", {
      unit: unit2
    }) }, "accountSendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountReload") }, "accountReload"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionLabel") }, "accountTransactionLabel"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionTime") }, "accountTransactionTime"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesGeneric") }, "accountTransactionAttributesGeneric"),
    hasTransactions && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesBTC") }, "accountTransactionAttributesBTC"),
    hasIncomingBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountIncomingBalance") }, "accountIncomingBalance"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionConfirmation") }, "accountTransactionConfirmation"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountFiat") }, "accountFiat"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "accountRates"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "CoinTracking",
        url: "https://cointracking.info/import/bitbox/?ref=BITBOX"
      },
      text: t2("guide.cointracking.text"),
      title: t2("guide.cointracking.title")
    } }, "cointracking")
  ] });
}
__name(AccountGuide, "AccountGuide");
const syncContainer = "_syncContainer_nrzbt_1", progressBar = "_progressBar_nrzbt_8", progressValue = "_progressValue_nrzbt_14", syncMessage = "_syncMessage_nrzbt_21", syncText = "_syncText_nrzbt_33", spinnerContainer = "_spinnerContainer_nrzbt_39", spinner = "_spinner_nrzbt_39", changeContent = "_changeContent_nrzbt_1", style$c = {
  syncContainer,
  progressBar,
  progressValue,
  syncMessage,
  syncText,
  spinnerContainer,
  spinner,
  changeContent
}, HeadersSync = /* @__PURE__ */ __name(({ coinCode }) => {
  const { i18n, t: t2 } = useTranslation(), status2 = useSubscribe(subscribeCoinHeaders(coinCode)), [hidden, setHidden] = reactExports.useState(!1), mounted = useMountedRef();
  if (reactExports.useEffect(() => {
    mounted.current && status2 && status2.tip === status2.targetHeight && setTimeout(() => setHidden(!0), 4e3);
  }, [mounted, status2]), !status2 || hidden)
    return null;
  const total2 = status2.targetHeight - status2.tipAtInitTime, value = 100 * (status2.tip - status2.tipAtInitTime) / total2, loaded = !total2 || value >= 100, formatted = new Intl.NumberFormat(i18n.language).format(status2.tip);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncMessage, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncText, children: [
        t2("headerssync.blocksSynced", { blocks: formatted }),
        " ",
        !loaded && `(${Math.ceil(value)}%)`
      ] }),
      loaded ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "progress-bar", className: style$c.progressBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.progressValue, style: { width: `${value}%` } }) })
  ] });
}, "HeadersSync"), container$6 = "_container_13974_1", background = "_background_13974_6", foreground = "_foreground_13974_7", complete = "_complete_13974_19", pending = "_pending_13974_23", generic = "_generic_13974_24", error2 = "_error_13974_28", style$b = {
  container: container$6,
  background,
  foreground,
  complete,
  pending,
  generic,
  error: error2
}, ProgressRing = /* @__PURE__ */ __name(({
  className,
  generic: generic2,
  isComplete,
  isError,
  value,
  width
}) => {
  const radius = (width - 3) / 2, circumference = radius * 2 * Math.PI, progress = isError ? 100 : value / 100, offset = circumference * (1 - progress);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: [style$b.container, className || ""].join(" "),
      width,
      height: width,
      style: { minWidth: width },
      viewBox: `0 0 ${width} ${width}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: style$b.background,
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: [
              style$b.foreground,
              !generic2 && isComplete ? style$b.complete : style$b.pending,
              generic2 && style$b.generic,
              isError && style$b.error
            ].join(" "),
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3,
            strokeDashoffset: offset,
            strokeDasharray: circumference
          }
        )
      ]
    }
  );
}, "ProgressRing"), txArrowType = "_txArrowType_m24u9_1", txArrowTypeIn = "_txArrowTypeIn_m24u9_6", txArrowTypeOut = "_txArrowTypeOut_m24u9_10", txArrowTypeSelf = "_txArrowTypeSelf_m24u9_14", style$a = {
  txArrowType,
  txArrowTypeIn,
  txArrowTypeOut,
  txArrowTypeSelf
}, ArrowIn = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeIn}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
), "ArrowIn"), ArrowOut = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeOut}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
), "ArrowOut"), ArrowSelf = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeSelf}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 5 19 12 12 19" })
    ]
  }
), "ArrowSelf"), container$5 = "_container_1j01g_1", header$1 = "_header_1j01g_5", columns = "_columns_1j01g_17", headers = "_headers_1j01g_27", columnGroup = "_columnGroup_1j01g_33", type = "_type_1j01g_46", date$1 = "_date_1j01g_52", activity = "_activity_1j01g_57", status$1 = "_status_1j01g_63", fiat$1 = "_fiat_1j01g_68", currency$1 = "_currency_1j01g_74", action$1 = "_action_1j01g_80", empty = "_empty_1j01g_87", hideOnMedium = "_hideOnMedium_1j01g_103", showOnMedium = "_showOnMedium_1j01g_113", style$9 = {
  container: container$5,
  header: header$1,
  columns,
  headers,
  columnGroup,
  type,
  date: date$1,
  activity,
  status: status$1,
  fiat: fiat$1,
  currency: currency$1,
  action: action$1,
  empty,
  hideOnMedium,
  showOnMedium
}, container$4 = "_container_1tutj_1", row = "_row_1tutj_5", date = "_date_1tutj_15", address$1 = "_address_1tutj_19", badge = "_badge_1tutj_24", statusIndicator = "_statusIndicator_1tutj_29", statusIndicatorComplete = "_statusIndicatorComplete_1tutj_37", statusIndicatorPending = "_statusIndicatorPending_1tutj_41", statusIndicatorFailed = "_statusIndicatorFailed_1tutj_45", status = "_status_1tutj_29", fiat = "_fiat_1tutj_53", amount = "_amount_1tutj_57", amountOverflow = "_amountOverflow_1tutj_62", send$1 = "_send_1tutj_74", receive$1 = "_receive_1tutj_78", currency = "_currency_1tutj_82", currencyUnit = "_currencyUnit_1tutj_86", action = "_action_1tutj_97", label$1 = "_label_1tutj_108", columnLabel = "_columnLabel_1tutj_113", inlineLabel = "_inlineLabel_1tutj_114", inlineValue = "_inlineValue_1tutj_128", fee = "_fee_1tutj_132", transactionId = "_transactionId_1tutj_136", detail = "_detail_1tutj_141", detailInput = "_detailInput_1tutj_142", textOnlyInput = "_textOnlyInput_1tutj_159", editButton = "_editButton_1tutj_167", addresses = "_addresses_1tutj_207", detailAddresses = "_detailAddresses_1tutj_218", detailAddress = "_detailAddress_1tutj_218", first = "_first_1tutj_231", style$8 = {
  container: container$4,
  row,
  date,
  address: address$1,
  badge,
  statusIndicator,
  statusIndicatorComplete,
  statusIndicatorPending,
  statusIndicatorFailed,
  status,
  fiat,
  amount,
  amountOverflow,
  send: send$1,
  receive: receive$1,
  currency,
  currencyUnit,
  action,
  label: label$1,
  columnLabel,
  inlineLabel,
  inlineValue,
  fee,
  transactionId,
  detail,
  detailInput,
  textOnlyInput,
  editButton,
  addresses,
  detailAddresses,
  detailAddress,
  first
}, _Transaction = class _Transaction extends reactExports.Component {
  constructor() {
    super(...arguments), this.input = reactExports.createRef(), this.editButton = reactExports.createRef(), this.state = {
      transactionDialog: !1,
      newNote: this.props.note,
      editMode: !this.props.note
    }, this.parseTimeShort = (time2) => {
      const options2 = {
        year: "numeric",
        month: "numeric",
        day: "numeric"
      };
      return new Date(Date.parse(time2)).toLocaleString(this.props.i18n.language, options2);
    }, this.showDetails = () => {
      getTransaction(this.props.accountCode, this.props.internalID).then((transaction2) => {
        if (!transaction2)
          return console.error("Unable to retrieve transaction " + this.props.internalID), null;
        this.setState({
          transactionInfo: transaction2,
          transactionDialog: !0,
          newNote: this.props.note,
          editMode: !this.props.note
        });
      }).catch(console.error);
    }, this.hideDetails = () => {
      this.setState({ transactionDialog: !1 });
    }, this.handleNoteInput = (e2) => {
      const target = e2.target;
      this.setState({ newNote: target.value });
    }, this.handleEdit = (e2) => {
      e2.preventDefault(), this.state.editMode && this.props.note !== this.state.newNote && postNotesTx(this.props.accountCode, {
        internalTxID: this.props.internalID,
        note: this.state.newNote
      }).catch(console.error), this.focusEdit(), this.setState(
        ({ editMode }) => ({ editMode: !editMode }),
        this.focusEdit
      );
    }, this.focusEdit = () => {
      this.editButton.current && this.editButton.current.blur(), this.state.editMode && this.input.current && (this.input.current.scrollLeft = this.input.current.scrollWidth, this.input.current.focus());
    };
  }
  render() {
    const {
      t: t2,
      index,
      explorerURL,
      type: type2,
      amount: amount2,
      feeRatePerKb,
      numConfirmations,
      numConfirmationsComplete,
      time: time2,
      addresses: addresses2,
      status: status2,
      note: note2 = ""
    } = this.props, {
      transactionDialog,
      newNote,
      editMode,
      transactionInfo
    } = this.state, arrow2 = type2 === "receive" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIn, {}) : type2 === "send" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowOut, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSelf, {}), sign = type2 === "send" && "" || type2 === "receive" && "+" || "", typeClassName = type2 === "send" && style$8.send || type2 === "receive" && style$8.receive || "", sDate = time2 ? this.parseTimeShort(time2) : "---", statusText = {
      complete: t2("transaction.status.complete"),
      pending: t2("transaction.status.pending"),
      failed: t2("transaction.status.failed")
    }[status2], progress = numConfirmations < numConfirmationsComplete ? numConfirmations / numConfirmationsComplete * 100 : 100, darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.container, index === 0 ? style$8.first : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.columns, style$8.row].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.columnGroup, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.type, children: arrow2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.date, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.columnLabel, children: [
              t2("transaction.details.date"),
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.date, children: sDate })
          ] }),
          note2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.activity, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.address, children: note2 }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.activity, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.label, children: t2(type2 === "receive" ? "transaction.tx.received" : "transaction.tx.sent") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.address, children: [
              addresses2[0],
              addresses2.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.badge, children: [
                "(+",
                addresses2.length - 1,
                ")"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$9.action, style$9.hideOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$8.action, onClick: this.showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.columnGroup, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.status, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.columnLabel, children: [
              t2("transaction.details.status"),
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProgressRing,
              {
                className: "m-right-quarter",
                width: 14,
                value: progress,
                isComplete: numConfirmations >= numConfirmationsComplete
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.status, children: statusText })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.fiat, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: !0 }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$9.currency} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: `${style$8.amount} ${style$8.amountOverflow}`,
              "data-unit": ` ${amount2.unit}`,
              children: [
                sign,
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.currencyUnit, children: [
                  "",
                  amount2.unit
                ] })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$9.action, style$9.showOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$8.action, onClick: this.showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: transactionDialog, title: "Transaction Details", onClose: this.hideDetails, slim: !0, medium: !0, children: transactionInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleEdit, className: style$8.detailInput, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "note", children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              align: "right",
              autoFocus: editMode,
              className: style$8.textOnlyInput,
              readOnly: !editMode,
              type: "text",
              id: "note",
              transparent: !0,
              placeholder: t2("note.input.placeholder"),
              value: newNote,
              maxLength: 256,
              onInput: this.handleNoteInput,
              ref: this.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$8.editButton,
              onClick: this.handleEdit,
              title: t2(`transaction.note.${editMode ? "save" : "edit"}`),
              type: "button",
              ref: this.editButton,
              children: editMode ? darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaveLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {}) : darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EditLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Edit, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.type") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: arrow2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.confirmation") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: numConfirmations })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.status") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "flex flex-items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProgressRing,
              {
                className: "m-right-quarter",
                width: 14,
                value: progress,
                isComplete: numConfirmations >= numConfirmationsComplete
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.status, children: [
              statusText,
              " ",
              status2 === "pending" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "(",
                numConfirmations,
                "/",
                numConfirmationsComplete,
                ")"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.date") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: sDate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiat") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: !0 }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiatAtTime") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: transactionInfo.amountAtTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: transactionInfo.amountAtTime, sign, noAction: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { noAction: !0 }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.amount") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: typeClassName, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.amount, children: [
              sign,
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit })
            ] }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: transactionInfo.amount.unit })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.fee") }),
          transactionInfo.fee && transactionInfo.fee.amount ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { title: feeRatePerKb.amount ? feeRatePerKb.amount + " " + feeRatePerKb.unit + "/Kb" : "", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: transactionInfo.fee.amount, unit: transactionInfo.fee.unit }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: transactionInfo.fee.unit })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "---" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.detail, style$8.addresses].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.address") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.detailAddresses, children: transactionInfo.addresses.map((address2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            CopyableInput,
            {
              alignRight: !0,
              borderLess: !0,
              flexibleHeight: !0,
              className: style$8.detailAddress,
              value: address2
            },
            address2
          )) })
        ] }),
        transactionInfo.gas ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.gas") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.gas })
        ] }) : null,
        transactionInfo.nonce !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Nonce" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.nonce })
        ] }) : null,
        transactionInfo.weight ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.weight") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.weight,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "WU" })
          ] })
        ] }) : null,
        transactionInfo.vsize ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.vsize") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.vsize,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "b" })
          ] })
        ] }) : null,
        transactionInfo.size ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.size") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.size,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "b" })
          ] })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.detail, style$8.addresses].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.explorer") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.detailAddresses, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CopyableInput,
            {
              alignRight: !0,
              borderLess: !0,
              flexibleHeight: !0,
              className: style$8.detailAddress,
              value: transactionInfo.txID
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$8.detail, "flex-center"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          A$3,
          {
            href: explorerURL + transactionInfo.txID,
            title: `${t2("transaction.explorerTitle")}
${explorerURL}${transactionInfo.txID}`,
            children: t2("transaction.explorerTitle")
          }
        ) })
      ] }) })
    ] });
  }
};
__name(_Transaction, "Transaction");
let Transaction = _Transaction;
const HOC$1 = translate()(Transaction), Transactions = /* @__PURE__ */ __name(({
  accountCode,
  explorerURL,
  transactions: transactions2,
  handleExport
}) => {
  const { t: t2 } = useTranslation(), csvExportDisabled = runningInAndroid();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("accountSummary.transactionHistory") }),
      !csvExportDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          transparent: !0,
          onClick: handleExport,
          title: t2("account.exportTransactions"),
          children: t2("account.export")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.columns, style$9.headers, style$9.showOnMedium].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.type, children: t2("transaction.details.type") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.date, children: t2("transaction.details.date") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.activity, children: t2("transaction.details.activity") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.status, children: t2("transaction.details.status") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.fiat, children: t2("transaction.details.fiatAmount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.currency, children: t2("transaction.details.amount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.action, children: "" })
    ] }),
    transactions2 && transactions2.success && transactions2.list.length > 0 ? transactions2.list.map((props, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      HOC$1,
      {
        accountCode,
        explorerURL,
        index,
        ...props
      },
      props.internalID
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-row flex-center ${style$9.empty}`, children: transactions2 && !transactions2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.errorLoadTransactions") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.placeholder") }) })
  ] });
}, "Transactions"), container$3 = "_container_8wadt_1", header = "_header_8wadt_12", actionsContainer = "_actionsContainer_8wadt_23", buy = "_buy_8wadt_29", receive = "_receive_8wadt_30", walletConnect = "_walletConnect_8wadt_31", send = "_send_8wadt_32", withWalletConnect = "_withWalletConnect_8wadt_50", disabled = "_disabled_8wadt_62", accountIcon = "_accountIcon_8wadt_71", style$7 = {
  container: container$3,
  header,
  actionsContainer,
  buy,
  receive,
  walletConnect,
  send,
  withWalletConnect,
  disabled,
  accountIcon
}, ActionButtons = /* @__PURE__ */ __name(({ canSend, code, coinCode, exchangeBuySupported, account: account2 }) => {
  const { t: t2 } = useTranslation(), navigate2 = useNavigate(), walletConnectEnabled = isEthereumBased(account2.coinCode) && !account2.isToken, isLargeTablet = useMediaQuery("(max-width: 830px)"), sendLink = `/account/${code}/send`, maybeRouteSend = /* @__PURE__ */ __name(async (e2) => {
    e2.preventDefault(), (await connectKeystore(code)).success && navigate2(sendLink);
  }, "maybeRouteSend");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$7.actionsContainer} ${walletConnectEnabled ? style$7.withWalletConnect : ""}`, children: [
    canSend ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: sendLink, className: style$7.send, onClick: isEthereumBased(coinCode) ? maybeRouteSend : void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.send") }) }, "sendLink") : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$7.send} ${style$7.disabled}`, children: t2("button.send") }, "sendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/account/${code}/receive`, className: style$7.receive, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.receive") }) }, "receive"),
    exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/buy/info/${code}`, className: style$7.buy, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.buy") }) }, "buy"),
    walletConnectEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/wallet-connect/dashboard`, className: style$7.walletConnect, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 24 }),
      " ",
      !isLargeTablet && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
    ] }, "wallet-connect")
  ] });
}, "ActionButtons");
function Account({
  accounts,
  code,
  devices
}) {
  const { t: t2 } = useTranslation(), [balance2, setBalance] = reactExports.useState(), [status2, setStatus] = reactExports.useState(), [syncedAddressesCount, setSyncedAddressesCount] = reactExports.useState(), [transactions2, setTransactions] = reactExports.useState(), [usesProxy, setUsesProxy] = reactExports.useState(), [stateCode, setStateCode] = reactExports.useState(), supportedExchanges = useLoad(getExchangeBuySupported(code), [code]);
  reactExports.useEffect(() => {
    apiGet("config").then(({ backend }) => setUsesProxy(backend.proxy.useProxy));
  }, []);
  const hasCard = useSDCard(devices, [code]), onAccountChanged = reactExports.useCallback((code2, status22) => {
    if (!(!code2 || status22 === void 0 || status22.fatalError))
      if (status22.synced && status22.offlineError === null) {
        const currentCode = code2;
        Promise.all([
          getBalance(currentCode).then((newBalance) => {
            currentCode === code2 && setBalance(newBalance);
          }),
          getTransactionList(code2).then((newTransactions) => {
            currentCode === code2 && setTransactions(newTransactions);
          })
        ]).catch(console.error);
      } else
        setBalance(void 0), setTransactions(void 0);
  }, []), onStatusChanged = reactExports.useCallback(() => {
    const currentCode = code;
    currentCode && getStatus$2(currentCode).then(async (status22) => {
      currentCode === code && (setStatus(status22), !status22.disabled && !status22.synced && await init(currentCode).catch(console.error), onAccountChanged(code, status22));
    }).catch(console.error);
  }, [onAccountChanged, code]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      syncAddressesCount(code)(setSyncedAddressesCount),
      statusChanged$1((eventCode) => eventCode === code && onStatusChanged()),
      syncdone((eventCode) => eventCode === code && onAccountChanged(code, status2))
    ];
    return () => unsubscribe(subscriptions2);
  }, [code, onAccountChanged, onStatusChanged, status2]);
  function exportAccount$1() {
    status2 === void 0 || status2.fatalError || exportAccount(code).then((result) => {
      result !== null && !result.success && alertUser(result.errorMessage);
    }).catch(console.error);
  }
  __name(exportAccount$1, "exportAccount$1"), reactExports.useEffect(() => {
    setStateCode(code), setBalance(void 0), setStatus(void 0), setSyncedAddressesCount(0), setTransactions(void 0), onStatusChanged();
  }, [code, onStatusChanged]);
  const hasDataLoaded = balance2 !== void 0 && transactions2 !== void 0, account2 = accounts && accounts.find((acct) => acct.code === code);
  if (stateCode !== code || !account2 || status2 === void 0)
    return null;
  const canSend = balance2 && balance2.hasAvailable, initializingSpinnerText = syncedAddressesCount !== void 0 && syncedAddressesCount > 1 ? `
` + t2("account.syncedAddressesCount", {
    count: syncedAddressesCount.toString(),
    defaultValue: 0
  }) : "", offlineErrorTextLines = [];
  status2.offlineError !== null && (offlineErrorTextLines.push(t2("account.reconnecting")), offlineErrorTextLines.push(status2.offlineError), usesProxy && offlineErrorTextLines.push(t2("account.maybeProxyError")));
  const exchangeBuySupported = supportedExchanges && supportedExchanges.exchanges.length > 0, isAccountEmpty = balance2 && !balance2.hasAvailable && !balance2.hasIncoming && transactions2 && transactions2.success && transactions2.list.length === 0, actionButtonsProps = {
    code,
    coinCode: account2.coinCode,
    canSend,
    exchangeBuySupported,
    account: account2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SharedHeader,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name }) }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/info`, title: t2("accountInfo.title"), className: "flex flex-row flex-items-center m-left-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$7.accountIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("accountInfo.label") })
            ] })
          ]
        }
      ),
      status2.synced && hasDataLoaded && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(HeadersSync, { coinCode: account2.coinCode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer scrollableContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-reverse-mobile", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile hide-on-small", children: t2("accountSummary.availableBalance") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-item-center flex-column-mobile flex-reverse-mobile", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile show-on-small", children: t2("accountSummary.availableBalance") }),
            !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtons, { ...actionButtonsProps })
          ] })
        ] }),
        isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          BuyReceiveCTA,
          {
            account: account2,
            code,
            exchangeBuySupported,
            unit: balance2.available.unit,
            balanceList: [balance2]
          }
        ),
        !status2.synced || offlineErrorTextLines.length || !hasDataLoaded || status2.fatalError ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: status2.fatalError && t2("account.fatalError") || offlineErrorTextLines.join(`
`) || !status2.synced && t2("account.initializing") + initializingSpinnerText || "" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Transactions,
          {
            accountCode: code,
            handleExport: exportAccount$1,
            explorerURL: account2.blockExplorerTxPrefix,
            transactions: transactions2
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccountGuide,
      {
        account: account2,
        unit: balance2 == null ? void 0 : balance2.available.unit,
        hasIncomingBalance: balance2 && balance2.hasIncoming,
        hasTransactions: transactions2 !== void 0 && transactions2.success && transactions2.list.length > 0,
        hasNoBalance: balance2 && balance2.available.amount === "0"
      }
    )
  ] });
}
__name(Account, "Account");
const ReceiveAccountsSelector = /* @__PURE__ */ __name(({ activeAccounts }) => {
  const [options2, setOptions] = reactExports.useState([]), [code, setCode] = reactExports.useState(""), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    const options22 = activeAccounts.map((account2) => ({ label: account2.name, value: account2.code, disabled: !1, coinCode: account2.coinCode }));
    setOptions(options22), getBalances(options22).then((options3) => setOptions(options3));
  }, [activeAccounts]);
  const handleProceed = /* @__PURE__ */ __name(() => {
    route(`/account/${code}/receive`);
  }, "handleProceed"), hasOnlyBTCAccounts = activeAccounts.every(({ coinCode }) => isBitcoinOnly(coinCode)), title2 = t2("receive.title", { accountName: hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto") }), getBalances = /* @__PURE__ */ __name(async (options22) => Promise.all(options22.map((option) => getBalance(option.value).then((balance2) => ({ ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` })))), "getBalances");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccountSelector, { onChange: setCode, onProceed: handleProceed, options: options2, title: t2("receive.selectAccount"), selected: code }) }) })
  ] });
}, "ReceiveAccountsSelector"), DarkmodeToggleSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { toggleDarkmode, isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("darkmode.toggle"),
      secondaryText: t2("newSettings.appearance.darkmode.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { checked: isDarkMode, onChange: () => toggleDarkmode(!isDarkMode) })
    }
  );
}, "DarkmodeToggleSetting"), dropdown = "_dropdown_1uw27_1", select$2 = "_select_1uw27_10", dropdownStyles = {
  dropdown,
  select: select$2
}, DropdownIndicator2 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) }), "DropdownIndicator"), Option2 = /* @__PURE__ */ __name((props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
}, "Option"), SingleValue2 = /* @__PURE__ */ __name((props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
}, "SingleValue"), SingleDropdown = /* @__PURE__ */ __name(({ options: options2, handleChange, defaultValue }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  StateManagedSelect$1,
  {
    className: dropdownStyles.select,
    classNamePrefix: "react-select",
    isSearchable: !0,
    defaultValue,
    components: { IndicatorSeparator: () => null, DropdownIndicator: DropdownIndicator2, SingleValue: SingleValue2, Option: Option2 },
    onChange: (selected2) => {
      if (selected2) {
        const value = (selected2 == null ? void 0 : selected2.value) || "";
        handleChange(value);
      }
    },
    options: options2
  }
), "SingleDropdown"), DefaultCurrencyDropdownSetting = /* @__PURE__ */ __name(() => {
  var _a46;
  const { t: t2 } = useTranslation(), { selectFiat, updateDefaultFiat, defaultCurrency: defaultCurrency2, activeCurrencies } = reactExports.useContext(RatesContext), valueLabel = (_a46 = currenciesWithDisplayName.find((fiat2) => fiat2.currency === defaultCurrency2)) == null ? void 0 : _a46.displayName, defaultValueLabel = valueLabel ? `${valueLabel} (${defaultCurrency2})` : defaultCurrency2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.defaultCurrency.title"),
      secondaryText: t2("newSettings.appearance.defaultCurrency.description"),
      collapseOnSmall: !0,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedCurrencies,
          handleChange: async (fiat2) => {
            updateDefaultFiat(fiat2), activeCurrencies.includes(fiat2) || await selectFiat(fiat2);
          },
          defaultValue: {
            label: defaultValueLabel,
            value: defaultCurrency2
          }
        }
      )
    }
  );
}, "DefaultCurrencyDropdownSetting"), DisplaySatsToggleSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), fetchedConfig = useLoad(getConfig), [displayAsSAT, setDisplayAsSAT] = reactExports.useState(), { updateRatesConfig } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    fetchedConfig && setDisplayAsSAT(fetchedConfig.backend.btcUnit === "sat");
  }, [fetchedConfig]);
  const handleToggleSatsUnit = /* @__PURE__ */ __name(async () => {
    const toggleDdisplayAsSAT = !displayAsSAT, unit2 = toggleDdisplayAsSAT ? "sat" : "default";
    setDisplayAsSAT(toggleDdisplayAsSAT), await setConfig({
      backend: { btcUnit: unit2 }
    }), updateRatesConfig(), (await setBtcUnit(unit2)).success || alertUser(t2("genericError"));
  }, "handleToggleSatsUnit");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.useSats"),
      secondaryText: t2("newSettings.appearance.toggleSats.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: displayAsSAT !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: displayAsSAT,
          onChange: handleToggleSatsUnit
        }
      ) : null })
    }
  ) });
}, "DisplaySatsToggleSetting"), LanguageDropdownSetting = /* @__PURE__ */ __name(() => {
  const { i18n, t: t2 } = useTranslation(), selectedLanguage = defaultLanguages[getSelectedIndex(defaultLanguages, i18n)], formattedLanguages = defaultLanguages.map((lang) => ({ label: lang.display, value: lang.code }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.language.title"),
      secondaryText: t2("newSettings.appearance.language.description"),
      collapseOnSmall: !0,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedLanguages,
          handleChange: i18n.changeLanguage,
          defaultValue: { label: selectedLanguage.display, value: selectedLanguage.code }
        }
      )
    }
  );
}, "LanguageDropdownSetting"), select$1 = "_select_1j2fm_1", hideMultiSelect = "_hideMultiSelect_1j2fm_30", defaultCurrency = "_defaultCurrency_1j2fm_51", defaultLabel = "_defaultLabel_1j2fm_55", activeCurrenciesDropdownStyle = {
  select: select$1,
  hideMultiSelect,
  defaultCurrency,
  defaultLabel
}, ActiveCurrenciesDropdown = /* @__PURE__ */ __name(({
  options: options2,
  defaultCurrency: defaultCurrency2,
  activeCurrencies
}) => {
  const [formattedActiveCurrencies, setFormattedActiveCurrencies] = reactExports.useState([]), [search, setSearch] = reactExports.useState(""), { t: t2 } = useTranslation(), { unselectFiat, selectFiat } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (activeCurrencies.length > 0) {
      const formattedSelectedCurrencies = activeCurrencies.map((currency2) => ({ label: currency2, value: currency2 }));
      setFormattedActiveCurrencies(formattedSelectedCurrencies);
    }
  }, [activeCurrencies]);
  const DropdownIndicator3 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) }), "DropdownIndicator"), Option3 = /* @__PURE__ */ __name((props) => {
    const { label: label2, value } = props.data, selected2 = formattedActiveCurrencies.findIndex((currency2) => currency2.value === value) >= 0, isDefaultCurrency = defaultCurrency2 === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(components.Option, { ...props, className: `${isDefaultCurrency ? activeCurrenciesDropdownStyle.defaultCurrency : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }),
      isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: activeCurrenciesDropdownStyle.defaultLabel, children: t2("fiat.default") }) : null,
      selected2 && !isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedCheckLight, {}) : null
    ] });
  }, "Option");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: `
         ${dropdownStyles.select}
         ${activeCurrenciesDropdownStyle.select}
         ${search.length > 0 ? activeCurrenciesDropdownStyle.hideMultiSelect : ""}
         `,
      classNamePrefix: "react-select",
      isSearchable: !0,
      isClearable: !1,
      components: { DropdownIndicator: DropdownIndicator3, IndicatorSeparator: () => null, MultiValueRemove: () => null, Option: Option3 },
      isMulti: !0,
      closeMenuOnSelect: !1,
      hideSelectedOptions: !1,
      value: [...formattedActiveCurrencies].reverse(),
      onInputChange: (newValue) => setSearch(newValue),
      onChange: async (_24, meta) => {
        switch (meta.action) {
          case "select-option":
            meta.option && await selectFiat(meta.option.value);
            break;
          case "deselect-option":
            meta.option && meta.option.value !== defaultCurrency2 && await unselectFiat(meta.option.value);
        }
      },
      options: options2
    }
  );
}, "ActiveCurrenciesDropdown"), ActiveCurrenciesDropdownSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { activeCurrencies, defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      collapseOnSmall: !0,
      settingName: t2("newSettings.appearance.activeCurrencies.title"),
      secondaryText: t2("newSettings.appearance.activeCurrencies.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActiveCurrenciesDropdown,
        {
          options: formattedCurrencies,
          defaultCurrency: defaultCurrency2,
          activeCurrencies
        }
      )
    }
  );
}, "ActiveCurrenciesDropdownSetting"), HideAmountsSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [allowHideAmounts, setAllowHideAmounts] = reactExports.useState(), config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      if (config.frontend.allowHideAmounts === void 0) {
        setAllowHideAmounts(!1);
        return;
      }
      setAllowHideAmounts(config.frontend.allowHideAmounts);
    }
  }, [config]);
  const toggleAllowHideAmounts = /* @__PURE__ */ __name(async () => {
    setAllowHideAmounts(!allowHideAmounts), await setConfig({
      frontend: { allowHideAmounts: !allowHideAmounts }
    });
  }, "toggleAllowHideAmounts");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.hideAmounts.title"),
      secondaryText: t2("newSettings.appearance.hideAmounts.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: allowHideAmounts !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: allowHideAmounts,
          onChange: toggleAllowHideAmounts
        }
      ) : null })
    }
  );
}, "HideAmountsSetting"), Appearance = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.appearance") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { hasAccounts, hideMobileMenu: !0, deviceIDs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultCurrencyDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActiveCurrenciesDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DarkmodeToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySatsToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsSetting, {})
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppearanceGuide, {})
  ] });
}, "Appearance"), AppearanceGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.sats") }, "guide.settings.sats"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "guide.accountRates")
  ] });
}, "AppearanceGuide"), MobileSettings = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const isMobile = useMediaQuery("(max-width: 768px)"), { t: t2 } = useTranslation();
  return reactExports.useEffect(() => {
    isMobile || route("/settings/appearance");
  }, [isMobile]), /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { deviceIDs, hasAccounts }) }) })
  ] });
}, "MobileSettings"), AppVersion = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), version = useLoad(getVersion$1), update = useLoad(getUpdate), secondaryText2 = t2(update ? "settings.info.out-of-date" : "settings.info.up-to-date"), icon2 = update ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}), versionNumber = version || "-";
  return update === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.about.appVersion.title"),
      secondaryText: secondaryText2,
      displayedValue: versionNumber,
      extraComponent: icon2,
      onClick: update ? () => open(downloadLinkByLanguage()) : void 0
    }
  );
}, "AppVersion"), About = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.about") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WithSettingsTabs, { deviceIDs, hideMobileMenu: !0, hasAccounts, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppVersion, {}) }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AboutGuide, {})
  ] });
}, "About"), AboutGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Guide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.servers") }, "guide.settings.servers") });
}, "AboutGuide"), EnableCustomFeesToggleSetting = /* @__PURE__ */ __name(({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleFee = /* @__PURE__ */ __name(async (e2) => {
    const config = await setConfig({
      frontend: {
        expertFee: e2.target.checked
      }
    });
    onChangeConfig(config);
  }, "handleToggleFee");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.fee"),
      secondaryText: t2("newSettings.advancedSettings.customFees.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.expertFee) || !1,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
}, "EnableCustomFeesToggleSetting"), EnableCoinControlSetting = /* @__PURE__ */ __name(({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleFee = /* @__PURE__ */ __name(async (e2) => {
    const config = await setConfig({
      frontend: {
        coinControl: e2.target.checked
      }
    });
    onChangeConfig(config);
  }, "handleToggleFee");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.coinControl"),
      secondaryText: t2("newSettings.advancedSettings.coinControl.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.coinControl) || !1,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
}, "EnableCoinControlSetting"), ConnectFullNodeSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.electrum.title"),
      onClick: () => route("/settings/electrum"),
      secondaryText: t2("settings.expert.electrum.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChevronRightDark,
        {
          width: 24,
          height: 24
        }
      )
    }
  );
}, "ConnectFullNodeSetting"), TorProxyDialog = /* @__PURE__ */ __name(({ open: open2, proxyConfig, onCloseDialog, onChangeConfig, handleShowRestartMessage }) => {
  const [proxyAddress, setProxyAddress] = reactExports.useState(), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    proxyConfig && setProxyAddress(proxyConfig.proxyAddress);
  }, [proxyConfig]);
  const handleSetProxyButton = /* @__PURE__ */ __name(async () => {
    if (!proxyConfig || proxyAddress === void 0)
      return;
    const proxy = proxyConfig;
    proxy.proxyAddress = proxyAddress.trim();
    const result = await socksProxyCheck(proxy.proxyAddress), { success: success2, errorMessage } = result;
    success2 ? await setProxyConfig(proxy) : alertUser(errorMessage || t2("account.fatalError"));
  }, "handleSetProxyButton"), setProxyConfig = /* @__PURE__ */ __name(async (proxyConfig2) => {
    const config = await setConfig({
      backend: { proxy: proxyConfig2 }
    });
    setProxyAddress(proxyConfig2.proxyAddress), onChangeConfig(config), handleShowRestartMessage(!0);
  }, "setProxyConfig"), handleToggleProxy = /* @__PURE__ */ __name(async (e2) => {
    if (!proxyConfig)
      return;
    const proxy = { ...proxyConfig, useProxy: e2.target.checked };
    await setProxyConfig(proxy);
  }, "handleToggleProxy"), handleInputChange = /* @__PURE__ */ __name((e2) => {
    setProxyAddress(e2.target.value), handleShowRestartMessage(!1);
  }, "handleInputChange");
  return !proxyConfig || proxyConfig === void 0 || proxyAddress === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, onClose: onCloseDialog, title: t2("settings.expert.setProxyAddress"), small: !0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("settings.expert.useProxy") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          id: "useProxy",
          checked: proxyConfig.useProxy,
          onChange: handleToggleProxy
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          name: "proxyAddress",
          onInput: handleInputChange,
          value: proxyAddress,
          placeholder: "127.0.0.1:9050",
          disabled: !proxyConfig.useProxy
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: handleSetProxyButton,
          disabled: !proxyConfig.useProxy || proxyAddress === proxyConfig.proxyAddress,
          children: t2("settings.expert.setProxyAddress")
        }
      ) })
    ] })
  ] });
}, "TorProxyDialog"), inlineMessage = "_inlineMessage_gi9x3_1", success = "_success_gi9x3_7", left = "_left_gi9x3_12", close = "_close_gi9x3_16", style$6 = {
  inlineMessage,
  success,
  left,
  close
}, _InlineMessage = class _InlineMessage extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "deactivate", /* @__PURE__ */ __name(() => {
      this.props.onEnd();
    }, "deactivate"));
  }
  render() {
    const {
      type: type2,
      message: message2,
      align
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$6.inlineMessage, style$6[type2], align ? style$6[align] : ""].join(" "), children: [
      message2,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$6.close, onClick: this.deactivate, children: "" })
    ] });
  }
};
__name(_InlineMessage, "InlineMessage");
let InlineMessage = _InlineMessage;
const settingItem = "_settingItem_6ge6v_3", styles$c = {
  settingItem
}, EnableTorProxySetting = /* @__PURE__ */ __name(({ proxyConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), [showTorProxyDialog, setShowTorProxyDialog] = reactExports.useState(!1), [showRestartMessage, setShowRestartMessage] = reactExports.useState(!1), proxyEnabled = proxyConfig ? proxyConfig.useProxy : !1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showRestartMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineMessage,
      {
        type: "success",
        align: "left",
        message: t2("settings.restart"),
        onEnd: () => setShowRestartMessage(!1)
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        className: styles$c.settingItem,
        settingName: t2("settings.expert.useProxy"),
        onClick: () => setShowTorProxyDialog(!0),
        secondaryText: t2("newSettings.advancedSettings.torProxy.description"),
        displayedValue: t2(proxyEnabled ? "generic.enabled_true" : "generic.enabled_false"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, { width: 24, height: 24 })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TorProxyDialog,
      {
        open: showTorProxyDialog,
        proxyConfig,
        onCloseDialog: () => setShowTorProxyDialog(!1),
        onChangeConfig,
        handleShowRestartMessage: setShowRestartMessage
      }
    )
  ] });
}, "EnableTorProxySetting"), EnableAuthSetting = /* @__PURE__ */ __name(({ backendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleAuth = /* @__PURE__ */ __name(async (e2) => {
    const unsubscribe2 = subscribeAuth((data) => {
      data.typ === "auth-ok" && (updateConfig(!e2.target.checked), unsubscribe2()), data.typ === "auth-canceled" && unsubscribe2();
    });
    forceAuth();
  }, "handleToggleAuth"), updateConfig = /* @__PURE__ */ __name(async (auth2) => {
    const config = await setConfig({
      backend: { authentication: auth2 }
    });
    onAuthSettingChanged(), onChangeConfig(config);
  }, "updateConfig");
  return runningInAndroid() ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.advancedSettings.authentication.title"),
      secondaryText: t2("newSettings.advancedSettings.authentication.description"),
      extraComponent: backendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (backendConfig == null ? void 0 : backendConfig.authentication) || !1,
          onChange: handleToggleAuth
        }
      ) : null
    }
  ) : null;
}, "EnableAuthSetting"), AdvancedSettings = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  var _a46;
  const { t: t2 } = useTranslation(), fetchedConfig = useLoad(getConfig), [config, setConfig2] = reactExports.useState(), frontendConfig = config == null ? void 0 : config.frontend, backendConfig = config == null ? void 0 : config.backend, proxyConfig = (_a46 = config == null ? void 0 : config.backend) == null ? void 0 : _a46.proxy;
  return reactExports.useEffect(() => {
    setConfig2(fetchedConfig);
  }, [fetchedConfig]), /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.advancedSettings") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: !0,
          hasAccounts,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCustomFeesToggleSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCoinControlSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableAuthSetting, { backendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableTorProxySetting, { proxyConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectFullNodeSetting, {})
          ]
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSettingsGuide, {})
  ] });
}, "AdvancedSettings"), AdvancedSettingsGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor")
  ] });
}, "AdvancedSettingsGuide"), WCWeb3WalletContext = reactExports.createContext({}), WCGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.whatIsWalletConnect")
      },
      "guide.walletConnect.whatIsWalletConnect"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.supportedNetworks")
      },
      "guide.walletConnect.supportedNetworks"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.noPreviousConnections")
      },
      "guide.walletConnect.noPreviousConnections"
    )
  ] });
}, "WCGuide"), SUPPORTED_CHAINS = {
  "eip155:1": {
    name: "Etherum mainnet",
    icon: reactExports.createElement(ETHLogo)
  },
  "eip155:5": {
    name: "Ethereum goerli",
    icon: reactExports.createElement(ETHLogo)
  }
}, EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  /**
     * Many dapps will request an 'eth_signTypedData' but in reality expect 'eth_signTypedData_v4'
     * because that's basically the standard. V4 is assumed, but not necessarily asked for specifically.
     * There aren't many uses of V3 in the wild, but leaving in just in case and returning a v4 signature instead,
     * the dapp can validate this anyway
     */
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction"
}, getAddressFromEIPString = /* @__PURE__ */ __name((address2) => {
  const parts = address2.split(":");
  return parts.length > 2 ? parts[2] : "";
}, "getAddressFromEIPString"), truncateAddress = /* @__PURE__ */ __name((address2) => address2 ? `${address2.substring(0, 6)}...${address2.substring(address2.length - 6)}` : "", "truncateAddress"), getTopicFromURI = /* @__PURE__ */ __name((wcURI) => {
  try {
    return wcURI.split(":")[1].split("@")[0];
  } catch {
    return "";
  }
}, "getTopicFromURI"), pairingHasEverBeenRejected = /* @__PURE__ */ __name((topic, web3wallet) => web3wallet.core.history.values.findIndex((history) => history.topic === topic && history.response && "error" in history.response) >= 0, "pairingHasEverBeenRejected"), rejectMessage = /* @__PURE__ */ __name((id2) => ({
  id: id2,
  jsonrpc: "2.0",
  error: {
    code: 5e3,
    message: "User rejected."
  }
}), "rejectMessage"), decodeEthMessage = /* @__PURE__ */ __name((hex) => {
  if (hex = hex.trim(), hex.startsWith("0x") && (hex = hex.substring(2)), hex.length % 2 !== 0 || !/^[0-9a-fA-F]*$/.test(hex))
    return console.error("Invalid hex string"), null;
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const byte = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
    if (isNaN(byte))
      return console.error("Invalid byte in hex string"), null;
    bytes[i] = byte;
  }
  return new TextDecoder("utf-8").decode(bytes);
}, "decodeEthMessage"), headerContainer$1 = "_headerContainer_wug0g_1", accountName$2 = "_accountName_wug0g_28", receiveAddress$3 = "_receiveAddress_wug0g_32", styles$b = {
  headerContainer: headerContainer$1,
  accountName: accountName$2,
  receiveAddress: receiveAddress$3
}, WCHeader = /* @__PURE__ */ __name(({ receiveAddress: receiveAddress2, accountName: accountName2 }) => {
  const displayedReceiveAddress = truncateAddress(receiveAddress2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.headerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDefaultLogo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "WalletConnect" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$b.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$b.receiveAddress, children: displayedReceiveAddress })
  ] });
}, "WCHeader"), formContainer = "_formContainer_1wrji_1", formButtonsContainer = "_formButtonsContainer_1wrji_6", inputWithIcon = "_inputWithIcon_1wrji_11", mobileQRScanner = "_mobileQRScanner_1wrji_28", scanQRLabel = "_scanQRLabel_1wrji_41", styles$a = {
  formContainer,
  formButtonsContainer,
  inputWithIcon,
  mobileQRScanner,
  scanQRLabel
}, MobileQRScanner = /* @__PURE__ */ __name(({ onQRScanned }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.mobileQRScanner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.scanQRLabel, children: t2("send.scanQR") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRVideo, { onResult: onQRScanned })
  ] });
}, "MobileQRScanner"), WCConnectForm = /* @__PURE__ */ __name(({
  code,
  uri,
  onInputChange,
  onSubmit,
  connectLoading
}) => {
  const { t: t2 } = useTranslation(), isMobile = useMediaQuery("(max-width: 768px)"), [activeScanQR, setActiveScanQR] = reactExports.useState(isMobile), showMobileQRReader = isMobile, showQRButton = !isMobile, toggleScanQR = /* @__PURE__ */ __name(() => {
    if (activeScanQR) {
      setActiveScanQR(!1);
      return;
    }
    setActiveScanQR(!0);
  }, "toggleScanQR");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.formContainer, children: [
    showMobileQRReader && /* @__PURE__ */ jsxRuntimeExports.jsx(MobileQRScanner, { onQRScanned: onSubmit }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        onSubmit: (e2) => {
          e2.preventDefault(), onSubmit(uri);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              label: t2("walletConnect.connect.dappLabel"),
              className: showQRButton ? styles$a.inputWithIcon : "",
              value: uri,
              readOnly: connectLoading,
              onInput: (e2) => onInputChange(e2.target.value.replace(/\s/g, "")),
              children: showQRButton && !connectLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ScanQRDialog,
            {
              activeScanQR: activeScanQR && !isMobile,
              toggleScanQR,
              onChangeActiveScanQR: setActiveScanQR,
              parseQRResult: (uri2) => onSubmit(uri2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.formButtonsContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading,
                secondary: !0,
                onClick: () => route(`/account/${code}/wallet-connect/dashboard`),
                children: t2("dialog.cancel")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading || !uri,
                type: "submit",
                primary: !0,
                children: t2("walletConnect.connect.button")
              }
            )
          ] })
        ]
      }
    )
  ] });
}, "WCConnectForm");
var chacha20poly1305 = {}, chacha = {}, binary = {}, int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  function imulShim(a2, b2) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535, bh2 = b2 >>> 16 & 65535, bl2 = b2 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  __name(imulShim, "imulShim"), exports.mul = Math.imul || imulShim;
  function add(a2, b2) {
    return a2 + b2 | 0;
  }
  __name(add, "add"), exports.add = add;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  __name(sub, "sub"), exports.sub = sub;
  function rotl(x2, n2) {
    return x2 << n2 | x2 >>> 32 - n2;
  }
  __name(rotl, "rotl"), exports.rotl = rotl;
  function rotr(x2, n2) {
    return x2 << 32 - n2 | x2 >>> n2;
  }
  __name(rotr, "rotr"), exports.rotr = rotr;
  function isIntegerShim(n2) {
    return typeof n2 == "number" && isFinite(n2) && Math.floor(n2) === n2;
  }
  __name(isIntegerShim, "isIntegerShim"), exports.isInteger = Number.isInteger || isIntegerShim, exports.MAX_SAFE_INTEGER = 9007199254740991, exports.isSafeInteger = function(n2) {
    return exports.isInteger(n2) && n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
__name(readInt16BE, "readInt16BE");
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
__name(readUint16BE, "readUint16BE");
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
__name(readInt16LE, "readInt16LE");
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 1] << 8 | array[offset]) >>> 0;
}
__name(readUint16LE, "readUint16LE");
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(2)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 8, out[offset + 1] = value >>> 0, out;
}
__name(writeUint16BE, "writeUint16BE");
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(2)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 0, out[offset + 1] = value >>> 8, out;
}
__name(writeUint16LE, "writeUint16LE");
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  return offset === void 0 && (offset = 0), array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
__name(readInt32BE, "readInt32BE");
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
__name(readUint32BE, "readUint32BE");
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  return offset === void 0 && (offset = 0), array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
__name(readInt32LE, "readInt32LE");
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
__name(readUint32LE, "readUint32LE");
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 24, out[offset + 1] = value >>> 16, out[offset + 2] = value >>> 8, out[offset + 3] = value >>> 0, out;
}
__name(writeUint32BE, "writeUint32BE");
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 0, out[offset + 1] = value >>> 8, out[offset + 2] = value >>> 16, out[offset + 3] = value >>> 24, out;
}
__name(writeUint32LE, "writeUint32LE");
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var hi2 = readInt32BE(array, offset), lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
__name(readInt64BE, "readInt64BE");
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var hi2 = readUint32BE(array, offset), lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
__name(readUint64BE, "readUint64BE");
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var lo = readInt32LE(array, offset), hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
__name(readInt64LE, "readInt64LE");
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var lo = readUint32LE(array, offset), hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
__name(readUint64LE, "readUint64LE");
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0), writeUint32BE(value / 4294967296 >>> 0, out, offset), writeUint32BE(value >>> 0, out, offset + 4), out;
}
__name(writeUint64BE, "writeUint64BE");
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0), writeUint32LE(value >>> 0, out, offset), writeUint32LE(value / 4294967296 >>> 0, out, offset + 4), out;
}
__name(writeUint64LE, "writeUint64LE");
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (bitLength / 8 > array.length - offset)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var result = 0, mul = 1, i = bitLength / 8 + offset - 1; i >= offset; i--)
    result += array[i] * mul, mul *= 256;
  return result;
}
__name(readUintBE, "readUintBE");
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (bitLength / 8 > array.length - offset)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var result = 0, mul = 1, i = offset; i < offset + bitLength / 8; i++)
    result += array[i] * mul, mul *= 256;
  return result;
}
__name(readUintLE, "readUintLE");
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0 && (out = new Uint8Array(bitLength / 8)), offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(value))
    throw new Error("writeUintBE value must be an integer");
  for (var div = 1, i = bitLength / 8 + offset - 1; i >= offset; i--)
    out[i] = value / div & 255, div *= 256;
  return out;
}
__name(writeUintBE, "writeUintBE");
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0 && (out = new Uint8Array(bitLength / 8)), offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(value))
    throw new Error("writeUintLE value must be an integer");
  for (var div = 1, i = offset; i < offset + bitLength / 8; i++)
    out[i] = value / div & 255, div *= 256;
  return out;
}
__name(writeUintLE, "writeUintLE");
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
__name(readFloat32BE, "readFloat32BE");
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, !0);
}
__name(readFloat32LE, "readFloat32LE");
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
__name(readFloat64BE, "readFloat64BE");
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, !0);
}
__name(readFloat64LE, "readFloat64LE");
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat32(offset, value), out;
}
__name(writeFloat32BE, "writeFloat32BE");
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat32(offset, value, !0), out;
}
__name(writeFloat32LE, "writeFloat32LE");
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat64(offset, value), out;
}
__name(writeFloat64BE, "writeFloat64BE");
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat64(offset, value, !0), out;
}
__name(writeFloat64LE, "writeFloat64LE");
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(array) {
  for (var i = 0; i < array.length; i++)
    array[i] = 0;
  return array;
}
__name(wipe, "wipe");
wipe$1.wipe = wipe;
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$3 = wipe$1, ROUNDS = 20;
function core(out, input2, key) {
  for (var j0 = 1634760805, j1 = 857760878, j2 = 2036477234, j3 = 1797285236, j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0], j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4], j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8], j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12], j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16], j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20], j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24], j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28], j12 = input2[3] << 24 | input2[2] << 16 | input2[1] << 8 | input2[0], j13 = input2[7] << 24 | input2[6] << 16 | input2[5] << 8 | input2[4], j14 = input2[11] << 24 | input2[10] << 16 | input2[9] << 8 | input2[8], j15 = input2[15] << 24 | input2[14] << 16 | input2[13] << 8 | input2[12], x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, i = 0; i < ROUNDS; i += 2)
    x0 = x0 + x4 | 0, x12 ^= x0, x12 = x12 >>> 32 - 16 | x12 << 16, x8 = x8 + x12 | 0, x4 ^= x8, x4 = x4 >>> 32 - 12 | x4 << 12, x1 = x1 + x5 | 0, x13 ^= x1, x13 = x13 >>> 32 - 16 | x13 << 16, x9 = x9 + x13 | 0, x5 ^= x9, x5 = x5 >>> 32 - 12 | x5 << 12, x2 = x2 + x6 | 0, x14 ^= x2, x14 = x14 >>> 32 - 16 | x14 << 16, x10 = x10 + x14 | 0, x6 ^= x10, x6 = x6 >>> 32 - 12 | x6 << 12, x3 = x3 + x7 | 0, x15 ^= x3, x15 = x15 >>> 32 - 16 | x15 << 16, x11 = x11 + x15 | 0, x7 ^= x11, x7 = x7 >>> 32 - 12 | x7 << 12, x2 = x2 + x6 | 0, x14 ^= x2, x14 = x14 >>> 32 - 8 | x14 << 8, x10 = x10 + x14 | 0, x6 ^= x10, x6 = x6 >>> 32 - 7 | x6 << 7, x3 = x3 + x7 | 0, x15 ^= x3, x15 = x15 >>> 32 - 8 | x15 << 8, x11 = x11 + x15 | 0, x7 ^= x11, x7 = x7 >>> 32 - 7 | x7 << 7, x1 = x1 + x5 | 0, x13 ^= x1, x13 = x13 >>> 32 - 8 | x13 << 8, x9 = x9 + x13 | 0, x5 ^= x9, x5 = x5 >>> 32 - 7 | x5 << 7, x0 = x0 + x4 | 0, x12 ^= x0, x12 = x12 >>> 32 - 8 | x12 << 8, x8 = x8 + x12 | 0, x4 ^= x8, x4 = x4 >>> 32 - 7 | x4 << 7, x0 = x0 + x5 | 0, x15 ^= x0, x15 = x15 >>> 32 - 16 | x15 << 16, x10 = x10 + x15 | 0, x5 ^= x10, x5 = x5 >>> 32 - 12 | x5 << 12, x1 = x1 + x6 | 0, x12 ^= x1, x12 = x12 >>> 32 - 16 | x12 << 16, x11 = x11 + x12 | 0, x6 ^= x11, x6 = x6 >>> 32 - 12 | x6 << 12, x2 = x2 + x7 | 0, x13 ^= x2, x13 = x13 >>> 32 - 16 | x13 << 16, x8 = x8 + x13 | 0, x7 ^= x8, x7 = x7 >>> 32 - 12 | x7 << 12, x3 = x3 + x4 | 0, x14 ^= x3, x14 = x14 >>> 32 - 16 | x14 << 16, x9 = x9 + x14 | 0, x4 ^= x9, x4 = x4 >>> 32 - 12 | x4 << 12, x2 = x2 + x7 | 0, x13 ^= x2, x13 = x13 >>> 32 - 8 | x13 << 8, x8 = x8 + x13 | 0, x7 ^= x8, x7 = x7 >>> 32 - 7 | x7 << 7, x3 = x3 + x4 | 0, x14 ^= x3, x14 = x14 >>> 32 - 8 | x14 << 8, x9 = x9 + x14 | 0, x4 ^= x9, x4 = x4 >>> 32 - 7 | x4 << 7, x1 = x1 + x6 | 0, x12 ^= x1, x12 = x12 >>> 32 - 8 | x12 << 8, x11 = x11 + x12 | 0, x6 ^= x11, x6 = x6 >>> 32 - 7 | x6 << 7, x0 = x0 + x5 | 0, x15 ^= x0, x15 = x15 >>> 32 - 8 | x15 << 8, x10 = x10 + x15 | 0, x5 ^= x10, x5 = x5 >>> 32 - 7 | x5 << 7;
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0), binary_1.writeUint32LE(x1 + j1 | 0, out, 4), binary_1.writeUint32LE(x2 + j2 | 0, out, 8), binary_1.writeUint32LE(x3 + j3 | 0, out, 12), binary_1.writeUint32LE(x4 + j4 | 0, out, 16), binary_1.writeUint32LE(x5 + j5 | 0, out, 20), binary_1.writeUint32LE(x6 + j6 | 0, out, 24), binary_1.writeUint32LE(x7 + j7 | 0, out, 28), binary_1.writeUint32LE(x8 + j8 | 0, out, 32), binary_1.writeUint32LE(x9 + j9 | 0, out, 36), binary_1.writeUint32LE(x10 + j10 | 0, out, 40), binary_1.writeUint32LE(x11 + j11 | 0, out, 44), binary_1.writeUint32LE(x12 + j12 | 0, out, 48), binary_1.writeUint32LE(x13 + j13 | 0, out, 52), binary_1.writeUint32LE(x14 + j14 | 0, out, 56), binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
__name(core, "core");
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0 && (nonceInplaceCounterLength = 0), key.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (dst.length < src2.length)
    throw new Error("ChaCha: destination is shorter than source");
  var nc2, counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    nc2 = new Uint8Array(16), counterLength = nc2.length - nonce.length, nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    nc2 = nonce, counterLength = nonceInplaceCounterLength;
  }
  for (var block2 = new Uint8Array(64), i = 0; i < src2.length; i += 64) {
    core(block2, nc2, key);
    for (var j2 = i; j2 < i + 64 && j2 < src2.length; j2++)
      dst[j2] = src2[j2] ^ block2[j2 - i];
    incrementCounter(nc2, 0, counterLength);
  }
  return wipe_1$3.wipe(block2), nonceInplaceCounterLength === 0 && wipe_1$3.wipe(nc2), dst;
}
__name(streamXOR, "streamXOR");
chacha.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  return nonceInplaceCounterLength === void 0 && (nonceInplaceCounterLength = 0), wipe_1$3.wipe(dst), streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
__name(stream, "stream");
chacha.stream = stream;
function incrementCounter(counter, pos, len) {
  for (var carry = 1; len--; )
    carry = carry + (counter[pos] & 255) | 0, counter[pos] = carry & 255, carry >>>= 8, pos++;
  if (carry > 0)
    throw new Error("ChaCha: counter overflow");
}
__name(incrementCounter, "incrementCounter");
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
__name(select, "select");
constantTime.select = select;
function lessOrEqual(a2, b2) {
  return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
__name(lessOrEqual, "lessOrEqual");
constantTime.lessOrEqual = lessOrEqual;
function compare(a2, b2) {
  if (a2.length !== b2.length)
    return 0;
  for (var result = 0, i = 0; i < a2.length; i++)
    result |= a2[i] ^ b2[i];
  return 1 & result - 1 >>> 8;
}
__name(compare, "compare");
constantTime.compare = compare;
function equal$1(a2, b2) {
  return a2.length === 0 || b2.length === 0 ? !1 : compare(a2, b2) !== 0;
}
__name(equal$1, "equal$1");
constantTime.equal = equal$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var constant_time_12 = constantTime, wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255, this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191, this._r[9] = t7 >>> 5 & 127, this._pad[0] = key[16] | key[17] << 8, this._pad[1] = key[18] | key[19] << 8, this._pad[2] = key[20] | key[21] << 8, this._pad[3] = key[22] | key[23] << 8, this._pad[4] = key[24] | key[25] << 8, this._pad[5] = key[26] | key[27] << 8, this._pad[6] = key[28] | key[29] << 8, this._pad[7] = key[30] | key[31] << 8;
      }
      return __name(Poly13052, "Poly1305"), Poly13052.prototype._blocks = function(m2, mpos, bytes) {
        for (var hibit = this._fin ? 0 : 2048, h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9], r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9]; bytes >= 16; ) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191, h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191, h9 += t7 >>> 5 | hibit;
          var c2 = 0, d0 = c2;
          d0 += h0 * r0, d0 += h1 * (5 * r9), d0 += h2 * (5 * r8), d0 += h3 * (5 * r7), d0 += h4 * (5 * r6), c2 = d0 >>> 13, d0 &= 8191, d0 += h5 * (5 * r5), d0 += h6 * (5 * r4), d0 += h7 * (5 * r3), d0 += h8 * (5 * r2), d0 += h9 * (5 * r1), c2 += d0 >>> 13, d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1, d1 += h1 * r0, d1 += h2 * (5 * r9), d1 += h3 * (5 * r8), d1 += h4 * (5 * r7), c2 = d1 >>> 13, d1 &= 8191, d1 += h5 * (5 * r6), d1 += h6 * (5 * r5), d1 += h7 * (5 * r4), d1 += h8 * (5 * r3), d1 += h9 * (5 * r2), c2 += d1 >>> 13, d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2, d2 += h1 * r1, d2 += h2 * r0, d2 += h3 * (5 * r9), d2 += h4 * (5 * r8), c2 = d2 >>> 13, d2 &= 8191, d2 += h5 * (5 * r7), d2 += h6 * (5 * r6), d2 += h7 * (5 * r5), d2 += h8 * (5 * r4), d2 += h9 * (5 * r3), c2 += d2 >>> 13, d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3, d3 += h1 * r2, d3 += h2 * r1, d3 += h3 * r0, d3 += h4 * (5 * r9), c2 = d3 >>> 13, d3 &= 8191, d3 += h5 * (5 * r8), d3 += h6 * (5 * r7), d3 += h7 * (5 * r6), d3 += h8 * (5 * r5), d3 += h9 * (5 * r4), c2 += d3 >>> 13, d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4, d4 += h1 * r3, d4 += h2 * r2, d4 += h3 * r1, d4 += h4 * r0, c2 = d4 >>> 13, d4 &= 8191, d4 += h5 * (5 * r9), d4 += h6 * (5 * r8), d4 += h7 * (5 * r7), d4 += h8 * (5 * r6), d4 += h9 * (5 * r5), c2 += d4 >>> 13, d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5, d5 += h1 * r4, d5 += h2 * r3, d5 += h3 * r2, d5 += h4 * r1, c2 = d5 >>> 13, d5 &= 8191, d5 += h5 * r0, d5 += h6 * (5 * r9), d5 += h7 * (5 * r8), d5 += h8 * (5 * r7), d5 += h9 * (5 * r6), c2 += d5 >>> 13, d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6, d6 += h1 * r5, d6 += h2 * r4, d6 += h3 * r3, d6 += h4 * r2, c2 = d6 >>> 13, d6 &= 8191, d6 += h5 * r1, d6 += h6 * r0, d6 += h7 * (5 * r9), d6 += h8 * (5 * r8), d6 += h9 * (5 * r7), c2 += d6 >>> 13, d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7, d7 += h1 * r6, d7 += h2 * r5, d7 += h3 * r4, d7 += h4 * r3, c2 = d7 >>> 13, d7 &= 8191, d7 += h5 * r2, d7 += h6 * r1, d7 += h7 * r0, d7 += h8 * (5 * r9), d7 += h9 * (5 * r8), c2 += d7 >>> 13, d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8, d8 += h1 * r7, d8 += h2 * r6, d8 += h3 * r5, d8 += h4 * r4, c2 = d8 >>> 13, d8 &= 8191, d8 += h5 * r3, d8 += h6 * r2, d8 += h7 * r1, d8 += h8 * r0, d8 += h9 * (5 * r9), c2 += d8 >>> 13, d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9, d9 += h1 * r8, d9 += h2 * r7, d9 += h3 * r6, d9 += h4 * r5, c2 = d9 >>> 13, d9 &= 8191, d9 += h5 * r4, d9 += h6 * r3, d9 += h7 * r2, d9 += h8 * r1, d9 += h9 * r0, c2 += d9 >>> 13, d9 &= 8191, c2 = (c2 << 2) + c2 | 0, c2 = c2 + d0 | 0, d0 = c2 & 8191, c2 = c2 >>> 13, d1 += c2, h0 = d0, h1 = d1, h2 = d2, h3 = d3, h4 = d4, h5 = d5, h6 = d6, h7 = d7, h8 = d8, h9 = d9, mpos += 16, bytes -= 16;
        }
        this._h[0] = h0, this._h[1] = h1, this._h[2] = h2, this._h[3] = h3, this._h[4] = h4, this._h[5] = h5, this._h[6] = h6, this._h[7] = h7, this._h[8] = h8, this._h[9] = h9;
      }, Poly13052.prototype.finish = function(mac, macpos) {
        macpos === void 0 && (macpos = 0);
        var g2 = new Uint16Array(10), c2, mask, f2, i;
        if (this._leftover) {
          for (i = this._leftover, this._buffer[i++] = 1; i < 16; i++)
            this._buffer[i] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (c2 = this._h[1] >>> 13, this._h[1] &= 8191, i = 2; i < 10; i++)
          this._h[i] += c2, c2 = this._h[i] >>> 13, this._h[i] &= 8191;
        for (this._h[0] += c2 * 5, c2 = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += c2, c2 = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += c2, g2[0] = this._h[0] + 5, c2 = g2[0] >>> 13, g2[0] &= 8191, i = 1; i < 10; i++)
          g2[i] = this._h[i] + c2, c2 = g2[i] >>> 13, g2[i] &= 8191;
        for (g2[9] -= 8192, mask = (c2 ^ 1) - 1, i = 0; i < 10; i++)
          g2[i] &= mask;
        for (mask = ~mask, i = 0; i < 10; i++)
          this._h[i] = this._h[i] & mask | g2[i];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, f2 = this._h[0] + this._pad[0], this._h[0] = f2 & 65535, i = 1; i < 8; i++)
          f2 = (this._h[i] + this._pad[i] | 0) + (f2 >>> 16) | 0, this._h[i] = f2 & 65535;
        return mac[macpos + 0] = this._h[0] >>> 0, mac[macpos + 1] = this._h[0] >>> 8, mac[macpos + 2] = this._h[1] >>> 0, mac[macpos + 3] = this._h[1] >>> 8, mac[macpos + 4] = this._h[2] >>> 0, mac[macpos + 5] = this._h[2] >>> 8, mac[macpos + 6] = this._h[3] >>> 0, mac[macpos + 7] = this._h[3] >>> 8, mac[macpos + 8] = this._h[4] >>> 0, mac[macpos + 9] = this._h[4] >>> 8, mac[macpos + 10] = this._h[5] >>> 0, mac[macpos + 11] = this._h[5] >>> 8, mac[macpos + 12] = this._h[6] >>> 0, mac[macpos + 13] = this._h[6] >>> 8, mac[macpos + 14] = this._h[7] >>> 0, mac[macpos + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Poly13052.prototype.update = function(m2) {
        var mpos = 0, bytes = m2.length, want;
        if (this._leftover) {
          want = 16 - this._leftover, want > bytes && (want = bytes);
          for (var i = 0; i < want; i++)
            this._buffer[this._leftover + i] = m2[mpos + i];
          if (bytes -= want, mpos += want, this._leftover += want, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (bytes >= 16 && (want = bytes - bytes % 16, this._blocks(m2, mpos, want), mpos += want, bytes -= want), bytes) {
          for (var i = 0; i < bytes; i++)
            this._buffer[this._leftover + i] = m2[mpos + i];
          this._leftover += bytes;
        }
        return this;
      }, Poly13052.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var mac = new Uint8Array(16);
        return this.finish(mac), mac;
      }, Poly13052.prototype.clean = function() {
        return wipe_12.wipe(this._buffer), wipe_12.wipe(this._r), wipe_12.wipe(this._h), wipe_12.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data) {
    var h2 = new Poly1305(key);
    h2.update(data);
    var digest = h2.digest();
    return h2.clean(), digest;
  }
  __name(oneTimeAuth, "oneTimeAuth"), exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b2) {
    return a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH ? !1 : constant_time_12.equal(a2, b2);
  }
  __name(equal2, "equal"), exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var chacha_1 = chacha, poly1305_1 = poly1305, wipe_12 = wipe$1, binary_12 = binary, constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32, exports.NONCE_LENGTH = 12, exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16), ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key) {
        if (this.nonceLength = exports.NONCE_LENGTH, this.tagLength = exports.TAG_LENGTH, key.length !== exports.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(key);
      }
      return __name(ChaCha20Poly13052, "ChaCha20Poly1305"), ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength, result;
        if (dst) {
          if (dst.length !== resultLength)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          result = dst;
        } else
          result = new Uint8Array(resultLength);
        return chacha_1.streamXOR(this._key, counter, plaintext, result, 4), this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData), wipe_12.wipe(counter), result;
      }, ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (sealed.length < this.tagLength)
          return null;
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        if (this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData), !constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length)))
          return null;
        var resultLength = sealed.length - this.tagLength, result;
        if (dst) {
          if (dst.length !== resultLength)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          result = dst;
        } else
          result = new Uint8Array(resultLength);
        return chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4), wipe_12.wipe(counter), result;
      }, ChaCha20Poly13052.prototype.clean = function() {
        return wipe_12.wipe(this._key), this;
      }, ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h2 = new poly1305_1.Poly1305(authKey);
        associatedData && (h2.update(associatedData), associatedData.length % 16 > 0 && h2.update(ZEROS.subarray(associatedData.length % 16))), h2.update(ciphertext), ciphertext.length % 16 > 0 && h2.update(ZEROS.subarray(ciphertext.length % 16));
        var length2 = new Uint8Array(8);
        associatedData && binary_12.writeUint64LE(associatedData.length, length2), h2.update(length2), binary_12.writeUint64LE(ciphertext.length, length2), h2.update(length2);
        for (var tag = h2.digest(), i = 0; i < tag.length; i++)
          tagOut[i] = tag[i];
        h2.clean(), wipe_12.wipe(tag), wipe_12.wipe(length2);
      }, ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash = {};
Object.defineProperty(hash, "__esModule", { value: !0 });
function isSerializableHash(h2) {
  return typeof h2.saveState < "u" && typeof h2.restoreState < "u" && typeof h2.cleanSavedState < "u";
}
__name(isSerializableHash, "isSerializableHash");
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash, constant_time_1 = constantTime, wipe_1$2 = wipe$1, HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key) {
      this._finished = !1, this._inner = new hash2(), this._outer = new hash2(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var pad = new Uint8Array(this.blockSize);
      key.length > this.blockSize ? this._inner.update(key).finish(pad).clean() : pad.set(key);
      for (var i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this._inner.update(pad);
      for (var i = 0; i < pad.length; i++)
        pad[i] ^= 106;
      this._outer.update(pad), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$2.wipe(pad);
    }
    return __name(HMAC2, "HMAC"), HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, HMAC2.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, HMAC2.prototype.update = function(data) {
      return this._inner.update(data), this;
    }, HMAC2.prototype.finish = function(out) {
      return this._finished ? (this._outer.finish(out), this) : (this._inner.finish(out), this._outer.update(out.subarray(0, this.digestLength)).finish(out), this._finished = !0, this);
    }, HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      return this.finish(out), out;
    }, HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(savedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(savedState);
    }, HMAC2;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(hash2, key, data) {
  var h2 = new HMAC(hash2, key);
  h2.update(data);
  var digest = h2.digest();
  return h2.clean(), digest;
}
__name(hmac, "hmac");
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1$1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key, salt, info2) {
      salt === void 0 && (salt = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = hash2, this._info = info2;
      var okm = hmac_1.hmac(this._hash, salt, key);
      this._hmac = new hmac_1.HMAC(hash2, okm), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return __name(HKDF2, "HKDF"), HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), ctr > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, HKDF2.prototype.expand = function(length2) {
      for (var out = new Uint8Array(length2), i = 0; i < out.length; i++)
        this._bufpos === this._buffer.length && this._fillBuffer(), out[i] = this._buffer[this._bufpos++];
      return out;
    }, HKDF2.prototype.clean = function() {
      this._hmac.clean(), wipe_1$1.wipe(this._buffer), wipe_1$1.wipe(this._counter), this._bufpos = 0;
    }, HKDF2;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, random = {}, system = {}, browser = {};
Object.defineProperty(browser, "__esModule", { value: !0 });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536, _BrowserRandomSource = class _BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const browserCrypto = typeof self < "u" ? self.crypto || self.msCrypto : null;
    browserCrypto && browserCrypto.getRandomValues !== void 0 && (this._crypto = browserCrypto, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i += QUOTA)
      this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
    return out;
  }
};
__name(_BrowserRandomSource, "BrowserRandomSource");
let BrowserRandomSource = _BrowserRandomSource;
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
__name(commonjsRequire, "commonjsRequire");
var node = {};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1, _NodeRandomSource = class _NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire < "u") {
      const nodeCrypto = require$$0$1;
      nodeCrypto && nodeCrypto.randomBytes && (this._crypto = nodeCrypto, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let buffer = this._crypto.randomBytes(length2);
    if (buffer.length !== length2)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i++)
      out[i] = buffer[i];
    return (0, wipe_1.wipe)(buffer), out;
  }
};
__name(_NodeRandomSource, "NodeRandomSource");
let NodeRandomSource = _NodeRandomSource;
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser, node_1 = node, _SystemRandomSource = class _SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(length2);
  }
};
__name(_SystemRandomSource, "SystemRandomSource");
let SystemRandomSource = _SystemRandomSource;
system.SystemRandomSource = SystemRandomSource;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system, binary_12 = binary, wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  __name(randomBytes, "randomBytes"), exports.randomBytes = randomBytes;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf = randomBytes(4, prng), result = (0, binary_12.readUint32LE)(buf);
    return (0, wipe_12.wipe)(buf), result;
  }
  __name(randomUint32, "randomUint32"), exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2)
      throw new Error("randomString charset is too short");
    if (charset.length > 256)
      throw new Error("randomString charset is too long");
    let out = "";
    const charsLen = charset.length, maxByte = 256 - 256 % charsLen;
    for (; length2 > 0; ) {
      const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i = 0; i < buf.length && length2 > 0; i++) {
        const randomByte = buf[i];
        randomByte < maxByte && (out += charset.charAt(randomByte % charsLen), length2--);
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  __name(randomString, "randomString"), exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  __name(randomStringForEntropy, "randomStringForEntropy"), exports.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var binary_12 = binary, wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32, exports.BLOCK_SIZE = 64;
  var SHA256 = (
    /** @class */
    function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH, this.blockSize = exports.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return __name(SHA2562, "SHA256"), SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, SHA2562.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, SHA2562.prototype.clean = function() {
        wipe_12.wipe(this._buffer), wipe_12.wipe(this._temp), this.reset();
      }, SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0 && (dataLength = data.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var dataPos = 0;
        if (this._bytesHashed += dataLength, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && dataLength > 0; )
            this._buffer[this._bufferLength++] = data[dataPos++], dataLength--;
          this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (dataLength >= this.blockSize && (dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength), dataLength %= this.blockSize); dataLength > 0; )
          this._buffer[this._bufferLength++] = data[dataPos++], dataLength--;
        return this;
      }, SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed, left2 = this._bufferLength, bitLenHi = bytesHashed / 536870912 | 0, bitLenLo = bytesHashed << 3, padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left2] = 128;
          for (var i = left2 + 1; i < padLength - 8; i++)
            this._buffer[i] = 0;
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8), binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4), hashBlocks(this._temp, this._state, this._buffer, 0, padLength), this._finished = !0;
        }
        for (var i = 0; i < this.digestLength / 4; i++)
          binary_12.writeUint32BE(this._state[i], out, i * 4);
        return this;
      }, SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        return this.finish(out), out;
      }, SHA2562.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, SHA2562.prototype.restoreState = function(savedState) {
        return this._state.set(savedState.state), this._bufferLength = savedState.bufferLength, savedState.buffer && this._buffer.set(savedState.buffer), this._bytesHashed = savedState.bytesHashed, this._finished = !1, this;
      }, SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state), savedState.buffer && wipe_12.wipe(savedState.buffer), savedState.bufferLength = 0, savedState.bytesHashed = 0;
      }, SHA2562;
    }()
  );
  exports.SHA256 = SHA256;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len) {
    for (; len >= 64; ) {
      for (var a2 = v2[0], b2 = v2[1], c2 = v2[2], d2 = v2[3], e2 = v2[4], f2 = v2[5], g2 = v2[6], h2 = v2[7], i = 0; i < 16; i++) {
        var j2 = pos + i * 4;
        w2[i] = binary_12.readUint32BE(p2, j2);
      }
      for (var i = 16; i < 64; i++) {
        var u2 = w2[i - 2], t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i] = (t1 + w2[i - 7] | 0) + (t2 + w2[i - 16] | 0);
      }
      for (var i = 0; i < 64; i++) {
        var t1 = (((e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h2 + (K2[i] + w2[i] | 0) | 0) | 0, t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
        h2 = g2, g2 = f2, f2 = e2, e2 = d2 + t1 | 0, d2 = c2, c2 = b2, b2 = a2, a2 = t1 + t2 | 0;
      }
      v2[0] += a2, v2[1] += b2, v2[2] += c2, v2[3] += d2, v2[4] += e2, v2[5] += f2, v2[6] += g2, v2[7] += h2, pos += 64, len -= 64;
    }
    return pos;
  }
  __name(hashBlocks, "hashBlocks");
  function hash2(data) {
    var h2 = new SHA256();
    h2.update(data);
    var digest = h2.digest();
    return h2.clean(), digest;
  }
  __name(hash2, "hash"), exports.hash = hash2;
})(sha256);
var x25519 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random, wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32, exports.SECRET_KEY_LENGTH = 32, exports.SHARED_KEY_LENGTH = 32;
  function gf(init2) {
    const r2 = new Float64Array(16);
    if (init2)
      for (let i = 0; i < init2.length; i++)
        r2[i] = init2[i];
    return r2;
  }
  __name(gf, "gf");
  const _92 = new Uint8Array(32);
  _92[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i = 0; i < 16; i++) {
      let v2 = o2[i] + c2 + 65535;
      c2 = Math.floor(v2 / 65536), o2[i] = v2 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  __name(car25519, "car25519");
  function sel25519(p2, q2, b2) {
    const c2 = ~(b2 - 1);
    for (let i = 0; i < 16; i++) {
      const t2 = c2 & (p2[i] ^ q2[i]);
      p2[i] ^= t2, q2[i] ^= t2;
    }
  }
  __name(sel25519, "sel25519");
  function pack25519(o2, n2) {
    const m2 = gf(), t2 = gf();
    for (let i = 0; i < 16; i++)
      t2[i] = n2[i];
    car25519(t2), car25519(t2), car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i = 1; i < 15; i++)
        m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1), m2[i - 1] &= 65535;
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535, sel25519(t2, m2, 1 - b2);
    }
    for (let i = 0; i < 16; i++)
      o2[2 * i] = t2[i] & 255, o2[2 * i + 1] = t2[i] >> 8;
  }
  __name(pack25519, "pack25519");
  function unpack25519(o2, n2) {
    for (let i = 0; i < 16; i++)
      o2[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
    o2[15] &= 32767;
  }
  __name(unpack25519, "unpack25519");
  function add(o2, a2, b2) {
    for (let i = 0; i < 16; i++)
      o2[i] = a2[i] + b2[i];
  }
  __name(add, "add");
  function sub(o2, a2, b2) {
    for (let i = 0; i < 16; i++)
      o2[i] = a2[i] - b2[i];
  }
  __name(sub, "sub");
  function mul(o2, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0], t0 += v2 * b0, t1 += v2 * b1, t2 += v2 * b22, t3 += v2 * b3, t4 += v2 * b4, t5 += v2 * b5, t6 += v2 * b6, t7 += v2 * b7, t8 += v2 * b8, t9 += v2 * b9, t10 += v2 * b10, t11 += v2 * b11, t12 += v2 * b12, t13 += v2 * b13, t14 += v2 * b14, t15 += v2 * b15, v2 = a2[1], t1 += v2 * b0, t2 += v2 * b1, t3 += v2 * b22, t4 += v2 * b3, t5 += v2 * b4, t6 += v2 * b5, t7 += v2 * b6, t8 += v2 * b7, t9 += v2 * b8, t10 += v2 * b9, t11 += v2 * b10, t12 += v2 * b11, t13 += v2 * b12, t14 += v2 * b13, t15 += v2 * b14, t16 += v2 * b15, v2 = a2[2], t2 += v2 * b0, t3 += v2 * b1, t4 += v2 * b22, t5 += v2 * b3, t6 += v2 * b4, t7 += v2 * b5, t8 += v2 * b6, t9 += v2 * b7, t10 += v2 * b8, t11 += v2 * b9, t12 += v2 * b10, t13 += v2 * b11, t14 += v2 * b12, t15 += v2 * b13, t16 += v2 * b14, t17 += v2 * b15, v2 = a2[3], t3 += v2 * b0, t4 += v2 * b1, t5 += v2 * b22, t6 += v2 * b3, t7 += v2 * b4, t8 += v2 * b5, t9 += v2 * b6, t10 += v2 * b7, t11 += v2 * b8, t12 += v2 * b9, t13 += v2 * b10, t14 += v2 * b11, t15 += v2 * b12, t16 += v2 * b13, t17 += v2 * b14, t18 += v2 * b15, v2 = a2[4], t4 += v2 * b0, t5 += v2 * b1, t6 += v2 * b22, t7 += v2 * b3, t8 += v2 * b4, t9 += v2 * b5, t10 += v2 * b6, t11 += v2 * b7, t12 += v2 * b8, t13 += v2 * b9, t14 += v2 * b10, t15 += v2 * b11, t16 += v2 * b12, t17 += v2 * b13, t18 += v2 * b14, t19 += v2 * b15, v2 = a2[5], t5 += v2 * b0, t6 += v2 * b1, t7 += v2 * b22, t8 += v2 * b3, t9 += v2 * b4, t10 += v2 * b5, t11 += v2 * b6, t12 += v2 * b7, t13 += v2 * b8, t14 += v2 * b9, t15 += v2 * b10, t16 += v2 * b11, t17 += v2 * b12, t18 += v2 * b13, t19 += v2 * b14, t20 += v2 * b15, v2 = a2[6], t6 += v2 * b0, t7 += v2 * b1, t8 += v2 * b22, t9 += v2 * b3, t10 += v2 * b4, t11 += v2 * b5, t12 += v2 * b6, t13 += v2 * b7, t14 += v2 * b8, t15 += v2 * b9, t16 += v2 * b10, t17 += v2 * b11, t18 += v2 * b12, t19 += v2 * b13, t20 += v2 * b14, t21 += v2 * b15, v2 = a2[7], t7 += v2 * b0, t8 += v2 * b1, t9 += v2 * b22, t10 += v2 * b3, t11 += v2 * b4, t12 += v2 * b5, t13 += v2 * b6, t14 += v2 * b7, t15 += v2 * b8, t16 += v2 * b9, t17 += v2 * b10, t18 += v2 * b11, t19 += v2 * b12, t20 += v2 * b13, t21 += v2 * b14, t22 += v2 * b15, v2 = a2[8], t8 += v2 * b0, t9 += v2 * b1, t10 += v2 * b22, t11 += v2 * b3, t12 += v2 * b4, t13 += v2 * b5, t14 += v2 * b6, t15 += v2 * b7, t16 += v2 * b8, t17 += v2 * b9, t18 += v2 * b10, t19 += v2 * b11, t20 += v2 * b12, t21 += v2 * b13, t22 += v2 * b14, t23 += v2 * b15, v2 = a2[9], t9 += v2 * b0, t10 += v2 * b1, t11 += v2 * b22, t12 += v2 * b3, t13 += v2 * b4, t14 += v2 * b5, t15 += v2 * b6, t16 += v2 * b7, t17 += v2 * b8, t18 += v2 * b9, t19 += v2 * b10, t20 += v2 * b11, t21 += v2 * b12, t22 += v2 * b13, t23 += v2 * b14, t24 += v2 * b15, v2 = a2[10], t10 += v2 * b0, t11 += v2 * b1, t12 += v2 * b22, t13 += v2 * b3, t14 += v2 * b4, t15 += v2 * b5, t16 += v2 * b6, t17 += v2 * b7, t18 += v2 * b8, t19 += v2 * b9, t20 += v2 * b10, t21 += v2 * b11, t22 += v2 * b12, t23 += v2 * b13, t24 += v2 * b14, t25 += v2 * b15, v2 = a2[11], t11 += v2 * b0, t12 += v2 * b1, t13 += v2 * b22, t14 += v2 * b3, t15 += v2 * b4, t16 += v2 * b5, t17 += v2 * b6, t18 += v2 * b7, t19 += v2 * b8, t20 += v2 * b9, t21 += v2 * b10, t22 += v2 * b11, t23 += v2 * b12, t24 += v2 * b13, t25 += v2 * b14, t26 += v2 * b15, v2 = a2[12], t12 += v2 * b0, t13 += v2 * b1, t14 += v2 * b22, t15 += v2 * b3, t16 += v2 * b4, t17 += v2 * b5, t18 += v2 * b6, t19 += v2 * b7, t20 += v2 * b8, t21 += v2 * b9, t22 += v2 * b10, t23 += v2 * b11, t24 += v2 * b12, t25 += v2 * b13, t26 += v2 * b14, t27 += v2 * b15, v2 = a2[13], t13 += v2 * b0, t14 += v2 * b1, t15 += v2 * b22, t16 += v2 * b3, t17 += v2 * b4, t18 += v2 * b5, t19 += v2 * b6, t20 += v2 * b7, t21 += v2 * b8, t22 += v2 * b9, t23 += v2 * b10, t24 += v2 * b11, t25 += v2 * b12, t26 += v2 * b13, t27 += v2 * b14, t28 += v2 * b15, v2 = a2[14], t14 += v2 * b0, t15 += v2 * b1, t16 += v2 * b22, t17 += v2 * b3, t18 += v2 * b4, t19 += v2 * b5, t20 += v2 * b6, t21 += v2 * b7, t22 += v2 * b8, t23 += v2 * b9, t24 += v2 * b10, t25 += v2 * b11, t26 += v2 * b12, t27 += v2 * b13, t28 += v2 * b14, t29 += v2 * b15, v2 = a2[15], t15 += v2 * b0, t16 += v2 * b1, t17 += v2 * b22, t18 += v2 * b3, t19 += v2 * b4, t20 += v2 * b5, t21 += v2 * b6, t22 += v2 * b7, t23 += v2 * b8, t24 += v2 * b9, t25 += v2 * b10, t26 += v2 * b11, t27 += v2 * b12, t28 += v2 * b13, t29 += v2 * b14, t30 += v2 * b15, t0 += 38 * t16, t1 += 38 * t17, t2 += 38 * t18, t3 += 38 * t19, t4 += 38 * t20, t5 += 38 * t21, t6 += 38 * t22, t7 += 38 * t23, t8 += 38 * t24, t9 += 38 * t25, t10 += 38 * t26, t11 += 38 * t27, t12 += 38 * t28, t13 += 38 * t29, t14 += 38 * t30, c2 = 1, v2 = t0 + c2 + 65535, c2 = Math.floor(v2 / 65536), t0 = v2 - c2 * 65536, v2 = t1 + c2 + 65535, c2 = Math.floor(v2 / 65536), t1 = v2 - c2 * 65536, v2 = t2 + c2 + 65535, c2 = Math.floor(v2 / 65536), t2 = v2 - c2 * 65536, v2 = t3 + c2 + 65535, c2 = Math.floor(v2 / 65536), t3 = v2 - c2 * 65536, v2 = t4 + c2 + 65535, c2 = Math.floor(v2 / 65536), t4 = v2 - c2 * 65536, v2 = t5 + c2 + 65535, c2 = Math.floor(v2 / 65536), t5 = v2 - c2 * 65536, v2 = t6 + c2 + 65535, c2 = Math.floor(v2 / 65536), t6 = v2 - c2 * 65536, v2 = t7 + c2 + 65535, c2 = Math.floor(v2 / 65536), t7 = v2 - c2 * 65536, v2 = t8 + c2 + 65535, c2 = Math.floor(v2 / 65536), t8 = v2 - c2 * 65536, v2 = t9 + c2 + 65535, c2 = Math.floor(v2 / 65536), t9 = v2 - c2 * 65536, v2 = t10 + c2 + 65535, c2 = Math.floor(v2 / 65536), t10 = v2 - c2 * 65536, v2 = t11 + c2 + 65535, c2 = Math.floor(v2 / 65536), t11 = v2 - c2 * 65536, v2 = t12 + c2 + 65535, c2 = Math.floor(v2 / 65536), t12 = v2 - c2 * 65536, v2 = t13 + c2 + 65535, c2 = Math.floor(v2 / 65536), t13 = v2 - c2 * 65536, v2 = t14 + c2 + 65535, c2 = Math.floor(v2 / 65536), t14 = v2 - c2 * 65536, v2 = t15 + c2 + 65535, c2 = Math.floor(v2 / 65536), t15 = v2 - c2 * 65536, t0 += c2 - 1 + 37 * (c2 - 1), c2 = 1, v2 = t0 + c2 + 65535, c2 = Math.floor(v2 / 65536), t0 = v2 - c2 * 65536, v2 = t1 + c2 + 65535, c2 = Math.floor(v2 / 65536), t1 = v2 - c2 * 65536, v2 = t2 + c2 + 65535, c2 = Math.floor(v2 / 65536), t2 = v2 - c2 * 65536, v2 = t3 + c2 + 65535, c2 = Math.floor(v2 / 65536), t3 = v2 - c2 * 65536, v2 = t4 + c2 + 65535, c2 = Math.floor(v2 / 65536), t4 = v2 - c2 * 65536, v2 = t5 + c2 + 65535, c2 = Math.floor(v2 / 65536), t5 = v2 - c2 * 65536, v2 = t6 + c2 + 65535, c2 = Math.floor(v2 / 65536), t6 = v2 - c2 * 65536, v2 = t7 + c2 + 65535, c2 = Math.floor(v2 / 65536), t7 = v2 - c2 * 65536, v2 = t8 + c2 + 65535, c2 = Math.floor(v2 / 65536), t8 = v2 - c2 * 65536, v2 = t9 + c2 + 65535, c2 = Math.floor(v2 / 65536), t9 = v2 - c2 * 65536, v2 = t10 + c2 + 65535, c2 = Math.floor(v2 / 65536), t10 = v2 - c2 * 65536, v2 = t11 + c2 + 65535, c2 = Math.floor(v2 / 65536), t11 = v2 - c2 * 65536, v2 = t12 + c2 + 65535, c2 = Math.floor(v2 / 65536), t12 = v2 - c2 * 65536, v2 = t13 + c2 + 65535, c2 = Math.floor(v2 / 65536), t13 = v2 - c2 * 65536, v2 = t14 + c2 + 65535, c2 = Math.floor(v2 / 65536), t14 = v2 - c2 * 65536, v2 = t15 + c2 + 65535, c2 = Math.floor(v2 / 65536), t15 = v2 - c2 * 65536, t0 += c2 - 1 + 37 * (c2 - 1), o2[0] = t0, o2[1] = t1, o2[2] = t2, o2[3] = t3, o2[4] = t4, o2[5] = t5, o2[6] = t6, o2[7] = t7, o2[8] = t8, o2[9] = t9, o2[10] = t10, o2[11] = t11, o2[12] = t12, o2[13] = t13, o2[14] = t14, o2[15] = t15;
  }
  __name(mul, "mul");
  function square(o2, a2) {
    mul(o2, a2, a2);
  }
  __name(square, "square");
  function inv25519(o2, inp) {
    const c2 = gf();
    for (let i = 0; i < 16; i++)
      c2[i] = inp[i];
    for (let i = 253; i >= 0; i--)
      square(c2, c2), i !== 2 && i !== 4 && mul(c2, c2, inp);
    for (let i = 0; i < 16; i++)
      o2[i] = c2[i];
  }
  __name(inv25519, "inv25519");
  function scalarMult(n2, p2) {
    const z2 = new Uint8Array(32), x2 = new Float64Array(80), a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f2 = gf();
    for (let i = 0; i < 31; i++)
      z2[i] = n2[i];
    z2[31] = n2[31] & 127 | 64, z2[0] &= 248, unpack25519(x2, p2);
    for (let i = 0; i < 16; i++)
      b2[i] = x2[i];
    a2[0] = d2[0] = 1;
    for (let i = 254; i >= 0; --i) {
      const r2 = z2[i >>> 3] >>> (i & 7) & 1;
      sel25519(a2, b2, r2), sel25519(c2, d2, r2), add(e2, a2, c2), sub(a2, a2, c2), add(c2, b2, d2), sub(b2, b2, d2), square(d2, e2), square(f2, a2), mul(a2, c2, a2), mul(c2, b2, e2), add(e2, a2, c2), sub(a2, a2, c2), square(b2, a2), sub(c2, d2, f2), mul(a2, c2, _121665), add(a2, a2, d2), mul(c2, c2, a2), mul(a2, d2, f2), mul(d2, b2, x2), square(b2, e2), sel25519(a2, b2, r2), sel25519(c2, d2, r2);
    }
    for (let i = 0; i < 16; i++)
      x2[i + 16] = a2[i], x2[i + 32] = c2[i], x2[i + 48] = b2[i], x2[i + 64] = d2[i];
    const x32 = x2.subarray(32), x16 = x2.subarray(16);
    inv25519(x32, x32), mul(x16, x16, x32);
    const q2 = new Uint8Array(32);
    return pack25519(q2, x16), q2;
  }
  __name(scalarMult, "scalarMult"), exports.scalarMult = scalarMult;
  function scalarMultBase(n2) {
    return scalarMult(n2, _92);
  }
  __name(scalarMultBase, "scalarMultBase"), exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed2) {
    if (seed2.length !== exports.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    const secretKey = new Uint8Array(seed2);
    return {
      publicKey: scalarMultBase(secretKey),
      secretKey
    };
  }
  __name(generateKeyPairFromSeed, "generateKeyPairFromSeed"), exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed2 = (0, random_1.randomBytes)(32, prng), result = generateKeyPairFromSeed(seed2);
    return (0, wipe_12.wipe)(seed2), result;
  }
  __name(generateKeyPair, "generateKeyPair"), exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = !1) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i = 0; i < result.length; i++)
        zeros |= result[i];
      if (zeros === 0)
        throw new Error("X25519: invalid shared key");
    }
    return result;
  }
  __name(sharedKey, "sharedKey"), exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf) {
  return globalThis.Buffer != null ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;
}
__name(asUint8Array, "asUint8Array");
function allocUnsafe(size2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(size2)) : new Uint8Array(size2);
}
__name(allocUnsafe, "allocUnsafe");
function concat(arrays, length2) {
  length2 || (length2 = arrays.reduce((acc, curr) => acc + curr.length, 0));
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays)
    output2.set(arr, offset), offset += arr.length;
  return asUint8Array(output2);
}
__name(concat, "concat");
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var BASE_MAP = new Uint8Array(256), j2 = 0; j2 < BASE_MAP.length; j2++)
    BASE_MAP[j2] = 255;
  for (var i = 0; i < ALPHABET.length; i++) {
    var x2 = ALPHABET.charAt(i), xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255)
      throw new TypeError(x2 + " is ambiguous");
    BASE_MAP[xc2] = i;
  }
  var BASE = ALPHABET.length, LEADER = ALPHABET.charAt(0), FACTOR = Math.log(BASE) / Math.log(256), iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array || (ArrayBuffer.isView(source) ? source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength) : Array.isArray(source) && (source = Uint8Array.from(source))), !(source instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (source.length === 0)
      return "";
    for (var zeroes = 0, length2 = 0, pbegin = 0, pend = source.length; pbegin !== pend && source[pbegin] === 0; )
      pbegin++, zeroes++;
    for (var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0, b58 = new Uint8Array(size2); pbegin !== pend; ) {
      for (var carry = source[pbegin], i2 = 0, it1 = size2 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++)
        carry += 256 * b58[it1] >>> 0, b58[it1] = carry % BASE >>> 0, carry = carry / BASE >>> 0;
      if (carry !== 0)
        throw new Error("Non-zero carry");
      length2 = i2, pbegin++;
    }
    for (var it2 = size2 - length2; it2 !== size2 && b58[it2] === 0; )
      it2++;
    for (var str = LEADER.repeat(zeroes); it2 < size2; ++it2)
      str += ALPHABET.charAt(b58[it2]);
    return str;
  }
  __name(encode2, "encode");
  function decodeUnsafe(source) {
    if (typeof source != "string")
      throw new TypeError("Expected String");
    if (source.length === 0)
      return new Uint8Array();
    var psz = 0;
    if (source[psz] !== " ") {
      for (var zeroes = 0, length2 = 0; source[psz] === LEADER; )
        zeroes++, psz++;
      for (var size2 = (source.length - psz) * FACTOR + 1 >>> 0, b256 = new Uint8Array(size2); source[psz]; ) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255)
          return;
        for (var i2 = 0, it3 = size2 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++)
          carry += BASE * b256[it3] >>> 0, b256[it3] = carry % 256 >>> 0, carry = carry / 256 >>> 0;
        if (carry !== 0)
          throw new Error("Non-zero carry");
        length2 = i2, psz++;
      }
      if (source[psz] !== " ") {
        for (var it4 = size2 - length2; it4 !== size2 && b256[it4] === 0; )
          it4++;
        for (var vch = new Uint8Array(zeroes + (size2 - it4)), j3 = zeroes; it4 !== size2; )
          vch[j3++] = b256[it4++];
        return vch;
      }
    }
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode2(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer)
      return buffer;
    throw new Error(`Non-${name} character`);
  }
  return __name(decode2, "decode"), {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
__name(base, "base");
var src = base, _brrp__multiformats_scope_baseX = src;
const coerce = /* @__PURE__ */ __name((o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2))
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  throw new Error("Unknown type, must be binary type");
}, "coerce"), fromString$1 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString$1"), toString$1 = /* @__PURE__ */ __name((b2) => new TextDecoder().decode(b2), "toString$1"), _Encoder = class _Encoder {
  constructor(name, prefix2, baseEncode) {
    this.name = name, this.prefix = prefix2, this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(bytes)}`;
    throw Error("Unknown type, must be binary type");
  }
};
__name(_Encoder, "Encoder");
let Encoder = _Encoder;
const _Decoder = class _Decoder {
  constructor(name, prefix2, baseDecode) {
    if (this.name = name, this.prefix = prefix2, prefix2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = prefix2.codePointAt(0), this.baseDecode = baseDecode;
  }
  decode(text2) {
    if (typeof text2 == "string") {
      if (text2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(text2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(decoder) {
    return or(this, decoder);
  }
};
__name(_Decoder, "Decoder");
let Decoder = _Decoder;
const _ComposedDecoder = class _ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input2) {
    const prefix2 = input2[0], decoder = this.decoders[prefix2];
    if (decoder)
      return decoder.decode(input2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(input2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
__name(_ComposedDecoder, "ComposedDecoder");
let ComposedDecoder = _ComposedDecoder;
const or = /* @__PURE__ */ __name((left2, right) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right.decoders || { [right.prefix]: right }
}), "or"), _Codec = class _Codec {
  constructor(name, prefix2, baseEncode, baseDecode) {
    this.name = name, this.prefix = prefix2, this.baseEncode = baseEncode, this.baseDecode = baseDecode, this.encoder = new Encoder(name, prefix2, baseEncode), this.decoder = new Decoder(name, prefix2, baseDecode);
  }
  encode(input2) {
    return this.encoder.encode(input2);
  }
  decode(input2) {
    return this.decoder.decode(input2);
  }
};
__name(_Codec, "Codec");
let Codec = _Codec;
const from = /* @__PURE__ */ __name(({ name, prefix: prefix2, encode: encode2, decode: decode2 }) => new Codec(name, prefix2, encode2, decode2), "from"), baseX = /* @__PURE__ */ __name(({ prefix: prefix2, name, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix: prefix2,
    name,
    encode: encode2,
    decode: (text2) => coerce(decode2(text2))
  });
}, "baseX"), decode$2 = /* @__PURE__ */ __name((string2, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i)
    codes[alphabet2[i]] = i;
  let end2 = string2.length;
  for (; string2[end2 - 1] === "="; )
    --end2;
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0, buffer = 0, written = 0;
  for (let i = 0; i < end2; ++i) {
    const value = codes[string2[i]];
    if (value === void 0)
      throw new SyntaxError(`Non-${name} character`);
    buffer = buffer << bitsPerChar | value, bits += bitsPerChar, bits >= 8 && (bits -= 8, out[written++] = 255 & buffer >> bits);
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits)
    throw new SyntaxError("Unexpected end of data");
  return out;
}, "decode$2"), encode$1 = /* @__PURE__ */ __name((data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=", mask = (1 << bitsPerChar) - 1;
  let out = "", bits = 0, buffer = 0;
  for (let i = 0; i < data.length; ++i)
    for (buffer = buffer << 8 | data[i], bits += 8; bits > bitsPerChar; )
      bits -= bitsPerChar, out += alphabet2[mask & buffer >> bits];
  if (bits && (out += alphabet2[mask & buffer << bitsPerChar - bits]), pad)
    for (; out.length * bitsPerChar & 7; )
      out += "=";
  return out;
}, "encode$1"), rfc4648 = /* @__PURE__ */ __name(({ name, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => from({
  prefix: prefix2,
  name,
  encode(input2) {
    return encode$1(input2, alphabet2, bitsPerChar);
  },
  decode(input2) {
    return decode$2(input2, alphabet2, bitsPerChar, name);
  }
}), "rfc4648"), identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from(""), alphabetBytesToChars = alphabet.reduce((p2, c2, i) => (p2[i] = c2, p2), []), alphabetCharsToBytes = alphabet.reduce((p2, c2, i) => (p2[c2.codePointAt(0)] = i, p2), []);
function encode(data) {
  return data.reduce((p2, c2) => (p2 += alphabetBytesToChars[c2], p2), "");
}
__name(encode, "encode");
function decode$1(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0)
      throw new Error(`Non-base256emoji character: ${char2}`);
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode$1, "decode$1");
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode: decode$1
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name, prefix2, encode2, decode2) {
  return {
    name,
    prefix: prefix2,
    encoder: {
      name,
      prefix: prefix2,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
__name(createCodec, "createCodec");
const string = createCodec("utf8", "u", (buf) => "u" + new TextDecoder("utf8").decode(buf), (str) => new TextEncoder().encode(str.substring(1))), ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++)
    string2 += String.fromCharCode(buf[i]);
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++)
    buf[i] = str.charCodeAt(i);
  return buf;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3)
    throw new Error(`Unsupported encoding "${encoding}"`);
  return (encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array(globalThis.Buffer.from(string2, "utf-8")) : base3.decoder.decode(`${base3.prefix}${string2}`);
}
__name(fromString, "fromString");
function toString(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3)
    throw new Error(`Unsupported encoding "${encoding}"`);
  return (encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8") : base3.encoder.encode(array).substring(1);
}
__name(toString, "toString");
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++)
      (ar || !(i in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i)), ar[i] = from2[i]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}, BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version, os2) {
      this.name = name, this.version = version, this.os = os2, this.type = "browser";
    }
    return __name(BrowserInfo2, "BrowserInfo"), BrowserInfo2;
  }()
), NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return __name(NodeInfo2, "NodeInfo"), NodeInfo2;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version, os2, bot) {
      this.name = name, this.version = version, this.os = os2, this.bot = bot, this.type = "bot-device";
    }
    return __name(SearchBotDeviceInfo2, "SearchBotDeviceInfo"), SearchBotDeviceInfo2;
  }()
), BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return __name(BotInfo2, "BotInfo"), BotInfo2;
  }()
), ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return __name(ReactNativeInfo2, "ReactNativeInfo"), ReactNativeInfo2;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  return userAgent ? parseUserAgent(userAgent) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
__name(detect, "detect");
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a46) {
    var browser2 = _a46[0], regex = _a46[1];
    if (matched)
      return matched;
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, !1);
}
__name(matchUserAgent, "matchUserAgent");
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule)
    return null;
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot")
    return new BotInfo();
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  versionParts ? versionParts.length < REQUIRED_VERSION_PARTS && (versionParts = __spreadArray(__spreadArray([], versionParts, !0), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), !0)) : versionParts = [];
  var version = versionParts.join("."), os2 = detectOS(ua2), searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  return searchBotMatch && searchBotMatch[1] ? new SearchBotDeviceInfo(name, version, os2, searchBotMatch[1]) : new BrowserInfo(name, version, os2);
}
__name(parseUserAgent, "parseUserAgent");
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a46 = operatingSystemRules[ii2], os2 = _a46[0], regex = _a46[1], match2 = regex.exec(ua2);
    if (match2)
      return os2;
  }
  return null;
}
__name(detectOS, "detectOS");
function getNodeVersion() {
  var isNode2 = typeof process < "u" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
__name(getNodeVersion, "getNodeVersion");
function createVersionParts(count) {
  for (var output2 = [], ii2 = 0; ii2 < count; ii2++)
    output2.push("0");
  return output2;
}
__name(createVersionParts, "createVersionParts");
var cjs$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      b3.hasOwnProperty(p2) && (d3[p2] = b3[p2]);
  }, extendStatics(d2, b2);
}, "extendStatics");
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  __name(__, "__"), d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
__name(__extends, "__extends");
var __assign = /* @__PURE__ */ __name(function() {
  return __assign = Object.assign || /* @__PURE__ */ __name(function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        Object.prototype.hasOwnProperty.call(s, p2) && (t2[p2] = s[p2]);
    }
    return t2;
  }, "__assign"), __assign.apply(this, arguments);
}, "__assign");
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s)
    Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s[p2]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++)
      e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]) && (t2[p2[i]] = s[p2[i]]);
  return t2;
}
__name(__rest, "__rest");
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d2 = decorators[i]) && (r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
__name(__decorate, "__decorate");
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(__param, "__param");
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
__name(__metadata, "__metadata");
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return __name(adopt, "adopt"), new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step2(generator.throw(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    __name(rejected, "rejected");
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step2, "step"), step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    for (; _24; )
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2.return : op[0] ? y2.throw || ((t2 = y2.return) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        switch (y2 = 0, t2 && (op = [op[0] & 2, t2.value]), op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            return _24.label++, { value: op[1], done: !1 };
          case 5:
            _24.label++, y2 = op[1], op = [0];
            continue;
          case 7:
            op = _24.ops.pop(), _24.trys.pop();
            continue;
          default:
            if (t2 = _24.trys, !(t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1], t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2], _24.ops.push(op);
              break;
            }
            t2[2] && _24.ops.pop(), _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e2) {
        op = [6, e2], y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
__name(__generator, "__generator");
function __createBinding(o2, m2, k2, k22) {
  k22 === void 0 && (k22 = k2), o2[k22] = m2[k2];
}
__name(__createBinding, "__createBinding");
function __exportStar(m2, exports) {
  for (var p2 in m2)
    p2 !== "default" && !exports.hasOwnProperty(p2) && (exports[p2] = m2[p2]);
}
__name(__exportStar, "__exportStar");
function __values(o2) {
  var s = typeof Symbol == "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length == "number")
    return {
      next: function() {
        return o2 && i >= o2.length && (o2 = void 0), { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o2, n2) {
  var m2 = typeof Symbol == "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    for (; (n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done; )
      ar.push(r2.value);
  } catch (error3) {
    e2 = { error: error3 };
  } finally {
    try {
      r2 && !r2.done && (m2 = i.return) && m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
__name(__spread, "__spread");
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
__name(__spreadArrays, "__spreadArrays");
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    g2[n2] && (i[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    });
  }
  function resume(n2, v2) {
    try {
      step2(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step2(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    f2(v2), q2.shift(), q2.length && resume(q2[0][0], q2[0][1]);
  }
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
__name(__asyncDelegator, "__asyncDelegator");
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values == "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject2) {
        v2 = o2[n2](v2), settle(resolve, reject2, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject2, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject2);
  }
}
__name(__asyncValues, "__asyncValues");
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
__name(__makeTemplateObject, "__makeTemplateObject");
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null)
    for (var k2 in mod)
      Object.hasOwnProperty.call(mod, k2) && (result[k2] = mod[k2]);
  return result.default = mod, result;
}
__name(__importStar, "__importStar");
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
__name(__importDefault, "__importDefault");
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return privateMap.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to set private field on non-instance");
  return privateMap.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(!0);
      }, timeout);
    });
  }
  return __name(delay$1, "delay$1"), delay.delay = delay$1, delay;
}
__name(requireDelay, "requireDelay");
var convert = {}, constants = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
__name(requireMisc, "requireMisc");
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0, exports.ONE_SECOND = 1, exports.FIVE_SECONDS = 5, exports.TEN_SECONDS = 10, exports.THIRTY_SECONDS = 30, exports.SIXTY_SECONDS = 60, exports.ONE_MINUTE = exports.SIXTY_SECONDS, exports.FIVE_MINUTES = exports.ONE_MINUTE * 5, exports.TEN_MINUTES = exports.ONE_MINUTE * 10, exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30, exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60, exports.ONE_HOUR = exports.SIXTY_MINUTES, exports.THREE_HOURS = exports.ONE_HOUR * 3, exports.SIX_HOURS = exports.ONE_HOUR * 6, exports.TWELVE_HOURS = exports.ONE_HOUR * 12, exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24, exports.ONE_DAY = exports.TWENTY_FOUR_HOURS, exports.THREE_DAYS = exports.ONE_DAY * 3, exports.FIVE_DAYS = exports.ONE_DAY * 5, exports.SEVEN_DAYS = exports.ONE_DAY * 7, exports.THIRTY_DAYS = exports.ONE_DAY * 30, exports.ONE_WEEK = exports.SEVEN_DAYS, exports.TWO_WEEKS = exports.ONE_WEEK * 2, exports.THREE_WEEKS = exports.ONE_WEEK * 3, exports.FOUR_WEEKS = exports.ONE_WEEK * 4, exports.ONE_YEAR = exports.ONE_DAY * 365;
  }(time)), time;
}
__name(requireTime, "requireTime");
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireMisc(), exports), tslib_1.__exportStar(requireTime(), exports);
  }(constants)), constants;
}
__name(requireConstants, "requireConstants");
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  __name(toMiliseconds, "toMiliseconds"), convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  return __name(fromMiliseconds, "fromMiliseconds"), convert.fromMiliseconds = fromMiliseconds, convert;
}
__name(requireConvert, "requireConvert");
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireDelay(), exports), tslib_1.__exportStar(requireConvert(), exports);
  }(utils)), utils;
}
__name(requireUtils, "requireUtils");
var watch$1 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.Watch = void 0;
  const _Watch = class _Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label2) {
      if (this.timestamps.has(label2))
        throw new Error(`Watch already started for label: ${label2}`);
      this.timestamps.set(label2, { started: Date.now() });
    }
    stop(label2) {
      const timestamp = this.get(label2);
      if (typeof timestamp.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${label2}`);
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label2, { started: timestamp.started, elapsed });
    }
    get(label2) {
      const timestamp = this.timestamps.get(label2);
      if (typeof timestamp > "u")
        throw new Error(`No timestamp found for label: ${label2}`);
      return timestamp;
    }
    elapsed(label2) {
      const timestamp = this.get(label2);
      return timestamp.elapsed || Date.now() - timestamp.started;
    }
  };
  __name(_Watch, "Watch");
  let Watch = _Watch;
  return watch$1.Watch = Watch, watch$1.default = Watch, watch$1;
}
__name(requireWatch$1, "requireWatch$1");
var types = {}, watch = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1, Object.defineProperty(watch, "__esModule", { value: !0 }), watch.IWatch = void 0;
  const _IWatch = class _IWatch {
  };
  __name(_IWatch, "IWatch");
  let IWatch = _IWatch;
  return watch.IWatch = IWatch, watch;
}
__name(requireWatch, "requireWatch");
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 }), require$$0.__exportStar(requireWatch(), exports);
  }(types)), types;
}
__name(requireTypes, "requireTypes");
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  const tslib_1 = require$$0;
  tslib_1.__exportStar(requireUtils(), exports), tslib_1.__exportStar(requireWatch$1(), exports), tslib_1.__exportStar(requireTypes(), exports), tslib_1.__exportStar(requireConstants(), exports);
})(cjs$2);
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0;
function getFromWindow(name) {
  let res;
  return typeof window < "u" && typeof window[name] < "u" && (res = window[name]), res;
}
__name(getFromWindow, "getFromWindow");
cjs$1.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
  const res = getFromWindow(name);
  if (!res)
    throw new Error(`${name} is not defined in Window`);
  return res;
}
__name(getFromWindowOrThrow, "getFromWindowOrThrow");
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
__name(getDocumentOrThrow, "getDocumentOrThrow");
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
__name(getDocument, "getDocument");
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
__name(getNavigatorOrThrow, "getNavigatorOrThrow");
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
__name(getNavigator, "getNavigator");
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
__name(getLocationOrThrow, "getLocationOrThrow");
cjs$1.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
__name(getLocation, "getLocation");
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
__name(getCryptoOrThrow, "getCryptoOrThrow");
cjs$1.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
__name(getCrypto, "getCrypto");
cjs$1.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
__name(getLocalStorageOrThrow, "getLocalStorageOrThrow");
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
__name(getLocalStorage, "getLocalStorage");
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
  let doc, loc;
  try {
    doc = window_getters_1.getDocumentOrThrow(), loc = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link"), icons2 = [];
    for (let i = 0; i < links.length; i++) {
      const link2 = links[i], rel = link2.getAttribute("rel");
      if (rel && rel.toLowerCase().indexOf("icon") > -1) {
        const href = link2.getAttribute("href");
        if (href)
          if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
            let absoluteHref = loc.protocol + "//" + loc.host;
            if (href.indexOf("/") === 0)
              absoluteHref += href;
            else {
              const path = loc.pathname.split("/");
              path.pop();
              const finalPath = path.join("/");
              absoluteHref += finalPath + "/" + href;
            }
            icons2.push(absoluteHref);
          } else if (href.indexOf("//") === 0) {
            const absoluteUrl = loc.protocol + href;
            icons2.push(absoluteUrl);
          } else
            icons2.push(href);
      }
    }
    return icons2;
  }
  __name(getIcons, "getIcons");
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i = 0; i < metaTags.length; i++) {
      const tag = metaTags[i], attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => attr ? args.includes(attr) : !1);
      if (attributes.length && attributes) {
        const content2 = tag.getAttribute("content");
        if (content2)
          return content2;
      }
    }
    return "";
  }
  __name(getWindowMetadataOfAny, "getWindowMetadataOfAny");
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    return name2 || (name2 = doc.title), name2;
  }
  __name(getName, "getName");
  function getDescription() {
    return getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
  }
  __name(getDescription, "getDescription");
  const name = getName(), description2 = getDescription(), url = loc.origin, icons = getIcons();
  return {
    description: description2,
    url,
    icons,
    name
  };
}
__name(getWindowMetadata, "getWindowMetadata");
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = /* @__PURE__ */ __name((str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`), "strictUriEncode"), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components2, split) {
  try {
    return [decodeURIComponent(components2.join(""))];
  } catch {
  }
  if (components2.length === 1)
    return components2;
  split = split || 1;
  var left2 = components2.slice(0, split), right = components2.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right));
}
__name(decodeComponents, "decodeComponents");
function decode(input2) {
  try {
    return decodeURIComponent(input2);
  } catch {
    for (var tokens = input2.match(singleMatcher) || [], i = 1; i < tokens.length; i++)
      input2 = decodeComponents(tokens, i).join(""), tokens = input2.match(singleMatcher) || [];
    return input2;
  }
}
__name(decode, "decode");
function customDecodeURIComponent(input2) {
  for (var replaceMap = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, match2 = multiMatcher.exec(input2); match2; ) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch {
      var result = decode(match2[0]);
      result !== match2[0] && (replaceMap[match2[0]] = result);
    }
    match2 = multiMatcher.exec(input2);
  }
  replaceMap["%C2"] = "";
  for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
    var key = entries[i];
    input2 = input2.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input2;
}
__name(customDecodeURIComponent, "customDecodeURIComponent");
var decodeUriComponent = /* @__PURE__ */ __name(function(encodedURI) {
  if (typeof encodedURI != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  try {
    return encodedURI = encodedURI.replace(/\+/g, " "), decodeURIComponent(encodedURI);
  } catch {
    return customDecodeURIComponent(encodedURI);
  }
}, "decodeUriComponent"), splitOnFirst = /* @__PURE__ */ __name((string2, separator2) => {
  if (!(typeof string2 == "string" && typeof separator2 == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (separator2 === "")
    return [string2];
  const separatorIndex = string2.indexOf(separator2);
  return separatorIndex === -1 ? [string2] : [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator2.length)
  ];
}, "splitOnFirst"), filterObj = /* @__PURE__ */ __name(function(obj, predicate) {
  for (var ret = {}, keys = Object.keys(obj), isArr = Array.isArray(predicate), i = 0; i < keys.length; i++) {
    var key = keys[i], val = obj[key];
    (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) && (ret[key] = val);
  }
  return ret;
}, "filterObj");
(function(exports) {
  const strictUriEncode$1 = strictUriEncode, decodeComponent = decodeUriComponent, splitOnFirst$1 = splitOnFirst, filterObject = filterObj, isNullOrUndefined = /* @__PURE__ */ __name((value) => value == null, "isNullOrUndefined"), encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options2) {
    switch (options2.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index = result.length;
          return value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), "[", index, "]"].join("")] : [
            ...result,
            [encode2(key, options2), "[", encode2(index, options2), "]=", encode2(value, options2)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), "[]"].join("")] : [...result, [encode2(key, options2), "[]=", encode2(value, options2)].join("")];
      case "colon-list-separator":
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), ":list="].join("")] : [...result, [encode2(key, options2), ":list=", encode2(value, options2)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : (value = value === null ? "" : value, result.length === 0 ? [[encode2(key, options2), keyValueSep, encode2(value, options2)].join("")] : [[result, encode2(value, options2)].join(options2.arrayFormatSeparator)]);
      }
      default:
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, encode2(key, options2)] : [...result, [encode2(key, options2), "=", encode2(value, options2)].join("")];
    }
  }
  __name(encoderForArrayFormat, "encoderForArrayFormat");
  function parserForArrayFormat(options2) {
    let result;
    switch (options2.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          if (result = /\[(\d*)\]$/.exec(key), key = key.replace(/\[\d*\]$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] === void 0 && (accumulator[key] = {}), accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          if (result = /(\[\])$/.exec(key), key = key.replace(/\[\]$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          if (result = /(:list)$/.exec(key), key = key.replace(/:list$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value == "string" && value.includes(options2.arrayFormatSeparator), isEncodedArray = typeof value == "string" && !isArray2 && decode2(value, options2).includes(options2.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options2) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2)) : value === null ? value : decode2(value, options2);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          if (key = key.replace(/\[\]$/, ""), !isArray2) {
            accumulator[key] = value && decode2(value, options2);
            return;
          }
          const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  __name(parserForArrayFormat, "parserForArrayFormat");
  function validateArrayFormatSeparator(value) {
    if (typeof value != "string" || value.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  __name(validateArrayFormatSeparator, "validateArrayFormatSeparator");
  function encode2(value, options2) {
    return options2.encode ? options2.strict ? strictUriEncode$1(value) : encodeURIComponent(value) : value;
  }
  __name(encode2, "encode");
  function decode2(value, options2) {
    return options2.decode ? decodeComponent(value) : value;
  }
  __name(decode2, "decode");
  function keysSorter(input2) {
    return Array.isArray(input2) ? input2.sort() : typeof input2 == "object" ? keysSorter(Object.keys(input2)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input2[key]) : input2;
  }
  __name(keysSorter, "keysSorter");
  function removeHash(input2) {
    const hashStart = input2.indexOf("#");
    return hashStart !== -1 && (input2 = input2.slice(0, hashStart)), input2;
  }
  __name(removeHash, "removeHash");
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    return hashStart !== -1 && (hash2 = url.slice(hashStart)), hash2;
  }
  __name(getHash, "getHash");
  function extract(input2) {
    input2 = removeHash(input2);
    const queryStart = input2.indexOf("?");
    return queryStart === -1 ? "" : input2.slice(queryStart + 1);
  }
  __name(extract, "extract");
  function parseValue(value, options2) {
    return options2.parseNumbers && !Number.isNaN(Number(value)) && typeof value == "string" && value.trim() !== "" ? value = Number(value) : options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false") && (value = value.toLowerCase() === "true"), value;
  }
  __name(parseValue, "parseValue");
  function parse2(query, options2) {
    options2 = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, options2), validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options2), ret = /* @__PURE__ */ Object.create(null);
    if (typeof query != "string" || (query = query.trim().replace(/^[?#&]/, ""), !query))
      return ret;
    for (const param of query.split("&")) {
      if (param === "")
        continue;
      let [key, value] = splitOnFirst$1(options2.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode2(value, options2), formatter(decode2(key, options2), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value == "object" && value !== null)
        for (const k2 of Object.keys(value))
          value[k2] = parseValue(value[k2], options2);
      else
        ret[key] = parseValue(value, options2);
    }
    return options2.sort === !1 ? ret : (options2.sort === !0 ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key) => {
      const value = ret[key];
      return value && typeof value == "object" && !Array.isArray(value) ? result[key] = keysSorter(value) : result[key] = value, result;
    }, /* @__PURE__ */ Object.create(null));
  }
  __name(parse2, "parse"), exports.extract = extract, exports.parse = parse2, exports.stringify = (object, options2) => {
    if (!object)
      return "";
    options2 = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options2), validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const shouldFilter = /* @__PURE__ */ __name((key) => options2.skipNull && isNullOrUndefined(object[key]) || options2.skipEmptyString && object[key] === "", "shouldFilter"), formatter = encoderForArrayFormat(options2), objectCopy = {};
    for (const key of Object.keys(object))
      shouldFilter(key) || (objectCopy[key] = object[key]);
    const keys = Object.keys(objectCopy);
    return options2.sort !== !1 && keys.sort(options2.sort), keys.map((key) => {
      const value = object[key];
      return value === void 0 ? "" : value === null ? encode2(key, options2) : Array.isArray(value) ? value.length === 0 && options2.arrayFormat === "bracket-separator" ? encode2(key, options2) + "[]" : value.reduce(formatter(key), []).join("&") : encode2(key, options2) + "=" + encode2(value, options2);
    }).filter((x2) => x2.length > 0).join("&");
  }, exports.parseUrl = (url, options2) => {
    options2 = Object.assign({
      decode: !0
    }, options2);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options2)
      },
      options2 && options2.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options2) } : {}
    );
  }, exports.stringifyUrl = (object, options2) => {
    options2 = Object.assign({
      encode: !0,
      strict: !0,
      [encodeFragmentIdentifier]: !0
    }, options2);
    const url = removeHash(object.url).split("?")[0] || "", queryFromUrl = exports.extract(object.url), parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: !1 }), query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options2);
    queryString2 && (queryString2 = `?${queryString2}`);
    let hash2 = getHash(object.url);
    return object.fragmentIdentifier && (hash2 = `#${options2[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`), `${url}${queryString2}${hash2}`;
  }, exports.pick = (input2, filter, options2) => {
    options2 = Object.assign({
      parseFragmentIdentifier: !0,
      [encodeFragmentIdentifier]: !1
    }, options2);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input2, options2);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options2);
  }, exports.exclude = (input2, filter, options2) => {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input2, exclusionFilter, options2);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function L(e2, n2) {
  return e2.includes(":") ? [e2] : n2.chains || [];
}
__name(L, "L");
const J = "base10", p = "base16", F = "base64pad", H = "utf8", Q = 0, _23 = 1, Dn = 0, Ie = 1, Z = 12, X = 32;
function kn() {
  const e2 = x25519.generateKeyPair();
  return { privateKey: toString(e2.secretKey, p), publicKey: toString(e2.publicKey, p) };
}
__name(kn, "kn");
function Vn() {
  const e2 = random.randomBytes(X);
  return toString(e2, p);
}
__name(Vn, "Vn");
function Mn(e2, n2) {
  const t2 = x25519.sharedKey(fromString(e2, p), fromString(n2, p), !0), r2 = new HKDF_1(sha256.SHA256, t2).expand(X);
  return toString(r2, p);
}
__name(Mn, "Mn");
function Kn(e2) {
  const n2 = sha256.hash(fromString(e2, p));
  return toString(n2, p);
}
__name(Kn, "Kn");
function Ln(e2) {
  const n2 = sha256.hash(fromString(e2, H));
  return toString(n2, p);
}
__name(Ln, "Ln");
function Pe(e2) {
  return fromString(`${e2}`, J);
}
__name(Pe, "Pe");
function $(e2) {
  return Number(toString(e2, J));
}
__name($, "$");
function xn(e2) {
  const n2 = Pe(typeof e2.type < "u" ? e2.type : Q);
  if ($(n2) === _23 && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e2.senderPublicKey < "u" ? fromString(e2.senderPublicKey, p) : void 0, r2 = typeof e2.iv < "u" ? fromString(e2.iv, p) : random.randomBytes(Z), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)).seal(r2, fromString(e2.message, H));
  return Re({ type: n2, sealed: o2, iv: r2, senderPublicKey: t2 });
}
__name(xn, "xn");
function Fn(e2) {
  const n2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)), { sealed: t2, iv: r2 } = ee(e2.encoded), o2 = n2.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, H);
}
__name(Fn, "Fn");
function Re(e2) {
  if ($(e2.type) === _23) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), F);
  }
  return toString(concat([e2.type, e2.iv, e2.sealed]), F);
}
__name(Re, "Re");
function ee(e2) {
  const n2 = fromString(e2, F), t2 = n2.slice(Dn, Ie), r2 = Ie;
  if ($(t2) === _23) {
    const d2 = r2 + X, l2 = d2 + Z, c2 = n2.slice(r2, d2), u2 = n2.slice(d2, l2), a2 = n2.slice(l2);
    return { type: t2, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o2 = r2 + Z, s = n2.slice(r2, o2), i = n2.slice(o2);
  return { type: t2, sealed: i, iv: s };
}
__name(ee, "ee");
function Hn(e2, n2) {
  const t2 = ee(e2);
  return Te({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
__name(Hn, "Hn");
function Te(e2) {
  const n2 = (e2 == null ? void 0 : e2.type) || Q;
  if (n2 === _23) {
    if (typeof (e2 == null ? void 0 : e2.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e2 == null ? void 0 : e2.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e2 == null ? void 0 : e2.senderPublicKey, receiverPublicKey: e2 == null ? void 0 : e2.receiverPublicKey };
}
__name(Te, "Te");
function qn(e2) {
  return e2.type === _23 && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
__name(qn, "qn");
var Bn = Object.defineProperty, Ae = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn = Object.prototype.propertyIsEnumerable, Ue = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? Bn(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "Ue"), _e = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Gn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  if (Ae)
    for (var t2 of Ae(n2))
      Wn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  return e2;
}, "_e");
const Ce = "ReactNative", m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, $e = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
__name(te, "te");
function C() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce;
}
__name(C, "C");
function D() {
  return !te() && !!getNavigator_1();
}
__name(D, "D");
function T() {
  return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
__name(T, "T");
function Jn() {
  var e2;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e2 = global.Application) == null ? void 0 : e2.applicationId : void 0;
  } catch {
    return;
  }
}
__name(Jn, "Jn");
function De(e2, n2) {
  let t2 = queryString.parse(e2);
  return t2 = _e(_e({}, t2), n2), e2 = queryString.stringify(t2), e2;
}
__name(De, "De");
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
__name(Qn, "Qn");
function ke() {
  if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n2 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n2, e2.name, e2.version].join("-") : [n2, e2.version].join("-");
}
__name(ke, "ke");
function Ve() {
  var e2;
  const n2 = T();
  return n2 === m.browser ? [n2, ((e2 = getLocation_1()) == null ? void 0 : e2.host) || "unknown"].join(":") : n2;
}
__name(Ve, "Ve");
function Me(e2, n2, t2) {
  const r2 = ke(), o2 = Ve();
  return [[e2, n2].join("-"), [$e, t2].join("-"), r2, o2].join("/");
}
__name(Me, "Me");
function Xn({ protocol: e2, version: n2, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i, bundleId: d2 }) {
  const l2 = t2.split("?"), c2 = Me(e2, n2, r2), u2 = { auth: o2, ua: c2, projectId: s, useOnCloseEvent: i || void 0, origin: d2 || void 0 }, a2 = De(l2[1] || "", u2);
  return l2[0] + "?" + a2;
}
__name(Xn, "Xn");
function O(e2, n2) {
  return e2.filter((t2) => n2.includes(t2)).length === e2.length;
}
__name(O, "O");
function rt(e2) {
  return Object.fromEntries(e2.entries());
}
__name(rt, "rt");
function ot(e2) {
  return new Map(Object.entries(e2));
}
__name(ot, "ot");
function at(e2 = cjs$2.FIVE_MINUTES, n2) {
  const t2 = cjs$2.toMiliseconds(e2 || cjs$2.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i) => {
    s && r2 && (clearTimeout(s), r2(i));
  }, reject: (i) => {
    s && o2 && (clearTimeout(s), o2(i));
  }, done: () => new Promise((i, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t2), r2 = i, o2 = d2;
  }) };
}
__name(at, "at");
function ut(e2, n2, t2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(t2)), n2);
    try {
      const i = await e2;
      r2(i);
    } catch (i) {
      o2(i);
    }
    clearTimeout(s);
  });
}
__name(ut, "ut");
function re(e2, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e2}:`))
    return n2;
  if (e2.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
__name(re, "re");
function lt(e2) {
  return re("topic", e2);
}
__name(lt, "lt");
function dt(e2) {
  return re("id", e2);
}
__name(dt, "dt");
function ft(e2) {
  const [n2, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
__name(ft, "ft");
function pt(e2, n2) {
  return cjs$2.fromMiliseconds((n2 || Date.now()) + cjs$2.toMiliseconds(e2));
}
__name(pt, "pt");
function mt(e2) {
  return Date.now() >= cjs$2.toMiliseconds(e2);
}
__name(mt, "mt");
function yt(e2, n2) {
  return `${e2}${n2 ? `:${n2}` : ""}`;
}
__name(yt, "yt");
function S(e2 = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e2, ...n2])];
}
__name(S, "S");
async function ht({ id: e2, topic: n2, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2 == null ? void 0 : r2.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e2}&sessionTopic=${n2}`, i = T();
    i === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r2) {
    console.error(r2);
  }
}
__name(ht, "ht");
async function gt(e2, n2) {
  try {
    return await e2.getItem(n2) || (D() ? localStorage.getItem(n2) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
__name(gt, "gt");
const Fe = "irn";
function vt(e2) {
  return (e2 == null ? void 0 : e2.relay) || { protocol: Fe };
}
__name(vt, "vt");
function Et(e2) {
  const n2 = RELAY_JSONRPC[e2];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n2;
}
__name(Et, "Et");
var bt = Object.defineProperty, He = Object.getOwnPropertySymbols, Nt = Object.prototype.hasOwnProperty, Ot = Object.prototype.propertyIsEnumerable, qe = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? bt(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "qe"), St = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Nt.call(n2, t2) && qe(e2, t2, n2[t2]);
  if (He)
    for (var t2 of He(n2))
      Ot.call(n2, t2) && qe(e2, t2, n2[t2]);
  return e2;
}, "St");
function Be(e2, n2 = "-") {
  const t2 = {}, r2 = "relay" + n2;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i = e2[o2];
      t2[s] = i;
    }
  }), t2;
}
__name(Be, "Be");
function wt(e2) {
  e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
  const n2 = e2.indexOf(":"), t2 = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r2 = e2.substring(0, n2), o2 = e2.substring(n2 + 1, t2).split("@"), s = typeof t2 < "u" ? e2.substring(t2) : "", i = queryString.parse(s);
  return { protocol: r2, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i.symKey, relay: Be(i) };
}
__name(wt, "wt");
function Ge(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
__name(Ge, "Ge");
function We(e2, n2 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e2).forEach((o2) => {
    const s = t2 + n2 + o2;
    e2[o2] && (r2[s] = e2[o2]);
  }), r2;
}
__name(We, "We");
function It(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + queryString.stringify(St({ symKey: e2.symKey }, We(e2.relay)));
}
__name(It, "It");
var Pt = Object.defineProperty, Rt = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, ze = Object.getOwnPropertySymbols, At = Object.prototype.hasOwnProperty, Ut = Object.prototype.propertyIsEnumerable, Ye = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? Pt(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "Ye"), _t = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    At.call(n2, t2) && Ye(e2, t2, n2[t2]);
  if (ze)
    for (var t2 of ze(n2))
      Ut.call(n2, t2) && Ye(e2, t2, n2[t2]);
  return e2;
}, "_t"), Ct = /* @__PURE__ */ __name((e2, n2) => Rt(e2, Tt(n2)), "Ct");
function A(e2) {
  const n2 = [];
  return e2.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n2.push(`${r2}:${o2}`);
  }), n2;
}
__name(A, "A");
function Je(e2) {
  const n2 = [];
  return Object.values(e2).forEach((t2) => {
    n2.push(...A(t2.accounts));
  }), n2;
}
__name(Je, "Je");
function Qe(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.methods);
  }), t2;
}
__name(Qe, "Qe");
function Ze(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.events);
  }), t2;
}
__name(Ze, "Ze");
function jt(e2, n2) {
  const t2 = un(e2, n2);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s] of Object.entries(e2))
    r2[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i) => `${i.split(":")[0]}:${i.split(":")[1]}`) };
  return r2;
}
__name(jt, "jt");
function $t(e2) {
  const { proposal: { requiredNamespaces: n2, optionalNamespaces: t2 = {} }, supportedNamespaces: r2 } = e2, o2 = se(n2), s = se(t2), i = {};
  Object.keys(r2).forEach((c2) => {
    const u2 = r2[c2].chains, a2 = r2[c2].methods, b2 = r2[c2].events, I2 = r2[c2].accounts;
    u2.forEach((y2) => {
      if (!I2.some((f2) => f2.includes(y2)))
        throw new Error(`No accounts provided for chain ${y2} in namespace ${c2}`);
    }), i[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  });
  const d2 = dn(n2, i, "approve()");
  if (d2)
    throw new Error(d2.message);
  const l2 = {};
  return !Object.keys(n2).length && !Object.keys(t2).length ? i : (Object.keys(o2).forEach((c2) => {
    const u2 = r2[c2].chains.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.chains) == null ? void 0 : g2.includes(y2);
    }), a2 = r2[c2].methods.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.methods) == null ? void 0 : g2.includes(y2);
    }), b2 = r2[c2].events.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.events) == null ? void 0 : g2.includes(y2);
    }), I2 = u2.map((y2) => r2[c2].accounts.filter((f2) => f2.includes(`${y2}:`))).flat();
    l2[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  }), Object.keys(s).forEach((c2) => {
    var u2, a2, b2, I2, y2, f2;
    if (!r2[c2])
      return;
    const g2 = (a2 = (u2 = s[c2]) == null ? void 0 : u2.chains) == null ? void 0 : a2.filter((P2) => r2[c2].chains.includes(P2)), vn2 = r2[c2].methods.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.methods) == null ? void 0 : j2.includes(P2);
    }), En2 = r2[c2].events.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.events) == null ? void 0 : j2.includes(P2);
    }), bn2 = g2 == null ? void 0 : g2.map((P2) => r2[c2].accounts.filter((R2) => R2.includes(`${P2}:`))).flat();
    l2[c2] = { chains: S((b2 = l2[c2]) == null ? void 0 : b2.chains, g2), methods: S((I2 = l2[c2]) == null ? void 0 : I2.methods, vn2), events: S((y2 = l2[c2]) == null ? void 0 : y2.events, En2), accounts: S((f2 = l2[c2]) == null ? void 0 : f2.accounts, bn2) };
  }), l2);
}
__name($t, "$t");
function oe(e2) {
  return e2.includes(":");
}
__name(oe, "oe");
function Xe(e2) {
  return oe(e2) ? e2.split(":")[0] : e2;
}
__name(Xe, "Xe");
function se(e2) {
  var n2, t2, r2;
  const o2 = {};
  if (!B(e2))
    return o2;
  for (const [s, i] of Object.entries(e2)) {
    const d2 = oe(s) ? [s] : i.chains, l2 = i.methods || [], c2 = i.events || [], u2 = Xe(s);
    o2[u2] = Ct(_t({}, o2[u2]), { chains: S(d2, (n2 = o2[u2]) == null ? void 0 : n2.chains), methods: S(l2, (t2 = o2[u2]) == null ? void 0 : t2.methods), events: S(c2, (r2 = o2[u2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
__name(se, "se");
const en = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, nn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e2, n2) {
  const { message: t2, code: r2 } = nn[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
__name(N, "N");
function U(e2, n2) {
  const { message: t2, code: r2 } = en[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
__name(U, "U");
function k(e2, n2) {
  return Array.isArray(e2) ? typeof n2 < "u" && e2.length ? e2.every(n2) : !0 : !1;
}
__name(k, "k");
function B(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
__name(B, "B");
function w(e2) {
  return typeof e2 > "u";
}
__name(w, "w");
function h(e2, n2) {
  return n2 && w(e2) ? !0 : typeof e2 == "string" && !!e2.trim().length;
}
__name(h, "h");
function G(e2, n2) {
  return n2 && w(e2) ? !0 : typeof e2 == "number" && !isNaN(e2);
}
__name(G, "G");
function Dt(e2, n2) {
  const { requiredNamespaces: t2 } = n2, r2 = Object.keys(e2.namespaces), o2 = Object.keys(t2);
  let s = !0;
  return O(o2, r2) ? (r2.forEach((i) => {
    const { accounts: d2, methods: l2, events: c2 } = e2.namespaces[i], u2 = A(d2), a2 = t2[i];
    (!O(L(i, a2), u2) || !O(a2.methods, l2) || !O(a2.events, c2)) && (s = !1);
  }), s) : !1;
}
__name(Dt, "Dt");
function V(e2) {
  return h(e2, !1) && e2.includes(":") ? e2.split(":").length === 2 : !1;
}
__name(V, "V");
function tn(e2) {
  if (h(e2, !1) && e2.includes(":")) {
    const n2 = e2.split(":");
    if (n2.length === 3) {
      const t2 = n2[0] + ":" + n2[1];
      return !!n2[2] && V(t2);
    }
  }
  return !1;
}
__name(tn, "tn");
function kt$1(e2) {
  if (h(e2, !1))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return !1;
    }
  return !1;
}
__name(kt$1, "kt$1");
function Vt(e2) {
  var n2;
  return (n2 = e2 == null ? void 0 : e2.proposer) == null ? void 0 : n2.publicKey;
}
__name(Vt, "Vt");
function Mt$1(e2) {
  return e2 == null ? void 0 : e2.topic;
}
__name(Mt$1, "Mt$1");
function Kt(e2, n2) {
  let t2 = null;
  return h(e2 == null ? void 0 : e2.publicKey, !1) || (t2 = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t2;
}
__name(Kt, "Kt");
function ie(e2) {
  let n2 = !0;
  return k(e2) ? e2.length && (n2 = e2.every((t2) => h(t2, !1))) : n2 = !1, n2;
}
__name(ie, "ie");
function rn(e2, n2, t2) {
  let r2 = null;
  return k(n2) && n2.length ? n2.forEach((o2) => {
    r2 || V(o2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V(e2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
__name(rn, "rn");
function on(e2, n2, t2) {
  let r2 = null;
  return Object.entries(e2).forEach(([o2, s]) => {
    if (r2)
      return;
    const i = rn(o2, L(o2, s), `${n2} ${t2}`);
    i && (r2 = i);
  }), r2;
}
__name(on, "on");
function sn(e2, n2) {
  let t2 = null;
  return k(e2) ? e2.forEach((r2) => {
    t2 || tn(r2) || (t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
__name(sn, "sn");
function cn(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = sn(r2 == null ? void 0 : r2.accounts, `${n2} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
__name(cn, "cn");
function an(e2, n2) {
  let t2 = null;
  return ie(e2 == null ? void 0 : e2.methods) ? ie(e2 == null ? void 0 : e2.events) || (t2 = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t2 = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t2;
}
__name(an, "an");
function ce(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = an(r2, `${n2}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
__name(ce, "ce");
function Lt(e2, n2, t2) {
  let r2 = null;
  if (e2 && B(e2)) {
    const o2 = ce(e2, n2);
    o2 && (r2 = o2);
    const s = on(e2, n2, t2);
    s && (r2 = s);
  } else
    r2 = N("MISSING_OR_INVALID", `${n2}, ${t2} should be an object with data`);
  return r2;
}
__name(Lt, "Lt");
function un(e2, n2) {
  let t2 = null;
  if (e2 && B(e2)) {
    const r2 = ce(e2, n2);
    r2 && (t2 = r2);
    const o2 = cn(e2, n2);
    o2 && (t2 = o2);
  } else
    t2 = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t2;
}
__name(un, "un");
function ln(e2) {
  return h(e2.protocol, !0);
}
__name(ln, "ln");
function xt(e2, n2) {
  let t2 = !1;
  return n2 && !e2 ? t2 = !0 : e2 && k(e2) && e2.length && e2.forEach((r2) => {
    t2 = ln(r2);
  }), t2;
}
__name(xt, "xt");
function Ft(e2) {
  return typeof e2 == "number";
}
__name(Ft, "Ft");
function Ht(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
__name(Ht, "Ht");
function qt(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G(e2.code, !1) || !e2.message || !h(e2.message, !1));
}
__name(qt, "qt");
function Bt(e2) {
  return !(w(e2) || !h(e2.method, !1));
}
__name(Bt, "Bt");
function Gt(e2) {
  return !(w(e2) || w(e2.result) && w(e2.error) || !G(e2.id, !1) || !h(e2.jsonrpc, !1));
}
__name(Gt, "Gt");
function Wt(e2) {
  return !(w(e2) || !h(e2.name, !1));
}
__name(Wt, "Wt");
function zt(e2, n2) {
  return !(!V(n2) || !Je(e2).includes(n2));
}
__name(zt, "zt");
function Yt(e2, n2, t2) {
  return h(t2, !1) ? Qe(e2, n2).includes(t2) : !1;
}
__name(Yt, "Yt");
function Jt(e2, n2, t2) {
  return h(t2, !1) ? Ze(e2, n2).includes(t2) : !1;
}
__name(Jt, "Jt");
function dn(e2, n2, t2) {
  let r2 = null;
  const o2 = Qt(e2), s = Zt(n2), i = Object.keys(o2), d2 = Object.keys(s), l2 = fn(Object.keys(e2)), c2 = fn(Object.keys(n2)), u2 = l2.filter((a2) => !c2.includes(a2));
  return u2.length && (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i, d2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b2 = A(n2[a2].accounts);
    b2.includes(a2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b2.toString()}`));
  }), i.forEach((a2) => {
    r2 || (O(o2[a2].methods, s[a2].methods) ? O(o2[a2].events, s[a2].events) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
__name(dn, "dn");
function Qt(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    var r2;
    t2.includes(":") ? n2[t2] = e2[t2] : (r2 = e2[t2].chains) == null || r2.forEach((o2) => {
      n2[o2] = { methods: e2[t2].methods, events: e2[t2].events };
    });
  }), n2;
}
__name(Qt, "Qt");
function fn(e2) {
  return [...new Set(e2.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
__name(fn, "fn");
function Zt(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    if (t2.includes(":"))
      n2[t2] = e2[t2];
    else {
      const r2 = A(e2[t2].accounts);
      r2 == null || r2.forEach((o2) => {
        n2[o2] = { accounts: e2[t2].accounts.filter((s) => s.includes(`${o2}:`)), methods: e2[t2].methods, events: e2[t2].events };
      });
    }
  }), n2;
}
__name(Zt, "Zt");
function Xt(e2, n2) {
  return G(e2, !1) && e2 <= n2.max && e2 >= n2.min;
}
__name(Xt, "Xt");
function er() {
  const e2 = T();
  return new Promise((n2) => {
    switch (e2) {
      case m.browser:
        n2(pn());
        break;
      case m.reactNative:
        n2(mn());
        break;
      case m.node:
        n2(yn());
        break;
      default:
        n2(!0);
    }
  });
}
__name(er, "er");
function pn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
__name(pn, "pn");
async function mn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e2 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e2 == null ? void 0 : e2.isConnected;
  }
  return !0;
}
__name(mn, "mn");
function yn() {
  return !0;
}
__name(yn, "yn");
function nr(e2) {
  switch (T()) {
    case m.browser:
      hn(e2);
      break;
    case m.reactNative:
      gn(e2);
      break;
  }
}
__name(nr, "nr");
function hn(e2) {
  !C() && D() && (window.addEventListener("online", () => e2(!0)), window.addEventListener("offline", () => e2(!1)));
}
__name(hn, "hn");
function gn(e2) {
  C() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((n2) => e2(n2 == null ? void 0 : n2.isConnected)));
}
__name(gn, "gn");
const ae = {}, _tr = class _tr {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t2) {
    ae[n2] = t2;
  }
  static delete(n2) {
    delete ae[n2];
  }
};
__name(_tr, "tr");
let tr = _tr;
const buttonsContainer = "_buttonsContainer_yg3s8_1", container$2 = "_container_yg3s8_7", connectionRequest = "_connectionRequest_yg3s8_12", receiveAddress$2 = "_receiveAddress_yg3s8_16", pairingDetailContainer = "_pairingDetailContainer_yg3s8_21", metadata = "_metadata_yg3s8_32", styles$9 = {
  buttonsContainer,
  container: container$2,
  connectionRequest,
  receiveAddress: receiveAddress$2,
  pairingDetailContainer,
  metadata
}, PairingContainer = /* @__PURE__ */ __name(({ pairingMetadata }) => {
  const { name, description: description2, url, icons } = pairingMetadata, hasIcon = icons && icons.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.pairingDetailContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: description2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: url })
    ] }),
    hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icons[0], alt: "logo" })
  ] });
}, "PairingContainer"), WCIncomingPairing = /* @__PURE__ */ __name(({
  currentProposal,
  pairingMetadata,
  receiveAddress: receiveAddress2,
  onReject,
  onApprove
}) => {
  const [pairingLoading, setPairingLoading] = reactExports.useState(!1), { web3wallet } = reactExports.useContext(WCWeb3WalletContext), { t: t2 } = useTranslation(), handleApprovePairing = /* @__PURE__ */ __name(async () => {
    setPairingLoading(!0);
    try {
      const { id: id2, params } = currentProposal, { requiredNamespaces } = params, eipList = Object.values(requiredNamespaces), accounts = eipList.flatMap((eip) => {
        var _a46;
        return ((_a46 = eip.chains) == null ? void 0 : _a46.map((chain) => `${chain}:${receiveAddress2}`)) || [];
      }), chains = eipList.flatMap(
        (proposal) => proposal.chains ? proposal.chains.filter((chain) => Object.keys(SUPPORTED_CHAINS).includes(chain)) : []
      ), namespaces = $t({
        proposal: params,
        supportedNamespaces: {
          eip155: {
            chains,
            methods: ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "personal_sign", "eth_signTypedData", "eth_signTypedData_v4"],
            events: ["accountsChanged", "chainChanged"],
            accounts
          }
        }
      });
      await (web3wallet == null ? void 0 : web3wallet.approveSession({
        id: id2,
        namespaces
      })), onApprove();
    } catch (e2) {
      console.error(`Wallet connect approve pairing error ${e2}`), console.error(e2), e2.message.includes("Non conforming namespaces") ? alertUser(t2(
        "walletConnect.invalidPairingChain",
        {
          chains: `
Ethereum 
Ethereum (Goerli)`
        }
      )) : alertUser(e2.messsage), await handleRejectPairing();
    } finally {
      setPairingLoading(!1);
    }
  }, "handleApprovePairing"), handleRejectPairing = /* @__PURE__ */ __name(async () => {
    setPairingLoading(!0), await (web3wallet == null ? void 0 : web3wallet.rejectSession({
      id: currentProposal.id,
      reason: U("USER_REJECTED_METHODS")
    })), onReject(), setPairingLoading(!1);
  }, "handleRejectPairing");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$9.connectionRequest, children: [
      t2("walletConnect.pairingRequest.title"),
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PairingContainer, { pairingMetadata }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$9.receiveAddress, children: [
      t2("accountInfo.address"),
      ": ",
      receiveAddress2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.buttonsContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, secondary: !0, onClick: handleRejectPairing, children: t2("walletConnect.pairingRequest.reject") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, primary: !0, onClick: handleApprovePairing, children: t2("walletConnect.pairingRequest.approve") })
    ] })
  ] });
}, "WCIncomingPairing"), container$1 = "_container_1h5wj_1", successIcon$1 = "_successIcon_1h5wj_7", successText$1 = "_successText_1h5wj_12", styles$8 = {
  container: container$1,
  successIcon: successIcon$1,
  successText: successText$1
}, WCSuccessPairing = /* @__PURE__ */ __name(({ accountCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles$8.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.successText, children: t2("walletConnect.pairingSuccess") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: () => route(`/account/${accountCode}/wallet-connect/dashboard`), children: t2("button.done") })
  ] });
}, "WCSuccessPairing"), contentContainer = "_contentContainer_1iwqe_1", styles$7 = {
  contentContainer
}, ConnectScreenWalletConnect = /* @__PURE__ */ __name(({
  code,
  accounts
}) => {
  var _a46;
  const [uri, setUri] = reactExports.useState(""), [status2, setStatus] = reactExports.useState("connect"), [loading2, setLoading] = reactExports.useState(!1), { web3wallet, isWalletInitialized, pair } = reactExports.useContext(WCWeb3WalletContext), [currentProposal, setCurrentProposal] = reactExports.useState(), { t: t2 } = useTranslation(), receiveAddresses = useLoad(getReceiveAddressList(code)), onSessionProposal = reactExports.useCallback(
    (proposal) => {
      setUri(""), setLoading(!1), setStatus("incoming_pairing"), setCurrentProposal(proposal);
    },
    []
  );
  reactExports.useEffect(() => {
    if (isWalletInitialized)
      return web3wallet == null || web3wallet.on("session_proposal", onSessionProposal), () => {
        web3wallet == null || web3wallet.off("session_proposal", onSessionProposal);
      };
  }, [onSessionProposal, isWalletInitialized, web3wallet]);
  const handleApprovePairingStates = /* @__PURE__ */ __name(() => {
    setStatus("success"), setUri(""), setCurrentProposal(void 0);
  }, "handleApprovePairingStates"), handleRejectPairingStates = /* @__PURE__ */ __name(() => {
    setStatus("connect"), setUri(""), setCurrentProposal(void 0);
  }, "handleRejectPairingStates"), handleConnect = /* @__PURE__ */ __name(async (uri2) => {
    if (uri2) {
      setLoading(!0);
      try {
        await pair({ uri: uri2 });
      } catch (err) {
        err.message.includes("Missing or invalid. pair()") ? alertUser(`${t2("walletConnect.connect.invalidPairingUri")}: ${uri2}`) : alertUser(err.message), setUri(""), setLoading(!1);
      }
    }
  }, "handleConnect");
  if (!receiveAddresses || !isWalletInitialized)
    return null;
  const accountName2 = ((_a46 = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a46.name) || "", receiveAddress2 = receiveAddresses[0].addresses[0].address;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          WCHeader,
          {
            accountName: accountName2,
            receiveAddress: receiveAddress2
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.contentContainer, children: [
          status2 === "connect" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            WCConnectForm,
            {
              connectLoading: loading2,
              code,
              uri,
              onInputChange: setUri,
              onSubmit: async (uri2) => {
                await handleConnect(uri2);
              }
            }
          ),
          status2 === "incoming_pairing" && currentProposal && /* @__PURE__ */ jsxRuntimeExports.jsx(
            WCIncomingPairing,
            {
              currentProposal,
              pairingMetadata: currentProposal.params.proposer.metadata,
              receiveAddress: receiveAddress2,
              onApprove: handleApprovePairingStates,
              onReject: handleRejectPairingStates
            }
          ),
          status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(WCSuccessPairing, { accountCode: code })
        ] })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
}, "ConnectScreenWalletConnect"), container = "_container_1jggi_1", textDataContainer = "_textDataContainer_1jggi_16", receiveAddress$1 = "_receiveAddress_1jggi_21", accountName$1 = "_accountName_1jggi_26", dAppMetadataAndIconContainer = "_dAppMetadataAndIconContainer_1jggi_33", dAppNameAndUrlContainer = "_dAppNameAndUrlContainer_1jggi_48", dappUrl = "_dappUrl_1jggi_54", accountNameAndWalletContainer = "_accountNameAndWalletContainer_1jggi_58", buttonAndIconContainer = "_buttonAndIconContainer_1jggi_63", buttonDisconnect = "_buttonDisconnect_1jggi_69", styles$6 = {
  container,
  textDataContainer,
  receiveAddress: receiveAddress$1,
  accountName: accountName$1,
  dAppMetadataAndIconContainer,
  dAppNameAndUrlContainer,
  dappUrl,
  accountNameAndWalletContainer,
  buttonAndIconContainer,
  buttonDisconnect
}, TextData = /* @__PURE__ */ __name(({ accountName: accountName2, receiveAddress: receiveAddress2, dAppName, dAppUrl, iconUrl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.textDataContainer, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.accountNameAndWalletContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} hide-on-small`, children: receiveAddress2 })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} show-on-small`, children: receiveAddress2 }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppMetadataAndIconContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppNameAndUrlContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: dAppName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.dappUrl, children: dAppUrl })
    ] }),
    iconUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "hide-on-small", src: iconUrl, alt: "dApp icon" })
  ] })
] }), "TextData"), WCSessionCard = /* @__PURE__ */ __name(({ metadata: metadata2, receiveAddress: receiveAddress2, onDisconnect }) => {
  const { t: t2 } = useTranslation(), { name, url, icons } = metadata2, accountDetail = useLoad(() => getEthAccountCodeAndNameByAddress(receiveAddress2), []), truncatedAddress = truncateAddress(receiveAddress2), accountName2 = accountDetail && accountDetail.success ? accountDetail.name : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextData,
      {
        accountName: accountName2,
        receiveAddress: truncatedAddress,
        dAppName: name,
        dAppUrl: url,
        iconUrl: icons[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.buttonAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "show-on-small", src: icons[0], alt: "logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$6.buttonDisconnect, onClick: onDisconnect, danger: !0, children: t2("settings.electrum.remove-server") })
    ] })
  ] });
}, "WCSessionCard"), buttonNewConnection = "_buttonNewConnection_13so1_1", headerContainer = "_headerContainer_13so1_5", receiveAddress = "_receiveAddress_13so1_16", noConnectedSessions = "_noConnectedSessions_13so1_22", separator = "_separator_13so1_30", sessionCardsContainer = "_sessionCardsContainer_13so1_37", allSessionsHeading = "_allSessionsHeading_13so1_42", styles$5 = {
  buttonNewConnection,
  headerContainer,
  receiveAddress,
  noConnectedSessions,
  separator,
  sessionCardsContainer,
  allSessionsHeading
}, DashboardWalletConnect = /* @__PURE__ */ __name(({ code, accounts }) => {
  var _a46;
  const { t: t2 } = useTranslation(), { web3wallet, isWalletInitialized, initializeWeb3Wallet } = reactExports.useContext(WCWeb3WalletContext), [sessions, setSessions] = reactExports.useState(), receiveAddresses = useLoad(getReceiveAddressList(code)), updateSessions = reactExports.useCallback(() => {
    const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || []);
    setSessions(activeSessions);
  }, [web3wallet]);
  reactExports.useEffect(() => {
    if (!web3wallet) {
      initializeWeb3Wallet();
      return;
    }
    updateSessions();
  }, [initializeWeb3Wallet, updateSessions, web3wallet]), reactExports.useEffect(() => {
    if (isWalletInitialized)
      return web3wallet == null || web3wallet.on("session_delete", updateSessions), () => {
        web3wallet == null || web3wallet.off("session_delete", updateSessions);
      };
  }, [isWalletInitialized, updateSessions, web3wallet]);
  const handleDisconnectSession = /* @__PURE__ */ __name(async (topic) => {
    await (web3wallet == null ? void 0 : web3wallet.disconnectSession({
      topic,
      reason: U("USER_DISCONNECTED")
    })), updateSessions();
  }, "handleDisconnectSession");
  if (!receiveAddresses || !isWalletInitialized)
    return null;
  const receiveAddress2 = truncateAddress(receiveAddresses[0].addresses[0].address), accountName2 = ((_a46 = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a46.name) || "", hasSession = sessions && sessions.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Status,
        {
          type: "info",
          dismissible: "walletConnectDisclaimerDismissed",
          children: t2("walletConnect.dashboard.disclaimer")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("walletConnect.walletConnect") })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: accountName2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.receiveAddress, children: receiveAddress2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$5.buttonNewConnection, onClick: () => route(`/account/${code}/wallet-connect/connect`), primary: !0, children: t2("walletConnect.dashboard.newConnection") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: styles$5.separator }),
        hasSession && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.sessionCardsContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.allSessionsHeading, children: t2("walletConnect.dashboard.allSessions") }),
          sessions.map(
            (session) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCSessionCard,
              {
                receiveAddress: getAddressFromEIPString(session.namespaces.eip155.accounts[0]),
                metadata: session.peer.metadata,
                onDisconnect: () => handleDisconnectSession(session.topic)
              },
              session.topic
            )
          )
        ] }),
        !hasSession && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.noConnectedSessions, children: t2("walletConnect.dashboard.noConnectedSessions") })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
}, "DashboardWalletConnect"), InjectParams = /* @__PURE__ */ __name(({ children: children2 }) => {
  const params = useParams();
  return React.cloneElement(children2, params);
}, "InjectParams"), AppRouter = /* @__PURE__ */ __name(({ devices, deviceIDs, devicesKey, accounts, activeAccounts }) => {
  const hasAccounts = accounts.length > 0, Homepage = /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch-default")
  ), Device2 = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch")
  ) }), Acc = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Account,
    {
      code: "",
      devices,
      accounts: activeAccounts
    }
  ) }), AccountsSummaryEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AccountsSummary,
    {
      devices,
      accounts: activeAccounts
    }
  ) }), AccSend = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SendWrapper,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) }), AccReceive = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Receive,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) }), AccInfo = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Info,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), AccDashboardWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DashboardWalletConnect,
    {
      accounts: activeAccounts,
      code: ""
    }
  ) }), AccConnectScreenWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ConnectScreenWalletConnect,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), BuyInfoEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BuyInfo,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), MoonpayEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Moonpay,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), ExchangeEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Exchange,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), PocketEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Pocket,
    {
      code: ""
    }
  ) }), PassphraseEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC$2, { deviceID: "" }) }), ManageBackupsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ManageBackups$1,
    {
      devices
    },
    devicesKey("manage-backups")
  ) }), MobileSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MobileSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AppearanceEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Appearance,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AboutEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    About,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AdvancedSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdvancedSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), ReceiveAccountsSelectorEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReceiveAccountsSelector, { activeAccounts }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: Homepage }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account/:code", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: Acc }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "send", element: AccSend }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "receive", element: AccReceive }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "info", element: AccInfo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/connect", element: AccConnectScreenWC }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/dashboard", element: AccDashboardWC })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "add-account", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccount, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account-summary", element: AccountsSummaryEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "buy", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "info", element: BuyInfoEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: BuyInfoEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BuyInfoEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "moonpay/:code", element: MoonpayEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pocket/:code", element: PocketEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "exchange/:code", element: ExchangeEl })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-backups/:deviceID", element: ManageBackupsEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "accounts/select-receive", element: ReceiveAccountsSelectorEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "settings", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: MobileSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appearance", element: AppearanceEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "about", element: AboutEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/:deviceID", element: Device2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/passphrase/:deviceID", element: PassphraseEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "advanced-settings", element: AdvancedSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "electrum", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumSettings, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-accounts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(
        HOC$3,
        {
          accounts,
          deviceIDs,
          hasAccounts
        },
        "manage-accounts"
      ) })
    ] })
  ] }) });
}, "AppRouter"), FirmwareUpgradeRequired = /* @__PURE__ */ __name(({
  deviceID,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        verticallyCentered: !0,
        textCenter: !0,
        width: "840px",
        withBottomBar: !0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("upgradeFirmware.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FirmwareSetting,
            {
              asButton: !0,
              deviceID,
              versionInfo
            }
          ) }) })
        ]
      }
    )
  ] });
}, "FirmwareUpgradeRequired"), PasswordGestureVideo = "" + new URL("password-gestures.webm", import.meta.url).href, passwordGesturesWrapper = "_passwordGesturesWrapper_mvckk_1", passwordGestures = "_passwordGestures_mvckk_1", styles$4 = {
  passwordGesturesWrapper,
  passwordGestures
};
function isVideoPlaying(video) {
  return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
}
__name(isVideoPlaying, "isVideoPlaying");
function replayVideo(ref) {
  ref && !isVideoPlaying(ref) && (ref.muted = !0, ref.play());
}
__name(replayVideo, "replayVideo");
const PasswordEntry = /* @__PURE__ */ __name(() => {
  let ref = reactExports.createRef();
  return reactExports.useEffect(() => {
    ref.current && replayVideo(ref.current);
  }, [ref]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.passwordGesturesWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      autoPlay: !0,
      ref,
      className: styles$4.passwordGestures,
      loop: !0,
      muted: !0,
      height: "338",
      width: "600",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: PasswordGestureVideo, type: "video/webm" })
    }
  ) });
}, "PasswordEntry"), Unlock = /* @__PURE__ */ __name(({ attestation }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "690px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("button.unlock"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepConnected.unlock") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: attestation === !1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { children: t2("bitbox02Wizard.attestationFailed") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
}, "Unlock"), Pairing = /* @__PURE__ */ __name(({
  attestation,
  deviceID,
  pairingFailed
}) => {
  const { t: t2 } = useTranslation(), [hash2, setHash] = reactExports.useState(""), [deviceVerified, setDeviceVerified] = reactExports.useState(!1), onChannelHashChanged = reactExports.useCallback(() => {
    getChannelHash(deviceID).then(({ hash: hash22, deviceVerified: deviceVerified2 }) => {
      setHash(hash22), setDeviceVerified(deviceVerified2);
    });
  }, [deviceID]);
  return reactExports.useEffect(onChannelHashChanged, [deviceID, onChannelHashChanged]), reactExports.useEffect(() => channelHashChanged(deviceID, onChannelHashChanged), [deviceID, onChannelHashChanged]), /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "670px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.pairing.title"), children: pairingFailed ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: t2("bitbox02Wizard.pairing.failed") }, "pairingFailed") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(deviceVerified ? "bitbox02Wizard.pairing.paired" : "bitbox02Wizard.pairing.unpaired") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { fullWidth: !0, children: [
          attestation === !1 && !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", className: "m-bottom-half", children: t2("bitbox02Wizard.attestationFailed") }),
          !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: hash2 }),
            !deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: !pairingFailed && deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: () => verifyChannelHash(deviceID, !0),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  );
}, "Pairing"), Wait = /* @__PURE__ */ __name(({ title: title2, text: text2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      width: "720px",
      verticallyCentered: !0,
      textCenter: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: title2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text2 || t2("bitbox02Interact.followInstructions") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
      ]
    }
  );
}, "Wait"), toggle = "_toggle_1lt1t_1", toggleLabel = "_toggleLabel_1lt1t_7", textIcon = "_textIcon_1lt1t_14", style$5 = {
  toggle,
  toggleLabel,
  textIcon
}, SetupOptions = /* @__PURE__ */ __name(({
  onSelectSetup,
  versionInfo
}) => {
  const { t: t2 } = useTranslation(), [advanced, setAdvanced] = reactExports.useState(!1), [withMnemonic, setWithMnemonic] = reactExports.useState(!1), [with12Words, setWith12Words] = reactExports.useState(!1);
  if (advanced) {
    const {
      canBackupWithRecoveryWords,
      // supported with firmware v9.13.0
      canCreate12Words
      // supported with firmware v9.6.0
    } = versionInfo;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        textCenter: !0,
        verticallyCentered: !0,
        withBottomBar: !0,
        width: "1100px",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("seed.create") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", textAlign: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("bitbox02Wizard.advanced.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-mnemonic",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canBackupWithRecoveryWords && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.skipSDCardLabel") }),
                      " ",
                      !canBackupWithRecoveryWords && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: withMnemonic,
                    disabled: !canBackupWithRecoveryWords,
                    id: "with-mnemonic",
                    onChange: () => setWithMnemonic(!withMnemonic)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.skipSDCardText") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-12words",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canCreate12Words && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.seed12WordLabel") }),
                      " ",
                      !canCreate12Words && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: with12Words,
                    disabled: !canCreate12Words,
                    id: "with-12words",
                    onChange: () => setWith12Words(!with12Words)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.seed12WordText") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
                t2("bitbox02Wizard.advanced.seed12WordInfo")
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { inline: !0, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic,
                    with12Words
                  }),
                  primary: !0,
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setWithMnemonic(!1), setWith12Words(!1), setAdvanced(!1);
                  },
                  secondary: !0,
                  children: t2("button.back")
                }
              )
            ] })
          ] }) }) })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "1100px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("bitbox02Wizard.stepUninitialized.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
          t2("bitbox02Wizard.initialize.tip")
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic: !1,
                    with12Words: !1
                  }),
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => setAdvanced(!0),
                  style: { border: "none", marginTop: "var(--space-half)", height: "1.5rem" },
                  transparent: !0,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.button") })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-sdcard"),
                  secondary: !0,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMicroSD")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-mnemonic"),
                  style: { marginBottom: "40px" },
                  secondary: !0,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMnemonic")
                }
              )
            ] })
          ] })
        ] }) })
      ]
    }
  );
}, "SetupOptions"), wizardCheckbox = "_wizardCheckbox_1shxj_2", style$4 = {
  wizardCheckbox
}, ChecklistWalletCreate = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation(), [agree1, setAgree1] = reactExports.useState(!1), [agree2, setAgree2] = reactExports.useState(!1), [agree3, setAgree3] = reactExports.useState(!1), [agree4, setAgree4] = reactExports.useState(!1), [agree5, setAgree5] = reactExports.useState(!1), handleContinue = /* @__PURE__ */ __name(() => {
    setAgree1(!1), setAgree2(!1), setAgree3(!1), setAgree4(!1), setAgree5(!1), onContinue();
  }, "handleContinue");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackup") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
}, "ChecklistWalletCreate"), ChecklistWalletCreateMnemonic = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation(), [agree1, setAgree1] = reactExports.useState(!1), [agree2, setAgree2] = reactExports.useState(!1), [agree3, setAgree3] = reactExports.useState(!1), [agree4, setAgree4] = reactExports.useState(!1), [agree5, setAgree5] = reactExports.useState(!1), handleContinue = /* @__PURE__ */ __name(() => {
    setAgree1(!1), setAgree2(!1), setAgree3(!1), setAgree4(!1), setAgree5(!1), onContinue();
  }, "handleContinue");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackupMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5mnemonic")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
}, "ChecklistWalletCreateMnemonic"), wizardLabel = "_wizardLabel_11dvu_2", style$3 = {
  wizardLabel
}, SetDeviceName = /* @__PURE__ */ __name(({
  onDeviceName,
  onBack,
  missingSDCardWarning
}) => {
  const { t: t2 } = useTranslation(), [deviceName, setDeviceName2] = reactExports.useState(""), handleDeviceNameInput = /* @__PURE__ */ __name((event2) => {
    const value = event2.target.value;
    setDeviceName2(value);
  }, "handleDeviceNameInput");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "form",
    {
      onSubmit: (event2) => {
        event2.preventDefault(), onDeviceName(deviceName);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          textCenter: !0,
          withBottomBar: !0,
          verticallyCentered: !0,
          width: "600px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepCreate.title"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreate.description") }),
              missingSDCardWarning && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { className: "m-bottom-half", type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitbox02Wizard.stepCreate.toastMicroSD") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { minHeight: "90px", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: !0,
                className: style$3.wizardLabel,
                label: t2("bitbox02Wizard.stepCreate.nameLabel"),
                pattern: "^.{0,63}$",
                onInput: handleDeviceNameInput,
                placeholder: t2("bitbox02Wizard.stepCreate.namePlaceholder"),
                value: deviceName,
                id: "deviceName"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: !deviceName,
                  primary: !0,
                  type: "submit",
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onBack,
                  secondary: !0,
                  type: "button",
                  children: t2("button.back")
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, "SetDeviceName"), SetDeviceNameWithSDCard = /* @__PURE__ */ __name(({
  deviceID,
  onDeviceName,
  onBack
}) => {
  const [hasSDCard, setSDCard] = reactExports.useState();
  return reactExports.useEffect(() => {
    checkSDCard(deviceID).then(setSDCard);
  }, [deviceID]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    SetDeviceName,
    {
      onDeviceName,
      onBack,
      missingSDCardWarning: hasSDCard === !1
    }
  );
}, "SetDeviceNameWithSDCard"), SetPassword = /* @__PURE__ */ __name(({ errorText: errorText2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "600px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepPassword.title"), children: [
          errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorText2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
}, "SetPassword"), SetPasswordWithBackup = /* @__PURE__ */ __name(({
  forBackup
}) => {
  const { i18n, t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle"), children: forBackup ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "div", markup: t2("backup.restore.selectedBackup", {
            backupName: forBackup.name,
            createdDateTime: convertDateToLocaleString(forBackup.date, i18n.language)
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-small text-ellipsis", children: [
            "ID:",
            " ",
            forBackup.id
          ] })
        ] }) : null }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {})
        ] })
      ]
    }
  );
}, "SetPasswordWithBackup"), WithSDCard = /* @__PURE__ */ __name(({
  children: children2,
  deviceID
}) => {
  const { t: t2 } = useTranslation(), [hasSDCard, setSDCard] = reactExports.useState(), ensureSDCard = reactExports.useCallback(async () => {
    try {
      const sdCardInserted = await checkSDCard(deviceID);
      if (setSDCard(sdCardInserted), sdCardInserted)
        return;
      const result = await insertSDCard(deviceID);
      if (setSDCard(result.success), result.success)
        return;
      result.message && alertUser(result.message, { asDialog: !1 });
    } catch (error3) {
      console.error(error3);
    }
  }, [deviceID]);
  return reactExports.useEffect(() => {
    ensureSDCard();
  }, [ensureSDCard]), hasSDCard ? children2 : hasSDCard === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !0, textCenter: !0, verticallyCentered: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: "Checking microSD card" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Wizard.stepInsertSD.insertSDcardTitle"),
      text: t2("bitbox02Wizard.stepInsertSD.insertSDCard")
    }
  );
}, "WithSDCard"), CreateWallet = /* @__PURE__ */ __name(({
  backupType,
  backupSeedLength,
  deviceID,
  isSeeded,
  onAbort
}) => {
  const { t: t2 } = useTranslation(), isMounted = useMountedRef(), [status2, setStatus] = reactExports.useState("intro"), [errorText2, setErrorText] = reactExports.useState(""), ensurePassword = /* @__PURE__ */ __name(async () => {
    setStatus("setPassword");
    try {
      const result = await setPassword(deviceID, backupSeedLength);
      if (!result.success) {
        result.code === errUserAbort ? (alertUser(t2("bitbox02Wizard.stepPassword.e104"), {
          asDialog: !1,
          callback: () => onAbort()
        }), setErrorText("")) : (setErrorText(t2("bitbox02Wizard.noPasswordMatch")), isMounted.current && ensurePassword());
        return;
      }
      setErrorText(""), setStatus("showDisclaimer");
    } catch (error3) {
      console.error(error3);
    }
  }, "ensurePassword"), setDeviceName$1 = /* @__PURE__ */ __name(async (deviceName) => {
    setStatus("setName");
    try {
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText22 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText22 || t2("genericError"), {
          asDialog: !1,
          callback: () => onAbort()
        });
        return;
      }
      ensurePassword();
    } catch (error3) {
      console.error(error3);
    }
  }, "setDeviceName$1"), createBackup$1 = /* @__PURE__ */ __name(async () => {
    setStatus("createBackup");
    try {
      const result = await createBackup(
        deviceID,
        backupType === "mnemonic" ? "recovery-words" : "sdcard"
      );
      result.success || (result.code === errUserAbort ? alertUser(t2("bitbox02Wizard.createBackupAborted"), {
        asDialog: !1,
        callback: () => onAbort()
      }) : alertUser(t2("bitbox02Wizard.createBackupFailed"), { asDialog: !1 }));
    } catch (error3) {
      console.error(error3);
    }
  }, "createBackup$1");
  if (isSeeded) {
    if (status2 === "showDisclaimer")
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreate, { onContinue: createBackup$1 }) });
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreateMnemonic, { onContinue: createBackup$1 });
      }
    if (status2 === "createBackup")
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmDate"),
              text: t2("bitbox02Interact.confirmDateText")
            }
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmWords", {
                amount: backupSeedLength === 16 ? "12" : "24"
              }),
              text: t2("bitbox02Interact.confirmWordsText")
            }
          );
      }
  }
  switch (status2) {
    case "intro":
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceNameWithSDCard,
            {
              deviceID,
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-sdcard"
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceName,
            {
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-mnemonic"
          );
      }
      break;
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetPassword,
        {
          errorText: errorText2
        }
      );
    default:
      return null;
  }
}, "CreateWallet"), RestoreFromSDCardBackup = /* @__PURE__ */ __name(({
  deviceID,
  onSelectBackup,
  onRestoreBackup,
  onBack
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID,
            showRestore: !0,
            showRadio: !0,
            onSelectBackup,
            onRestoreBackup,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: onBack,
                children: t2("button.back")
              }
            )
          }
        ) })
      ]
    }
  );
}, "RestoreFromSDCardBackup"), RestoreFromSDCard = /* @__PURE__ */ __name(({
  deviceID,
  onAbort
}) => {
  const [status2, setStatus] = reactExports.useState("restore"), [backup2, setBackup] = reactExports.useState(), onSelectBackup = /* @__PURE__ */ __name((backup22) => {
    setStatus("setPassword"), setBackup(backup22);
  }, "onSelectBackup"), onRestoreBackup = /* @__PURE__ */ __name((success2) => {
    if (!success2) {
      onAbort();
      return;
    }
    setBackup(void 0);
  }, "onRestoreBackup");
  switch (status2) {
    case "restore":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCardBackup,
        {
          deviceID,
          onSelectBackup,
          onRestoreBackup,
          onBack: onAbort
        }
      ) });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SetPasswordWithBackup, { forBackup: backup2 });
  }
}, "RestoreFromSDCard"), RestoreFromMnemonic = /* @__PURE__ */ __name(({
  deviceID,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  return reactExports.useEffect(() => {
    restoreFromMnemonic(deviceID).then((result) => {
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Wizard.restoreFromMnemonic.e104") : t2("bitbox02Wizard.restoreFromMnemonic.failed");
        alertUser(errorText2, {
          asDialog: !1,
          callback: () => onAbort()
        });
      }
    }).catch(console.error);
  }, [deviceID, onAbort, t2]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Interact.followInstructionsMnemonicTitle"),
      text: t2("bitbox02Interact.followInstructionsMnemonic")
    }
  );
}, "RestoreFromMnemonic"), CreateWalletSuccess = /* @__PURE__ */ __name(({
  backupType,
  onContinue
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: !0,
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.success.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.success") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { withIcon: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(backupType === "sdcard" ? "bitbox02Wizard.stepCreateSuccess.removeMicroSD" : "bitbox02Wizard.stepCreateSuccess.storeMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "CreateWalletSuccess"), RestoreFromSDCardSuccess = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "RestoreFromSDCardSuccess"), RestoreFromMnemonicSuccess = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5mnemonic") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "RestoreFromMnemonicSuccess"), _Wizard = class _Wizard extends reactExports.Component {
  constructor(props) {
    super(props), this.unsubscribeList = [], this.updateAttestationCheck = () => {
      verifyAttestation(this.props.deviceID).then((attestation) => {
        this.setState({ attestation });
      });
    }, this.handleGetStarted = () => {
      this.setState({ status: "" }), route("/account-summary", !0);
    }, this.onStatusChanged = () => {
      const { showWizard, unlockOnly } = this.state;
      getStatus$1(this.props.deviceID).then((status2) => {
        !showWizard && ["connected", "unpaired", "pairingFailed", "uninitialized", "seeded"].includes(status2) && this.setState({ showWizard: !0 }), unlockOnly && ["uninitialized", "seeded"].includes(status2) && this.setState({ unlockOnly: !1 }), this.setState({ status: status2 });
      });
    }, this.handleAbort = () => {
      this.setState({
        appStatus: "",
        createOptions: void 0
      });
    }, this.state = {
      attestation: null,
      status: "",
      appStatus: "",
      unlockOnly: !0,
      showWizard: !1,
      waitDialog: void 0
    };
  }
  componentDidMount() {
    const { deviceID } = this.props;
    getVersion(deviceID).then((versionInfo) => {
      this.setState({ versionInfo });
    }), this.updateAttestationCheck(), this.onStatusChanged(), this.unsubscribeList = [
      statusChanged(deviceID, this.onStatusChanged),
      attestationCheckDone(deviceID, this.updateAttestationCheck)
    ];
  }
  componentWillUnmount() {
    unsubscribe(this.unsubscribeList);
  }
  render() {
    const { deviceID } = this.props, {
      attestation,
      createOptions,
      versionInfo,
      status: status2,
      appStatus,
      unlockOnly,
      showWizard,
      waitDialog
    } = this.state;
    return status2 === "" || !versionInfo ? null : status2 === "require_firmware_upgrade" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      FirmwareUpgradeRequired,
      {
        deviceID,
        versionInfo
      }
    ) : status2 === "require_app_upgrade" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {}) : showWizard ? waitDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Wait,
      {
        title: waitDialog.title,
        text: waitDialog.text
      },
      "wait-view"
    ) : appStatus === "" && status2 === "initialized" ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "connected" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Unlock,
        {
          attestation
        },
        "unlock"
      ) : null,
      (status2 === "unpaired" || status2 === "pairingFailed") && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Pairing,
        {
          deviceID,
          attestation,
          pairingFailed: status2 === "pairingFailed"
        },
        "pairing"
      ),
      !unlockOnly && appStatus === "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetupOptions,
        {
          versionInfo,
          onSelectSetup: (type2, createOptions2) => this.setState({ appStatus: type2, createOptions: createOptions2 })
        },
        "choose-setup"
      ),
      !unlockOnly && appStatus === "create-wallet" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        CreateWallet,
        {
          backupType: createOptions != null && createOptions.withMnemonic ? "mnemonic" : "sdcard",
          backupSeedLength: createOptions != null && createOptions.with12Words ? 16 : 32,
          deviceID,
          isSeeded: status2 === "seeded",
          onAbort: this.handleAbort
        }
      ),
      !unlockOnly && appStatus === "restore-sdcard" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCard,
        {
          deviceID,
          onAbort: this.handleAbort
        },
        "restore-sdcard"
      ),
      !unlockOnly && appStatus === "restore-mnemonic" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromMnemonic,
        {
          deviceID,
          onAbort: this.handleAbort
        },
        "restore-mnemonic"
      ),
      appStatus === "create-wallet" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        CreateWalletSuccess,
        {
          backupType: createOptions != null && createOptions.withMnemonic ? "mnemonic" : "sdcard",
          onContinue: this.handleGetStarted
        },
        "success"
      ),
      appStatus === "restore-sdcard" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromSDCardSuccess, { onContinue: this.handleGetStarted }, "backup-success"),
      appStatus === "restore-mnemonic" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromMnemonicSuccess, { onContinue: this.handleGetStarted }, "backup-mnemonic-success")
    ] }) : null;
  }
};
__name(_Wizard, "Wizard");
let Wizard = _Wizard;
const syncNewTxs = /* @__PURE__ */ __name((cb2) => subscribe$1("newTxs", (event2) => {
  event2.type === "backend" && cb2(event2.meta);
}), "syncNewTxs"), _ConnectedApp = class _ConnectedApp extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      connected: !0
    };
  }
  componentDidMount() {
    this.unsubscribe = backendConnected((connected) => this.setState({ connected }));
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  render() {
    const { children: children2 } = this.props, { connected } = this.state;
    return connected ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: children2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", style: { padding: 40 }, children: "The WebSocket closed. Please restart the backend and reload this page." });
  }
};
__name(_ConnectedApp, "ConnectedApp");
let ConnectedApp = _ConnectedApp;
const cancel = /* @__PURE__ */ __name(() => apiPost("aopp/cancel"), "cancel"), approve = /* @__PURE__ */ __name(() => apiPost("aopp/approve"), "approve"), chooseAccount = /* @__PURE__ */ __name((accountCode) => apiPost("aopp/choose-account", { accountCode }), "chooseAccount");
function subscribe(endpointsObjectOrFunction, renderOnlyOnceLoaded = !0, subscribeWithoutLoading = !1) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      constructor() {
        super(...arguments), this.subscriptions = {}, this.component = subscribeWithoutLoading ? WrappedComponent : load(endpointsObjectOrFunction, renderOnlyOnceLoaded)(WrappedComponent);
      }
      determineEndpoints() {
        return typeof endpointsObjectOrFunction == "function" ? endpointsObjectOrFunction(this.props) : endpointsObjectOrFunction;
      }
      unsubscribeEndpoint(key) {
        const subscription = this.subscriptions[key];
        subscription !== void 0 && (subscription(), delete this.subscriptions[key], (subscribeWithoutLoading || !renderOnlyOnceLoaded) && this.setState({ [key]: void 0 }));
      }
      subscribeEndpoint(key, endpoint) {
        this.unsubscribeEndpoint(key), this.subscriptions[key] = apiSubscribe(endpoint, (event2) => {
          switch (event2.action) {
            case "replace":
              this.setState({ [key]: event2.object });
              break;
            case "reload":
              apiGet(event2.subject).then((object) => this.setState({ [key]: object }));
              break;
          }
        });
      }
      subscribeEndpoints() {
        const oldEndpoints = this.endpoints, newEndpoints = this.determineEndpoints();
        for (const key of Object.keys(newEndpoints))
          (oldEndpoints === void 0 || newEndpoints[key] !== oldEndpoints[key]) && this.subscribeEndpoint(key, newEndpoints[key]);
        if (oldEndpoints !== void 0)
          for (const key of Object.keys(oldEndpoints))
            newEndpoints[key] === void 0 && (this.unsubscribeEndpoint(key), this.setState({ [key]: void 0 }));
        this.endpoints = newEndpoints;
      }
      componentDidMount() {
        this.subscribeEndpoints();
      }
      componentDidUpdate() {
        this.subscribeEndpoints();
      }
      componentWillUnmount() {
        for (const key of Object.keys(this.subscriptions))
          this.unsubscribeEndpoint(key);
      }
      render() {
        const props = this.props, state = this.state, Component2 = this.component;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Component2, { ...state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Subscribe(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(subscribe, "subscribe");
const isArray = Array.isArray, keyList = Object.keys, hasProp = Object.prototype.hasOwnProperty;
function equal(a2, b2) {
  if (Object.is(a2, b2))
    return !0;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    let arrA = isArray(a2), arrB = isArray(b2), i, length2, key;
    if (arrA && arrB) {
      if (length2 = a2.length, length2 !== b2.length)
        return !1;
      for (i = 0; i < length2; i++)
        if (!equal(a2[i], b2[i]))
          return !1;
      return !0;
    }
    if (arrA !== arrB)
      return !1;
    let keys = keyList(a2);
    if (length2 = keys.length, length2 !== keyList(b2).length)
      return !1;
    for (i = 0; i < length2; i++)
      if (!hasProp.call(b2, keys[i]))
        return !1;
    for (i = 0; i < length2; i++)
      if (key = keys[i], !equal(a2[key], b2[key]))
        return !1;
    return !0;
  }
  return !1;
}
__name(equal, "equal");
const VerifyAddress = /* @__PURE__ */ __name(({ accountCode, address: address2, addressID }) => {
  const [verifying, setVerifying] = reactExports.useState(!1), { t: t2 } = useTranslation(), verifyAddress2 = /* @__PURE__ */ __name(async () => {
    setVerifying(!0), await verifyAddress$1(accountCode, addressID), setVerifying(!1);
  }, "verifyAddress");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: verifyAddress2, children: t2("receive.verifyBitBox02") }),
    verifying ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("receive.verifyBitBox02"), children: address2 }) : null
  ] });
}, "VerifyAddress"), logo = "_logo_rqpye_1", prominent = "_prominent_rqpye_9", hostname = "_hostname_rqpye_22", capitalized = "_capitalized_rqpye_31", styles$3 = {
  logo,
  prominent,
  hostname,
  capitalized
}, AOPPGroupLogo = "" + new URL("aoppgroup.svg", import.meta.url).href, BitcoinSuisseLogo = "" + new URL("bitcoin_suisse.png", import.meta.url).href, BittrLogo = "" + new URL("bittr.png", import.meta.url).href, BityLogo = "" + new URL("bity.png", import.meta.url).href, PocketBitcoinLogo = "" + new URL("pocketbitcoin.svg", import.meta.url).href, VASPLogoMap = {
  "demo.aopp.group": AOPPGroupLogo,
  "testing.aopp.group": AOPPGroupLogo,
  "bitcoinsuisse.com": BitcoinSuisseLogo,
  "bity.com": BityLogo,
  "getbittr.com": BittrLogo,
  "pocketbitcoin.com": PocketBitcoinLogo
}, VASPHostnameMap = {
  "demo.aopp.group": "AOPP.group",
  "testing.aopp.group": "AOPP.group"
}, Vasp = /* @__PURE__ */ __name(({
  fallback,
  hostname: hostname2,
  prominent: prominent2,
  withLogoText
}) => {
  if (!(hostname2 in VASPLogoMap))
    return fallback || /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$3.hostname, children: hostname2 });
  const logoClasses = prominent2 ? `${styles$3.logo} ${styles$3.prominent}` : styles$3.logo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: logoClasses, src: VASPLogoMap[hostname2], alt: hostname2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$3.hostname} ${styles$3.capitalized}`, children: hostname2 in VASPHostnameMap ? VASPHostnameMap[hostname2] : hostname2 }),
    withLogoText ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: withLogoText }) : null
  ] });
}, "Vasp"), banner = "_banner_yebbr_1", smallIcon = "_smallIcon_yebbr_10", successText = "_successText_yebbr_15", proceed = "_proceed_yebbr_28", message = "_message_yebbr_33", styles$2 = {
  banner,
  smallIcon,
  successText,
  proceed,
  message
}, Banner$1 = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.banner, children: children2 }), "Banner$1"), domain = /* @__PURE__ */ __name((callback2) => new URL(callback2).host, "domain"), _Aopp = class _Aopp extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      accountCode: ""
    }, this.chooseAccount = (e2) => {
      this.state.accountCode && chooseAccount(this.state.accountCode), e2.preventDefault();
    };
  }
  componentDidMount() {
    this.setAccountCodeDefault();
  }
  componentDidUpdate(prevProps) {
    var _a46;
    this.props.aopp !== void 0 && this.props.aopp.state === "choosing-account" && (((_a46 = prevProps.aopp) == null ? void 0 : _a46.state) !== "choosing-account" || !equal(this.props.aopp.accounts, prevProps.aopp.accounts)) && this.setAccountCodeDefault();
  }
  setAccountCodeDefault() {
    const { aopp: aopp2 } = this.props;
    aopp2 === void 0 || aopp2.state !== "choosing-account" || aopp2.accounts.length && this.setState({ accountCode: aopp2.accounts[0].code });
  }
  render() {
    const { t: t2, aopp: aopp2 } = this.props, { accountCode } = this.state;
    if (!aopp2)
      return null;
    switch (aopp2.state) {
      case "error":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.errorTitle"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "error", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$2.smallIcon }),
                t2(`error.${aopp2.errorCode}`, { host: domain(aopp2.callback) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, onClick: cancel, children: t2("button.dismiss") }) })
            ]
          }
        );
      case "inactive":
        return null;
      case "user-approval":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), withAppLogo: !0 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Vasp,
                {
                  prominent: !0,
                  hostname: domain(aopp2.callback),
                  fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("aopp.addressRequest", {
                    host: `<strong>${domain(aopp2.callback)}</strong>`
                  }) }),
                  withLogoText: t2("aopp.addressRequestWithLogo")
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: approve, children: t2("button.continue") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        );
      case "awaiting-keystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Banner$1, { children: t2("aopp.banner") });
      case "choosing-account": {
        const options2 = aopp2.accounts.map((account2) => ({
          text: account2.name,
          value: account2.code
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: this.chooseAccount, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  label: t2("buy.info.selectLabel"),
                  options: options2,
                  value: accountCode,
                  onChange: (e2) => {
                    var _a46;
                    return this.setState({ accountCode: (_a46 = e2.target) == null ? void 0 : _a46.value });
                  },
                  id: "account"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.next") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        ) });
      }
      case "syncing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.syncing") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") }) })
            ]
          }
        );
      case "signing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.signing") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: !0, flexibleHeight: !0, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
              ] })
            ]
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fitContent: !0,
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { withIcon: "success", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.successText, children: t2("aopp.success.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.proceed, children: t2("aopp.success.message", { host: domain(aopp2.callback) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: !0, flexibleHeight: !0, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { style: { marginBottom: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: cancel, children: t2("button.done") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VerifyAddress,
                  {
                    accountCode: aopp2.accountCode,
                    address: aopp2.address,
                    addressID: aopp2.addressID
                  }
                )
              ] })
            ]
          }
        );
    }
  }
};
__name(_Aopp, "Aopp");
let Aopp = _Aopp;
const subscribeHOC = subscribe(
  { aopp: "aopp" },
  !1,
  !1
)(Aopp), translateHOC = translate()(subscribeHOC), getBanner = /* @__PURE__ */ __name((msgKey) => apiGet(`banners/${msgKey}`), "getBanner"), syncBanner = /* @__PURE__ */ __name((msgKey, cb2) => subscribeEndpoint(`banners/${msgKey}`, cb2), "syncBanner"), link$1 = "_link_4u2en_1", style$2 = {
  link: link$1
}, Banner = /* @__PURE__ */ __name(({ msgKey }) => {
  const { i18n, t: t2 } = useTranslation(), [banner2, setBanner] = reactExports.useState();
  if (reactExports.useEffect(() => {
    getBanner(msgKey).then(setBanner), syncBanner(msgKey, setBanner);
  }, [msgKey]), !banner2 || !i18n.options.fallbackLng)
    return null;
  const { message: message2, link: link2 } = banner2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Status,
    {
      dismissible: banner2.dismissible ? `banner-${msgKey}-${banner2.id}` : "",
      type: banner2.type ? banner2.type : "warning",
      children: [
        message2[i18n.resolvedLanguage] || message2[i18n.options.fallbackLng[0]],
        "",
        link2 && /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: link2.href, className: style$2.link, children: link2.text || t2("clickHere") })
      ]
    }
  );
}, "Banner"), bitboxContainer = "_bitboxContainer_1nxo8_1", failed = "_failed_1nxo8_18", bitboxImage = "_bitboxImage_1nxo8_24", cancelIcon = "_cancelIcon_1nxo8_29", text = "_text_1nxo8_35", styles$1 = {
  bitboxContainer,
  failed,
  bitboxImage,
  cancelIcon,
  text
};
function KeystoreConnectPrompt() {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), [data, reset2] = useSubscribeReset(syncConnectKeystore());
  if (!data)
    return null;
  switch (data.typ) {
    case "connect":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: !0, open: !0, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$1.text, children: [
          data.keystoreName === "" ? t2("connectKeystore.promptNoName") : t2("connectKeystore.promptWithName", { name: data.keystoreName }),
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.bitboxContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => cancelConnectKeystore(), children: t2("dialog.cancel") }) })
      ] });
    case "error":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: !0, open: !0, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$1.text, children: data.errorCode === "wrongKeystore" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t2("error.wrongKeystore"),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          t2("error.wrongKeystore2")
        ] }) : data.errorMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$1.bitboxContainer} ${styles$1.failed}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$1.cancelIcon }),
          isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: styles$1.bitboxImage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: styles$1.bitboxImage })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => reset2(), children: t2("dialog.cancel") }) })
      ] });
    default:
      return null;
  }
}
__name(KeystoreConnectPrompt, "KeystoreConnectPrompt");
const getUsingMobileData = /* @__PURE__ */ __name(() => apiGet("using-mobile-data"), "getUsingMobileData"), subscribeUsingMobileData = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("using-mobile-data", cb2), "subscribeUsingMobileData"), MobileDataWarning = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), isUsingMobileData = useSync(getUsingMobileData, subscribeUsingMobileData);
  return isUsingMobileData === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Status,
    {
      dismissible: "mobile-data-warning",
      type: "warning",
      hidden: !isUsingMobileData,
      children: t2("mobile.usingMobileDataWarning")
    }
  );
}, "MobileDataWarning"), link = "_link_13in7_1", style$1 = {
  link
}, Update = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), file = useLoad(getUpdate);
  return file ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Status, { dismissible: `update-${file.version}`, type: "info", children: [
    t2("app.upgrade", {
      current: file.current,
      version: file.version
    }),
    file.description,
    " ",
    !runningInAndroid() && /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadLink, { className: style$1.link })
  ] }) : null;
}, "Update"), setDarkTheme = /* @__PURE__ */ __name((isDark) => apiPost("set-dark-theme", isDark), "setDarkTheme"), detectDarkTheme = /* @__PURE__ */ __name(() => apiGet("detect-dark-theme"), "detectDarkTheme"), DarkModeProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [isDarkMode, setIsDarkMode] = reactExports.useState(!1), androidPrefersDarkMode = useMediaQuery("(prefers-color-scheme: dark)"), setAppTheme = reactExports.useCallback(() => {
    setDarkTheme(isDarkMode), isDarkMode ? (document.body.classList.add("dark-mode"), document.body.classList.remove("light-mode")) : (document.body.classList.remove("dark-mode"), document.body.classList.add("light-mode"));
  }, [isDarkMode]);
  reactExports.useEffect(() => {
    getConfig().then((config) => {
      if (config.frontend && "darkmode" in config.frontend) {
        setIsDarkMode(config.frontend.darkmode);
        return;
      }
      runningInAndroid() ? setIsDarkMode(androidPrefersDarkMode) : detectDarkTheme().then(setIsDarkMode);
    }).catch(console.error);
  }, [androidPrefersDarkMode]), reactExports.useEffect(() => {
    setAppTheme();
  }, [isDarkMode, setAppTheme]);
  const toggleDarkmode = /* @__PURE__ */ __name((darkmode2) => {
    setIsDarkMode(darkmode2), getConfig().then(async (config) => {
      let preferredDarkMode;
      if (runningInAndroid() ? preferredDarkMode = androidPrefersDarkMode : preferredDarkMode = await detectDarkTheme(), preferredDarkMode === darkmode2) {
        const { darkmode: darkmode22, ...frontend } = config.frontend;
        setConfig({
          frontend: {
            ...frontend,
            darkmode: void 0
          }
        });
      } else
        setConfig({
          frontend: {
            ...config.frontend,
            darkmode: darkmode2
          }
        });
    });
  }, "toggleDarkmode");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeContext.Provider, { value: { isDarkMode, toggleDarkmode }, children: children2 });
}, "DarkModeProvider"), AppProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [guideShown, setGuideShown] = reactExports.useState(!1), [guideExists, setGuideExists] = reactExports.useState(!1), [hideAmounts, setHideAmounts] = reactExports.useState(!1), toggleGuide = /* @__PURE__ */ __name(() => {
    setConfig({ frontend: { guideShown: !guideShown } }), setGuideShown((prev2) => !prev2);
  }, "toggleGuide"), toggleHideAmounts = /* @__PURE__ */ __name(() => {
    setConfig({ frontend: { hideAmounts: !hideAmounts } }), setHideAmounts((prev2) => !prev2);
  }, "toggleHideAmounts");
  return reactExports.useEffect(() => {
    getConfig().then(({ frontend }) => {
      frontend ? (frontend.guideShown !== void 0 && setGuideShown(frontend.guideShown), frontend.hideAmounts !== void 0 && setHideAmounts(frontend.hideAmounts)) : setGuideShown(!0);
    });
  }, []), /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppContext.Provider,
    {
      value: {
        toggleGuide,
        guideShown,
        guideExists,
        hideAmounts,
        setGuideShown,
        setGuideExists,
        toggleHideAmounts
      },
      children: children2
    }
  );
}, "AppProvider"), auth = "_auth_xdrxz_1", style = {
  auth
}, AuthRequired = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [authRequired, setAuthRequired] = reactExports.useState(!1), [authenticating, setAuthenticating] = reactExports.useState(!1), authForced = reactExports.useRef(!1), newAuthentication = /* @__PURE__ */ __name(() => {
    setAuthenticating(!0), authenticate(authForced.current);
  }, "newAuthentication");
  return reactExports.useEffect(() => {
    const unsubscribe2 = subscribeAuth((data) => {
      switch (data.typ) {
        case "auth-forced":
          authForced.current = !0;
          break;
        case "auth-required":
          setAuthRequired((prevAuthRequired) => (prevAuthRequired || newAuthentication(), !0));
          break;
        case "auth-err":
          setAuthenticating(!1);
          break;
        case "auth-canceled":
          authForced.current ? (setAuthRequired(!1), authForced.current = !1) : setAuthenticating(!1);
          break;
        case "auth-ok":
          setAuthRequired(!1), authForced.current = !1;
      }
    });
    return setAuthRequired(!0), newAuthentication(), unsubscribe2;
  }, []), authRequired ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style.auth, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("auth.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: void 0, minHeight: "0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: !0,
            primary: !0,
            hidden: authForced.current,
            disabled: authenticating,
            onClick: newAuthentication,
            children: t2("auth.authButton")
          }
        ) })
      ]
    }
  ) }) : null;
}, "AuthRequired"), WCWeb3WalletProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const { t: t2 } = useTranslation(), [web3wallet, setWeb3wallet] = reactExports.useState(), [isWalletInitialized, setIsWalletInitialized] = reactExports.useState(!1), config = useLoad(getConfig), hasUsedWC = config && config.frontend && config.frontend.hasUsedWalletConnect, initializeWeb3Wallet = /* @__PURE__ */ __name(async () => {
    try {
      const { Core } = await __vitePreload(() => import("./index.es.js").then((n2) => n2.l), [], import.meta.url), { Web3Wallet } = await __vitePreload(() => import("./index.es2.js"), [], import.meta.url), core2 = new Core({
        projectId: "89733df088867a1a1bf644013addd6cc"
      }), wallet = await Web3Wallet.init({
        core: core2,
        metadata: {
          name: "BitBox",
          description: "BitBox02 hardware wallet",
          url: "https://bitbox.swiss",
          icons: ["https://bitbox.swiss/assets/images/logos/dbb-logo.png"]
        }
      });
      setWeb3wallet(wallet), setIsWalletInitialized(!0);
    } catch (err) {
      console.log("Error for initializing", err);
    }
  }, "initializeWeb3Wallet");
  reactExports.useEffect(() => {
    !web3wallet && !isWalletInitialized && hasUsedWC && initializeWeb3Wallet();
  }, [isWalletInitialized, web3wallet, hasUsedWC]);
  const pair = /* @__PURE__ */ __name(async (params) => {
    if (web3wallet)
      try {
        const { uri } = params, topic = getTopicFromURI(uri);
        if (pairingHasEverBeenRejected(topic, web3wallet))
          throw new Error(t2("walletConnect.useNewUri"));
        await (web3wallet == null ? void 0 : web3wallet.core.pairing.pair({ uri })), setConfig({ frontend: { hasUsedWalletConnect: !0 } });
      } catch (e2) {
        throw console.error(`Wallet connect attempt to pair error ${e2}`), e2.message.includes("Pairing already exists") ? new Error(t2("walletConnect.useNewUri")) : new Error(e2.message);
      }
  }, "pair");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCWeb3WalletContext.Provider,
    {
      value: {
        initializeWeb3Wallet,
        isWalletInitialized,
        web3wallet,
        pair
      },
      children: children2
    }
  );
}, "WCWeb3WalletProvider"), RatesProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [defaultCurrency2, setDefaultCurrency] = reactExports.useState("USD"), [activeCurrencies, setActiveCurrencies] = reactExports.useState(["USD", "EUR", "CHF"]), [btcUnit, setBtcUnit2] = reactExports.useState("default");
  reactExports.useEffect(() => {
    updateRatesConfig();
  }, []);
  const updateRatesConfig = /* @__PURE__ */ __name(async () => {
    var _a46, _b, _c;
    const appConf = await getConfig();
    (_a46 = appConf.backend) != null && _a46.mainFiat && setDefaultCurrency(appConf.backend.mainFiat), (_b = appConf.backend) != null && _b.fiatList && ((_c = appConf.backend) != null && _c.btcUnit) && (setActiveCurrencies(appConf.backend.fiatList), setBtcUnit2(appConf.backend.btcUnit));
  }, "updateRatesConfig"), rotateFiat = /* @__PURE__ */ __name(() => {
    const index = activeCurrencies.indexOf(defaultCurrency2), fiat2 = activeCurrencies[(index + 1) % activeCurrencies.length];
    setDefaultCurrency(fiat2);
  }, "rotateFiat"), updateDefaultFiat = /* @__PURE__ */ __name((fiat2) => {
    activeCurrencies.includes(fiat2) || selectFiat(fiat2), setDefaultCurrency(fiat2), setConfig({ backend: { mainFiat: fiat2 } });
  }, "updateDefaultFiat"), selectFiat = /* @__PURE__ */ __name(async (fiat2) => {
    const selected2 = [...activeCurrencies, fiat2];
    await setConfig({ backend: { fiatList: selected2 } }), handleChangeSelectedFiat(selected2);
  }, "selectFiat"), unselectFiat = /* @__PURE__ */ __name(async (fiat2) => {
    const selected2 = activeCurrencies.filter((item2) => !equal(item2, fiat2));
    await setConfig({ backend: { fiatList: selected2 } }), handleChangeSelectedFiat(selected2);
  }, "unselectFiat"), handleChangeSelectedFiat = /* @__PURE__ */ __name((selected2) => {
    setActiveCurrencies(selected2), reinitializeAccounts();
  }, "handleChangeSelectedFiat");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RatesContext.Provider,
    {
      value: {
        defaultCurrency: defaultCurrency2,
        activeCurrencies,
        btcUnit,
        rotateFiat,
        selectFiat,
        updateDefaultFiat,
        updateRatesConfig,
        unselectFiat
      },
      children: children2
    }
  );
}, "RatesProvider"), fetchAccountNameAndAddress = /* @__PURE__ */ __name(async (address2) => {
  const accountDetail = await getEthAccountCodeAndNameByAddress(address2);
  if (!accountDetail.success)
    return console.log("Failed in fetching account name and code"), { accountName: "", accountCode: "" };
  const { code, name } = accountDetail;
  return { accountName: name, accountCode: code };
}, "fetchAccountNameAndAddress");
async function handleWcEthSignRequest(method, args) {
  switch (method) {
    case EIP155_SIGNING_METHODS.ETH_SIGN:
    case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      await ethSignHandler(args, method);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      await ethSignTypedDataHandler(args);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
    case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      await ethSignOrSendTransactionHandler(args, method);
      break;
    default:
      console.log(`${method} is unsupported`);
  }
}
__name(handleWcEthSignRequest, "handleWcEthSignRequest");
async function ethSignHandler({ params, launchSignDialog, topic, id: id2, currentSession }, method) {
  const isPersonalSign = method === EIP155_SIGNING_METHODS.PERSONAL_SIGN, requestParams = params.request.params, accountAddress = isPersonalSign ? requestParams[1] : requestParams[0], signingData = isPersonalSign ? requestParams[0] : requestParams[1], decoded = decodeEthMessage(signingData);
  if (decoded === null) {
    alertUser(t$1("walletConnect.signingRequest.decodeError"));
    return;
  }
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  launchSignDialog({
    topic,
    id: id2,
    apiCaller: /* @__PURE__ */ __name(async () => {
      const result = await ethSignMessage(accountCode, signingData);
      return result.success ? {
        response: { id: id2, jsonrpc: "2.0", result: result.signature },
        success: !0
      } : { success: !1, error: result };
    }, "apiCaller"),
    dialogContent: {
      signingData: decoded,
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signMessage")
    }
  });
}
__name(ethSignHandler, "ethSignHandler");
async function ethSignTypedDataHandler({ params, launchSignDialog, topic, id: id2, currentSession }) {
  const requestParams = params.request.params, accountAddress = requestParams[0], data = requestParams[1];
  let typedData;
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  try {
    typedData = JSON.parse(data);
  } catch (e2) {
    console.error("Failed to parse JSON", e2), alertUser(t$1("walletConnect.signingRequest.dataParsingError"));
    return;
  }
  launchSignDialog({
    topic,
    id: id2,
    apiCaller: /* @__PURE__ */ __name(async () => {
      var _a46;
      const chainId = (_a46 = typedData == null ? void 0 : typedData.domain) != null && _a46.chainId ? Number(typedData.domain.chainId) : Number(params.chainId.replace(/^eip155:/, "")), result = await ethSignTypedMessage(accountCode, chainId, data);
      return result.success ? { response: { id: id2, jsonrpc: "2.0", result: result.signature }, success: !0 } : { success: !1, error: result };
    }, "apiCaller"),
    dialogContent: {
      signingData: JSON.stringify(typedData, null, 2),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signTypedData")
    }
  });
}
__name(ethSignTypedDataHandler, "ethSignTypedDataHandler");
async function ethSignOrSendTransactionHandler(args, method) {
  const isSendAndSign = method === EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION, { params, launchSignDialog, topic, id: id2, currentSession } = args, requestParams = params.request.params, accountAddress = requestParams[0].from, data = requestParams[0], { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress), apiCaller = /* @__PURE__ */ __name(async () => {
    const chainId = Number(params.chainId.replace(/^eip155:/, "")), result = await ethSignWalletConnectTx(accountCode, isSendAndSign, chainId, data);
    return result.success ? { response: { id: id2, jsonrpc: "2.0", result: isSendAndSign ? result.txHash : result.rawTx }, success: !0 } : { success: !1, error: result };
  }, "apiCaller"), formattedMethod = t$1(isSendAndSign ? "walletConnect.signingRequest.method.sendTransaction" : "walletConnect.signingRequest.method.signTransaction");
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(data),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: formattedMethod
    }
  });
}
__name(ethSignOrSendTransactionHandler, "ethSignOrSendTransactionHandler");
const accountName = "_accountName_gsa52_1", accountNameAndAddress = "_accountNameAndAddress_gsa52_6", address = "_address_gsa52_10", animationAndTextContainer = "_animationAndTextContainer_gsa52_16", chainContainer = "_chainContainer_gsa52_28", itemText = "_itemText_gsa52_33", dappIcon = "_dappIcon_gsa52_42", item = "_item_gsa52_33", label = "_label_gsa52_62", listContainer = "_listContainer_gsa52_68", outerContainer = "_outerContainer_gsa52_77", successIcon = "_successIcon_gsa52_84", textarea = "_textarea_gsa52_89", titleContainer = "_titleContainer_gsa52_97", styles = {
  accountName,
  accountNameAndAddress,
  address,
  animationAndTextContainer,
  chainContainer,
  itemText,
  dappIcon,
  item,
  label,
  listContainer,
  outerContainer,
  successIcon,
  textarea,
  titleContainer
}, ConfirmOnBB02 = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("confirmOnDevice") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
  ] });
}, "ConfirmOnBB02"), RequestSuccessfullySigned = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("walletConnect.signingRequest.successfullySigned") })
  ] });
}, "RequestSuccessfullySigned"), WCIncomingSignRequestDialog = /* @__PURE__ */ __name(({
  open: open2,
  onAccept,
  onReject,
  content: content2,
  stage
}) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), { accountAddress, accountName: accountName2, signingData, chain, method, currentSession } = content2, formattedChain = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].name : chain, chainIcon = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].icon : null, metadata2 = currentSession.peer.metadata, maxTextAreaRows = 20, signingDataHeight = signingData.toString().split(`
`).length + 3, textAreaRows = signingDataHeight > maxTextAreaRows ? maxTextAreaRows : signingDataHeight;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, large: !0, onClose: onReject, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titleContainer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { height: 32, width: 32 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDark, { height: 40, width: 40 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("walletConnect.signingRequest.walletConnectRequest") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.outerContainer, children: [
      stage !== "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: styles.listContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.account") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles.accountNameAndAddress, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.accountName, children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: accountName2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.address, children: truncateAddress(accountAddress) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.chain") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.chainContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: formattedChain }),
              chainIcon
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.dapp") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: metadata2.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: method })
          ] }),
          signingData && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.data") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { rows: textAreaRows, className: styles.textarea, readOnly: !0, value: signingData.toString() })
          ] })
        ] }),
        stage === "confirming" && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmOnBB02, {}),
        stage === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onAccept, primary: !0, type: "submit", children: t2("button.continue") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onReject, secondary: !0, type: "submit", children: t2("dialog.cancel") })
        ] })
      ] }),
      stage === "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsx(RequestSuccessfullySigned, {})
    ] })
  ] });
}, "WCIncomingSignRequestDialog"), WCSigningRequest = /* @__PURE__ */ __name(() => {
  const { web3wallet, isWalletInitialized } = reactExports.useContext(WCWeb3WalletContext), [dialogOpen, setDialogOpen] = reactExports.useState(!1), [dialogContent, setDialogContent] = reactExports.useState(), [stage, setStage] = reactExports.useState("initial"), signMessageApiCallerRef = reactExports.useRef(), requestDataRef = reactExports.useRef(), launchSignDialog = /* @__PURE__ */ __name(({ topic, id: id2, apiCaller, dialogContent: dialogContent2 }) => {
    const { signingData, currentSession, accountAddress, accountName: accountName2, chain, method } = dialogContent2;
    requestDataRef.current = { topic, id: id2 }, signMessageApiCallerRef.current = apiCaller, setDialogContent({
      accountAddress,
      accountName: accountName2,
      signingData,
      chain,
      currentSession,
      method
    }), setDialogOpen(!0);
  }, "launchSignDialog");
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized)
      return;
    const onSessionRequest = /* @__PURE__ */ __name(async (requestEvent) => {
      const { topic, params, id: id2 } = requestEvent, currentSession = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || {}).find((session) => session.topic === topic);
      if (currentSession) {
        const handlerArgs = {
          topic,
          id: id2,
          params,
          currentSession,
          launchSignDialog
        };
        await handleWcEthSignRequest(params.request.method, handlerArgs);
      }
    }, "onSessionRequest");
    return web3wallet == null || web3wallet.on("session_request", onSessionRequest), () => {
      web3wallet == null || web3wallet.off("session_request", onSessionRequest);
    };
  }, [isWalletInitialized, web3wallet]);
  const handleRejectBtn = /* @__PURE__ */ __name(async () => {
    setDialogOpen(!1);
    const requestData = requestDataRef.current;
    if (requestData) {
      const { topic, id: id2 } = requestData;
      await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
    }
  }, "handleRejectBtn"), handleAcceptBtn = /* @__PURE__ */ __name(async () => {
    const apiCaller = signMessageApiCallerRef.current, requestData = requestDataRef.current;
    if (apiCaller && requestData) {
      setStage("confirming");
      const { topic, id: id2 } = requestData, { response, success: success2, error: error3 } = await apiCaller();
      if (success2)
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response })), setStage("accepted"), setTimeout(() => {
          setDialogOpen(!1), setStage("initial");
        }, 5e3);
      else if (error3.aborted)
        setStage("initial"), setDialogOpen(!1), await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
      else {
        setStage("initial");
        const { errorMessage } = error3;
        alertUser(errorMessage || t$1("pairing.error.text"));
      }
    }
  }, "handleAcceptBtn");
  return !dialogContent || !dialogOpen ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCIncomingSignRequestDialog,
    {
      content: dialogContent,
      open: dialogOpen,
      stage,
      onAccept: handleAcceptBtn,
      onReject: handleRejectBtn
    }
  );
}, "WCSigningRequest"), sillyFN = /* @__PURE__ */ __name(() => {
  let b2 = 1;
  return b2 = b2 + 1, (/* @__PURE__ */ __name(() => 40 + b2, "sillyFn2"))();
}, "sillyFN");
window.sillyVal = sillyFN();
const _App = class _App extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      accounts: [],
      devices: {}
    }, this.unsubscribeList = [], this.handleRoute = () => {
      panelStore.state.activeSidebar && toggleSidebar();
    }, this.maybeRoute = () => {
      const currentURL = window.location.pathname, isIndex = currentURL === "/" || currentURL === "/index.html" || currentURL === "/android_asset/web/index.html", inAccounts = currentURL.startsWith("/account/"), accounts = this.state.accounts;
      if (isIndex && currentURL !== "/" && (!accounts || accounts.length === 0)) {
        route("/", !0);
        return;
      }
      if (accounts.length === 0 && (currentURL.startsWith("/account-summary") || currentURL.startsWith("/add-account") || currentURL.startsWith("/settings/manage-accounts"))) {
        route("/", !0);
        return;
      }
      if (Object.keys(this.state.devices).length === 0 && currentURL.startsWith("/settings/device-settings/")) {
        route("/", !0);
        return;
      }
      if (inAccounts && !accounts.some((account2) => currentURL.startsWith("/account/" + account2.code))) {
        route("/", !0);
        return;
      }
      if (isIndex && accounts.length) {
        route("/account-summary", !0);
        return;
      }
      if (accounts.length === 0 && currentURL.startsWith("/buy/")) {
        route("/", !0);
        return;
      }
    }, this.devicesKey = (prefix2) => prefix2 + ":" + JSON.stringify(this.state.devices, Object.keys(this.state.devices).sort()), this.activeAccounts = () => this.state.accounts.filter((acct) => acct.active);
  }
  componentDidMount() {
    Promise.all([getDeviceList(), getAccounts()]).then(([devices, accounts]) => {
      this.setStateWithDeviceList({ accounts, devices });
    }).catch(console.error), this.unsubscribeList.push(
      syncNewTxs((meta) => {
        notifyUser(this.props.t("notification.newTxs", {
          count: meta.count,
          accountName: meta.accountName
        }));
      }),
      syncAccountsList((accounts) => {
        this.setState({ accounts }, () => this.maybeRoute());
      }),
      syncDeviceList((devices) => {
        this.setStateWithDeviceList({ devices });
      })
    );
  }
  setStateWithDeviceList(newState) {
    const oldDeviceIDList = Object.keys(this.state.devices);
    this.setState((currentState) => ({ ...currentState, ...newState }), () => {
      const newDeviceIDList = Object.keys(this.state.devices);
      if (newDeviceIDList.length > 0 && newDeviceIDList[0] !== oldDeviceIDList[0]) {
        const productName = this.state.devices[newDeviceIDList[0]];
        if (productName === "bitbox" || productName === "bitbox02-bootloader") {
          route(`settings/device-settings/${newDeviceIDList[0]}`, !0);
          return;
        }
      }
      this.maybeRoute();
    });
  }
  componentWillUnmount() {
    unsubscribe(this.unsubscribeList);
  }
  render() {
    const { accounts, devices } = this.state, deviceIDs = Object.keys(devices), activeAccounts = this.activeAccounts();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedApp, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RatesProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WCWeb3WalletProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Darkmode, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRequired, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          guideShareHOC,
          {
            accounts: activeAccounts,
            deviceIDs
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "appContent flex flex-column flex-1", style: { minWidth: 0 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Update, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox01" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox02" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDataWarning, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(WCSigningRequest, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(translateHOC, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(KeystoreConnectPrompt, {}),
          Object.entries(devices).map(([deviceID, productName]) => productName === "bitbox02" ? /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wizard,
            {
              deviceID
            }
          ) }, deviceID) : null),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AppRouter,
            {
              accounts,
              activeAccounts,
              deviceIDs,
              devices,
              devicesKey: this.devicesKey
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(RouterWatcher, { onChange: this.handleRoute })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Confirm, {})
      ] })
    ] }) }) }) }) });
  }
};
__name(_App, "App");
let App = _App;
const HOC = translate()(App);
const rootEl = document.getElementById("root"), root = createRoot(rootEl);
root.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nextProvider, { i18n: instance, children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC, {}) }) }) }) })
);
export {
  Vn as $,
  Bt as A,
  B,
  ft as C,
  D,
  require$$0 as E,
  Ft as F,
  Gt as G,
  Ht as H,
  binary as I,
  Jt as J,
  Kn as K,
  Ln as L,
  wipe$1 as M,
  N,
  random as O,
  fromString as P,
  Qn as Q,
  toString as R,
  concat as S,
  rt as T,
  U,
  ot as V,
  Wt as W,
  Xt as X,
  Yt as Y,
  kn as Z,
  _23 as _,
  getAugmentedNamespace as a,
  Mn as a0,
  Te as a1,
  qn as a2,
  xn as a3,
  Hn as a4,
  Fn as a5,
  ee as a6,
  $ as a7,
  vt as a8,
  Et as a9,
  ut as aa,
  k as ab,
  Jn as ac,
  er as ad,
  Xn as ae,
  nr as af,
  Vt as ag,
  Mt$1 as ah,
  It as ai,
  wt as aj,
  lt as ak,
  dt as al,
  C as am,
  te as an,
  p as ao,
  cjs$2 as b,
  commonjsGlobal as c,
  at as d,
  gt as e,
  Dt as f,
  getDefaultExportFromCjs as g,
  ht as h,
  Lt as i,
  jt as j,
  kt$1 as k,
  dn as l,
  mt as m,
  h as n,
  ln as o,
  pt as p,
  qt as q,
  require$$0$1 as r,
  sha256 as s,
  tr as t,
  un as u,
  Kt as v,
  w,
  xt as x,
  yt as y,
  zt as z
};
